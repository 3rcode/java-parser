[
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8ConfigMapPropertySourceLocator.java",
        "name": "Fabric8ConfigMapPropertySourceLocator",
        "modifiers": "@Order(0) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8ConfigMapPropertySourceLocator",
        "extend": "ConfigMapPropertySourceLocator",
        "implements": "",
        "raw": "/** \n * A  {@link PropertySourceLocator} that uses config maps.\n * @author Ioannis Canellos\n * @author Michael Moudatsos\n * @author Isik Erhan\n */\n@Order(0) public class Fabric8ConfigMapPropertySourceLocator extends ConfigMapPropertySourceLocator {\n  private final KubernetesClient client;\n  private final KubernetesNamespaceProvider provider;\n  Fabric8ConfigMapPropertySourceLocator(  KubernetesClient client,  ConfigMapConfigProperties properties,  KubernetesNamespaceProvider provider){\n    super(properties,new Fabric8ConfigMapsCache());\n    this.client\u003dclient;\n    this.provider\u003dprovider;\n  }\n  @Override protected MapPropertySource getMapPropertySource(  NormalizedSource normalizedSource,  ConfigurableEnvironment environment){\n    String namespace\u003dgetApplicationNamespace(this.client,normalizedSource.namespace().orElse(null),normalizedSource.target(),provider);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(client,normalizedSource,namespace,environment);\n    return new Fabric8ConfigMapPropertySource(context);\n  }\n}\n",
        "abstract": "/** \n * A  {@link PropertySourceLocator} that uses config maps.\n * @author Ioannis Canellos\n * @author Michael Moudatsos\n * @author Isik Erhan\n */\n@Order(0) public class Fabric8ConfigMapPropertySourceLocator extends ConfigMapPropertySourceLocator {\n  private final KubernetesClient client;\n  private final KubernetesNamespaceProvider provider;\n  Fabric8ConfigMapPropertySourceLocator(  KubernetesClient client,  ConfigMapConfigProperties properties,  KubernetesNamespaceProvider provider);\n  @Override protected MapPropertySource getMapPropertySource(  NormalizedSource normalizedSource,  ConfigurableEnvironment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8ConfigUtils.java",
        "name": "Fabric8ConfigUtils",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8ConfigUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Utility class that works with configuration properties.\n * @author Ioannis Canellos\n */\npublic final class Fabric8ConfigUtils {\n  private static final Log LOG\u003dLogFactory.getLog(Fabric8ConfigUtils.class);\n  private Fabric8ConfigUtils(){\n  }\n  /** \n * finds namespaces to be used for the event based reloading.\n */\n  public static Set\u003cString\u003e namespaces(  KubernetesClient client,  KubernetesNamespaceProvider provider,  ConfigReloadProperties properties,  String target){\n    Set\u003cString\u003e namespaces\u003dproperties.namespaces();\n    if (namespaces.isEmpty()) {\n      namespaces\u003dSet.of(Fabric8Utils.getApplicationNamespace(client,null,target,provider));\n    }\n    LOG.debug(\"informer namespaces : \" + namespaces);\n    return namespaces;\n  }\n  /** \n * \u003cpre\u003e 1. read all secrets in the provided namespace 2. from the above, filter the ones that we care about (filter by labels) 3. with secret names from (2), find out if there are any profile based secrets (if profiles is not empty) 4. concat (2) and (3) and these are the secrets we are interested in 5. see if any of the secrets from (4) has a single yaml/properties file 6. gather all the names of the secrets (from 4) + data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer secretsDataByLabels(  KubernetesClient client,  String namespace,  Map\u003cString,String\u003e labels,  Environment environment,  Set\u003cString\u003e profiles){\n    List\u003cStrippedSourceContainer\u003e strippedSecrets\u003dstrippedSecrets(client,namespace);\n    if (strippedSecrets.isEmpty()) {\n      return MultipleSourcesContainer.empty();\n    }\n    return ConfigUtils.processLabeledData(strippedSecrets,environment,labels,namespace,profiles,true);\n  }\n  /** \n * \u003cpre\u003e 1. read all config maps in the provided namespace 2. from the above, filter the ones that we care about (filter by labels) 3. with config maps names from (2), find out if there are any profile based ones (if profiles is not empty) 4. concat (2) and (3) and these are the config maps we are interested in 5. see if any from (4) has a single yaml/properties file 6. gather all the names of the config maps (from 4) + data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer configMapsDataByLabels(  KubernetesClient client,  String namespace,  Map\u003cString,String\u003e labels,  Environment environment,  Set\u003cString\u003e profiles){\n    List\u003cStrippedSourceContainer\u003e strippedConfigMaps\u003dstrippedConfigMaps(client,namespace);\n    if (strippedConfigMaps.isEmpty()) {\n      return MultipleSourcesContainer.empty();\n    }\n    return ConfigUtils.processLabeledData(strippedConfigMaps,environment,labels,namespace,profiles,false);\n  }\n  /** \n * \u003cpre\u003e 1. read all secrets in the provided namespace 2. from the above, filter the ones that we care about (by name) 3. see if any of the secrets has a single yaml/properties file 4. gather all the names of the secrets + decoded data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer secretsDataByName(  KubernetesClient client,  String namespace,  LinkedHashSet\u003cString\u003e sourceNames,  Environment environment){\n    List\u003cStrippedSourceContainer\u003e strippedSecrets\u003dstrippedSecrets(client,namespace);\n    if (strippedSecrets.isEmpty()) {\n      return MultipleSourcesContainer.empty();\n    }\n    return ConfigUtils.processNamedData(strippedSecrets,environment,sourceNames,namespace,true);\n  }\n  /** \n * \u003cpre\u003e 1. read all config maps in the provided namespace 2. from the above, filter the ones that we care about (by name) 3. see if any of the config maps has a single yaml/properties file 4. gather all the names of the config maps + data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer configMapsDataByName(  KubernetesClient client,  String namespace,  LinkedHashSet\u003cString\u003e sourceNames,  Environment environment){\n    List\u003cStrippedSourceContainer\u003e strippedConfigMaps\u003dstrippedConfigMaps(client,namespace);\n    if (strippedConfigMaps.isEmpty()) {\n      return MultipleSourcesContainer.empty();\n    }\n    return ConfigUtils.processNamedData(strippedConfigMaps,environment,sourceNames,namespace,false);\n  }\n  private static List\u003cStrippedSourceContainer\u003e strippedConfigMaps(  KubernetesClient client,  String namespace){\n    List\u003cStrippedSourceContainer\u003e strippedConfigMaps\u003dFabric8ConfigMapsCache.byNamespace(client,namespace);\n    if (strippedConfigMaps.isEmpty()) {\n      LOG.debug(\"No configmaps in namespace \u0027\" + namespace + \"\u0027\");\n    }\n    return strippedConfigMaps;\n  }\n  private static List\u003cStrippedSourceContainer\u003e strippedSecrets(  KubernetesClient client,  String namespace){\n    List\u003cStrippedSourceContainer\u003e strippedSecrets\u003dFabric8SecretsCache.byNamespace(client,namespace);\n    if (strippedSecrets.isEmpty()) {\n      LOG.debug(\"No secrets in namespace \u0027\" + namespace + \"\u0027\");\n    }\n    return strippedSecrets;\n  }\n}\n",
        "abstract": "/** \n * Utility class that works with configuration properties.\n * @author Ioannis Canellos\n */\npublic final class Fabric8ConfigUtils {\n  private static final Log LOG\u003dLogFactory.getLog(Fabric8ConfigUtils.class);\n  private Fabric8ConfigUtils();\n  /** \n * finds namespaces to be used for the event based reloading.\n */\n  public static Set\u003cString\u003e namespaces(  KubernetesClient client,  KubernetesNamespaceProvider provider,  ConfigReloadProperties properties,  String target);\n  /** \n * \u003cpre\u003e 1. read all secrets in the provided namespace 2. from the above, filter the ones that we care about (filter by labels) 3. with secret names from (2), find out if there are any profile based secrets (if profiles is not empty) 4. concat (2) and (3) and these are the secrets we are interested in 5. see if any of the secrets from (4) has a single yaml/properties file 6. gather all the names of the secrets (from 4) + data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer secretsDataByLabels(  KubernetesClient client,  String namespace,  Map\u003cString,String\u003e labels,  Environment environment,  Set\u003cString\u003e profiles);\n  /** \n * \u003cpre\u003e 1. read all config maps in the provided namespace 2. from the above, filter the ones that we care about (filter by labels) 3. with config maps names from (2), find out if there are any profile based ones (if profiles is not empty) 4. concat (2) and (3) and these are the config maps we are interested in 5. see if any from (4) has a single yaml/properties file 6. gather all the names of the config maps (from 4) + data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer configMapsDataByLabels(  KubernetesClient client,  String namespace,  Map\u003cString,String\u003e labels,  Environment environment,  Set\u003cString\u003e profiles);\n  /** \n * \u003cpre\u003e 1. read all secrets in the provided namespace 2. from the above, filter the ones that we care about (by name) 3. see if any of the secrets has a single yaml/properties file 4. gather all the names of the secrets + decoded data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer secretsDataByName(  KubernetesClient client,  String namespace,  LinkedHashSet\u003cString\u003e sourceNames,  Environment environment);\n  /** \n * \u003cpre\u003e 1. read all config maps in the provided namespace 2. from the above, filter the ones that we care about (by name) 3. see if any of the config maps has a single yaml/properties file 4. gather all the names of the config maps + data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer configMapsDataByName(  KubernetesClient client,  String namespace,  LinkedHashSet\u003cString\u003e sourceNames,  Environment environment);\n  private static List\u003cStrippedSourceContainer\u003e strippedConfigMaps(  KubernetesClient client,  String namespace);\n  private static List\u003cStrippedSourceContainer\u003e strippedSecrets(  KubernetesClient client,  String namespace);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8ConfigMapPropertySource.java",
        "name": "Fabric8ConfigMapPropertySource",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8ConfigMapPropertySource",
        "extend": "SourceDataEntriesProcessor",
        "implements": "",
        "raw": "/** \n * A  {@link MapPropertySource} that uses Kubernetes config maps.\n * @author Ioannis Canellos\n * @author Ali Shahbour\n * @author Michael Moudatsos\n * @author Isik Erhan\n */\npublic final class Fabric8ConfigMapPropertySource extends SourceDataEntriesProcessor {\n  private static final EnumMap\u003cNormalizedSourceType,Fabric8ContextToSourceData\u003e STRATEGIES\u003dnew EnumMap\u003c\u003e(NormalizedSourceType.class);\nstatic {\n    STRATEGIES.put(NormalizedSourceType.NAMED_CONFIG_MAP,namedConfigMap());\n    STRATEGIES.put(NormalizedSourceType.LABELED_CONFIG_MAP,labeledConfigMap());\n  }\n  Fabric8ConfigMapPropertySource(  Fabric8ConfigContext context){\n    super(getSourceData(context));\n  }\n  private static SourceData getSourceData(  Fabric8ConfigContext context){\n    NormalizedSourceType type\u003dcontext.normalizedSource().type();\n    return Optional.ofNullable(STRATEGIES.get(type)).map(x -\u003e x.apply(context)).orElseThrow(() -\u003e new IllegalArgumentException(\"no strategy found for : \" + type));\n  }\n  private static Fabric8ContextToSourceData namedConfigMap(){\n    return new NamedConfigMapContextToSourceDataProvider().get();\n  }\n  private static Fabric8ContextToSourceData labeledConfigMap(){\n    return new LabeledConfigMapContextToSourceDataProvider().get();\n  }\n}\n",
        "abstract": "/** \n * A  {@link MapPropertySource} that uses Kubernetes config maps.\n * @author Ioannis Canellos\n * @author Ali Shahbour\n * @author Michael Moudatsos\n * @author Isik Erhan\n */\npublic final class Fabric8ConfigMapPropertySource extends SourceDataEntriesProcessor {\n  private static final EnumMap\u003cNormalizedSourceType,Fabric8ContextToSourceData\u003e STRATEGIES\u003dnew EnumMap\u003c\u003e(NormalizedSourceType.class);\nstatic {\n    STRATEGIES.put(NormalizedSourceType.NAMED_CONFIG_MAP,namedConfigMap());\n    STRATEGIES.put(NormalizedSourceType.LABELED_CONFIG_MAP,labeledConfigMap());\n  }\n  Fabric8ConfigMapPropertySource(  Fabric8ConfigContext context);\n  private static SourceData getSourceData(  Fabric8ConfigContext context);\n  private static Fabric8ContextToSourceData namedConfigMap();\n  private static Fabric8ContextToSourceData labeledConfigMap();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/RetryableFabric8ConfigMapPropertySourceLocator.java",
        "name": "RetryableFabric8ConfigMapPropertySourceLocator",
        "modifiers": "@Order(0)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.RetryableFabric8ConfigMapPropertySourceLocator",
        "extend": "Fabric8ConfigMapPropertySourceLocator",
        "implements": "",
        "raw": "/** \n * ConfigMapPropertySourceLocator for when retry is enabled.\n * @author Ryan Baxter\n */\n@Order(0) class RetryableFabric8ConfigMapPropertySourceLocator extends Fabric8ConfigMapPropertySourceLocator {\n  RetryableFabric8ConfigMapPropertySourceLocator(  KubernetesClient client,  ConfigMapConfigProperties properties,  KubernetesNamespaceProvider provider){\n    super(client,properties,provider);\n  }\n  @Override @Retryable(interceptor\u003d\"kubernetesConfigRetryInterceptor\") public PropertySource\u003c?\u003e locate(  Environment environment){\n    return super.locate(environment);\n  }\n  @Override @Retryable(interceptor\u003d\"kubernetesConfigRetryInterceptor\") public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment){\n    return super.locateCollection(environment);\n  }\n}\n",
        "abstract": "/** \n * ConfigMapPropertySourceLocator for when retry is enabled.\n * @author Ryan Baxter\n */\n@Order(0) class RetryableFabric8ConfigMapPropertySourceLocator extends Fabric8ConfigMapPropertySourceLocator {\n  RetryableFabric8ConfigMapPropertySourceLocator(  KubernetesClient client,  ConfigMapConfigProperties properties,  KubernetesNamespaceProvider provider);\n  @Override @Retryable(interceptor\u003d\"kubernetesConfigRetryInterceptor\") public PropertySource\u003c?\u003e locate(  Environment environment);\n  @Override @Retryable(interceptor\u003d\"kubernetesConfigRetryInterceptor\") public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8ConfigDataLocationResolver.java",
        "name": "Fabric8ConfigDataLocationResolver",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8ConfigDataLocationResolver",
        "extend": "KubernetesConfigDataLocationResolver",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class Fabric8ConfigDataLocationResolver extends KubernetesConfigDataLocationResolver {\n  public Fabric8ConfigDataLocationResolver(  DeferredLogFactory factory){\n    super(factory);\n  }\n  @Override protected void registerBeans(  ConfigDataLocationResolverContext resolverContext,  ConfigDataLocation location,  Profiles profiles,  KubernetesConfigDataLocationResolver.PropertyHolder propertyHolder,  KubernetesNamespaceProvider namespaceProvider){\n    KubernetesClientProperties kubernetesClientProperties\u003dpropertyHolder.kubernetesClientProperties();\n    ConfigMapConfigProperties configMapProperties\u003dpropertyHolder.configMapConfigProperties();\n    SecretsConfigProperties secretsProperties\u003dpropertyHolder.secretsProperties();\n    ConfigurableBootstrapContext bootstrapContext\u003dresolverContext.getBootstrapContext();\n    KubernetesClient kubernetesClient\u003dregisterConfigAndClient(bootstrapContext,kubernetesClientProperties);\n    if (configMapProperties !\u003d null \u0026\u0026 configMapProperties.enabled()) {\n      ConfigMapPropertySourceLocator configMapPropertySourceLocator\u003dnew Fabric8ConfigMapPropertySourceLocator(kubernetesClient,configMapProperties,namespaceProvider);\n      if (isRetryEnabledForConfigMap(configMapProperties)) {\n        configMapPropertySourceLocator\u003dnew ConfigDataRetryableConfigMapPropertySourceLocator(configMapPropertySourceLocator,configMapProperties,new Fabric8ConfigMapsCache());\n      }\n      registerSingle(bootstrapContext,ConfigMapPropertySourceLocator.class,configMapPropertySourceLocator,\"configDataConfigMapPropertySourceLocator\");\n    }\n    if (secretsProperties !\u003d null \u0026\u0026 secretsProperties.enabled()) {\n      SecretsPropertySourceLocator secretsPropertySourceLocator\u003dnew Fabric8SecretsPropertySourceLocator(kubernetesClient,secretsProperties,namespaceProvider);\n      if (isRetryEnabledForSecrets(secretsProperties)) {\n        secretsPropertySourceLocator\u003dnew ConfigDataRetryableSecretsPropertySourceLocator(secretsPropertySourceLocator,secretsProperties,new Fabric8SecretsCache());\n      }\n      registerSingle(bootstrapContext,SecretsPropertySourceLocator.class,secretsPropertySourceLocator,\"configDataSecretsPropertySourceLocator\");\n    }\n  }\n  private KubernetesClient registerConfigAndClient(  ConfigurableBootstrapContext bootstrapContext,  KubernetesClientProperties kubernetesClientProperties){\n    Config config\u003dnew Fabric8AutoConfiguration().kubernetesClientConfig(kubernetesClientProperties);\n    registerSingle(bootstrapContext,Config.class,config,\"fabric8Config\");\n    KubernetesClient kubernetesClient\u003dnew Fabric8AutoConfiguration().kubernetesClient(config);\n    registerSingle(bootstrapContext,KubernetesClient.class,kubernetesClient,\"configKubernetesClient\");\n    return kubernetesClient;\n  }\n  @Override protected KubernetesNamespaceProvider kubernetesNamespaceProvider(  Environment environment){\n    return new KubernetesNamespaceProvider(environment);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class Fabric8ConfigDataLocationResolver extends KubernetesConfigDataLocationResolver {\n  public Fabric8ConfigDataLocationResolver(  DeferredLogFactory factory);\n  @Override protected void registerBeans(  ConfigDataLocationResolverContext resolverContext,  ConfigDataLocation location,  Profiles profiles,  KubernetesConfigDataLocationResolver.PropertyHolder propertyHolder,  KubernetesNamespaceProvider namespaceProvider);\n  private KubernetesClient registerConfigAndClient(  ConfigurableBootstrapContext bootstrapContext,  KubernetesClientProperties kubernetesClientProperties);\n  @Override protected KubernetesNamespaceProvider kubernetesNamespaceProvider(  Environment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8SecretsPropertySource.java",
        "name": "Fabric8SecretsPropertySource",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8SecretsPropertySource",
        "extend": "SecretsPropertySource",
        "implements": "",
        "raw": "/** \n * Kubernetes property source for secrets.\n * @author l burgazzoli\n * @author Haytham Mohamed\n * @author Isik Erhan\n */\npublic final class Fabric8SecretsPropertySource extends SecretsPropertySource {\n  private static final EnumMap\u003cNormalizedSourceType,Fabric8ContextToSourceData\u003e STRATEGIES\u003dnew EnumMap\u003c\u003e(NormalizedSourceType.class);\nstatic {\n    STRATEGIES.put(NormalizedSourceType.NAMED_SECRET,namedSecret());\n    STRATEGIES.put(NormalizedSourceType.LABELED_SECRET,labeledSecret());\n  }\n  Fabric8SecretsPropertySource(  Fabric8ConfigContext context){\n    super(getSourceData(context));\n  }\n  private static SourceData getSourceData(  Fabric8ConfigContext context){\n    NormalizedSourceType type\u003dcontext.normalizedSource().type();\n    return Optional.ofNullable(STRATEGIES.get(type)).map(x -\u003e x.apply(context)).orElseThrow(() -\u003e new IllegalArgumentException(\"no strategy found for : \" + type));\n  }\n  private static Fabric8ContextToSourceData namedSecret(){\n    return new NamedSecretContextToSourceDataProvider().get();\n  }\n  private static Fabric8ContextToSourceData labeledSecret(){\n    return new LabeledSecretContextToSourceDataProvider().get();\n  }\n}\n",
        "abstract": "/** \n * Kubernetes property source for secrets.\n * @author l burgazzoli\n * @author Haytham Mohamed\n * @author Isik Erhan\n */\npublic final class Fabric8SecretsPropertySource extends SecretsPropertySource {\n  private static final EnumMap\u003cNormalizedSourceType,Fabric8ContextToSourceData\u003e STRATEGIES\u003dnew EnumMap\u003c\u003e(NormalizedSourceType.class);\nstatic {\n    STRATEGIES.put(NormalizedSourceType.NAMED_SECRET,namedSecret());\n    STRATEGIES.put(NormalizedSourceType.LABELED_SECRET,labeledSecret());\n  }\n  Fabric8SecretsPropertySource(  Fabric8ConfigContext context);\n  private static SourceData getSourceData(  Fabric8ConfigContext context);\n  private static Fabric8ContextToSourceData namedSecret();\n  private static Fabric8ContextToSourceData labeledSecret();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/LabeledSecretContextToSourceDataProvider.java",
        "name": "LabeledSecretContextToSourceDataProvider",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.LabeledSecretContextToSourceDataProvider",
        "extend": "",
        "implements": "Supplier\u003cFabric8ContextToSourceData\u003e",
        "raw": "/** \n * Provides an implementation of  {@link Fabric8ContextToSourceData} for a labeled secret.\n * @author wind57\n */\nfinal class LabeledSecretContextToSourceDataProvider implements Supplier\u003cFabric8ContextToSourceData\u003e {\n  LabeledSecretContextToSourceDataProvider(){\n  }\n  @Override public Fabric8ContextToSourceData get(){\n    return context -\u003e {\n      LabeledSecretNormalizedSource source\u003d(LabeledSecretNormalizedSource)context.normalizedSource();\n      return new LabeledSourceData(){\n        @Override public MultipleSourcesContainer dataSupplier(        Map\u003cString,String\u003e labels,        Set\u003cString\u003e profiles){\n          return Fabric8ConfigUtils.secretsDataByLabels(context.client(),context.namespace(),labels,context.environment(),profiles);\n        }\n      }\n.compute(source.labels(),source.prefix(),source.target(),source.profileSpecificSources(),source.failFast(),context.namespace(),context.environment().getActiveProfiles());\n    }\n;\n  }\n}\n",
        "abstract": "/** \n * Provides an implementation of  {@link Fabric8ContextToSourceData} for a labeled secret.\n * @author wind57\n */\nfinal class LabeledSecretContextToSourceDataProvider implements Supplier\u003cFabric8ContextToSourceData\u003e {\n  LabeledSecretContextToSourceDataProvider();\n  @Override public Fabric8ContextToSourceData get();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/NamedConfigMapContextToSourceDataProvider.java",
        "name": "NamedConfigMapContextToSourceDataProvider",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.NamedConfigMapContextToSourceDataProvider",
        "extend": "",
        "implements": "Supplier\u003cFabric8ContextToSourceData\u003e",
        "raw": "/** \n * Provides an implementation of  {@link Fabric8ContextToSourceData} for a named configmap.\n * @author wind57\n */\nfinal class NamedConfigMapContextToSourceDataProvider implements Supplier\u003cFabric8ContextToSourceData\u003e {\n  NamedConfigMapContextToSourceDataProvider(){\n  }\n  @Override public Fabric8ContextToSourceData get(){\n    return context -\u003e {\n      NamedConfigMapNormalizedSource source\u003d(NamedConfigMapNormalizedSource)context.normalizedSource();\n      return new NamedSourceData(){\n        @Override protected String generateSourceName(        String target,        String sourceName,        String namespace,        String[] activeProfiles){\n          if (source.appendProfileToName()) {\n            return ConfigUtils.sourceName(target,sourceName,namespace,activeProfiles);\n          }\n          return super.generateSourceName(target,sourceName,namespace,activeProfiles);\n        }\n        @Override public MultipleSourcesContainer dataSupplier(        LinkedHashSet\u003cString\u003e sourceNames){\n          return Fabric8ConfigUtils.configMapsDataByName(context.client(),context.namespace(),sourceNames,context.environment());\n        }\n      }\n.compute(source.name().orElseThrow(),source.prefix(),source.target(),source.profileSpecificSources(),source.failFast(),context.namespace(),context.environment().getActiveProfiles());\n    }\n;\n  }\n}\n",
        "abstract": "/** \n * Provides an implementation of  {@link Fabric8ContextToSourceData} for a named configmap.\n * @author wind57\n */\nfinal class NamedConfigMapContextToSourceDataProvider implements Supplier\u003cFabric8ContextToSourceData\u003e {\n  NamedConfigMapContextToSourceDataProvider();\n  @Override public Fabric8ContextToSourceData get();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/NamedSecretContextToSourceDataProvider.java",
        "name": "NamedSecretContextToSourceDataProvider",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.NamedSecretContextToSourceDataProvider",
        "extend": "",
        "implements": "Supplier\u003cFabric8ContextToSourceData\u003e",
        "raw": "/** \n * Provides an implementation of  {@link Fabric8ContextToSourceData} for a named secret.\n * @author wind57\n */\nfinal class NamedSecretContextToSourceDataProvider implements Supplier\u003cFabric8ContextToSourceData\u003e {\n  NamedSecretContextToSourceDataProvider(){\n  }\n  @Override public Fabric8ContextToSourceData get(){\n    return context -\u003e {\n      NamedSecretNormalizedSource source\u003d(NamedSecretNormalizedSource)context.normalizedSource();\n      return new NamedSourceData(){\n        @Override protected String generateSourceName(        String target,        String sourceName,        String namespace,        String[] activeProfiles){\n          if (source.appendProfileToName()) {\n            return ConfigUtils.sourceName(target,sourceName,namespace,activeProfiles);\n          }\n          return super.generateSourceName(target,sourceName,namespace,activeProfiles);\n        }\n        @Override public MultipleSourcesContainer dataSupplier(        LinkedHashSet\u003cString\u003e sourceNames){\n          return Fabric8ConfigUtils.secretsDataByName(context.client(),context.namespace(),sourceNames,context.environment());\n        }\n      }\n.compute(source.name().orElseThrow(),source.prefix(),source.target(),source.profileSpecificSources(),source.failFast(),context.namespace(),context.environment().getActiveProfiles());\n    }\n;\n  }\n}\n",
        "abstract": "/** \n * Provides an implementation of  {@link Fabric8ContextToSourceData} for a named secret.\n * @author wind57\n */\nfinal class NamedSecretContextToSourceDataProvider implements Supplier\u003cFabric8ContextToSourceData\u003e {\n  NamedSecretContextToSourceDataProvider();\n  @Override public Fabric8ContextToSourceData get();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8SecretsCache.java",
        "name": "Fabric8SecretsCache",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8SecretsCache",
        "extend": "",
        "implements": "SecretsCache",
        "raw": "/** \n * A cache of ConfigMaps per namespace. Makes sure we read config maps only once from a namespace.\n * @author wind57\n */\nfinal class Fabric8SecretsCache implements SecretsCache {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8SecretsCache.class));\n  /** \n * at the moment our loading of config maps is using a single thread, but might change in the future, thus a thread safe structure.\n */\n  private static final ConcurrentHashMap\u003cString,List\u003cStrippedSourceContainer\u003e\u003e CACHE\u003dnew ConcurrentHashMap\u003c\u003e();\n  @Override public void discardAll(){\n    CACHE.clear();\n  }\n  static List\u003cStrippedSourceContainer\u003e byNamespace(  KubernetesClient client,  String namespace){\n    boolean[] b\u003dnew boolean[1];\n    List\u003cStrippedSourceContainer\u003e result\u003dCACHE.computeIfAbsent(namespace,x -\u003e {\n      b[0]\u003dtrue;\n      return strippedSecrets(client.secrets().inNamespace(namespace).list().getItems());\n    }\n);\n    if (b[0]) {\n      LOG.debug(() -\u003e \"Loaded all secrets in namespace \u0027\" + namespace + \"\u0027\");\n    }\n else {\n      LOG.debug(() -\u003e \"Loaded (from cache) all secrets in namespace \u0027\" + namespace + \"\u0027\");\n    }\n    return result;\n  }\n  private static List\u003cStrippedSourceContainer\u003e strippedSecrets(  List\u003cSecret\u003e secrets){\n    return secrets.stream().map(secret -\u003e new StrippedSourceContainer(secret.getMetadata().getLabels(),secret.getMetadata().getName(),secret.getData())).collect(Collectors.toList());\n  }\n}\n",
        "abstract": "/** \n * A cache of ConfigMaps per namespace. Makes sure we read config maps only once from a namespace.\n * @author wind57\n */\nfinal class Fabric8SecretsCache implements SecretsCache {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8SecretsCache.class));\n  /** \n * at the moment our loading of config maps is using a single thread, but might change in the future, thus a thread safe structure.\n */\n  private static final ConcurrentHashMap\u003cString,List\u003cStrippedSourceContainer\u003e\u003e CACHE\u003dnew ConcurrentHashMap\u003c\u003e();\n  @Override public void discardAll();\n  static List\u003cStrippedSourceContainer\u003e byNamespace(  KubernetesClient client,  String namespace);\n  private static List\u003cStrippedSourceContainer\u003e strippedSecrets(  List\u003cSecret\u003e secrets);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/LabeledConfigMapContextToSourceDataProvider.java",
        "name": "LabeledConfigMapContextToSourceDataProvider",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.LabeledConfigMapContextToSourceDataProvider",
        "extend": "",
        "implements": "Supplier\u003cFabric8ContextToSourceData\u003e",
        "raw": "/** \n * Provides an implementation of  {@link Fabric8ContextToSourceData} for a labeled configmap.\n * @author wind57\n */\nfinal class LabeledConfigMapContextToSourceDataProvider implements Supplier\u003cFabric8ContextToSourceData\u003e {\n  LabeledConfigMapContextToSourceDataProvider(){\n  }\n  @Override public Fabric8ContextToSourceData get(){\n    return context -\u003e {\n      LabeledConfigMapNormalizedSource source\u003d(LabeledConfigMapNormalizedSource)context.normalizedSource();\n      return new LabeledSourceData(){\n        @Override public MultipleSourcesContainer dataSupplier(        Map\u003cString,String\u003e labels,        Set\u003cString\u003e profiles){\n          return Fabric8ConfigUtils.configMapsDataByLabels(context.client(),context.namespace(),labels,context.environment(),profiles);\n        }\n      }\n.compute(source.labels(),source.prefix(),source.target(),source.profileSpecificSources(),source.failFast(),context.namespace(),context.environment().getActiveProfiles());\n    }\n;\n  }\n}\n",
        "abstract": "/** \n * Provides an implementation of  {@link Fabric8ContextToSourceData} for a labeled configmap.\n * @author wind57\n */\nfinal class LabeledConfigMapContextToSourceDataProvider implements Supplier\u003cFabric8ContextToSourceData\u003e {\n  LabeledConfigMapContextToSourceDataProvider();\n  @Override public Fabric8ContextToSourceData get();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/RetryableFabric8SecretsPropertySourceLocator.java",
        "name": "RetryableFabric8SecretsPropertySourceLocator",
        "modifiers": "@Order(1)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.RetryableFabric8SecretsPropertySourceLocator",
        "extend": "Fabric8SecretsPropertySourceLocator",
        "implements": "",
        "raw": "/** \n * SecretsPropertySourceLocator for when retry is enabled.\n * @author Ryan Baxter\n */\n@Order(1) class RetryableFabric8SecretsPropertySourceLocator extends Fabric8SecretsPropertySourceLocator {\n  RetryableFabric8SecretsPropertySourceLocator(  KubernetesClient client,  SecretsConfigProperties properties,  KubernetesNamespaceProvider provider){\n    super(client,properties,provider);\n  }\n  @Override @Retryable(interceptor\u003d\"kubernetesSecretsRetryInterceptor\") public PropertySource\u003c?\u003e locate(  Environment environment){\n    return super.locate(environment);\n  }\n  @Override @Retryable(interceptor\u003d\"kubernetesSecretsRetryInterceptor\") public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment){\n    return super.locateCollection(environment);\n  }\n}\n",
        "abstract": "/** \n * SecretsPropertySourceLocator for when retry is enabled.\n * @author Ryan Baxter\n */\n@Order(1) class RetryableFabric8SecretsPropertySourceLocator extends Fabric8SecretsPropertySourceLocator {\n  RetryableFabric8SecretsPropertySourceLocator(  KubernetesClient client,  SecretsConfigProperties properties,  KubernetesNamespaceProvider provider);\n  @Override @Retryable(interceptor\u003d\"kubernetesSecretsRetryInterceptor\") public PropertySource\u003c?\u003e locate(  Environment environment);\n  @Override @Retryable(interceptor\u003d\"kubernetesSecretsRetryInterceptor\") public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8RetryBootstrapConfiguration.java",
        "name": "Fabric8RetryBootstrapConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @AutoConfigureBefore(Fabric8BootstrapConfiguration.class) @Import({KubernetesCommonsAutoConfiguration.class,Fabric8AutoConfiguration.class}) @ConditionalOnClass({ConfigMap.class,Secret.class}) @AutoConfigureAfter(KubernetesBootstrapConfiguration.class) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesConfigOrSecretsRetryEnabled @ConditionalOnBootstrapEnabled public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8RetryBootstrapConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @AutoConfigureBefore(Fabric8BootstrapConfiguration.class) @Import({KubernetesCommonsAutoConfiguration.class,Fabric8AutoConfiguration.class}) @ConditionalOnClass({ConfigMap.class,Secret.class}) @AutoConfigureAfter(KubernetesBootstrapConfiguration.class) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesConfigOrSecretsRetryEnabled @ConditionalOnBootstrapEnabled public class Fabric8RetryBootstrapConfiguration {\n  @Bean @ConditionalOnKubernetesConfigRetryEnabled public Fabric8ConfigMapPropertySourceLocator configMapPropertySourceLocator(  ConfigMapConfigProperties properties,  KubernetesClient client,  KubernetesNamespaceProvider provider){\n    return new RetryableFabric8ConfigMapPropertySourceLocator(client,properties,provider);\n  }\n  @Bean @ConditionalOnKubernetesSecretsRetryEnabled public Fabric8SecretsPropertySourceLocator secretsPropertySourceLocator(  SecretsConfigProperties properties,  KubernetesClient client,  KubernetesNamespaceProvider provider){\n    return new RetryableFabric8SecretsPropertySourceLocator(client,properties,provider);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @AutoConfigureBefore(Fabric8BootstrapConfiguration.class) @Import({KubernetesCommonsAutoConfiguration.class,Fabric8AutoConfiguration.class}) @ConditionalOnClass({ConfigMap.class,Secret.class}) @AutoConfigureAfter(KubernetesBootstrapConfiguration.class) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesConfigOrSecretsRetryEnabled @ConditionalOnBootstrapEnabled public class Fabric8RetryBootstrapConfiguration {\n  @Bean @ConditionalOnKubernetesConfigRetryEnabled public Fabric8ConfigMapPropertySourceLocator configMapPropertySourceLocator(  ConfigMapConfigProperties properties,  KubernetesClient client,  KubernetesNamespaceProvider provider);\n  @Bean @ConditionalOnKubernetesSecretsRetryEnabled public Fabric8SecretsPropertySourceLocator secretsPropertySourceLocator(  SecretsConfigProperties properties,  KubernetesClient client,  KubernetesNamespaceProvider provider);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/reload/Fabric8EventBasedConfigMapChangeDetector.java",
        "name": "Fabric8EventBasedConfigMapChangeDetector",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.reload.Fabric8EventBasedConfigMapChangeDetector",
        "extend": "ConfigurationChangeDetector",
        "implements": "",
        "raw": "/** \n * An Event Based change detector that subscribes to changes in configMaps and fire a reload when something changes.\n * @author Nicola Ferraro\n * @author Haytham Mohamed\n * @author Kris Iyer\n */\npublic class Fabric8EventBasedConfigMapChangeDetector extends ConfigurationChangeDetector {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8EventBasedConfigMapChangeDetector.class));\n  private final Fabric8ConfigMapPropertySourceLocator fabric8ConfigMapPropertySourceLocator;\n  private final KubernetesClient kubernetesClient;\n  private final List\u003cSharedIndexInformer\u003cConfigMap\u003e\u003e informers\u003dnew ArrayList\u003c\u003e();\n  private final Set\u003cString\u003e namespaces;\n  private final boolean enableReloadFiltering;\n  public Fabric8EventBasedConfigMapChangeDetector(  AbstractEnvironment environment,  ConfigReloadProperties properties,  KubernetesClient kubernetesClient,  ConfigurationUpdateStrategy strategy,  Fabric8ConfigMapPropertySourceLocator fabric8ConfigMapPropertySourceLocator,  KubernetesNamespaceProvider namespaceProvider){\n    super(environment,properties,strategy);\n    this.kubernetesClient\u003dkubernetesClient;\n    this.fabric8ConfigMapPropertySourceLocator\u003dfabric8ConfigMapPropertySourceLocator;\n    this.enableReloadFiltering\u003dproperties.enableReloadFiltering();\n    namespaces\u003dnamespaces(kubernetesClient,namespaceProvider,properties,\"configmap\");\n  }\n  @PostConstruct private void inform(){\n    LOG.info(\"Kubernetes event-based configMap change detector activated\");\n    namespaces.forEach(namespace -\u003e {\n      SharedIndexInformer\u003cConfigMap\u003e informer;\n      if (enableReloadFiltering) {\n        informer\u003dkubernetesClient.configMaps().inNamespace(namespace).withLabels(Map.of(ConfigReloadProperties.RELOAD_LABEL_FILTER,\"true\")).inform();\n        LOG.debug(\"added configmap informer for namespace : \" + namespace + \" with enabled filter\");\n      }\n else {\n        informer\u003dkubernetesClient.configMaps().inNamespace(namespace).inform();\n        LOG.debug(\"added configmap informer for namespace : \" + namespace);\n      }\n      informer.addEventHandler(new ConfigMapInformerAwareEventHandler(informer));\n      informers.add(informer);\n    }\n);\n  }\n  @PreDestroy private void shutdown(){\n    informers.forEach(SharedIndexInformer::close);\n    kubernetesClient.close();\n  }\n  protected void onEvent(  ConfigMap configMap){\n    boolean reload\u003dConfigReloadUtil.reload(\"config-map\",configMap.toString(),fabric8ConfigMapPropertySourceLocator,environment,Fabric8ConfigMapPropertySource.class);\n    if (reload) {\n      reloadProperties();\n    }\n  }\nprivate final class ConfigMapInformerAwareEventHandler implements ResourceEventHandler\u003cConfigMap\u003e {\n    private final SharedIndexInformer\u003cConfigMap\u003e informer;\n    private ConfigMapInformerAwareEventHandler(    SharedIndexInformer\u003cConfigMap\u003e informer){\n      this.informer\u003dinformer;\n    }\n    @Override public void onAdd(    ConfigMap configMap){\n      LOG.debug(\"ConfigMap \" + configMap.getMetadata().getName() + \" was added in namespace \"+ configMap.getMetadata().getNamespace());\n      onEvent(configMap);\n    }\n    @Override public void onUpdate(    ConfigMap oldConfigMap,    ConfigMap newConfigMap){\n      LOG.debug(\"ConfigMap \" + newConfigMap.getMetadata().getName() + \" was updated in namespace \"+ newConfigMap.getMetadata().getNamespace());\n      if (Objects.equals(oldConfigMap.getData(),newConfigMap.getData())) {\n        LOG.debug(() -\u003e \"data in configmap has not changed, will not reload\");\n      }\n else {\n        onEvent(newConfigMap);\n      }\n    }\n    @Override public void onDelete(    ConfigMap configMap,    boolean deletedFinalStateUnknown){\n      LOG.debug(\"ConfigMap \" + configMap.getMetadata().getName() + \" was deleted in namespace \"+ configMap.getMetadata().getName());\n      onEvent(configMap);\n    }\n    @Override public void onNothing(){\n      List\u003cConfigMap\u003e store\u003dinformer.getStore().list();\n      LOG.info(\"onNothing called with a store of size : \" + store.size());\n      LOG.info(\"this might be an indication of a HTTP_GONE code\");\n    }\n  }\n}\n",
        "abstract": "/** \n * An Event Based change detector that subscribes to changes in configMaps and fire a reload when something changes.\n * @author Nicola Ferraro\n * @author Haytham Mohamed\n * @author Kris Iyer\n */\npublic class Fabric8EventBasedConfigMapChangeDetector extends ConfigurationChangeDetector {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8EventBasedConfigMapChangeDetector.class));\n  private final Fabric8ConfigMapPropertySourceLocator fabric8ConfigMapPropertySourceLocator;\n  private final KubernetesClient kubernetesClient;\n  private final List\u003cSharedIndexInformer\u003cConfigMap\u003e\u003e informers\u003dnew ArrayList\u003c\u003e();\n  private final Set\u003cString\u003e namespaces;\n  private final boolean enableReloadFiltering;\n  public Fabric8EventBasedConfigMapChangeDetector(  AbstractEnvironment environment,  ConfigReloadProperties properties,  KubernetesClient kubernetesClient,  ConfigurationUpdateStrategy strategy,  Fabric8ConfigMapPropertySourceLocator fabric8ConfigMapPropertySourceLocator,  KubernetesNamespaceProvider namespaceProvider);\n  @PostConstruct private void inform();\n  @PreDestroy private void shutdown();\n  protected void onEvent(  ConfigMap configMap);\nprivate final class ConfigMapInformerAwareEventHandler implements ResourceEventHandler\u003cConfigMap\u003e {\n    private final SharedIndexInformer\u003cConfigMap\u003e informer;\n    private ConfigMapInformerAwareEventHandler(    SharedIndexInformer\u003cConfigMap\u003e informer);\n    @Override public void onAdd(    ConfigMap configMap);\n    @Override public void onUpdate(    ConfigMap oldConfigMap,    ConfigMap newConfigMap);\n    @Override public void onDelete(    ConfigMap configMap,    boolean deletedFinalStateUnknown);\n    @Override public void onNothing();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/reload/Fabric8ConfigReloadAutoConfiguration.java",
        "name": "Fabric8ConfigReloadAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesReloadEnabled @ConditionalOnClass({EndpointAutoConfiguration.class,RestartEndpoint.class,ContextRefresher.class}) @AutoConfigureAfter({InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,RefreshAutoConfiguration.class,ConfigReloadPropertiesAutoConfiguration.class}) @Import(ConfigReloadAutoConfiguration.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.reload.Fabric8ConfigReloadAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Definition of beans needed for the automatic reload of configuration.\n * @author Nicolla Ferraro\n * @author Kris Iyer\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesReloadEnabled @ConditionalOnClass({EndpointAutoConfiguration.class,RestartEndpoint.class,ContextRefresher.class}) @AutoConfigureAfter({InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,RefreshAutoConfiguration.class,ConfigReloadPropertiesAutoConfiguration.class}) @Import(ConfigReloadAutoConfiguration.class) public class Fabric8ConfigReloadAutoConfiguration {\n  /** \n * Polling configMap ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param fabric8ConfigMapPropertySourceLocator configMap property source locator\n * @return a bean that listen to configuration changes and fire a reload.\n */\n  @Bean @ConditionalOnConfigMapsReloadEnabled @ConditionalOnBean(Fabric8ConfigMapPropertySourceLocator.class) @Conditional(PollingReloadDetectionMode.class) public ConfigurationChangeDetector configMapPropertyChangePollingWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  Fabric8ConfigMapPropertySourceLocator fabric8ConfigMapPropertySourceLocator,  TaskSchedulerWrapper\u003cTaskScheduler\u003e taskSchedulerWrapper,  AbstractEnvironment environment){\n    return new PollingConfigMapChangeDetector(environment,properties,strategy,Fabric8ConfigMapPropertySource.class,fabric8ConfigMapPropertySourceLocator,taskSchedulerWrapper.getTaskScheduler());\n  }\n  /** \n * Polling secrets ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param fabric8SecretsPropertySourceLocator secrets property source locator\n * @return a bean that listen to configuration changes and fire a reload.\n */\n  @Bean @ConditionalOnSecretsReloadEnabled @ConditionalOnBean(Fabric8SecretsPropertySourceLocator.class) @Conditional(PollingReloadDetectionMode.class) public ConfigurationChangeDetector secretsPropertyChangePollingWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  Fabric8SecretsPropertySourceLocator fabric8SecretsPropertySourceLocator,  TaskSchedulerWrapper\u003cTaskScheduler\u003e taskScheduler,  AbstractEnvironment environment){\n    return new PollingSecretsChangeDetector(environment,properties,strategy,Fabric8SecretsPropertySource.class,fabric8SecretsPropertySourceLocator,taskScheduler.getTaskScheduler());\n  }\n  /** \n * Event Based configMap ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param fabric8ConfigMapPropertySourceLocator configMap property source locator\n * @return a bean that listen to configMap change events and fire a reload.\n */\n  @Bean @ConditionalOnConfigMapsReloadEnabled @ConditionalOnBean(Fabric8ConfigMapPropertySourceLocator.class) @Conditional(EventReloadDetectionMode.class) public ConfigurationChangeDetector configMapPropertyChangeEventWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  Fabric8ConfigMapPropertySourceLocator fabric8ConfigMapPropertySourceLocator,  AbstractEnvironment environment,  KubernetesClient kubernetesClient){\n    return new Fabric8EventBasedConfigMapChangeDetector(environment,properties,kubernetesClient,strategy,fabric8ConfigMapPropertySourceLocator,new KubernetesNamespaceProvider(environment));\n  }\n  /** \n * Event Based secrets ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param fabric8SecretsPropertySourceLocator secrets property source locator\n * @return a bean that listen to secrets change events and fire a reload.\n */\n  @Bean @ConditionalOnSecretsReloadEnabled @ConditionalOnBean(Fabric8SecretsPropertySourceLocator.class) @Conditional(EventReloadDetectionMode.class) public ConfigurationChangeDetector secretsPropertyChangeEventWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  Fabric8SecretsPropertySourceLocator fabric8SecretsPropertySourceLocator,  AbstractEnvironment environment,  KubernetesClient kubernetesClient){\n    return new Fabric8EventBasedSecretsChangeDetector(environment,properties,kubernetesClient,strategy,fabric8SecretsPropertySourceLocator,new KubernetesNamespaceProvider(environment));\n  }\n}\n",
        "abstract": "/** \n * Definition of beans needed for the automatic reload of configuration.\n * @author Nicolla Ferraro\n * @author Kris Iyer\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesReloadEnabled @ConditionalOnClass({EndpointAutoConfiguration.class,RestartEndpoint.class,ContextRefresher.class}) @AutoConfigureAfter({InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,RefreshAutoConfiguration.class,ConfigReloadPropertiesAutoConfiguration.class}) @Import(ConfigReloadAutoConfiguration.class) public class Fabric8ConfigReloadAutoConfiguration {\n  /** \n * Polling configMap ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param fabric8ConfigMapPropertySourceLocator configMap property source locator\n * @return a bean that listen to configuration changes and fire a reload.\n */\n  @Bean @ConditionalOnConfigMapsReloadEnabled @ConditionalOnBean(Fabric8ConfigMapPropertySourceLocator.class) @Conditional(PollingReloadDetectionMode.class) public ConfigurationChangeDetector configMapPropertyChangePollingWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  Fabric8ConfigMapPropertySourceLocator fabric8ConfigMapPropertySourceLocator,  TaskSchedulerWrapper\u003cTaskScheduler\u003e taskSchedulerWrapper,  AbstractEnvironment environment);\n  /** \n * Polling secrets ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param fabric8SecretsPropertySourceLocator secrets property source locator\n * @return a bean that listen to configuration changes and fire a reload.\n */\n  @Bean @ConditionalOnSecretsReloadEnabled @ConditionalOnBean(Fabric8SecretsPropertySourceLocator.class) @Conditional(PollingReloadDetectionMode.class) public ConfigurationChangeDetector secretsPropertyChangePollingWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  Fabric8SecretsPropertySourceLocator fabric8SecretsPropertySourceLocator,  TaskSchedulerWrapper\u003cTaskScheduler\u003e taskScheduler,  AbstractEnvironment environment);\n  /** \n * Event Based configMap ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param fabric8ConfigMapPropertySourceLocator configMap property source locator\n * @return a bean that listen to configMap change events and fire a reload.\n */\n  @Bean @ConditionalOnConfigMapsReloadEnabled @ConditionalOnBean(Fabric8ConfigMapPropertySourceLocator.class) @Conditional(EventReloadDetectionMode.class) public ConfigurationChangeDetector configMapPropertyChangeEventWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  Fabric8ConfigMapPropertySourceLocator fabric8ConfigMapPropertySourceLocator,  AbstractEnvironment environment,  KubernetesClient kubernetesClient);\n  /** \n * Event Based secrets ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param fabric8SecretsPropertySourceLocator secrets property source locator\n * @return a bean that listen to secrets change events and fire a reload.\n */\n  @Bean @ConditionalOnSecretsReloadEnabled @ConditionalOnBean(Fabric8SecretsPropertySourceLocator.class) @Conditional(EventReloadDetectionMode.class) public ConfigurationChangeDetector secretsPropertyChangeEventWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  Fabric8SecretsPropertySourceLocator fabric8SecretsPropertySourceLocator,  AbstractEnvironment environment,  KubernetesClient kubernetesClient);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/reload/Fabric8EventBasedSecretsChangeDetector.java",
        "name": "Fabric8EventBasedSecretsChangeDetector",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.reload.Fabric8EventBasedSecretsChangeDetector",
        "extend": "ConfigurationChangeDetector",
        "implements": "",
        "raw": "/** \n * An event based change detector that subscribes to changes in secrets and fire a reload when something changes.\n * @author Nicola Ferraro\n * @author Haytham Mohamed\n * @author Kris Iyer\n */\npublic class Fabric8EventBasedSecretsChangeDetector extends ConfigurationChangeDetector {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8EventBasedSecretsChangeDetector.class));\n  private final Fabric8SecretsPropertySourceLocator fabric8SecretsPropertySourceLocator;\n  private final KubernetesClient kubernetesClient;\n  private final List\u003cSharedIndexInformer\u003cSecret\u003e\u003e informers\u003dnew ArrayList\u003c\u003e();\n  private final Set\u003cString\u003e namespaces;\n  private final boolean enableReloadFiltering;\n  public Fabric8EventBasedSecretsChangeDetector(  AbstractEnvironment environment,  ConfigReloadProperties properties,  KubernetesClient kubernetesClient,  ConfigurationUpdateStrategy strategy,  Fabric8SecretsPropertySourceLocator fabric8SecretsPropertySourceLocator,  KubernetesNamespaceProvider namespaceProvider){\n    super(environment,properties,strategy);\n    this.kubernetesClient\u003dkubernetesClient;\n    this.fabric8SecretsPropertySourceLocator\u003dfabric8SecretsPropertySourceLocator;\n    this.enableReloadFiltering\u003dproperties.enableReloadFiltering();\n    namespaces\u003dnamespaces(kubernetesClient,namespaceProvider,properties,\"secrets\");\n  }\n  @PreDestroy private void shutdown(){\n    informers.forEach(SharedIndexInformer::close);\n    kubernetesClient.close();\n  }\n  @PostConstruct private void inform(){\n    LOG.info(\"Kubernetes event-based secrets change detector activated\");\n    namespaces.forEach(namespace -\u003e {\n      SharedIndexInformer\u003cSecret\u003e informer;\n      if (enableReloadFiltering) {\n        informer\u003dkubernetesClient.secrets().inNamespace(namespace).withLabels(Map.of(ConfigReloadProperties.RELOAD_LABEL_FILTER,\"true\")).inform();\n        LOG.debug(\"added secret informer for namespace : \" + namespace + \" with enabled filter\");\n      }\n else {\n        informer\u003dkubernetesClient.secrets().inNamespace(namespace).inform();\n        LOG.debug(\"added secret informer for namespace : \" + namespace);\n      }\n      informer.addEventHandler(new SecretInformerAwareEventHandler(informer));\n      informers.add(informer);\n    }\n);\n  }\n  protected void onEvent(  Secret secret){\n    boolean reload\u003dConfigReloadUtil.reload(\"secrets\",secret.toString(),fabric8SecretsPropertySourceLocator,environment,Fabric8SecretsPropertySource.class);\n    if (reload) {\n      reloadProperties();\n    }\n  }\nprivate final class SecretInformerAwareEventHandler implements ResourceEventHandler\u003cSecret\u003e {\n    private final SharedIndexInformer\u003cSecret\u003e informer;\n    private SecretInformerAwareEventHandler(    SharedIndexInformer\u003cSecret\u003e informer){\n      this.informer\u003dinformer;\n    }\n    @Override public void onAdd(    Secret secret){\n      LOG.debug(\"Secret \" + secret.getMetadata().getName() + \" was added in namespace \"+ secret.getMetadata().getNamespace());\n      onEvent(secret);\n    }\n    @Override public void onUpdate(    Secret oldSecret,    Secret newSecret){\n      LOG.debug(\"Secret \" + newSecret.getMetadata().getName() + \" was updated in namespace \"+ newSecret.getMetadata().getNamespace());\n      if (Objects.equals(oldSecret.getData(),newSecret.getData())) {\n        LOG.debug(() -\u003e \"data in secret has not changed, will not reload\");\n      }\n else {\n        onEvent(newSecret);\n      }\n    }\n    @Override public void onDelete(    Secret secret,    boolean deletedFinalStateUnknown){\n      LOG.debug(\"Secret \" + secret.getMetadata().getName() + \" was deleted in namespace \"+ secret.getMetadata().getNamespace());\n      onEvent(secret);\n    }\n    @Override public void onNothing(){\n      List\u003cSecret\u003e store\u003dinformer.getStore().list();\n      LOG.info(\"onNothing called with a store of size : \" + store.size());\n      LOG.info(\"this might be an indication of a HTTP_GONE code\");\n    }\n  }\n}\n",
        "abstract": "/** \n * An event based change detector that subscribes to changes in secrets and fire a reload when something changes.\n * @author Nicola Ferraro\n * @author Haytham Mohamed\n * @author Kris Iyer\n */\npublic class Fabric8EventBasedSecretsChangeDetector extends ConfigurationChangeDetector {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8EventBasedSecretsChangeDetector.class));\n  private final Fabric8SecretsPropertySourceLocator fabric8SecretsPropertySourceLocator;\n  private final KubernetesClient kubernetesClient;\n  private final List\u003cSharedIndexInformer\u003cSecret\u003e\u003e informers\u003dnew ArrayList\u003c\u003e();\n  private final Set\u003cString\u003e namespaces;\n  private final boolean enableReloadFiltering;\n  public Fabric8EventBasedSecretsChangeDetector(  AbstractEnvironment environment,  ConfigReloadProperties properties,  KubernetesClient kubernetesClient,  ConfigurationUpdateStrategy strategy,  Fabric8SecretsPropertySourceLocator fabric8SecretsPropertySourceLocator,  KubernetesNamespaceProvider namespaceProvider);\n  @PreDestroy private void shutdown();\n  @PostConstruct private void inform();\n  protected void onEvent(  Secret secret);\nprivate final class SecretInformerAwareEventHandler implements ResourceEventHandler\u003cSecret\u003e {\n    private final SharedIndexInformer\u003cSecret\u003e informer;\n    private SecretInformerAwareEventHandler(    SharedIndexInformer\u003cSecret\u003e informer);\n    @Override public void onAdd(    Secret secret);\n    @Override public void onUpdate(    Secret oldSecret,    Secret newSecret);\n    @Override public void onDelete(    Secret secret,    boolean deletedFinalStateUnknown);\n    @Override public void onNothing();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8ContextToSourceData.java",
        "name": "Fabric8ContextToSourceData",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8ContextToSourceData",
        "extend": "",
        "implements": "Function\u003cFabric8ConfigContext,SourceData\u003e",
        "raw": "/** \n * A more succinct way to define a Function from Fabric8ConfigContext to SourceData.\n * @author wind57\n */\ninterface Fabric8ContextToSourceData extends Function\u003cFabric8ConfigContext,SourceData\u003e {\n}\n",
        "abstract": "/** \n * A more succinct way to define a Function from Fabric8ConfigContext to SourceData.\n * @author wind57\n */\ninterface Fabric8ContextToSourceData extends Function\u003cFabric8ConfigContext,SourceData\u003e {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8SecretsPropertySourceLocator.java",
        "name": "Fabric8SecretsPropertySourceLocator",
        "modifiers": "@Order(1) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8SecretsPropertySourceLocator",
        "extend": "SecretsPropertySourceLocator",
        "implements": "",
        "raw": "/** \n * Kubernetes  {@link PropertySourceLocator} for secrets.\n * @author l burgazzoli\n * @author Haytham Mohamed\n * @author Isik Erhan\n */\n@Order(1) public class Fabric8SecretsPropertySourceLocator extends SecretsPropertySourceLocator {\n  private final KubernetesClient client;\n  private final KubernetesNamespaceProvider provider;\n  Fabric8SecretsPropertySourceLocator(  KubernetesClient client,  SecretsConfigProperties properties,  KubernetesNamespaceProvider provider){\n    super(properties,new Fabric8SecretsCache());\n    this.client\u003dclient;\n    this.provider\u003dprovider;\n  }\n  @Override protected SecretsPropertySource getPropertySource(  ConfigurableEnvironment environment,  NormalizedSource normalizedSource){\n    String namespace\u003dgetApplicationNamespace(client,normalizedSource.namespace().orElse(null),normalizedSource.target(),provider);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(client,normalizedSource,namespace,environment);\n    return new Fabric8SecretsPropertySource(context);\n  }\n}\n",
        "abstract": "/** \n * Kubernetes  {@link PropertySourceLocator} for secrets.\n * @author l burgazzoli\n * @author Haytham Mohamed\n * @author Isik Erhan\n */\n@Order(1) public class Fabric8SecretsPropertySourceLocator extends SecretsPropertySourceLocator {\n  private final KubernetesClient client;\n  private final KubernetesNamespaceProvider provider;\n  Fabric8SecretsPropertySourceLocator(  KubernetesClient client,  SecretsConfigProperties properties,  KubernetesNamespaceProvider provider);\n  @Override protected SecretsPropertySource getPropertySource(  ConfigurableEnvironment environment,  NormalizedSource normalizedSource);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8BootstrapConfiguration.java",
        "name": "Fabric8BootstrapConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnBootstrapEnabled @ConditionalOnClass({ConfigMap.class,Secret.class}) @Import({KubernetesCommonsAutoConfiguration.class,Fabric8AutoConfiguration.class}) @AutoConfigureAfter(KubernetesBootstrapConfiguration.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8BootstrapConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Auto configuration that reuses Kubernetes config maps as property sources.\n * @author Ioannis Canellos\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnBootstrapEnabled @ConditionalOnClass({ConfigMap.class,Secret.class}) @Import({KubernetesCommonsAutoConfiguration.class,Fabric8AutoConfiguration.class}) @AutoConfigureAfter(KubernetesBootstrapConfiguration.class) public class Fabric8BootstrapConfiguration {\n  @Bean KubernetesNamespaceProvider provider(  Environment env){\n    return new KubernetesNamespaceProvider(env);\n  }\n  @Bean @ConditionalOnKubernetesConfigEnabled @ConditionalOnKubernetesConfigRetryDisabled public Fabric8ConfigMapPropertySourceLocator configMapPropertySourceLocator(  ConfigMapConfigProperties properties,  KubernetesClient client,  KubernetesNamespaceProvider provider){\n    return new Fabric8ConfigMapPropertySourceLocator(client,properties,provider);\n  }\n  @Bean @ConditionalOnKubernetesSecretsEnabled @ConditionalOnKubernetesSecretsRetryDisabled public Fabric8SecretsPropertySourceLocator secretsPropertySourceLocator(  SecretsConfigProperties properties,  KubernetesClient client,  KubernetesNamespaceProvider provider){\n    return new Fabric8SecretsPropertySourceLocator(client,properties,provider);\n  }\n}\n",
        "abstract": "/** \n * Auto configuration that reuses Kubernetes config maps as property sources.\n * @author Ioannis Canellos\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnBootstrapEnabled @ConditionalOnClass({ConfigMap.class,Secret.class}) @Import({KubernetesCommonsAutoConfiguration.class,Fabric8AutoConfiguration.class}) @AutoConfigureAfter(KubernetesBootstrapConfiguration.class) public class Fabric8BootstrapConfiguration {\n  @Bean KubernetesNamespaceProvider provider(  Environment env);\n  @Bean @ConditionalOnKubernetesConfigEnabled @ConditionalOnKubernetesConfigRetryDisabled public Fabric8ConfigMapPropertySourceLocator configMapPropertySourceLocator(  ConfigMapConfigProperties properties,  KubernetesClient client,  KubernetesNamespaceProvider provider);\n  @Bean @ConditionalOnKubernetesSecretsEnabled @ConditionalOnKubernetesSecretsRetryDisabled public Fabric8SecretsPropertySourceLocator secretsPropertySourceLocator(  SecretsConfigProperties properties,  KubernetesClient client,  KubernetesNamespaceProvider provider);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/main/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8ConfigMapsCache.java",
        "name": "Fabric8ConfigMapsCache",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8ConfigMapsCache",
        "extend": "",
        "implements": "ConfigMapCache",
        "raw": "/** \n * A cache of ConfigMaps per namespace. Makes sure we read config maps only once from a namespace.\n * @author wind57\n */\nfinal class Fabric8ConfigMapsCache implements ConfigMapCache {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8ConfigMapsCache.class));\n  /** \n * at the moment our loading of config maps is using a single thread, but might change in the future, thus a thread safe structure.\n */\n  private static final ConcurrentHashMap\u003cString,List\u003cStrippedSourceContainer\u003e\u003e CACHE\u003dnew ConcurrentHashMap\u003c\u003e();\n  @Override public void discardAll(){\n    CACHE.clear();\n  }\n  static List\u003cStrippedSourceContainer\u003e byNamespace(  KubernetesClient client,  String namespace){\n    boolean[] b\u003dnew boolean[1];\n    List\u003cStrippedSourceContainer\u003e result\u003dCACHE.computeIfAbsent(namespace,x -\u003e {\n      b[0]\u003dtrue;\n      return strippedConfigMaps(client.configMaps().inNamespace(namespace).list().getItems());\n    }\n);\n    if (b[0]) {\n      LOG.debug(() -\u003e \"Loaded all config maps in namespace \u0027\" + namespace + \"\u0027\");\n    }\n else {\n      LOG.debug(() -\u003e \"Loaded (from cache) all config maps in namespace \u0027\" + namespace + \"\u0027\");\n    }\n    return result;\n  }\n  private static List\u003cStrippedSourceContainer\u003e strippedConfigMaps(  List\u003cConfigMap\u003e configMaps){\n    return configMaps.stream().map(configMap -\u003e new StrippedSourceContainer(configMap.getMetadata().getLabels(),configMap.getMetadata().getName(),configMap.getData())).collect(Collectors.toList());\n  }\n}\n",
        "abstract": "/** \n * A cache of ConfigMaps per namespace. Makes sure we read config maps only once from a namespace.\n * @author wind57\n */\nfinal class Fabric8ConfigMapsCache implements ConfigMapCache {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8ConfigMapsCache.class));\n  /** \n * at the moment our loading of config maps is using a single thread, but might change in the future, thus a thread safe structure.\n */\n  private static final ConcurrentHashMap\u003cString,List\u003cStrippedSourceContainer\u003e\u003e CACHE\u003dnew ConcurrentHashMap\u003c\u003e();\n  @Override public void discardAll();\n  static List\u003cStrippedSourceContainer\u003e byNamespace(  KubernetesClient client,  String namespace);\n  private static List\u003cStrippedSourceContainer\u003e strippedConfigMaps(  List\u003cConfigMap\u003e configMaps);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/BootstrapConfigMapsWithProfilesTests.java",
        "name": "BootstrapConfigMapsWithProfilesTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.BootstrapConfigMapsWithProfilesTests",
        "extend": "ConfigMapsWithProfilesTests",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapConfigMapsWithProfilesTests extends ConfigMapsWithProfilesTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapConfigMapsWithProfilesTests extends ConfigMapsWithProfilesTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/single_source_multiple_files/properties/Type.java",
        "name": "Type",
        "modifiers": "@ConfigurationProperties(\"fruit\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.single_source_multiple_files.properties.Type",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"fruit\") public class Type {\n  private String type;\n  public String getType(){\n    return type;\n  }\n  public void setType(  String type){\n    this.type\u003dtype;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"fruit\") public class Type {\n  private String type;\n  public String getType();\n  public void setType(  String type);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/single_source_multiple_files/properties/Shape.java",
        "name": "Shape",
        "modifiers": "@ConfigurationProperties(\"shape.when\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.single_source_multiple_files.properties.Shape",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"shape.when\") public class Shape {\n  private String raw;\n  private String ripe;\n  public String getRaw(){\n    return raw;\n  }\n  public void setRaw(  String raw){\n    this.raw\u003draw;\n  }\n  public String getRipe(){\n    return ripe;\n  }\n  public void setRipe(  String ripe){\n    this.ripe\u003dripe;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"shape.when\") public class Shape {\n  private String raw;\n  private String ripe;\n  public String getRaw();\n  public void setRaw(  String raw);\n  public String getRipe();\n  public void setRipe(  String ripe);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/single_source_multiple_files/properties/Name.java",
        "name": "Name",
        "modifiers": "@ConfigurationProperties(\"cool\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.single_source_multiple_files.properties.Name",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"cool\") public class Name {\n  private String name;\n  public String getName(){\n    return name;\n  }\n  public void setName(  String name){\n    this.name\u003dname;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"cool\") public class Name {\n  private String name;\n  public String getName();\n  public void setName(  String name);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/single_source_multiple_files/properties/Color.java",
        "name": "Color",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"color.when\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.single_source_multiple_files.properties.Color",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"color.when\") public class Color {\n  private String raw;\n  private String ripe;\n  public String getRaw(){\n    return raw;\n  }\n  public void setRaw(  String raw){\n    this.raw\u003draw;\n  }\n  public String getRipe(){\n    return ripe;\n  }\n  public void setRipe(  String ripe){\n    this.ripe\u003dripe;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"color.when\") public class Color {\n  private String raw;\n  private String ripe;\n  public String getRaw();\n  public void setRaw(  String raw);\n  public String getRipe();\n  public void setRipe(  String ripe);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/single_source_multiple_files/controller/SingleSourceMultipleFilesController.java",
        "name": "SingleSourceMultipleFilesController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.single_source_multiple_files.controller.SingleSourceMultipleFilesController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class SingleSourceMultipleFilesController {\n  private final Name name;\n  private final Shape shape;\n  private final Color color;\n  private final Type type;\n  public SingleSourceMultipleFilesController(  Name name,  Shape shape,  Color color,  Type type){\n    this.name\u003dname;\n    this.shape\u003dshape;\n    this.color\u003dcolor;\n    this.type\u003dtype;\n  }\n  @GetMapping(\"/single_source-multiple-files/type\") public String type(){\n    return type.getType();\n  }\n  @GetMapping(\"/single_source-multiple-files/shape\") public String shape(){\n    return shape.getRaw();\n  }\n  @GetMapping(\"/single_source-multiple-files/color\") public String color(){\n    return \"raw:\" + color.getRaw() + \"###\"+ \"ripe:\"+ color.getRipe();\n  }\n  @GetMapping(\"/single_source-multiple-files/name\") public String name(){\n    return name.getName();\n  }\n}\n",
        "abstract": "@RestController public class SingleSourceMultipleFilesController {\n  private final Name name;\n  private final Shape shape;\n  private final Color color;\n  private final Type type;\n  public SingleSourceMultipleFilesController(  Name name,  Shape shape,  Color color,  Type type);\n  @GetMapping(\"/single_source-multiple-files/type\") public String type();\n  @GetMapping(\"/single_source-multiple-files/shape\") public String shape();\n  @GetMapping(\"/single_source-multiple-files/color\") public String color();\n  @GetMapping(\"/single_source-multiple-files/name\") public String name();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/single_source_multiple_files/SingleSourceMultipleFilesApp.java",
        "name": "SingleSourceMultipleFilesApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({Name.class,Shape.class,Color.class,Type.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.single_source_multiple_files.SingleSourceMultipleFilesApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({Name.class,Shape.class,Color.class,Type.class}) public class SingleSourceMultipleFilesApp {\n  public static void main(  String[] args){\n    SpringApplication.run(SingleSourceMultipleFilesApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({Name.class,Shape.class,Color.class,Type.class}) public class SingleSourceMultipleFilesApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/single_source_multiple_files/SingleSourceMultipleFilesBootstrapTests.java",
        "name": "SingleSourceMultipleFilesBootstrapTests",
        "modifiers": "@ActiveProfiles(\"color\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSingleSourceMultipleFilesApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsingle-source-multiple-files\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.single_source_multiple_files.SingleSourceMultipleFilesBootstrapTests",
        "extend": "SingleSourceMultipleFilesTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles(\"color\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSingleSourceMultipleFilesApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsingle-source-multiple-files\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class SingleSourceMultipleFilesBootstrapTests extends SingleSourceMultipleFilesTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles(\"color\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSingleSourceMultipleFilesApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsingle-source-multiple-files\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class SingleSourceMultipleFilesBootstrapTests extends SingleSourceMultipleFilesTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/single_source_multiple_files/SingleSourceMultipleFilesConfigDataTests.java",
        "name": "SingleSourceMultipleFilesConfigDataTests",
        "modifiers": "@ActiveProfiles(\"color\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSingleSourceMultipleFilesApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./single-source-multiple-files.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.single_source_multiple_files.SingleSourceMultipleFilesConfigDataTests",
        "extend": "SingleSourceMultipleFilesTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles(\"color\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSingleSourceMultipleFilesApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./single-source-multiple-files.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class SingleSourceMultipleFilesConfigDataTests extends SingleSourceMultipleFilesTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles(\"color\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSingleSourceMultipleFilesApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./single-source-multiple-files.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class SingleSourceMultipleFilesConfigDataTests extends SingleSourceMultipleFilesTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/single_source_multiple_files/SingleSourceMultipleFilesTests.java",
        "name": "SingleSourceMultipleFilesTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.single_source_multiple_files.SingleSourceMultipleFilesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57issue: https://github.com/spring-cloud/spring-cloud-kubernetes/issues/640\n */\nabstract class SingleSourceMultipleFilesTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    SingleSourceMultipleFilesTests.mockClient\u003dmockClient;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e one\u003dnew HashMap\u003c\u003e();\n    one.put(\"fruit.type\",\"yummy\");\n    one.put(\"fruit.properties\",\"cool.name\u003dbanana\");\n    one.put(\"fruit-color.properties\",\"color.when.raw\u003dgreen\\ncolor.when.ripe\u003dyellow\");\n    one.put(\"fruit-shape.properties\",\"shape.when.raw\u003dsmall-sphere\\nshape.when.ripe\u003dbigger-sphere\");\n    createConfigmap(one);\n  }\n  static void createConfigmap(  Map\u003cString,String\u003e data){\n    mockClient.configMaps().inNamespace(\"spring-k8s\").resource(new ConfigMapBuilder().withNewMetadata().withName(\"my-configmap\").endMetadata().addToData(data).build()).create();\n  }\n  /** \n * \u003cpre\u003e \"fruit-color.properties\" is taken since \"spring.application.name\u003dfruit\" and \"color\" is an active profile \u003c/pre\u003e\n */\n  @Test void color(){\n    this.webClient.get().uri(\"/single_source-multiple-files/color\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"raw:green###ripe:yellow\"));\n  }\n  /** \n * \u003cpre\u003e \"fruit.properties\" is read, since it matches \"spring.application.name\" \u003c/pre\u003e\n */\n  @Test void name(){\n    this.webClient.get().uri(\"/single_source-multiple-files/name\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"banana\"));\n  }\n  /** \n * \u003cpre\u003e shape profile is not active, thus property \"fruit-shape.properties\" is skipped and as such, a null comes here. \u003c/pre\u003e\n */\n  @Test void shape(){\n    this.webClient.get().uri(\"/single_source-multiple-files/shape\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.nullValue());\n  }\n  /** \n * \u003cpre\u003e this is a non-file property in the configmap \u003c/pre\u003e\n */\n  @Test void type(){\n    this.webClient.get().uri(\"/single_source-multiple-files/type\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"yummy\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57issue: https://github.com/spring-cloud/spring-cloud-kubernetes/issues/640\n */\nabstract class SingleSourceMultipleFilesTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n  static void createConfigmap(  Map\u003cString,String\u003e data);\n  /** \n * \u003cpre\u003e \"fruit-color.properties\" is taken since \"spring.application.name\u003dfruit\" and \"color\" is an active profile \u003c/pre\u003e\n */\n  @Test void color();\n  /** \n * \u003cpre\u003e \"fruit.properties\" is read, since it matches \"spring.application.name\" \u003c/pre\u003e\n */\n  @Test void name();\n  /** \n * \u003cpre\u003e shape profile is not active, thus property \"fruit-shape.properties\" is skipped and as such, a null comes here. \u003c/pre\u003e\n */\n  @Test void shape();\n  /** \n * \u003cpre\u003e this is a non-file property in the configmap \u003c/pre\u003e\n */\n  @Test void type();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_prefix/properties/One.java",
        "name": "One",
        "modifiers": "@ConfigurationProperties(\"one\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_prefix.properties.One",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_prefix/properties/Two.java",
        "name": "Two",
        "modifiers": "@ConfigurationProperties(\"two\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_prefix.properties.Two",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_prefix/properties/Three.java",
        "name": "Three",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"configmap-three\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_prefix.properties.Three",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"configmap-three\") public class Three {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"configmap-three\") public class Three {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_prefix/properties/Four.java",
        "name": "Four",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"configmap-four\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_prefix.properties.Four",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"configmap-four\") public class Four {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"configmap-four\") public class Four {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_prefix/LabeledConfigMapWithPrefixApp.java",
        "name": "LabeledConfigMapWithPrefixApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class,Four.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_prefix.LabeledConfigMapWithPrefixApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class,Four.class}) public class LabeledConfigMapWithPrefixApp {\n  public static void main(  String[] args){\n    SpringApplication.run(LabeledConfigMapWithPrefixApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class,Four.class}) public class LabeledConfigMapWithPrefixApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_prefix/controller/LabeledConfigMapWithPrefixController.java",
        "name": "LabeledConfigMapWithPrefixController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_prefix.controller.LabeledConfigMapWithPrefixController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class LabeledConfigMapWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  private final Four four;\n  public LabeledConfigMapWithPrefixController(  One one,  Two two,  Three three,  Four four){\n    this.one\u003done;\n    this.two\u003dtwo;\n    this.three\u003dthree;\n    this.four\u003dfour;\n  }\n  @GetMapping(\"/labeled-configmap/prefix/one\") public String one(){\n    return one.getProperty();\n  }\n  @GetMapping(\"/labeled-configmap/prefix/two\") public String two(){\n    return two.getProperty();\n  }\n  @GetMapping(\"/labeled-configmap/prefix/three\") public String three(){\n    return three.getProperty();\n  }\n  @GetMapping(\"/labeled-configmap/prefix/four\") public String four(){\n    return four.getProperty();\n  }\n}\n",
        "abstract": "@RestController public class LabeledConfigMapWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  private final Four four;\n  public LabeledConfigMapWithPrefixController(  One one,  Two two,  Three three,  Four four);\n  @GetMapping(\"/labeled-configmap/prefix/one\") public String one();\n  @GetMapping(\"/labeled-configmap/prefix/two\") public String two();\n  @GetMapping(\"/labeled-configmap/prefix/three\") public String three();\n  @GetMapping(\"/labeled-configmap/prefix/four\") public String four();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_prefix/LabeledConfigMapWithPrefixTests.java",
        "name": "LabeledConfigMapWithPrefixTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_prefix.LabeledConfigMapWithPrefixTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class LabeledConfigMapWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    LabeledConfigMapWithPrefixTests.mockClient\u003dmockClient;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e one\u003dCollections.singletonMap(\"one.property\",\"one\");\n    createConfigMap(\"configmap-one\",one,Collections.singletonMap(\"letter\",\"a\"));\n    Map\u003cString,String\u003e two\u003dCollections.singletonMap(\"property\",\"two\");\n    createConfigMap(\"configmap-two\",two,Collections.singletonMap(\"letter\",\"b\"));\n    Map\u003cString,String\u003e three\u003dCollections.singletonMap(\"property\",\"three\");\n    createConfigMap(\"configmap-three\",three,Collections.singletonMap(\"letter\",\"c\"));\n    Map\u003cString,String\u003e four\u003dCollections.singletonMap(\"property\",\"four\");\n    createConfigMap(\"configmap-four\",four,Collections.singletonMap(\"letter\",\"d\"));\n  }\n  private static void createConfigMap(  String name,  Map\u003cString,String\u003e data,  Map\u003cString,String\u003e labels){\n    mockClient.configMaps().inNamespace(\"spring-k8s\").resource(new ConfigMapBuilder().withNewMetadata().withName(name).withLabels(labels).endMetadata().addToData(data).build()).create();\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.configmap.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.configmap.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne(){\n    this.webClient.get().uri(\"/labeled-configmap/prefix/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo(){\n    this.webClient.get().uri(\"/labeled-configmap/prefix/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[2].labels\u003dletter:c\u0027 (\"property\", \"three\") We find the configmap by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"configmap-three\") \u003c/pre\u003e\n */\n  @Test void testThree(){\n    this.webClient.get().uri(\"/labeled-configmap/prefix/three\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"three\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[3].labels\u003dletter:d\u0027 (\"property\", \"four\") We find the configmap by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"configmap-four\") \u003c/pre\u003e\n */\n  @Test void testFour(){\n    this.webClient.get().uri(\"/labeled-configmap/prefix/four\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"four\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class LabeledConfigMapWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n  private static void createConfigMap(  String name,  Map\u003cString,String\u003e data,  Map\u003cString,String\u003e labels);\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.configmap.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.configmap.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[2].labels\u003dletter:c\u0027 (\"property\", \"three\") We find the configmap by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"configmap-three\") \u003c/pre\u003e\n */\n  @Test void testThree();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[3].labels\u003dletter:d\u0027 (\"property\", \"four\") We find the configmap by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"configmap-four\") \u003c/pre\u003e\n */\n  @Test void testFour();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_prefix/LabeledConfigMapWithPrefixConfigDataTests.java",
        "name": "LabeledConfigMapWithPrefixConfigDataTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithPrefixApp.class,properties\u003d{\"spring.application.name\u003dlabeled-configmap-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-configmap-with-prefix.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_prefix.LabeledConfigMapWithPrefixConfigDataTests",
        "extend": "LabeledConfigMapWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithPrefixApp.class,properties\u003d{\"spring.application.name\u003dlabeled-configmap-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-configmap-with-prefix.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledConfigMapWithPrefixConfigDataTests extends LabeledConfigMapWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithPrefixApp.class,properties\u003d{\"spring.application.name\u003dlabeled-configmap-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-configmap-with-prefix.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledConfigMapWithPrefixConfigDataTests extends LabeledConfigMapWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_prefix/LabeledConfigMapWithPrefixBootstrapTests.java",
        "name": "LabeledConfigMapWithPrefixBootstrapTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-configmap-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_prefix.LabeledConfigMapWithPrefixBootstrapTests",
        "extend": "LabeledConfigMapWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-configmap-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledConfigMapWithPrefixBootstrapTests extends LabeledConfigMapWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-configmap-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledConfigMapWithPrefixBootstrapTests extends LabeledConfigMapWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/Application.java",
        "name": "Application",
        "modifiers": "@SpringBootApplication public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Application",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication public class Application {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication public class Application {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retryable_sources_order/Properties.java",
        "name": "Properties",
        "modifiers": "@ConfigurationProperties(\"my\")",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retryable_sources_order.Properties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"my\") class Properties {\n  private String key;\n  private String one;\n  private String two;\n  public String getKey(){\n    return key;\n  }\n  public void setKey(  String key){\n    this.key\u003dkey;\n  }\n  public String getOne(){\n    return one;\n  }\n  public void setOne(  String one){\n    this.one\u003done;\n  }\n  public String getTwo(){\n    return two;\n  }\n  public void setTwo(  String two){\n    this.two\u003dtwo;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"my\") class Properties {\n  private String key;\n  private String one;\n  private String two;\n  public String getKey();\n  public void setKey(  String key);\n  public String getOne();\n  public void setOne(  String one);\n  public String getTwo();\n  public void setTwo(  String two);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retryable_sources_order/RetryableSourcesOrderTests.java",
        "name": "RetryableSourcesOrderTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retryable_sources_order.RetryableSourcesOrderTests",
        "extend": "",
        "implements": "",
        "raw": "abstract class RetryableSourcesOrderTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    RetryableSourcesOrderTests.mockClient\u003dmockClient;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e secretData\u003dnew HashMap\u003c\u003e();\n    secretData.put(\"my.key\",Base64.getEncoder().encodeToString(\"from-secret\".getBytes(StandardCharsets.UTF_8)));\n    secretData.put(\"my.one\",Base64.getEncoder().encodeToString(\"one\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"my-secret\",secretData);\n    Map\u003cString,String\u003e configMapData\u003dnew HashMap\u003c\u003e();\n    configMapData.put(\"my.key\",\"from-configmap\");\n    configMapData.put(\"my.two\",\"two\");\n    createConfigmap(\"my-configmap\",configMapData);\n  }\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data){\n    mockClient.secrets().inNamespace(\"spring-k8s\").create(new SecretBuilder().withNewMetadata().withName(name).endMetadata().addToData(data).build());\n  }\n  private static void createConfigmap(  String name,  Map\u003cString,String\u003e data){\n    mockClient.configMaps().inNamespace(\"spring-k8s\").create(new ConfigMapBuilder().withNewMetadata().withName(name).endMetadata().addToData(data).build());\n  }\n  /** \n * \u003cpre\u003e 1. There is one secret deployed: my-secret. It has two properties: {my.one\u003done, my.key\u003dfrom-secret} 2. There is one configmap deployed: my-configmap. It has two properties: {my.two\u003dtwo, my.key\u003dfrom-configmap} We invoke three endpoints: /one, /two, /key. The first two prove that both the secret and configmap have been read, the last one proves that config maps have a higher precedence. \u003c/pre\u003e\n */\n  @Test void test(){\n    this.webClient.get().uri(\"/retryable-one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one\"));\n    this.webClient.get().uri(\"/retryable-two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n    this.webClient.get().uri(\"/retryable-key\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"from-configmap\"));\n  }\n}\n",
        "abstract": "abstract class RetryableSourcesOrderTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data);\n  private static void createConfigmap(  String name,  Map\u003cString,String\u003e data);\n  /** \n * \u003cpre\u003e 1. There is one secret deployed: my-secret. It has two properties: {my.one\u003done, my.key\u003dfrom-secret} 2. There is one configmap deployed: my-configmap. It has two properties: {my.two\u003dtwo, my.key\u003dfrom-configmap} We invoke three endpoints: /one, /two, /key. The first two prove that both the secret and configmap have been read, the last one proves that config maps have a higher precedence. \u003c/pre\u003e\n */\n  @Test void test();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retryable_sources_order/ConfigDataRetryableSourcesOrderTests.java",
        "name": "ConfigDataRetryableSourcesOrderTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dRetryableSourcesOrderApp.class,properties\u003d{\"spring.application.name\u003dsources-order\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./retryable-sources-order.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retryable_sources_order.ConfigDataRetryableSourcesOrderTests",
        "extend": "RetryableSourcesOrderTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dRetryableSourcesOrderApp.class,properties\u003d{\"spring.application.name\u003dsources-order\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./retryable-sources-order.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class ConfigDataRetryableSourcesOrderTests extends RetryableSourcesOrderTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUp(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dRetryableSourcesOrderApp.class,properties\u003d{\"spring.application.name\u003dsources-order\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./retryable-sources-order.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class ConfigDataRetryableSourcesOrderTests extends RetryableSourcesOrderTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUp();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retryable_sources_order/RetryableSourcesOrderController.java",
        "name": "RetryableSourcesOrderController",
        "modifiers": "@RestController",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retryable_sources_order.RetryableSourcesOrderController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController class RetryableSourcesOrderController {\n  private final Properties properties;\n  RetryableSourcesOrderController(  Properties properties){\n    this.properties\u003dproperties;\n  }\n  @GetMapping(\"/retryable-key\") String key(){\n    return properties.getKey();\n  }\n  @GetMapping(\"/retryable-one\") String one(){\n    return properties.getOne();\n  }\n  @GetMapping(\"/retryable-two\") String two(){\n    return properties.getTwo();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController class RetryableSourcesOrderController {\n  private final Properties properties;\n  RetryableSourcesOrderController(  Properties properties);\n  @GetMapping(\"/retryable-key\") String key();\n  @GetMapping(\"/retryable-one\") String one();\n  @GetMapping(\"/retryable-two\") String two();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retryable_sources_order/BootstrapRetryableSourcesOrderTests.java",
        "name": "BootstrapRetryableSourcesOrderTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dRetryableSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dretryable-sources-order\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retryable_sources_order.BootstrapRetryableSourcesOrderTests",
        "extend": "RetryableSourcesOrderTests",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dRetryableSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dretryable-sources-order\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class BootstrapRetryableSourcesOrderTests extends RetryableSourcesOrderTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUp(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dRetryableSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dretryable-sources-order\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class BootstrapRetryableSourcesOrderTests extends RetryableSourcesOrderTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUp();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retryable_sources_order/RetryableSourcesOrderApp.java",
        "name": "RetryableSourcesOrderApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties(Properties.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retryable_sources_order.RetryableSourcesOrderApp",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties(Properties.class) class RetryableSourcesOrderApp {\n  static void main(  String[] args){\n    SpringApplication.run(RetryableSourcesOrderApp.class,args);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties(Properties.class) class RetryableSourcesOrderApp {\n  static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigDataConfigMapsFromFilePathsTests.java",
        "name": "ConfigDataConfigMapsFromFilePathsTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-path-example\",\"spring.cloud.kubernetes.config.enableApi\u003dfalse\",\"spring.cloud.kubernetes.config.paths\u003d\" + ConfigDataConfigMapsFromFilePathsTests.FIRST_FILE_NAME_FULL_PATH + \",\"+ ConfigDataConfigMapsFromFilePathsTests.SECOND_FILE_NAME_FULL_PATH+ \",\"+ ConfigDataConfigMapsFromFilePathsTests.FIRST_FILE_NAME_DUPLICATED_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigDataConfigMapsFromFilePathsTests",
        "extend": "ConfigMapsFromFilePathsTests",
        "implements": "",
        "raw": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-path-example\",\"spring.cloud.kubernetes.config.enableApi\u003dfalse\",\"spring.cloud.kubernetes.config.paths\u003d\" + ConfigDataConfigMapsFromFilePathsTests.FIRST_FILE_NAME_FULL_PATH + \",\"+ ConfigDataConfigMapsFromFilePathsTests.SECOND_FILE_NAME_FULL_PATH+ \",\"+ ConfigDataConfigMapsFromFilePathsTests.FIRST_FILE_NAME_DUPLICATED_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsFromFilePathsTests extends ConfigMapsFromFilePathsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass() throws IOException {\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-path-example\",\"spring.cloud.kubernetes.config.enableApi\u003dfalse\",\"spring.cloud.kubernetes.config.paths\u003d\" + ConfigDataConfigMapsFromFilePathsTests.FIRST_FILE_NAME_FULL_PATH + \",\"+ ConfigDataConfigMapsFromFilePathsTests.SECOND_FILE_NAME_FULL_PATH+ \",\"+ ConfigDataConfigMapsFromFilePathsTests.FIRST_FILE_NAME_DUPLICATED_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsFromFilePathsTests extends ConfigMapsFromFilePathsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass() throws IOException;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigMapTestUtil.java",
        "name": "ConfigMapTestUtil",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigMapTestUtil",
        "extend": "",
        "implements": "",
        "raw": "final class ConfigMapTestUtil {\n  private ConfigMapTestUtil(){\n  }\n  static String readResourceFile(  String file){\n    String resource;\n    try {\n      resource\u003dIOHelpers.readFully(ConfigMapTestUtil.class.getClassLoader().getResourceAsStream(file));\n    }\n catch (    IOException e) {\n      resource\u003d\"\";\n    }\n    return resource;\n  }\n  static void createFileWithContent(  String file,  String content) throws IOException {\n    Files.write(Paths.get(file),content.getBytes(),StandardOpenOption.CREATE);\n  }\n}\n",
        "abstract": "final class ConfigMapTestUtil {\n  private ConfigMapTestUtil();\n  static String readResourceFile(  String file);\n  static void createFileWithContent(  String file,  String content) throws IOException;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8ConfigMapPropertySourceLocatorTests.java",
        "name": "Fabric8ConfigMapPropertySourceLocatorTests",
        "modifiers": "@EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8ConfigMapPropertySourceLocatorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@EnableKubernetesMockClient class Fabric8ConfigMapPropertySourceLocatorTests {\n  private KubernetesMockServer mockServer;\n  private KubernetesClient mockClient;\n  @Test void locateShouldThrowExceptionOnFailureWhenFailFastIsEnabled(){\n    String name\u003d\"my-config\";\n    String namespace\u003d\"default\";\n    String path\u003d\"/api/v1/namespaces/default/configmaps\";\n    mockServer.expect().withPath(path).andReturn(500,\"Internal Server Error\").always();\n    ConfigMapConfigProperties configMapConfigProperties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(),Map.of(),true,name,namespace,false,true,true,RetryProperties.DEFAULT);\n    Fabric8ConfigMapPropertySourceLocator locator\u003dnew Fabric8ConfigMapPropertySourceLocator(mockClient,configMapConfigProperties,new KubernetesNamespaceProvider(new MockEnvironment()));\n    assertThatThrownBy(() -\u003e locator.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessageContaining(\"api/v1/namespaces/default/configmaps. Message: Internal Server Error.\");\n  }\n  @Test void locateShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled(){\n    String name\u003d\"my-config\";\n    String namespace\u003d\"default\";\n    String path\u003d\"/api/v1/namespaces/default/configmaps\";\n    mockServer.expect().withPath(path).andReturn(500,\"Internal Server Error\").always();\n    ConfigMapConfigProperties configMapConfigProperties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(),Map.of(),true,name,namespace,false,true,false,RetryProperties.DEFAULT);\n    Fabric8ConfigMapPropertySourceLocator locator\u003dnew Fabric8ConfigMapPropertySourceLocator(mockClient,configMapConfigProperties,new KubernetesNamespaceProvider(new MockEnvironment()));\n    assertThatNoException().isThrownBy(() -\u003e locator.locate(new MockEnvironment()));\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@EnableKubernetesMockClient class Fabric8ConfigMapPropertySourceLocatorTests {\n  private KubernetesMockServer mockServer;\n  private KubernetesClient mockClient;\n  @Test void locateShouldThrowExceptionOnFailureWhenFailFastIsEnabled();\n  @Test void locateShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigMapsFromFilePathsTests.java",
        "name": "ConfigMapsFromFilePathsTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-path-example\",\"spring.cloud.kubernetes.config.enableApi\u003dfalse\",\"spring.cloud.kubernetes.config.paths\u003d\" + ConfigMapsFromFilePathsTests.FIRST_FILE_NAME_FULL_PATH + \",\"+ ConfigMapsFromFilePathsTests.SECOND_FILE_NAME_FULL_PATH+ \",\"+ ConfigMapsFromFilePathsTests.FIRST_FILE_NAME_DUPLICATED_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\"}) abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigMapsFromFilePathsTests",
        "extend": "",
        "implements": "",
        "raw": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-path-example\",\"spring.cloud.kubernetes.config.enableApi\u003dfalse\",\"spring.cloud.kubernetes.config.paths\u003d\" + ConfigMapsFromFilePathsTests.FIRST_FILE_NAME_FULL_PATH + \",\"+ ConfigMapsFromFilePathsTests.SECOND_FILE_NAME_FULL_PATH+ \",\"+ ConfigMapsFromFilePathsTests.FIRST_FILE_NAME_DUPLICATED_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\"}) abstract class ConfigMapsFromFilePathsTests {\n  protected static final String FILES_ROOT_PATH\u003d\"/tmp/scktests\";\n  protected static final String FILES_SUB_PATH\u003d\"another-directory\";\n  protected static final String FIRST_FILE_NAME\u003d\"application.properties\";\n  protected static final String SECOND_FILE_NAME\u003d\"extra.properties\";\n  protected static final String UNUSED_FILE_NAME\u003d\"unused.properties\";\n  protected static final String FIRST_FILE_NAME_FULL_PATH\u003dFILES_ROOT_PATH + \"/\" + FIRST_FILE_NAME;\n  protected static final String SECOND_FILE_NAME_FULL_PATH\u003dFILES_ROOT_PATH + \"/\" + SECOND_FILE_NAME;\n  protected static final String UNUSED_FILE_NAME_FULL_PATH\u003dFILES_ROOT_PATH + \"/\" + UNUSED_FILE_NAME;\n  protected static final String FIRST_FILE_NAME_DUPLICATED_FULL_PATH\u003dFILES_ROOT_PATH + \"/\" + FILES_SUB_PATH+ \"/\"+ FIRST_FILE_NAME;\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient) throws IOException {\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Files.createDirectories(Paths.get(FILES_ROOT_PATH + \"/\" + FILES_SUB_PATH));\n    ConfigMapTestUtil.createFileWithContent(FIRST_FILE_NAME_FULL_PATH,\"bean.greeting\u003dHello from path!\");\n    ConfigMapTestUtil.createFileWithContent(SECOND_FILE_NAME_FULL_PATH,\"bean.farewell\u003dBye from path!\");\n    ConfigMapTestUtil.createFileWithContent(UNUSED_FILE_NAME_FULL_PATH,\"bean.morning\u003dMorning from path!\");\n    ConfigMapTestUtil.createFileWithContent(FIRST_FILE_NAME_DUPLICATED_FULL_PATH,\"bean.bonjour\u003dBonjour from path!\");\n  }\n  @AfterAll public static void teardownAfterClass(){\n    newArrayList(FIRST_FILE_NAME_FULL_PATH,SECOND_FILE_NAME_FULL_PATH,SECOND_FILE_NAME_FULL_PATH,FILES_ROOT_PATH).forEach(fn -\u003e {\n      try {\n        Files.delete(Paths.get(fn));\n      }\n catch (      IOException ignored) {\n      }\n    }\n);\n  }\n  @Test public void greetingInputShouldReturnPropertyFromFirstFile(){\n    this.webClient.get().uri(\"/api/greeting\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Hello from path!\");\n  }\n  @Test public void farewellInputShouldReturnPropertyFromSecondFile(){\n    this.webClient.get().uri(\"/api/farewell\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Bye from path!\");\n  }\n  @Test public void morningInputShouldReturnDefaultValue(){\n    this.webClient.get().uri(\"/api/morning\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Good morning, World!\");\n  }\n  @Test public void bonjourInputShouldReturnPropertyFromDuplicatedFile(){\n    this.webClient.get().uri(\"/api/bonjour\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Bonjour from path!\");\n  }\n}\n",
        "abstract": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-path-example\",\"spring.cloud.kubernetes.config.enableApi\u003dfalse\",\"spring.cloud.kubernetes.config.paths\u003d\" + ConfigMapsFromFilePathsTests.FIRST_FILE_NAME_FULL_PATH + \",\"+ ConfigMapsFromFilePathsTests.SECOND_FILE_NAME_FULL_PATH+ \",\"+ ConfigMapsFromFilePathsTests.FIRST_FILE_NAME_DUPLICATED_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\"}) abstract class ConfigMapsFromFilePathsTests {\n  protected static final String FILES_ROOT_PATH\u003d\"/tmp/scktests\";\n  protected static final String FILES_SUB_PATH\u003d\"another-directory\";\n  protected static final String FIRST_FILE_NAME\u003d\"application.properties\";\n  protected static final String SECOND_FILE_NAME\u003d\"extra.properties\";\n  protected static final String UNUSED_FILE_NAME\u003d\"unused.properties\";\n  protected static final String FIRST_FILE_NAME_FULL_PATH\u003dFILES_ROOT_PATH + \"/\" + FIRST_FILE_NAME;\n  protected static final String SECOND_FILE_NAME_FULL_PATH\u003dFILES_ROOT_PATH + \"/\" + SECOND_FILE_NAME;\n  protected static final String UNUSED_FILE_NAME_FULL_PATH\u003dFILES_ROOT_PATH + \"/\" + UNUSED_FILE_NAME;\n  protected static final String FIRST_FILE_NAME_DUPLICATED_FULL_PATH\u003dFILES_ROOT_PATH + \"/\" + FILES_SUB_PATH+ \"/\"+ FIRST_FILE_NAME;\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient) throws IOException;\n  @AfterAll public static void teardownAfterClass();\n  @Test public void greetingInputShouldReturnPropertyFromFirstFile();\n  @Test public void farewellInputShouldReturnPropertyFromSecondFile();\n  @Test public void morningInputShouldReturnDefaultValue();\n  @Test public void bonjourInputShouldReturnPropertyFromDuplicatedFile();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigDataConfigMapsWithProfilesTests.java",
        "name": "ConfigDataConfigMapsWithProfilesTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigDataConfigMapsWithProfilesTests",
        "extend": "ConfigMapsWithProfilesTests",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsWithProfilesTests extends ConfigMapsWithProfilesTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsWithProfilesTests extends ConfigMapsWithProfilesTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/NamedSecretContextToSourceDataProviderTests.java",
        "name": "NamedSecretContextToSourceDataProviderTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.NamedSecretContextToSourceDataProviderTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Tests only for the happy-path scenarios. All others are tested elsewhere.\n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class) class NamedSecretContextToSourceDataProviderTests {\n  private static final String NAMESPACE\u003d\"default\";\n  private static KubernetesClient mockClient;\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"some\",false,false,\"irrelevant\");\n  @BeforeAll static void beforeAll(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,NAMESPACE);\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterEach void afterEach(){\n    mockClient.secrets().inNamespace(NAMESPACE).delete();\n    new Fabric8SecretsCache().discardAll();\n  }\n  /** \n * we have a single secret deployed. it matched the name in our queries\n */\n  @Test void singleSecretMatchAgainstLabels(){\n    Secret secret\u003dnew SecretBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(\"color\",Base64.getEncoder().encodeToString(\"really-red\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(secret).create();\n    NormalizedSource normalizedSource\u003dnew NamedSecretNormalizedSource(\"red\",NAMESPACE,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.red.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Map.of(\"color\",\"really-red\"));\n  }\n  /** \n * we have three secret deployed. one of them has a name that matches (red), the other two have different names, thus no match.\n */\n  @Test void twoSecretMatchAgainstLabels(){\n    Secret red\u003dnew SecretBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(\"color\",Base64.getEncoder().encodeToString(\"really-red\".getBytes())).build();\n    Secret blue\u003dnew SecretBuilder().withNewMetadata().withName(\"blue\").endMetadata().addToData(\"color\",Base64.getEncoder().encodeToString(\"really-blue\".getBytes())).build();\n    Secret yellow\u003dnew SecretBuilder().withNewMetadata().withName(\"yellow\").endMetadata().addToData(\"color\",Base64.getEncoder().encodeToString(\"really-yellow\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(red).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(blue).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(yellow).create();\n    NormalizedSource normalizedSource\u003dnew NamedSecretNormalizedSource(\"red\",NAMESPACE,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.red.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),1);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color\"),\"really-red\");\n  }\n  /** \n * one secret deployed (pink), does not match our query (blue).\n */\n  @Test void testSecretNoMatch(){\n    Secret pink\u003dnew SecretBuilder().withNewMetadata().withName(\"pink\").endMetadata().addToData(\"color\",Base64.getEncoder().encodeToString(\"pink\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(pink).create();\n    NormalizedSource normalizedSource\u003dnew NamedSecretNormalizedSource(\"blue\",NAMESPACE,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.blue.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Collections.emptyMap());\n  }\n  /** \n * NamedSecretContextToSourceDataProvider gets as input a Fabric8ConfigContext. This context has a namespace as well as a NormalizedSource, that has a namespace too. It is easy to get confused in code on which namespace to use. This test makes sure that we use the proper one.\n */\n  @Test void namespaceMatch(){\n    Secret secret\u003dnew SecretBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(\"color\",Base64.getEncoder().encodeToString(\"really-red\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(secret).create();\n    NormalizedSource normalizedSource\u003dnew NamedSecretNormalizedSource(\"red\",NAMESPACE + \"nope\",true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.red.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Map.of(\"color\",\"really-red\"));\n  }\n  /** \n * we have two secrets deployed. one matches the query name. the other matches the active profile + name, thus is taken also.\n */\n  @Test void matchIncludeSingleProfile(){\n    Secret red\u003dnew SecretBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(\"color\",Base64.getEncoder().encodeToString(\"really-red\".getBytes())).build();\n    Secret redWithProfile\u003dnew SecretBuilder().withNewMetadata().withName(\"red-with-profile\").endMetadata().addToData(\"taste\",Base64.getEncoder().encodeToString(\"mango\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(red).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(redWithProfile).create();\n    MockEnvironment env\u003dnew MockEnvironment();\n    env.setActiveProfiles(\"with-profile\");\n    NormalizedSource normalizedSource\u003dnew NamedSecretNormalizedSource(\"red\",NAMESPACE,true,ConfigUtils.Prefix.DEFAULT,true,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,env);\n    Fabric8ContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.red.red-with-profile.default.with-profile\");\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color\"),\"really-red\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"taste\"),\"mango\");\n  }\n  /** \n * we have two secrets deployed. one matches the query name. the other matches the active profile + name, thus is taken also. This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based secrets as well.\n */\n  @Test void matchIncludeSingleProfileWithPrefix(){\n    Secret red\u003dnew SecretBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(\"color\",Base64.getEncoder().encodeToString(\"really-red\".getBytes())).build();\n    Secret redWithProfile\u003dnew SecretBuilder().withNewMetadata().withName(\"red-with-profile\").endMetadata().addToData(\"taste\",Base64.getEncoder().encodeToString(\"mango\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(red).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(redWithProfile).create();\n    MockEnvironment env\u003dnew MockEnvironment();\n    env.setActiveProfiles(\"with-profile\");\n    NormalizedSource normalizedSource\u003dnew NamedSecretNormalizedSource(\"red\",NAMESPACE,true,PREFIX,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,env);\n    Fabric8ContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.red.red-with-profile.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.color\"),\"really-red\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.taste\"),\"mango\");\n  }\n  /** \n * we have three secrets deployed. one matches the query name. the other two match the active profile + name, thus are taken also. This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based config maps as well.\n */\n  @Test void matchIncludeTwoProfilesWithPrefix(){\n    Secret red\u003dnew SecretBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(\"color\",Base64.getEncoder().encodeToString(\"really-red\".getBytes())).build();\n    Secret redWithTaste\u003dnew SecretBuilder().withNewMetadata().withName(\"red-with-taste\").endMetadata().addToData(\"taste\",Base64.getEncoder().encodeToString(\"mango\".getBytes())).build();\n    Secret redWithShape\u003dnew SecretBuilder().withNewMetadata().withName(\"red-with-shape\").endMetadata().addToData(\"shape\",Base64.getEncoder().encodeToString(\"round\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(red).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(redWithTaste).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(redWithShape).create();\n    MockEnvironment env\u003dnew MockEnvironment();\n    env.setActiveProfiles(\"with-taste\",\"with-shape\");\n    NormalizedSource normalizedSource\u003dnew NamedSecretNormalizedSource(\"red\",NAMESPACE,true,PREFIX,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,env);\n    Fabric8ContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.red.red-with-shape.red-with-taste.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),3);\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.color\"),\"really-red\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.taste\"),\"mango\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.shape\"),\"round\");\n  }\n  /** \n * \u003cpre\u003e - proves that single yaml file gets special treatment \u003c/pre\u003e\n */\n  @Test void testSingleYaml(){\n    Secret secret\u003dnew SecretBuilder().withNewMetadata().withName(\"single-yaml\").endMetadata().addToData(\"single.yaml\",Base64.getEncoder().encodeToString(\"key: value\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(secret).create();\n    NormalizedSource normalizedSource\u003dnew NamedSecretNormalizedSource(\"single-yaml\",NAMESPACE,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.single-yaml.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Collections.singletonMap(\"key\",\"value\"));\n  }\n  /** \n * \u003cpre\u003e - two secrets are deployed : \"red\", \"green\", in the same namespace. - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output){\n    Secret red\u003dnew SecretBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(\"color\",Base64.getEncoder().encodeToString(\"red\".getBytes())).build();\n    Secret green\u003dnew SecretBuilder().withNewMetadata().withName(\"green\").endMetadata().addToData(\"taste\",Base64.getEncoder().encodeToString(\"mango\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(red).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(green).create();\n    MockEnvironment env\u003dnew MockEnvironment();\n    NormalizedSource redNormalizedSource\u003dnew NamedSecretNormalizedSource(\"red\",NAMESPACE,true,PREFIX,false);\n    Fabric8ConfigContext redContext\u003dnew Fabric8ConfigContext(mockClient,redNormalizedSource,NAMESPACE,env);\n    Fabric8ContextToSourceData redData\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData redSourceData\u003dredData.apply(redContext);\n    Assertions.assertEquals(redSourceData.sourceName(),\"secret.red.default\");\n    Assertions.assertEquals(redSourceData.sourceData().size(),1);\n    Assertions.assertEquals(redSourceData.sourceData().get(\"some.color\"),\"red\");\n    Assertions.assertTrue(output.getAll().contains(\"Loaded all secrets in namespace \u0027\" + NAMESPACE + \"\u0027\"));\n    NormalizedSource greenNormalizedSource\u003dnew NamedSecretNormalizedSource(\"green\",NAMESPACE,true,PREFIX,false);\n    Fabric8ConfigContext greenContext\u003dnew Fabric8ConfigContext(mockClient,greenNormalizedSource,NAMESPACE,env);\n    Fabric8ContextToSourceData greenData\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData greenSourceData\u003dgreenData.apply(greenContext);\n    Assertions.assertEquals(greenSourceData.sourceName(),\"secret.green.default\");\n    Assertions.assertEquals(greenSourceData.sourceData().size(),1);\n    Assertions.assertEquals(greenSourceData.sourceData().get(\"some.taste\"),\"mango\");\n    String[] out\u003doutput.getAll().split(\"Loaded all secrets in namespace\");\n    Assertions.assertEquals(out.length,2);\n    out\u003doutput.getAll().split(\"Loaded \\\\(from cache\\\\) all secrets in namespace\");\n    Assertions.assertEquals(out.length,2);\n  }\n}\n",
        "abstract": "/** \n * Tests only for the happy-path scenarios. All others are tested elsewhere.\n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class) class NamedSecretContextToSourceDataProviderTests {\n  private static final String NAMESPACE\u003d\"default\";\n  private static KubernetesClient mockClient;\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"some\",false,false,\"irrelevant\");\n  @BeforeAll static void beforeAll();\n  @AfterEach void afterEach();\n  /** \n * we have a single secret deployed. it matched the name in our queries\n */\n  @Test void singleSecretMatchAgainstLabels();\n  /** \n * we have three secret deployed. one of them has a name that matches (red), the other two have different names, thus no match.\n */\n  @Test void twoSecretMatchAgainstLabels();\n  /** \n * one secret deployed (pink), does not match our query (blue).\n */\n  @Test void testSecretNoMatch();\n  /** \n * NamedSecretContextToSourceDataProvider gets as input a Fabric8ConfigContext. This context has a namespace as well as a NormalizedSource, that has a namespace too. It is easy to get confused in code on which namespace to use. This test makes sure that we use the proper one.\n */\n  @Test void namespaceMatch();\n  /** \n * we have two secrets deployed. one matches the query name. the other matches the active profile + name, thus is taken also.\n */\n  @Test void matchIncludeSingleProfile();\n  /** \n * we have two secrets deployed. one matches the query name. the other matches the active profile + name, thus is taken also. This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based secrets as well.\n */\n  @Test void matchIncludeSingleProfileWithPrefix();\n  /** \n * we have three secrets deployed. one matches the query name. the other two match the active profile + name, thus are taken also. This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based config maps as well.\n */\n  @Test void matchIncludeTwoProfilesWithPrefix();\n  /** \n * \u003cpre\u003e - proves that single yaml file gets special treatment \u003c/pre\u003e\n */\n  @Test void testSingleYaml();\n  /** \n * \u003cpre\u003e - two secrets are deployed : \"red\", \"green\", in the same namespace. - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8ConfigUtilsTests.java",
        "name": "Fabric8ConfigUtilsTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8ConfigUtilsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8ConfigUtilsTests {\n  private KubernetesClient client;\n  @AfterEach void afterEach(){\n    new Fabric8ConfigMapsCache().discardAll();\n    new Fabric8SecretsCache().discardAll();\n  }\n  @Test void testSecretDataByLabelsSecretNotFound(){\n    client.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-secret\").build()).build()).create();\n    MultipleSourcesContainer result\u003dFabric8ConfigUtils.secretsDataByLabels(client,\"spring-k8s\",Map.of(\"color\",\"red\"),new MockEnvironment(),Set.of());\n    Assertions.assertEquals(Map.of(),result.data());\n    Assertions.assertTrue(result.names().isEmpty());\n  }\n  @Test void testSecretDataByLabelsSecretFound(){\n    client.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-secret\").withLabels(Map.of(\"color\",\"pink\")).build()).addToData(Map.of(\"property\",Base64.getEncoder().encodeToString(\"value\".getBytes()))).build()).create();\n    MultipleSourcesContainer result\u003dFabric8ConfigUtils.secretsDataByLabels(client,\"spring-k8s\",Map.of(\"color\",\"pink\"),new MockEnvironment(),Set.of());\n    Assertions.assertEquals(Set.of(\"my-secret\"),result.names());\n    Assertions.assertEquals(Map.of(\"property\",\"value\"),result.data());\n  }\n  @Test void testSecretDataByLabelsSecretFoundWithPropertyFile(){\n    client.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-secret\").withLabels(Map.of(\"color\",\"pink\")).build()).addToData(Map.of(\"application.yaml\",Base64.getEncoder().encodeToString(\"key1: value1\".getBytes()))).build()).create();\n    MultipleSourcesContainer result\u003dFabric8ConfigUtils.secretsDataByLabels(client,\"spring-k8s\",Map.of(\"color\",\"pink\"),new MockEnvironment(),Set.of());\n    Assertions.assertEquals(Set.of(\"my-secret\"),result.names());\n    Assertions.assertEquals(Map.of(\"key1\",\"value1\"),result.data());\n  }\n  @Test void testSecretDataByLabelsTwoSecretsFound(){\n    client.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-secret\").withLabels(Map.of(\"color\",\"pink\")).build()).addToData(Map.of(\"property\",Base64.getEncoder().encodeToString(\"value\".getBytes()))).build()).create();\n    client.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-secret-2\").withLabels(Map.of(\"color\",\"pink\")).build()).addToData(Map.of(\"property-2\",Base64.getEncoder().encodeToString(\"value-2\".getBytes()))).build()).create();\n    MultipleSourcesContainer result\u003dFabric8ConfigUtils.secretsDataByLabels(client,\"spring-k8s\",Map.of(\"color\",\"pink\"),new MockEnvironment(),Set.of());\n    Assertions.assertTrue(result.names().contains(\"my-secret\"));\n    Assertions.assertTrue(result.names().contains(\"my-secret-2\"));\n    Assertions.assertEquals(2,result.data().size());\n    Assertions.assertEquals(\"value\",result.data().get(\"property\"));\n    Assertions.assertEquals(\"value-2\",result.data().get(\"property-2\"));\n  }\n  /** \n * \u003cpre\u003e - secret deployed with name \"blue-circle-secret\" and labels \"color\u003dblue, shape\u003dcircle, tag\u003dfit\" - secret deployed with name \"blue-square-secret\" and labels \"color\u003dblue, shape\u003dsquare, tag\u003dfit\" - secret deployed with name \"blue-triangle-secret\" and labels \"color\u003dblue, shape\u003dtriangle, tag\u003dno-fit\" - secret deployed with name \"blue-square-secret-k8s\" and labels \"color\u003dblue, shape\u003dtriangle, tag\u003dno-fit\" - we search by labels \"color\u003dblue, tag\u003dfits\", as such first find two secrets: \"blue-circle-secret\" and \"blue-square-secret\". - since \"k8s\" profile is enabled, we also take \"blue-square-secret-k8s\". Notice that this one does not match the initial labels (it has \"tag\u003dno-fit\"), but it does not matter, we take it anyway. \u003c/pre\u003e\n */\n  @Test void testSecretDataByLabelsThreeSecretsFound(){\n    client.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withMetadata(new ObjectMetaBuilder().withName(\"blue-circle-secret\").withLabels(Map.of(\"color\",\"blue\",\"shape\",\"circle\",\"tag\",\"fit\")).build()).addToData(Map.of(\"one\",Base64.getEncoder().encodeToString(\"1\".getBytes()))).build()).create();\n    client.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withMetadata(new ObjectMetaBuilder().withName(\"blue-square-secret\").withLabels(Map.of(\"color\",\"blue\",\"shape\",\"square\",\"tag\",\"fit\")).build()).addToData(Map.of(\"two\",Base64.getEncoder().encodeToString(\"2\".getBytes()))).build()).create();\n    client.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withMetadata(new ObjectMetaBuilder().withName(\"blue-triangle-secret\").withLabels(Map.of(\"color\",\"blue\",\"shape\",\"triangle\",\"tag\",\"no-fit\")).build()).addToData(Map.of(\"three\",Base64.getEncoder().encodeToString(\"3\".getBytes()))).build()).create();\n    client.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withMetadata(new ObjectMetaBuilder().withName(\"blue-square-secret-k8s\").withLabels(Map.of(\"color\",\"blue\",\"shape\",\"triangle\",\"tag\",\"no-fit\")).build()).addToData(Map.of(\"four\",Base64.getEncoder().encodeToString(\"4\".getBytes()))).build()).create();\n    MultipleSourcesContainer result\u003dFabric8ConfigUtils.secretsDataByLabels(client,\"spring-k8s\",Map.of(\"tag\",\"fit\",\"color\",\"blue\"),new MockEnvironment(),Set.of(\"k8s\"));\n    Assertions.assertTrue(result.names().contains(\"blue-circle-secret\"));\n    Assertions.assertTrue(result.names().contains(\"blue-square-secret\"));\n    Assertions.assertTrue(result.names().contains(\"blue-square-secret-k8s\"));\n    Assertions.assertEquals(3,result.data().size());\n    Assertions.assertEquals(\"1\",result.data().get(\"one\"));\n    Assertions.assertEquals(\"2\",result.data().get(\"two\"));\n    Assertions.assertEquals(\"4\",result.data().get(\"four\"));\n  }\n  @Test void testSecretDataByNameSecretNotFound(){\n    client.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-secret\").build()).build()).create();\n    LinkedHashSet\u003cString\u003e names\u003dnew LinkedHashSet\u003c\u003e();\n    names.add(\"nope\");\n    MultipleSourcesContainer result\u003dFabric8ConfigUtils.secretsDataByName(client,\"spring-k8s\",names,new MockEnvironment());\n    Assertions.assertEquals(0,result.names().size());\n    Assertions.assertEquals(0,result.data().size());\n  }\n  @Test void testSecretDataByNameSecretFound(){\n    client.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-secret\").build()).addToData(Map.of(\"property\",Base64.getEncoder().encodeToString(\"value\".getBytes()))).build()).create();\n    LinkedHashSet\u003cString\u003e names\u003dnew LinkedHashSet\u003c\u003e();\n    names.add(\"my-secret\");\n    MultipleSourcesContainer result\u003dFabric8ConfigUtils.secretsDataByName(client,\"spring-k8s\",names,new MockEnvironment());\n    Assertions.assertEquals(1,result.names().size());\n    Assertions.assertEquals(\"value\",result.data().get(\"property\"));\n  }\n  @Test void testSecretDataByNameTwoSecretsFound(){\n    client.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-secret\").build()).addToData(Map.of(\"property\",Base64.getEncoder().encodeToString(\"value\".getBytes()))).build()).create();\n    client.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-secret-2\").build()).addToData(Map.of(\"property-2\",Base64.getEncoder().encodeToString(\"value-2\".getBytes()))).build()).create();\n    LinkedHashSet\u003cString\u003e names\u003dnew LinkedHashSet\u003c\u003e();\n    names.add(\"my-secret\");\n    names.add(\"my-secret-2\");\n    MultipleSourcesContainer result\u003dFabric8ConfigUtils.secretsDataByName(client,\"spring-k8s\",names,new MockEnvironment());\n    Assertions.assertTrue(result.names().contains(\"my-secret\"));\n    Assertions.assertTrue(result.names().contains(\"my-secret-2\"));\n    Assertions.assertEquals(2,result.data().size());\n    Assertions.assertEquals(\"value\",result.data().get(\"property\"));\n    Assertions.assertEquals(\"value-2\",result.data().get(\"property-2\"));\n  }\n  @Test void testConfigMapsDataByNameFoundNoData(){\n    client.configMaps().inNamespace(\"spring-k8s\").resource(new ConfigMapBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-config-map\").build()).build()).create();\n    LinkedHashSet\u003cString\u003e names\u003dnew LinkedHashSet\u003c\u003e();\n    names.add(\"my-config-map\");\n    MultipleSourcesContainer result\u003dFabric8ConfigUtils.configMapsDataByName(client,\"spring-k8s\",names,new MockEnvironment());\n    Assertions.assertEquals(Set.of(\"my-config-map\"),result.names());\n    Assertions.assertTrue(result.data().isEmpty());\n  }\n  @Test void testConfigMapsDataByNameNotFound(){\n    client.configMaps().inNamespace(\"spring-k8s\").resource(new ConfigMapBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-config-map\").build()).build()).create();\n    LinkedHashSet\u003cString\u003e names\u003dnew LinkedHashSet\u003c\u003e();\n    names.add(\"my-config-map-not-found\");\n    MultipleSourcesContainer result\u003dFabric8ConfigUtils.configMapsDataByName(client,\"spring-k8s\",names,new MockEnvironment());\n    Assertions.assertEquals(Set.of(),result.names());\n    Assertions.assertTrue(result.data().isEmpty());\n  }\n  @Test void testConfigMapDataByNameFound(){\n    client.configMaps().inNamespace(\"spring-k8s\").resource(new ConfigMapBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-config-map\").build()).addToData(Map.of(\"property\",\"value\")).build()).create();\n    LinkedHashSet\u003cString\u003e names\u003dnew LinkedHashSet\u003c\u003e();\n    names.add(\"my-config-map\");\n    MultipleSourcesContainer result\u003dFabric8ConfigUtils.configMapsDataByName(client,\"spring-k8s\",names,new MockEnvironment());\n    Assertions.assertEquals(Set.of(\"my-config-map\"),result.names());\n    Assertions.assertEquals(Map.of(\"property\",\"value\"),result.data());\n  }\n  @Test void testConfigMapDataByNameFoundWithPropertyFile(){\n    client.configMaps().inNamespace(\"spring-k8s\").resource(new ConfigMapBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-config-map\").build()).addToData(Map.of(\"application.yaml\",\"key1: value1\")).build()).create();\n    LinkedHashSet\u003cString\u003e names\u003dnew LinkedHashSet\u003c\u003e();\n    names.add(\"my-config-map\");\n    MultipleSourcesContainer result\u003dFabric8ConfigUtils.configMapsDataByName(client,\"spring-k8s\",names,new MockEnvironment());\n    Assertions.assertEquals(Set.of(\"my-config-map\"),result.names());\n    Assertions.assertEquals(Map.of(\"key1\",\"value1\"),result.data());\n  }\n  @Test void testConfigMapDataByNameTwoFound(){\n    client.configMaps().inNamespace(\"spring-k8s\").resource(new ConfigMapBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-config-map\").build()).addToData(Map.of(\"property\",\"value\")).build()).create();\n    client.configMaps().inNamespace(\"spring-k8s\").resource(new ConfigMapBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-config-map-2\").build()).addToData(Map.of(\"property-2\",\"value-2\")).build()).create();\n    LinkedHashSet\u003cString\u003e names\u003dnew LinkedHashSet\u003c\u003e();\n    names.add(\"my-config-map\");\n    names.add(\"my-config-map-2\");\n    MultipleSourcesContainer result\u003dFabric8ConfigUtils.configMapsDataByName(client,\"spring-k8s\",names,new MockEnvironment());\n    Assertions.assertTrue(result.names().contains(\"my-config-map\"));\n    Assertions.assertTrue(result.names().contains(\"my-config-map-2\"));\n    Assertions.assertEquals(2,result.data().size());\n    Assertions.assertEquals(\"value\",result.data().get(\"property\"));\n    Assertions.assertEquals(\"value-2\",result.data().get(\"property-2\"));\n  }\n  @Test void testNamespacesFromProperties(){\n    ConfigReloadProperties configReloadProperties\u003dnew ConfigReloadProperties(false,true,false,ConfigReloadProperties.ReloadStrategy.REFRESH,ConfigReloadProperties.ReloadDetectionMode.EVENT,Duration.ofMillis(15000),Set.of(\"non-default\"),false,Duration.ofSeconds(2));\n    Set\u003cString\u003e namespaces\u003dFabric8ConfigUtils.namespaces(null,new KubernetesNamespaceProvider(new MockEnvironment()),configReloadProperties,\"configmap\");\n    Assertions.assertEquals(1,namespaces.size());\n    Assertions.assertEquals(namespaces.iterator().next(),\"non-default\");\n  }\n  @Test void testNamespacesFromProvider(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.client.namespace\",\"some\");\n    KubernetesNamespaceProvider provider\u003dnew KubernetesNamespaceProvider(environment);\n    Set\u003cString\u003e namespaces\u003dFabric8ConfigUtils.namespaces(null,provider,ConfigReloadProperties.DEFAULT,\"configmap\");\n    Assertions.assertEquals(1,namespaces.size());\n    Assertions.assertEquals(namespaces.iterator().next(),\"some\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8ConfigUtilsTests {\n  private KubernetesClient client;\n  @AfterEach void afterEach();\n  @Test void testSecretDataByLabelsSecretNotFound();\n  @Test void testSecretDataByLabelsSecretFound();\n  @Test void testSecretDataByLabelsSecretFoundWithPropertyFile();\n  @Test void testSecretDataByLabelsTwoSecretsFound();\n  /** \n * \u003cpre\u003e - secret deployed with name \"blue-circle-secret\" and labels \"color\u003dblue, shape\u003dcircle, tag\u003dfit\" - secret deployed with name \"blue-square-secret\" and labels \"color\u003dblue, shape\u003dsquare, tag\u003dfit\" - secret deployed with name \"blue-triangle-secret\" and labels \"color\u003dblue, shape\u003dtriangle, tag\u003dno-fit\" - secret deployed with name \"blue-square-secret-k8s\" and labels \"color\u003dblue, shape\u003dtriangle, tag\u003dno-fit\" - we search by labels \"color\u003dblue, tag\u003dfits\", as such first find two secrets: \"blue-circle-secret\" and \"blue-square-secret\". - since \"k8s\" profile is enabled, we also take \"blue-square-secret-k8s\". Notice that this one does not match the initial labels (it has \"tag\u003dno-fit\"), but it does not matter, we take it anyway. \u003c/pre\u003e\n */\n  @Test void testSecretDataByLabelsThreeSecretsFound();\n  @Test void testSecretDataByNameSecretNotFound();\n  @Test void testSecretDataByNameSecretFound();\n  @Test void testSecretDataByNameTwoSecretsFound();\n  @Test void testConfigMapsDataByNameFoundNoData();\n  @Test void testConfigMapsDataByNameNotFound();\n  @Test void testConfigMapDataByNameFound();\n  @Test void testConfigMapDataByNameFoundWithPropertyFile();\n  @Test void testConfigMapDataByNameTwoFound();\n  @Test void testNamespacesFromProperties();\n  @Test void testNamespacesFromProvider();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigMapEnableRetryWithoutFailFastTest.java",
        "name": "ConfigMapEnableRetryWithoutFailFastTest",
        "modifiers": "@EnableKubernetesMockClient public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigMapEnableRetryWithoutFailFastTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@EnableKubernetesMockClient public class ConfigMapEnableRetryWithoutFailFastTest {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps/application\";\n  static KubernetesMockServer mockServer;\n  static KubernetesClient mockClient;\n  private ConfigurableApplicationContext context;\n  protected void setup(  String... env){\n    List\u003cString\u003e envList\u003d(env !\u003d null) ? new ArrayList\u003c\u003e(Arrays.asList(env)) : new ArrayList\u003c\u003e();\n    envList.add(\"spring.cloud.kubernetes.client.namespace\u003ddefault\");\n    String[] envArray\u003denvList.toArray(new String[0]);\n    context\u003dnew SpringApplicationBuilder(RetryConfiguration.class,PropertyPlaceholderAutoConfiguration.class,ConfigReloadAutoConfiguration.class,RefreshAutoConfiguration.class,EndpointAutoConfiguration.class,InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,ConfigurationPropertiesBindingPostProcessor.class,ConfigurationPropertiesRebinderAutoConfiguration.class,Fabric8BootstrapConfiguration.class,Fabric8RetryBootstrapConfiguration.class,KubernetesBootstrapConfiguration.class).web(org.springframework.boot.WebApplicationType.NONE).properties(envArray).run();\n  }\n  @AfterEach public void afterEach(){\n    if (this.context !\u003d null) {\n      this.context.close();\n      this.context\u003dnull;\n    }\n  }\n  @Test public void doesNotContainRetryableConfigMapPropertySourceLocator() throws Exception {\n    mockServer.expect().withPath(API).andReturn(500,\"Internal Server Error\").once();\n    setup(\"debug\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.test.enable-retry\u003dtrue\");\n    assertThat(context.containsBean(\"retryableConfigMapPropertySourceLocator\")).isFalse();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@EnableKubernetesMockClient public class ConfigMapEnableRetryWithoutFailFastTest {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps/application\";\n  static KubernetesMockServer mockServer;\n  static KubernetesClient mockClient;\n  private ConfigurableApplicationContext context;\n  protected void setup(  String... env);\n  @AfterEach public void afterEach();\n  @Test public void doesNotContainRetryableConfigMapPropertySourceLocator() throws Exception;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigDataConfigMapsWithProfilesNoActiveProfileTests.java",
        "name": "ConfigDataConfigMapsWithProfilesNoActiveProfileTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-no-active-profiles-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigDataConfigMapsWithProfilesNoActiveProfileTests",
        "extend": "ConfigMapsWithProfilesNoActiveProfileTests",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-no-active-profiles-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsWithProfilesNoActiveProfileTests extends ConfigMapsWithProfilesNoActiveProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-no-active-profiles-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsWithProfilesNoActiveProfileTests extends ConfigMapsWithProfilesNoActiveProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/BootstrapConfigMapsWithoutProfilesTests.java",
        "name": "BootstrapConfigMapsWithoutProfilesTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-without-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.BootstrapConfigMapsWithoutProfilesTests",
        "extend": "ConfigMapsWithoutProfilesTests",
        "implements": "",
        "raw": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-without-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapConfigMapsWithoutProfilesTests extends ConfigMapsWithoutProfilesTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-without-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapConfigMapsWithoutProfilesTests extends ConfigMapsWithoutProfilesTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_prefix/properties/One.java",
        "name": "One",
        "modifiers": "@ConfigurationProperties(\"one\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_prefix.properties.One",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_prefix/properties/Two.java",
        "name": "Two",
        "modifiers": "@ConfigurationProperties(\"two\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_prefix.properties.Two",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_prefix/properties/Three.java",
        "name": "Three",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"secret-three\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_prefix.properties.Three",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"secret-three\") public class Three {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"secret-three\") public class Three {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_prefix/properties/Four.java",
        "name": "Four",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"secret-four\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_prefix.properties.Four",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"secret-four\") public class Four {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"secret-four\") public class Four {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_prefix/LabeledSecretWithPrefixConfigDataTests.java",
        "name": "LabeledSecretWithPrefixConfigDataTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithPrefixApp.class,properties\u003d{\"spring.application.name\u003dlabeled-secret-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-secret-with-prefix.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_prefix.LabeledSecretWithPrefixConfigDataTests",
        "extend": "LabeledSecretWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithPrefixApp.class,properties\u003d{\"spring.application.name\u003dlabeled-secret-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-secret-with-prefix.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledSecretWithPrefixConfigDataTests extends LabeledSecretWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithPrefixApp.class,properties\u003d{\"spring.application.name\u003dlabeled-secret-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-secret-with-prefix.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledSecretWithPrefixConfigDataTests extends LabeledSecretWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_prefix/controller/LabeledSecretWithPrefixController.java",
        "name": "LabeledSecretWithPrefixController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_prefix.controller.LabeledSecretWithPrefixController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class LabeledSecretWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  private final Four four;\n  public LabeledSecretWithPrefixController(  One one,  Two two,  Three three,  Four four){\n    this.one\u003done;\n    this.two\u003dtwo;\n    this.three\u003dthree;\n    this.four\u003dfour;\n  }\n  @GetMapping(\"/labeled-secret/prefix/one\") public String one(){\n    return one.getProperty();\n  }\n  @GetMapping(\"/labeled-secret/prefix/two\") public String two(){\n    return two.getProperty();\n  }\n  @GetMapping(\"/labeled-secret/prefix/three\") public String three(){\n    return three.getProperty();\n  }\n  @GetMapping(\"/labeled-secret/prefix/four\") public String four(){\n    return four.getProperty();\n  }\n}\n",
        "abstract": "@RestController public class LabeledSecretWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  private final Four four;\n  public LabeledSecretWithPrefixController(  One one,  Two two,  Three three,  Four four);\n  @GetMapping(\"/labeled-secret/prefix/one\") public String one();\n  @GetMapping(\"/labeled-secret/prefix/two\") public String two();\n  @GetMapping(\"/labeled-secret/prefix/three\") public String three();\n  @GetMapping(\"/labeled-secret/prefix/four\") public String four();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_prefix/LabeledSecretWithPrefixTests.java",
        "name": "LabeledSecretWithPrefixTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_prefix.LabeledSecretWithPrefixTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class LabeledSecretWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    LabeledSecretWithPrefixTests.mockClient\u003dmockClient;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e one\u003dCollections.singletonMap(\"one.property\",Base64.getEncoder().encodeToString(\"one\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"secret-one\",one,Collections.singletonMap(\"letter\",\"a\"));\n    Map\u003cString,String\u003e two\u003dCollections.singletonMap(\"property\",Base64.getEncoder().encodeToString(\"two\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"secret-two\",two,Collections.singletonMap(\"letter\",\"b\"));\n    Map\u003cString,String\u003e three\u003dCollections.singletonMap(\"property\",Base64.getEncoder().encodeToString(\"three\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"secret-three\",three,Collections.singletonMap(\"letter\",\"c\"));\n    Map\u003cString,String\u003e four\u003dCollections.singletonMap(\"property\",Base64.getEncoder().encodeToString(\"four\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"secret-four\",four,Collections.singletonMap(\"letter\",\"d\"));\n  }\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data,  Map\u003cString,String\u003e labels){\n    mockClient.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withNewMetadata().withName(name).withLabels(labels).endMetadata().addToData(data).build()).create();\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne(){\n    this.webClient.get().uri(\"/labeled-secret/prefix/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo(){\n    this.webClient.get().uri(\"/labeled-secret/prefix/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[2].labels\u003dletter:c\u0027 (\"property\", \"three\") We find the secret by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"secret-three\") \u003c/pre\u003e\n */\n  @Test void testThree(){\n    this.webClient.get().uri(\"/labeled-secret/prefix/three\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"three\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[3].labels\u003dletter:d\u0027 (\"property\", \"four\") We find the secret by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"secret-four\") \u003c/pre\u003e\n */\n  @Test void testFour(){\n    this.webClient.get().uri(\"/labeled-secret/prefix/four\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"four\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class LabeledSecretWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data,  Map\u003cString,String\u003e labels);\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[2].labels\u003dletter:c\u0027 (\"property\", \"three\") We find the secret by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"secret-three\") \u003c/pre\u003e\n */\n  @Test void testThree();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[3].labels\u003dletter:d\u0027 (\"property\", \"four\") We find the secret by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"secret-four\") \u003c/pre\u003e\n */\n  @Test void testFour();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_prefix/LabeledSecretWithPrefixBootstrapTests.java",
        "name": "LabeledSecretWithPrefixBootstrapTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-secret-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_prefix.LabeledSecretWithPrefixBootstrapTests",
        "extend": "LabeledSecretWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-secret-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledSecretWithPrefixBootstrapTests extends LabeledSecretWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-secret-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledSecretWithPrefixBootstrapTests extends LabeledSecretWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_prefix/LabeledSecretWithPrefixApp.java",
        "name": "LabeledSecretWithPrefixApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class,Four.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_prefix.LabeledSecretWithPrefixApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class,Four.class}) public class LabeledSecretWithPrefixApp {\n  public static void main(  String[] args){\n    SpringApplication.run(LabeledSecretWithPrefixApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class,Four.class}) public class LabeledSecretWithPrefixApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/locator_retry/BoostrapConfigFailFastDisabled.java",
        "name": "BoostrapConfigFailFastDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.locator_retry.BoostrapConfigFailFastDisabled",
        "extend": "ConfigFailFastDisabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BoostrapConfigFailFastDisabled extends ConfigFailFastDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BoostrapConfigFailFastDisabled extends ConfigFailFastDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/locator_retry/BoostrapConfigRetryDisabledButSecretsRetryEnabled.java",
        "name": "BoostrapConfigRetryDisabledButSecretsRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.locator_retry.BoostrapConfigRetryDisabledButSecretsRetryEnabled",
        "extend": "ConfigRetryDisabledButSecretsRetryEnabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BoostrapConfigRetryDisabledButSecretsRetryEnabled extends ConfigRetryDisabledButSecretsRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n  @Override protected void assertRetryBean(  ApplicationContext context){\n    assertThat(context.containsBean(\"kubernetesConfigRetryInterceptor\")).isTrue();\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BoostrapConfigRetryDisabledButSecretsRetryEnabled extends ConfigRetryDisabledButSecretsRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup();\n  @Override protected void assertRetryBean(  ApplicationContext context);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/locator_retry/config_retry_enabled/BoostrapConfigRetryEnabled.java",
        "name": "BoostrapConfigRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.locator_retry.config_retry_enabled.BoostrapConfigRetryEnabled",
        "extend": "ConfigRetryEnabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BoostrapConfigRetryEnabled extends ConfigRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n  @SpyBean Fabric8ConfigMapPropertySourceLocator propertySourceLocator;\n  @BeforeEach public void beforeEach(){\n    psl\u003dpropertySourceLocator;\n    verifiablePsl\u003dpropertySourceLocator;\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BoostrapConfigRetryEnabled extends ConfigRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup();\n  @SpyBean Fabric8ConfigMapPropertySourceLocator propertySourceLocator;\n  @BeforeEach public void beforeEach();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/locator_retry/config_retry_enabled/ConfigRetryEnabled.java",
        "name": "ConfigRetryEnabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.locator_retry.config_retry_enabled.ConfigRetryEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\nabstract class ConfigRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  protected ConfigMapPropertySourceLocator psl;\n  protected ConfigMapPropertySourceLocator verifiablePsl;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer){\n    ConfigRetryEnabled.mockClient\u003dmockClient;\n    ConfigRetryEnabled.mockServer\u003dmockServer;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    mockServer.expect().withPath(API).andReturn(200,new ConfigMapListBuilder().build()).once();\n  }\n  @Test void locateShouldNotRetryWhenThereIsNoFailure(){\n    Map\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"some.prop\",\"theValue\");\n    data.put(\"some.number\",\"0\");\n    mockServer.expect().withPath(API).andReturn(200,new ConfigMapListBuilder().withItems(new ConfigMapBuilder().withNewMetadata().withName(\"application\").endMetadata().addToData(data).build()).build()).once();\n    PropertySource\u003c?\u003e propertySource\u003dAssertions.assertDoesNotThrow(() -\u003e psl.locate(new MockEnvironment()));\n    verify(verifiablePsl,times(1)).locate(any());\n    assertThat(propertySource.getProperty(\"some.prop\")).isEqualTo(\"theValue\");\n    assertThat(propertySource.getProperty(\"some.number\")).isEqualTo(\"0\");\n  }\n  @Test void locateShouldRetryAndRecover(){\n    Map\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"some.prop\",\"theValue\");\n    data.put(\"some.number\",\"0\");\n    mockServer.expect().withPath(API).andReturn(500,\"Internal Server Error\").times(3);\n    mockServer.expect().withPath(API).andReturn(200,new ConfigMapListBuilder().withItems(new ConfigMapBuilder().withNewMetadata().withName(\"application\").endMetadata().addToData(data).build()).build()).once();\n    PropertySource\u003c?\u003e propertySource\u003dAssertions.assertDoesNotThrow(() -\u003e psl.locate(new MockEnvironment()));\n    verify(verifiablePsl,times(4)).locate(any());\n    assertThat(propertySource.getProperty(\"some.prop\")).isEqualTo(\"theValue\");\n    assertThat(propertySource.getProperty(\"some.number\")).isEqualTo(\"0\");\n  }\n  @Test void locateShouldRetryAndFail(){\n    mockServer.expect().withPath(API).andReturn(500,\"Internal Server Error\").times(5);\n    assertThatThrownBy(() -\u003e psl.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessageContaining(\"api/v1/namespaces/default/configmaps. Message: Internal Server Error\");\n    verify(verifiablePsl,times(5)).locate(any());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\nabstract class ConfigRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  protected ConfigMapPropertySourceLocator psl;\n  protected ConfigMapPropertySourceLocator verifiablePsl;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer);\n  @Test void locateShouldNotRetryWhenThereIsNoFailure();\n  @Test void locateShouldRetryAndRecover();\n  @Test void locateShouldRetryAndFail();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/locator_retry/config_retry_enabled/ConfigDataConfigRetryEnabled.java",
        "name": "ConfigDataConfigRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.locator_retry.config_retry_enabled.ConfigDataConfigRetryEnabled",
        "extend": "ConfigRetryEnabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataConfigRetryEnabled extends ConfigRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @MockBean private KubernetesNamespaceProvider namespaceProvider;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n  @Autowired ConfigDataRetryableConfigMapPropertySourceLocator propertySourceLocator;\n  @BeforeEach public void beforeEach(){\n    psl\u003dpropertySourceLocator;\n    verifiablePsl\u003dspy(propertySourceLocator.getConfigMapPropertySourceLocator());\n    propertySourceLocator.setConfigMapPropertySourceLocator(verifiablePsl);\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataConfigRetryEnabled extends ConfigRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @MockBean private KubernetesNamespaceProvider namespaceProvider;\n  @BeforeAll static void setup();\n  @Autowired ConfigDataRetryableConfigMapPropertySourceLocator propertySourceLocator;\n  @BeforeEach public void beforeEach();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/locator_retry/ConfigRetryDisabledButSecretsRetryEnabled.java",
        "name": "ConfigRetryDisabledButSecretsRetryEnabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.locator_retry.ConfigRetryDisabledButSecretsRetryEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\nabstract class ConfigRetryDisabledButSecretsRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @Autowired private Fabric8ConfigMapPropertySourceLocator propertySourceLocator;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer){\n    ConfigRetryDisabledButSecretsRetryEnabled.mockClient\u003dmockClient;\n    ConfigRetryDisabledButSecretsRetryEnabled.mockServer\u003dmockServer;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    mockServer.expect().withPath(API).andReturn(200,new ConfigMapListBuilder().build()).always();\n  }\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying(){\n    Fabric8ConfigMapPropertySourceLocator psl\u003dspy(propertySourceLocator);\n    mockServer.clearExpectations();\n    mockServer.expect().withPath(API).andReturn(500,\"Internal Server Error\").once();\n    assertRetryBean(context);\n    assertThatThrownBy(() -\u003e psl.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessageContaining(\"v1/namespaces/default/configmaps. Message: Internal Server Error\");\n    verify(psl,times(1)).locate(any());\n  }\n  protected abstract void assertRetryBean(  ApplicationContext context);\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\nabstract class ConfigRetryDisabledButSecretsRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @Autowired private Fabric8ConfigMapPropertySourceLocator propertySourceLocator;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer);\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying();\n  protected abstract void assertRetryBean(  ApplicationContext context);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/locator_retry/ConfigDataConfigFailFastDisabled.java",
        "name": "ConfigDataConfigFailFastDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.locator_retry.ConfigDataConfigFailFastDisabled",
        "extend": "ConfigFailFastDisabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataConfigFailFastDisabled extends ConfigFailFastDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataConfigFailFastDisabled extends ConfigFailFastDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/locator_retry/fail_fast_enabled_retry_disabled/BootstrapConfigFailFastEnabledButRetryDisabled.java",
        "name": "BootstrapConfigFailFastEnabledButRetryDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.locator_retry.fail_fast_enabled_retry_disabled.BootstrapConfigFailFastEnabledButRetryDisabled",
        "extend": "ConfigFailFastEnabledButRetryDisabled",
        "implements": "",
        "raw": "/** \n * we call Fabric8ConfigMapPropertySourceLocator::locate directly, thus no need for bootstrap phase to kick in. As such two flags that might look a bit un-expected: \"spring.cloud.kubernetes.config.enabled\u003dfalse\" \"spring.cloud.kubernetes.secrets.enabled\u003dfalse\"\n * @author Isik Erhan\n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BootstrapConfigFailFastEnabledButRetryDisabled extends ConfigFailFastEnabledButRetryDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n}\n",
        "abstract": "/** \n * we call Fabric8ConfigMapPropertySourceLocator::locate directly, thus no need for bootstrap phase to kick in. As such two flags that might look a bit un-expected: \"spring.cloud.kubernetes.config.enabled\u003dfalse\" \"spring.cloud.kubernetes.secrets.enabled\u003dfalse\"\n * @author Isik Erhan\n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BootstrapConfigFailFastEnabledButRetryDisabled extends ConfigFailFastEnabledButRetryDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/locator_retry/fail_fast_enabled_retry_disabled/ConfigDataConfigFailFastEnabledButRetryDisabled.java",
        "name": "ConfigDataConfigFailFastEnabledButRetryDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient @Import(ConfigDataConfigFailFastEnabledButRetryDisabled.LocalConfig.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.locator_retry.fail_fast_enabled_retry_disabled.ConfigDataConfigFailFastEnabledButRetryDisabled",
        "extend": "ConfigFailFastEnabledButRetryDisabled",
        "implements": "",
        "raw": "/** \n * we call Fabric8ConfigMapPropertySourceLocator::locate directly, thus no need for bootstrap phase to kick in. As such two flags that might look a bit un-expected: \"spring.cloud.kubernetes.config.enabled\u003dfalse\" \"spring.cloud.kubernetes.secrets.enabled\u003dfalse\"\n * @author Isik Erhan\n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient @Import(ConfigDataConfigFailFastEnabledButRetryDisabled.LocalConfig.class) class ConfigDataConfigFailFastEnabledButRetryDisabled extends ConfigFailFastEnabledButRetryDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @MockBean private KubernetesNamespaceProvider kubernetesNamespaceProvider;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n@Configuration static class LocalConfig {\n    /** \n * we need this config because ConfigMapConfigProperties is now a record, so we can\u0027t use @SpyBean on it. We also read the property of fail-fast from the Environment, that in turn is set in the @SpringBootTest properties.\n */\n    @Bean ConfigMapConfigProperties properties(    Environment environment){\n      return new ConfigMapConfigProperties(true,List.of(),List.of(),Map.of(),true,null,null,false,true,Boolean.parseBoolean(environment.getProperty(\"spring.cloud.kubernetes.config.fail-fast\")),RetryProperties.DEFAULT);\n    }\n  }\n}\n",
        "abstract": "/** \n * we call Fabric8ConfigMapPropertySourceLocator::locate directly, thus no need for bootstrap phase to kick in. As such two flags that might look a bit un-expected: \"spring.cloud.kubernetes.config.enabled\u003dfalse\" \"spring.cloud.kubernetes.secrets.enabled\u003dfalse\"\n * @author Isik Erhan\n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient @Import(ConfigDataConfigFailFastEnabledButRetryDisabled.LocalConfig.class) class ConfigDataConfigFailFastEnabledButRetryDisabled extends ConfigFailFastEnabledButRetryDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @MockBean private KubernetesNamespaceProvider kubernetesNamespaceProvider;\n  @BeforeAll static void setup();\n@Configuration static class LocalConfig {\n    /** \n * we need this config because ConfigMapConfigProperties is now a record, so we can\u0027t use @SpyBean on it. We also read the property of fail-fast from the Environment, that in turn is set in the @SpringBootTest properties.\n */\n    @Bean ConfigMapConfigProperties properties(    Environment environment);\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/locator_retry/fail_fast_enabled_retry_disabled/ConfigFailFastEnabledButRetryDisabled.java",
        "name": "ConfigFailFastEnabledButRetryDisabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.locator_retry.fail_fast_enabled_retry_disabled.ConfigFailFastEnabledButRetryDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * we call Fabric8ConfigMapPropertySourceLocator::locate directly, thus no need for bootstrap phase to kick in. As such two flags that might look a bit un-expected: \"spring.cloud.kubernetes.config.enabled\u003dfalse\" \"spring.cloud.kubernetes.secrets.enabled\u003dfalse\"\n * @author Isik Erhan\n * @author wind57\n */\nabstract class ConfigFailFastEnabledButRetryDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps/application\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer){\n    ConfigFailFastEnabledButRetryDisabled.mockClient\u003dmockClient;\n    ConfigFailFastEnabledButRetryDisabled.mockServer\u003dmockServer;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @SpyBean private Fabric8ConfigMapPropertySourceLocator propertySourceLocator;\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying(){\n    mockServer.expect().withPath(API).andReturn(500,\"Internal Server Error\").once();\n    assertThat(context.containsBean(\"kubernetesConfigRetryInterceptor\")).isFalse();\n    assertThatThrownBy(() -\u003e propertySourceLocator.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessageContaining(\"api/v1/namespaces/default/configmaps. Message: Not Found.\");\n    verify(propertySourceLocator,times(1)).locate(any());\n  }\n}\n",
        "abstract": "/** \n * we call Fabric8ConfigMapPropertySourceLocator::locate directly, thus no need for bootstrap phase to kick in. As such two flags that might look a bit un-expected: \"spring.cloud.kubernetes.config.enabled\u003dfalse\" \"spring.cloud.kubernetes.secrets.enabled\u003dfalse\"\n * @author Isik Erhan\n * @author wind57\n */\nabstract class ConfigFailFastEnabledButRetryDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps/application\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer);\n  @SpyBean private Fabric8ConfigMapPropertySourceLocator propertySourceLocator;\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/locator_retry/ConfigDataConfigRetryDisabledButSecretsRetryEnabled.java",
        "name": "ConfigDataConfigRetryDisabledButSecretsRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.locator_retry.ConfigDataConfigRetryDisabledButSecretsRetryEnabled",
        "extend": "ConfigRetryDisabledButSecretsRetryEnabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataConfigRetryDisabledButSecretsRetryEnabled extends ConfigRetryDisabledButSecretsRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n  @Override protected void assertRetryBean(  ApplicationContext context){\n    assertThat(context.getBean(ConfigDataRetryableSecretsPropertySourceLocator.class)).isNotNull();\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataConfigRetryDisabledButSecretsRetryEnabled extends ConfigRetryDisabledButSecretsRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup();\n  @Override protected void assertRetryBean(  ApplicationContext context);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/locator_retry/ConfigFailFastDisabled.java",
        "name": "ConfigFailFastDisabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.locator_retry.ConfigFailFastDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\nabstract class ConfigFailFastDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps/application\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @Autowired private Fabric8ConfigMapPropertySourceLocator propertySourceLocator;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer){\n    ConfigFailFastDisabled.mockClient\u003dmockClient;\n    ConfigFailFastDisabled.mockServer\u003dmockServer;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @Test void locateShouldNotRetry(){\n    Fabric8ConfigMapPropertySourceLocator psl\u003dspy(propertySourceLocator);\n    mockServer.expect().withPath(API).andReturn(500,\"Internal Server Error\").once();\n    Assertions.assertDoesNotThrow(() -\u003e psl.locate(new MockEnvironment()));\n    verify(psl,times(1)).locate(any());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\nabstract class ConfigFailFastDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps/application\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @Autowired private Fabric8ConfigMapPropertySourceLocator propertySourceLocator;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer);\n  @Test void locateShouldNotRetry();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_prefix/NamedSecretWithPrefixConfigDataTests.java",
        "name": "NamedSecretWithPrefixConfigDataTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithPrefixApp.class,properties\u003d{\"spring.application.name\u003dnamed-secret-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-secret-with-prefix.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_prefix.NamedSecretWithPrefixConfigDataTests",
        "extend": "NamedSecretWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithPrefixApp.class,properties\u003d{\"spring.application.name\u003dnamed-secret-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-secret-with-prefix.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedSecretWithPrefixConfigDataTests extends NamedSecretWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithPrefixApp.class,properties\u003d{\"spring.application.name\u003dnamed-secret-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-secret-with-prefix.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedSecretWithPrefixConfigDataTests extends NamedSecretWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_prefix/properties/One.java",
        "name": "One",
        "modifiers": "@ConfigurationProperties(\"one\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_prefix.properties.One",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_prefix/properties/Two.java",
        "name": "Two",
        "modifiers": "@ConfigurationProperties(\"two\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_prefix.properties.Two",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_prefix/properties/Three.java",
        "name": "Three",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"secret-three\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_prefix.properties.Three",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"secret-three\") public class Three {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"secret-three\") public class Three {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_prefix/NamedSecretWithPrefixBootstrapTests.java",
        "name": "NamedSecretWithPrefixBootstrapTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-secret-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_prefix.NamedSecretWithPrefixBootstrapTests",
        "extend": "NamedSecretWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-secret-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedSecretWithPrefixBootstrapTests extends NamedSecretWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-secret-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedSecretWithPrefixBootstrapTests extends NamedSecretWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_prefix/NamedSecretWithPrefixApp.java",
        "name": "NamedSecretWithPrefixApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_prefix.NamedSecretWithPrefixApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedSecretWithPrefixApp {\n  public static void main(  String[] args){\n    SpringApplication.run(NamedSecretWithPrefixApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedSecretWithPrefixApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_prefix/controller/NamedSecretWithPrefixController.java",
        "name": "NamedSecretWithPrefixController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_prefix.controller.NamedSecretWithPrefixController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class NamedSecretWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedSecretWithPrefixController(  One one,  Two two,  Three three){\n    this.one\u003done;\n    this.two\u003dtwo;\n    this.three\u003dthree;\n  }\n  @GetMapping(\"/named-secret/prefix/one\") public String one(){\n    return one.getProperty();\n  }\n  @GetMapping(\"/named-secret/prefix/two\") public String two(){\n    return two.getProperty();\n  }\n  @GetMapping(\"/named-secret/prefix/three\") public String three(){\n    return three.getProperty();\n  }\n}\n",
        "abstract": "@RestController public class NamedSecretWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedSecretWithPrefixController(  One one,  Two two,  Three three);\n  @GetMapping(\"/named-secret/prefix/one\") public String one();\n  @GetMapping(\"/named-secret/prefix/two\") public String two();\n  @GetMapping(\"/named-secret/prefix/three\") public String three();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_prefix/NamedSecretWithPrefixTests.java",
        "name": "NamedSecretWithPrefixTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_prefix.NamedSecretWithPrefixTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class NamedSecretWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    NamedSecretWithPrefixTests.mockClient\u003dmockClient;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e one\u003dCollections.singletonMap(\"one.property\",Base64.getEncoder().encodeToString(\"one\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"secret-one\",one);\n    Map\u003cString,String\u003e two\u003dCollections.singletonMap(\"property\",Base64.getEncoder().encodeToString(\"two\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"secret-two\",two);\n    Map\u003cString,String\u003e three\u003dCollections.singletonMap(\"property\",Base64.getEncoder().encodeToString(\"three\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"secret-three\",three);\n  }\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data){\n    mockClient.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withNewMetadata().withName(name).endMetadata().addToData(data).build()).create();\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne(){\n    this.webClient.get().uri(\"/named-secret/prefix/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo(){\n    this.webClient.get().uri(\"/named-secret/prefix/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[2].name\u003dsecret-three\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"secret-three\") \u003c/pre\u003e\n */\n  @Test void testThree(){\n    this.webClient.get().uri(\"/named-secret/prefix/three\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"three\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class NamedSecretWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data);\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[2].name\u003dsecret-three\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"secret-three\") \u003c/pre\u003e\n */\n  @Test void testThree();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8ConfigMapPropertySourceTests.java",
        "name": "Fabric8ConfigMapPropertySourceTests",
        "modifiers": "@EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8ConfigMapPropertySourceTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@EnableKubernetesMockClient class Fabric8ConfigMapPropertySourceTests {\n  private KubernetesMockServer mockServer;\n  private KubernetesClient mockClient;\n  private static final ConfigUtils.Prefix DEFAULT\u003dConfigUtils.findPrefix(\"default\",false,false,\"irrelevant\");\n  @AfterEach void afterEach(){\n    new Fabric8ConfigMapsCache().discardAll();\n  }\n  @Test void constructorShouldThrowExceptionOnFailureWhenFailFastIsEnabled(){\n    String name\u003d\"my-config\";\n    String namespace\u003d\"default\";\n    String path\u003dString.format(\"/api/v1/namespaces/%s/configmaps\",namespace);\n    mockServer.expect().withPath(path).andReturn(500,\"Internal Server Error\").always();\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(name,namespace,true,DEFAULT,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,source,\"default\",new MockEnvironment());\n    assertThatThrownBy(() -\u003e new Fabric8ConfigMapPropertySource(context)).isInstanceOf(IllegalStateException.class).hasMessageContaining(\"v1/namespaces/default/configmaps. Message: Internal Server Error.\");\n  }\n  @Test void constructorShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled(){\n    String name\u003d\"my-config\";\n    String namespace\u003d\"default\";\n    String path\u003dString.format(\"/api/v1/namespaces/%s/configmaps/%s\",namespace,name);\n    mockServer.expect().withPath(path).andReturn(500,\"Internal Server Error\").always();\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(name,namespace,false,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,source,\"\",new MockEnvironment());\n    assertThatNoException().isThrownBy(() -\u003e new Fabric8ConfigMapPropertySource(context));\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@EnableKubernetesMockClient class Fabric8ConfigMapPropertySourceTests {\n  private KubernetesMockServer mockServer;\n  private KubernetesClient mockClient;\n  private static final ConfigUtils.Prefix DEFAULT\u003dConfigUtils.findPrefix(\"default\",false,false,\"irrelevant\");\n  @AfterEach void afterEach();\n  @Test void constructorShouldThrowExceptionOnFailureWhenFailFastIsEnabled();\n  @Test void constructorShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8ConfigMapPropertySourceLocatorMockTests.java",
        "name": "Fabric8ConfigMapPropertySourceLocatorMockTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8ConfigMapPropertySourceLocatorMockTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass Fabric8ConfigMapPropertySourceLocatorMockTests {\n  private final KubernetesClient client\u003dMockito.mock(KubernetesClient.class);\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"prefix\",false,false,\"irrelevant\");\n  @Test void constructorWithoutClientNamespaceMustFail(){\n    ConfigMapConfigProperties configMapConfigProperties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(),Map.of(),true,\"name\",null,false,true,false,RetryProperties.DEFAULT);\n    Mockito.when(client.getNamespace()).thenReturn(null);\n    Fabric8ConfigMapPropertySourceLocator source\u003dnew Fabric8ConfigMapPropertySourceLocator(client,configMapConfigProperties,new KubernetesNamespaceProvider(new MockEnvironment()));\n    NormalizedSource normalizedSource\u003dnew NamedConfigMapNormalizedSource(\"name\",null,false,PREFIX,false);\n    assertThatThrownBy(() -\u003e source.getMapPropertySource(normalizedSource,new MockEnvironment())).isInstanceOf(NamespaceResolutionFailedException.class);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass Fabric8ConfigMapPropertySourceLocatorMockTests {\n  private final KubernetesClient client\u003dMockito.mock(KubernetesClient.class);\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"prefix\",false,false,\"irrelevant\");\n  @Test void constructorWithoutClientNamespaceMustFail();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/BootstrapConfigMapsFromFilePathsTests.java",
        "name": "BootstrapConfigMapsFromFilePathsTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-path-example\",\"spring.cloud.kubernetes.config.enableApi\u003dfalse\",\"spring.cloud.kubernetes.config.paths\u003d\" + BootstrapConfigMapsFromFilePathsTests.FIRST_FILE_NAME_FULL_PATH + \",\"+ BootstrapConfigMapsFromFilePathsTests.SECOND_FILE_NAME_FULL_PATH+ \",\"+ BootstrapConfigMapsFromFilePathsTests.FIRST_FILE_NAME_DUPLICATED_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.BootstrapConfigMapsFromFilePathsTests",
        "extend": "ConfigMapsFromFilePathsTests",
        "implements": "",
        "raw": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-path-example\",\"spring.cloud.kubernetes.config.enableApi\u003dfalse\",\"spring.cloud.kubernetes.config.paths\u003d\" + BootstrapConfigMapsFromFilePathsTests.FIRST_FILE_NAME_FULL_PATH + \",\"+ BootstrapConfigMapsFromFilePathsTests.SECOND_FILE_NAME_FULL_PATH+ \",\"+ BootstrapConfigMapsFromFilePathsTests.FIRST_FILE_NAME_DUPLICATED_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapConfigMapsFromFilePathsTests extends ConfigMapsFromFilePathsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass() throws IOException {\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-path-example\",\"spring.cloud.kubernetes.config.enableApi\u003dfalse\",\"spring.cloud.kubernetes.config.paths\u003d\" + BootstrapConfigMapsFromFilePathsTests.FIRST_FILE_NAME_FULL_PATH + \",\"+ BootstrapConfigMapsFromFilePathsTests.SECOND_FILE_NAME_FULL_PATH+ \",\"+ BootstrapConfigMapsFromFilePathsTests.FIRST_FILE_NAME_DUPLICATED_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapConfigMapsFromFilePathsTests extends ConfigMapsFromFilePathsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass() throws IOException;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigMapsTests.java",
        "name": "ConfigMapsTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigMapsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\nabstract class ConfigMapsTests {\n  private static final String APPLICATION_NAME\u003d\"configmap-example\";\n  private static KubernetesClient mockClient;\n  @Autowired(required\u003dfalse) private Config config;\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient){\n    ConfigMapsTests.mockClient\u003dmockClient;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    HashMap\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"bean.greeting\",\"Hello ConfigMap, %s!\");\n    mockClient.configMaps().inNamespace(\"test\").resource(new ConfigMapBuilder().withNewMetadata().withName(APPLICATION_NAME).endMetadata().addToData(data).build()).create();\n  }\n  @Test public void testConfig(){\n    assertThat(mockClient.getConfiguration().getMasterUrl()).isEqualTo(this.config.getMasterUrl());\n    assertThat(mockClient.getNamespace()).isEqualTo(this.config.getNamespace());\n  }\n  @Test public void testConfigMap(){\n    ConfigMap configmap\u003dmockClient.configMaps().inNamespace(\"test\").withName(APPLICATION_NAME).get();\n    HashMap\u003cString,String\u003e keys\u003d(HashMap\u003cString,String\u003e)configmap.getData();\n    assertThat(\"Hello ConfigMap, %s!\").isEqualTo(keys.get(\"bean.greeting\"));\n  }\n  @Test public void testGreetingEndpoint(){\n    this.webClient.get().uri(\"/api/greeting\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Hello ConfigMap, World!\");\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\nabstract class ConfigMapsTests {\n  private static final String APPLICATION_NAME\u003d\"configmap-example\";\n  private static KubernetesClient mockClient;\n  @Autowired(required\u003dfalse) private Config config;\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient);\n  @Test public void testConfig();\n  @Test public void testConfigMap();\n  @Test public void testGreetingEndpoint();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigDataCoreTest.java",
        "name": "ConfigDataCoreTest",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(classes\u003dTestApplication.class,properties\u003d{\"spring.application.name\u003dtestapp\",\"spring.cloud.kubernetes.client.namespace\u003dtestns\",\"spring.cloud.kubernetes.client.trustCerts\u003dtrue\",\"spring.cloud.kubernetes.config.namespace\u003dtestns\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigDataCoreTest",
        "extend": "CoreTest",
        "implements": "",
        "raw": "@ExtendWith(SpringExtension.class) @SpringBootTest(classes\u003dTestApplication.class,properties\u003d{\"spring.application.name\u003dtestapp\",\"spring.cloud.kubernetes.client.namespace\u003dtestns\",\"spring.cloud.kubernetes.client.trustCerts\u003dtrue\",\"spring.cloud.kubernetes.config.namespace\u003dtestns\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataCoreTest extends CoreTest {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "@ExtendWith(SpringExtension.class) @SpringBootTest(classes\u003dTestApplication.class,properties\u003d{\"spring.application.name\u003dtestapp\",\"spring.cloud.kubernetes.client.namespace\u003dtestns\",\"spring.cloud.kubernetes.client.trustCerts\u003dtrue\",\"spring.cloud.kubernetes.config.namespace\u003dtestns\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataCoreTest extends CoreTest {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/BootstrapCoreTest.java",
        "name": "BootstrapCoreTest",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(classes\u003dTestApplication.class,properties\u003d{\"spring.application.name\u003dtestapp\",\"spring.cloud.kubernetes.client.namespace\u003dtestns\",\"spring.cloud.kubernetes.client.trustCerts\u003dtrue\",\"spring.cloud.kubernetes.config.namespace\u003dtestns\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.BootstrapCoreTest",
        "extend": "CoreTest",
        "implements": "",
        "raw": "@ExtendWith(SpringExtension.class) @SpringBootTest(classes\u003dTestApplication.class,properties\u003d{\"spring.application.name\u003dtestapp\",\"spring.cloud.kubernetes.client.namespace\u003dtestns\",\"spring.cloud.kubernetes.client.trustCerts\u003dtrue\",\"spring.cloud.kubernetes.config.namespace\u003dtestns\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapCoreTest extends CoreTest {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "@ExtendWith(SpringExtension.class) @SpringBootTest(classes\u003dTestApplication.class,properties\u003d{\"spring.application.name\u003dtestapp\",\"spring.cloud.kubernetes.client.namespace\u003dtestns\",\"spring.cloud.kubernetes.client.trustCerts\u003dtrue\",\"spring.cloud.kubernetes.config.namespace\u003dtestns\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapCoreTest extends CoreTest {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/BootstrapConfigMapsWithActiveProfilesNameTests.java",
        "name": "BootstrapConfigMapsWithActiveProfilesNameTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dRANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-active-profile-name-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.BootstrapConfigMapsWithActiveProfilesNameTests",
        "extend": "ConfigMapsWithActiveProfilesNameTests",
        "implements": "",
        "raw": "/** \n * @author Ali Shahbour\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dRANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-active-profile-name-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapConfigMapsWithActiveProfilesNameTests extends ConfigMapsWithActiveProfilesNameTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author Ali Shahbour\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dRANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-active-profile-name-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapConfigMapsWithActiveProfilesNameTests extends ConfigMapsWithActiveProfilesNameTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/KubernetesConfigTestBase.java",
        "name": "KubernetesConfigTestBase",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.KubernetesConfigTestBase",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Haytham Mohamed\n */\npublic class KubernetesConfigTestBase {\n  private ConfigurableApplicationContext context;\n  protected String[] commonProperties\u003dnew String[0];\n  protected ConfigurableApplicationContext getContext(){\n    return context;\n  }\n  protected void setup(  Class\u003c?\u003e mockClientConfiguration,  String... env){\n    String[] properties\u003dStream.concat(Arrays.stream(commonProperties),Arrays.stream(env)).toArray(String[]::new);\n    context\u003dnew SpringApplicationBuilder(PropertyPlaceholderAutoConfiguration.class,mockClientConfiguration,BootstrapConfiguration.class,Fabric8ConfigReloadAutoConfiguration.class,ConfigReloadPropertiesAutoConfiguration.class,RefreshAutoConfiguration.class).web(WebApplicationType.NONE).properties(properties).run();\n  }\n  @AfterEach public void close(){\n    if (context !\u003d null) {\n      context.close();\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Haytham Mohamed\n */\npublic class KubernetesConfigTestBase {\n  private ConfigurableApplicationContext context;\n  protected String[] commonProperties\u003dnew String[0];\n  protected ConfigurableApplicationContext getContext();\n  protected void setup(  Class\u003c?\u003e mockClientConfiguration,  String... env);\n  @AfterEach public void close();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/NamedConfigMapContextToSourceDataProviderTests.java",
        "name": "NamedConfigMapContextToSourceDataProviderTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.NamedConfigMapContextToSourceDataProviderTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Tests only for the happy-path scenarios. All others are tested elsewhere.\n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class) class NamedConfigMapContextToSourceDataProviderTests {\n  private static final String NAMESPACE\u003d\"default\";\n  private static KubernetesClient mockClient;\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"some\",false,false,\"irrelevant\");\n  private static final Map\u003cString,String\u003e COLOR_REALLY_RED\u003dMap.of(\"color\",\"really-red\");\n  @BeforeAll static void beforeAll(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,NAMESPACE);\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterEach void afterEach(){\n    mockClient.configMaps().inNamespace(NAMESPACE).delete();\n    new Fabric8ConfigMapsCache().discardAll();\n  }\n  /** \n * \u003cpre\u003e one configmap deployed with name \"red\" we search by name, but for the \"blue\" one, as such not find it \u003c/pre\u003e\n */\n  @Test void noMatch(){\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(COLOR_REALLY_RED).build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(configMap).create();\n    NormalizedSource normalizedSource\u003dnew NamedConfigMapNormalizedSource(\"blue\",NAMESPACE,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.blue.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Collections.emptyMap());\n  }\n  /** \n * \u003cpre\u003e one configmap deployed with name \"red\" we search by name, for the \"red\" one, as such we find it \u003c/pre\u003e\n */\n  @Test void match(){\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(COLOR_REALLY_RED).build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(configMap).create();\n    NormalizedSource normalizedSource\u003dnew NamedConfigMapNormalizedSource(\"red\",NAMESPACE,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red.default\");\n    Assertions.assertEquals(sourceData.sourceData(),COLOR_REALLY_RED);\n  }\n  /** \n * \u003cpre\u003e - two configmaps deployed : \"red\" and \"red-with-profile\". - \"red\" is matched directly, \"red-with-profile\" is matched because we have an active profile \"active-profile\" \u003c/pre\u003e\n */\n  @Test void matchIncludeSingleProfile(){\n    ConfigMap red\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(COLOR_REALLY_RED).build();\n    ConfigMap redWithProfile\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red-with-profile\").endMetadata().addToData(\"taste\",\"mango\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(red).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(redWithProfile).create();\n    MockEnvironment env\u003dnew MockEnvironment();\n    env.setActiveProfiles(\"with-profile\");\n    NormalizedSource normalizedSource\u003dnew NamedConfigMapNormalizedSource(\"red\",NAMESPACE,true,ConfigUtils.Prefix.DEFAULT,true,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,env);\n    Fabric8ContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red.red-with-profile.default.with-profile\");\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color\"),\"really-red\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"taste\"),\"mango\");\n  }\n  /** \n * \u003cpre\u003e - two configmaps deployed : \"red\" and \"red-with-profile\". - \"red\" is matched directly, \"red-with-profile\" is matched because we have an active profile \"active-profile\" -  This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based config maps as well. \u003c/pre\u003e\n */\n  @Test void matchIncludeSingleProfileWithPrefix(){\n    ConfigMap red\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(COLOR_REALLY_RED).build();\n    ConfigMap redWithProfile\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red-with-profile\").endMetadata().addToData(\"taste\",\"mango\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(red).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(redWithProfile).create();\n    MockEnvironment env\u003dnew MockEnvironment();\n    env.setActiveProfiles(\"with-profile\");\n    NormalizedSource normalizedSource\u003dnew NamedConfigMapNormalizedSource(\"red\",NAMESPACE,true,PREFIX,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,env);\n    Fabric8ContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red.red-with-profile.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.color\"),\"really-red\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.taste\"),\"mango\");\n  }\n  /** \n * \u003cpre\u003e - three configmaps deployed : \"red\", \"red-with-taste\" and \"red-with-shape\" - \"red\" is matched directly, the other two are matched because of active profiles -  This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based config maps as well. \u003c/pre\u003e\n */\n  @Test void matchIncludeTwoProfilesWithPrefix(){\n    ConfigMap red\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(COLOR_REALLY_RED).build();\n    ConfigMap redWithTaste\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red-with-taste\").endMetadata().addToData(\"taste\",\"mango\").build();\n    ConfigMap redWithShape\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red-with-shape\").endMetadata().addToData(\"shape\",\"round\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(red).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(redWithTaste).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(redWithShape).create();\n    MockEnvironment env\u003dnew MockEnvironment();\n    env.setActiveProfiles(\"with-taste\",\"with-shape\");\n    NormalizedSource normalizedSource\u003dnew NamedConfigMapNormalizedSource(\"red\",NAMESPACE,true,PREFIX,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,env);\n    Fabric8ContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red.red-with-shape.red-with-taste.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),3);\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.color\"),\"really-red\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.taste\"),\"mango\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.shape\"),\"round\");\n  }\n  /** \n * \u003cpre\u003e proves that an implicit configmap is going to be generated and read, even if we did not provide one \u003c/pre\u003e\n */\n  @Test void matchWithName(){\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"application\").endMetadata().addToData(\"color\",\"red\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(configMap).create();\n    NormalizedSource normalizedSource\u003dnew NamedConfigMapNormalizedSource(\"application\",NAMESPACE,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.application.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Collections.singletonMap(\"color\",\"red\"));\n  }\n  /** \n * \u003cpre\u003e - NamedSecretContextToSourceDataProvider gets as input a KubernetesClientConfigContext - This context has a namespace as well as a NormalizedSource, that has a namespace too. - This test makes sure that we use the proper one. \u003c/pre\u003e\n */\n  @Test void namespaceMatch(){\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(COLOR_REALLY_RED).build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(configMap).create();\n    String wrongNamespace\u003dNAMESPACE + \"nope\";\n    NormalizedSource normalizedSource\u003dnew NamedConfigMapNormalizedSource(\"red\",wrongNamespace,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Collections.singletonMap(\"color\",\"really-red\"));\n  }\n  /** \n * \u003cpre\u003e - proves that single yaml file gets special treatment \u003c/pre\u003e\n */\n  @Test void testSingleYaml(){\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(\"single.yaml\",\"key: value\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(configMap).create();\n    NormalizedSource normalizedSource\u003dnew NamedConfigMapNormalizedSource(\"red\",NAMESPACE,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Collections.singletonMap(\"key\",\"value\"));\n  }\n  /** \n * \u003cpre\u003e - one configmap is deployed with name \"one\" - profile is enabled with name \"k8s\" we assert that the name of the source is \"one\" and does not contain \"one-dev\" \u003c/pre\u003e\n */\n  @Test void testCorrectNameWithProfile(){\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"one\").endMetadata().addToData(\"key\",\"value\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(configMap).create();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource normalizedSource\u003dnew NamedConfigMapNormalizedSource(\"one\",NAMESPACE,true,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,environment);\n    Fabric8ContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.one.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Collections.singletonMap(\"key\",\"value\"));\n  }\n  /** \n * \u003cpre\u003e - two configmaps are deployed : \"red\", \"green\", in the same namespace. - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output){\n    ConfigMap red\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red\").endMetadata().addToData(COLOR_REALLY_RED).build();\n    ConfigMap green\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"green\").endMetadata().addToData(\"taste\",\"mango\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(red).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(green).create();\n    MockEnvironment env\u003dnew MockEnvironment();\n    NormalizedSource redNormalizedSource\u003dnew NamedConfigMapNormalizedSource(\"red\",NAMESPACE,true,PREFIX,false);\n    Fabric8ConfigContext redContext\u003dnew Fabric8ConfigContext(mockClient,redNormalizedSource,NAMESPACE,env);\n    Fabric8ContextToSourceData redData\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData redSourceData\u003dredData.apply(redContext);\n    Assertions.assertEquals(redSourceData.sourceName(),\"configmap.red.default\");\n    Assertions.assertEquals(redSourceData.sourceData().size(),1);\n    Assertions.assertEquals(redSourceData.sourceData().get(\"some.color\"),\"really-red\");\n    Assertions.assertTrue(output.getAll().contains(\"Loaded all config maps in namespace \u0027\" + NAMESPACE + \"\u0027\"));\n    NormalizedSource greenNormalizedSource\u003dnew NamedConfigMapNormalizedSource(\"green\",NAMESPACE,true,PREFIX,false);\n    Fabric8ConfigContext greenContext\u003dnew Fabric8ConfigContext(mockClient,greenNormalizedSource,NAMESPACE,env);\n    Fabric8ContextToSourceData greenData\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData greenSourceData\u003dgreenData.apply(greenContext);\n    Assertions.assertEquals(greenSourceData.sourceName(),\"configmap.green.default\");\n    Assertions.assertEquals(greenSourceData.sourceData().size(),1);\n    Assertions.assertEquals(greenSourceData.sourceData().get(\"some.taste\"),\"mango\");\n    String[] out\u003doutput.getAll().split(\"Loaded all config maps in namespace\");\n    Assertions.assertEquals(out.length,2);\n    out\u003doutput.getAll().split(\"Loaded \\\\(from cache\\\\) all config maps in namespace\");\n    Assertions.assertEquals(out.length,2);\n  }\n}\n",
        "abstract": "/** \n * Tests only for the happy-path scenarios. All others are tested elsewhere.\n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class) class NamedConfigMapContextToSourceDataProviderTests {\n  private static final String NAMESPACE\u003d\"default\";\n  private static KubernetesClient mockClient;\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"some\",false,false,\"irrelevant\");\n  private static final Map\u003cString,String\u003e COLOR_REALLY_RED\u003dMap.of(\"color\",\"really-red\");\n  @BeforeAll static void beforeAll();\n  @AfterEach void afterEach();\n  /** \n * \u003cpre\u003e one configmap deployed with name \"red\" we search by name, but for the \"blue\" one, as such not find it \u003c/pre\u003e\n */\n  @Test void noMatch();\n  /** \n * \u003cpre\u003e one configmap deployed with name \"red\" we search by name, for the \"red\" one, as such we find it \u003c/pre\u003e\n */\n  @Test void match();\n  /** \n * \u003cpre\u003e - two configmaps deployed : \"red\" and \"red-with-profile\". - \"red\" is matched directly, \"red-with-profile\" is matched because we have an active profile \"active-profile\" \u003c/pre\u003e\n */\n  @Test void matchIncludeSingleProfile();\n  /** \n * \u003cpre\u003e - two configmaps deployed : \"red\" and \"red-with-profile\". - \"red\" is matched directly, \"red-with-profile\" is matched because we have an active profile \"active-profile\" -  This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based config maps as well. \u003c/pre\u003e\n */\n  @Test void matchIncludeSingleProfileWithPrefix();\n  /** \n * \u003cpre\u003e - three configmaps deployed : \"red\", \"red-with-taste\" and \"red-with-shape\" - \"red\" is matched directly, the other two are matched because of active profiles -  This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based config maps as well. \u003c/pre\u003e\n */\n  @Test void matchIncludeTwoProfilesWithPrefix();\n  /** \n * \u003cpre\u003e proves that an implicit configmap is going to be generated and read, even if we did not provide one \u003c/pre\u003e\n */\n  @Test void matchWithName();\n  /** \n * \u003cpre\u003e - NamedSecretContextToSourceDataProvider gets as input a KubernetesClientConfigContext - This context has a namespace as well as a NormalizedSource, that has a namespace too. - This test makes sure that we use the proper one. \u003c/pre\u003e\n */\n  @Test void namespaceMatch();\n  /** \n * \u003cpre\u003e - proves that single yaml file gets special treatment \u003c/pre\u003e\n */\n  @Test void testSingleYaml();\n  /** \n * \u003cpre\u003e - one configmap is deployed with name \"one\" - profile is enabled with name \"k8s\" we assert that the name of the source is \"one\" and does not contain \"one-dev\" \u003c/pre\u003e\n */\n  @Test void testCorrectNameWithProfile();\n  /** \n * \u003cpre\u003e - two configmaps are deployed : \"red\", \"green\", in the same namespace. - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigDataConfigMapsWithoutProfilesTests.java",
        "name": "ConfigDataConfigMapsWithoutProfilesTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-without-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigDataConfigMapsWithoutProfilesTests",
        "extend": "ConfigMapsWithoutProfilesTests",
        "implements": "",
        "raw": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-without-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsWithoutProfilesTests extends ConfigMapsWithoutProfilesTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-without-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsWithoutProfilesTests extends ConfigMapsWithoutProfilesTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigDataConfigMapsWithActiveProfilesNameTests.java",
        "name": "ConfigDataConfigMapsWithActiveProfilesNameTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dRANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-active-profile-name-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigDataConfigMapsWithActiveProfilesNameTests",
        "extend": "ConfigMapsWithActiveProfilesNameTests",
        "implements": "",
        "raw": "/** \n * @author Ali Shahbour\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dRANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-active-profile-name-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsWithActiveProfilesNameTests extends ConfigMapsWithActiveProfilesNameTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author Ali Shahbour\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dRANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-active-profile-name-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @ActiveProfiles(\"development\") @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsWithActiveProfilesNameTests extends ConfigMapsWithActiveProfilesNameTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/example3/MultiSecretsApp.java",
        "name": "MultiSecretsApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties(MultiSecretsProperties.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.example3.MultiSecretsApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties(MultiSecretsProperties.class) public class MultiSecretsApp {\n  public static void main(  String[] args){\n    SpringApplication.run(MultiSecretsApp.class,args);\n  }\n@RestController public static class Controller {\n    private final MultiSecretsProperties properties;\n    public Controller(    MultiSecretsProperties properties){\n      this.properties\u003dproperties;\n    }\n    @GetMapping(\"/secret1\") public Response secret1(){\n      return new Response(this.properties.getSecret1());\n    }\n    @GetMapping(\"/secret2\") public Response secret2(){\n      return new Response(this.properties.getSecret2());\n    }\n  }\npublic static class Response {\n    private final String secret;\n    public Response(    String secret){\n      this.secret\u003dsecret;\n    }\n    public String getSecret(){\n      return this.secret;\n    }\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties(MultiSecretsProperties.class) public class MultiSecretsApp {\n  public static void main(  String[] args);\n@RestController public static class Controller {\n    private final MultiSecretsProperties properties;\n    public Controller(    MultiSecretsProperties properties);\n    @GetMapping(\"/secret1\") public Response secret1();\n    @GetMapping(\"/secret2\") public Response secret2();\n  }\npublic static class Response {\n    private final String secret;\n    public Response(    String secret);\n    public String getSecret();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/example3/MultiSecretsProperties.java",
        "name": "MultiSecretsProperties",
        "modifiers": "@ConfigurationProperties(\"secrets\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.example3.MultiSecretsProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Haytham Mohamed\n */\n@ConfigurationProperties(\"secrets\") public class MultiSecretsProperties {\n  private String secret1;\n  private String secret2;\n  public String getSecret1(){\n    return secret1;\n  }\n  public void setSecret1(  String secret1){\n    this.secret1\u003dsecret1;\n  }\n  public String getSecret2(){\n    return secret2;\n  }\n  public void setSecret2(  String secret2){\n    this.secret2\u003dsecret2;\n  }\n}\n",
        "abstract": "/** \n * @author Haytham Mohamed\n */\n@ConfigurationProperties(\"secrets\") public class MultiSecretsProperties {\n  private String secret1;\n  private String secret2;\n  public String getSecret1();\n  public void setSecret1(  String secret1);\n  public String getSecret2();\n  public void setSecret2(  String secret2);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/CoreTest.java",
        "name": "CoreTest",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.CoreTest",
        "extend": "",
        "implements": "",
        "raw": "abstract class CoreTest {\n  private static KubernetesClient mockClient;\n  @Autowired private Environment environment;\n  @Autowired private Config config;\n  public static void setUpBeforeClass(  KubernetesClient mockClient){\n    CoreTest.mockClient\u003dmockClient;\n    Map\u003cString,String\u003e data1\u003dnew HashMap\u003c\u003e();\n    data1.put(\"spring.kubernetes.test.value\",\"value1\");\n    mockClient.configMaps().inNamespace(\"testns\").resource(new ConfigMapBuilder().withNewMetadata().withName(\"testapp\").endMetadata().addToData(data1).build()).create();\n    Map\u003cString,String\u003e data2\u003dnew HashMap\u003c\u003e();\n    data2.put(\"amq.user\",\"YWRtaW4K\");\n    data2.put(\"amq.pwd\",\"MWYyZDFlMmU2N2Rm\");\n    mockClient.secrets().inNamespace(\"testns\").resource(new SecretBuilder().withNewMetadata().withName(\"testapp\").endMetadata().addToData(data2).build()).create();\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @Test public void kubernetesClientConfigBeanShouldBeConfigurableViaSystemProperties(){\n    assertThat(config).isNotNull();\n    assertThat(config.getMasterUrl()).isEqualTo(mockClient.getConfiguration().getMasterUrl());\n    assertThat(config.getNamespace()).isEqualTo(\"testns\");\n    assertThat(config.isTrustCerts()).isTrue();\n  }\n  @Test public void propertiesShouldBeReadFromConfigMap(){\n    assertThat(environment.getProperty(\"spring.kubernetes.test.value\")).isEqualTo(\"value1\");\n  }\n  @Test public void propertiesShouldBeReadFromSecret(){\n    assertThat(environment.getProperty(\"amq.user\")).isEqualTo(\"admin\");\n    assertThat(environment.getProperty(\"amq.pwd\")).isEqualTo(\"1f2d1e2e67df\");\n  }\n}\n",
        "abstract": "abstract class CoreTest {\n  private static KubernetesClient mockClient;\n  @Autowired private Environment environment;\n  @Autowired private Config config;\n  public static void setUpBeforeClass(  KubernetesClient mockClient);\n  @Test public void kubernetesClientConfigBeanShouldBeConfigurableViaSystemProperties();\n  @Test public void propertiesShouldBeReadFromConfigMap();\n  @Test public void propertiesShouldBeReadFromSecret();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_profile/properties/Green.java",
        "name": "Green",
        "modifiers": "@ConfigurationProperties(\"green-purple-secret.green-purple-secret-k8s.green-secret.green-secret-k8s.green-secret-prod\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_profile.properties.Green",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"green-purple-secret.green-purple-secret-k8s.green-secret.green-secret-k8s.green-secret-prod\") public class Green {\n  private String two;\n  private String six;\n  private String seven;\n  private String eight;\n  public String getTwo(){\n    return two;\n  }\n  public void setTwo(  String two){\n    this.two\u003dtwo;\n  }\n  public String getSix(){\n    return six;\n  }\n  public void setSix(  String six){\n    this.six\u003dsix;\n  }\n  public String getSeven(){\n    return seven;\n  }\n  public void setSeven(  String seven){\n    this.seven\u003dseven;\n  }\n  public String getEight(){\n    return eight;\n  }\n  public void setEight(  String eight){\n    this.eight\u003deight;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"green-purple-secret.green-purple-secret-k8s.green-secret.green-secret-k8s.green-secret-prod\") public class Green {\n  private String two;\n  private String six;\n  private String seven;\n  private String eight;\n  public String getTwo();\n  public void setTwo(  String two);\n  public String getSix();\n  public void setSix(  String six);\n  public String getSeven();\n  public void setSeven(  String seven);\n  public String getEight();\n  public void setEight(  String eight);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_profile/properties/Blue.java",
        "name": "Blue",
        "modifiers": "@ConfigurationProperties(\"blue\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_profile.properties.Blue",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"blue\") public class Blue {\n  private String one;\n  public String getOne(){\n    return one;\n  }\n  public void setOne(  String one){\n    this.one\u003done;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"blue\") public class Blue {\n  private String one;\n  public String getOne();\n  public void setOne(  String one);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_profile/LabeledSecretWithProfileConfigDataTests.java",
        "name": "LabeledSecretWithProfileConfigDataTests",
        "modifiers": "@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithProfileApp.class,properties\u003d{\"spring.application.name\u003dlabeled-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-secret-with-profile.yaml\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_profile.LabeledSecretWithProfileConfigDataTests",
        "extend": "LabeledSecretWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithProfileApp.class,properties\u003d{\"spring.application.name\u003dlabeled-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-secret-with-profile.yaml\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledSecretWithProfileConfigDataTests extends LabeledSecretWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithProfileApp.class,properties\u003d{\"spring.application.name\u003dlabeled-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-secret-with-profile.yaml\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledSecretWithProfileConfigDataTests extends LabeledSecretWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_profile/LabeledSecretWithProfileTests.java",
        "name": "LabeledSecretWithProfileTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_profile.LabeledSecretWithProfileTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class LabeledSecretWithProfileTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  /** \n * \u003cpre\u003e - secret with name \"color-secret\", with labels: \"{color: blue}\" and \"explicitPrefix: blue\" - secret with name \"green-secret\", with labels: \"{color: green}\" and \"explicitPrefix: blue-again\" - secret with name \"red-secret\", with labels \"{color: not-red}\" and \"useNameAsPrefix: true\" - secret with name \"yellow-secret\" with labels \"{color: not-yellow}\" and useNameAsPrefix: true - secret with name \"color-secret-k8s\", with labels : \"{color: not-blue}\" - secret with name \"green-secret-k8s\", with labels : \"{color: green-k8s}\" - secret with name \"green-secret-prod\", with labels : \"{color: green-prod}\" # a test that proves order: first read non-profile based secrets, thus profile based # secrets override non-profile ones. - secret with name \"green-purple-secret\", labels \"{color: green, shape: round}\", data: \"{eight: 8}\" - secret with name \"green-purple-secret-k8s\", labels \"{color: black}\", data: \"{eight: eight-ish}\" \u003c/pre\u003e\n */\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    LabeledSecretWithProfileTests.mockClient\u003dmockClient;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e colorSecret\u003dCollections.singletonMap(\"one\",Base64.getEncoder().encodeToString(\"1\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"color-secret\",colorSecret,Collections.singletonMap(\"color\",\"blue\"));\n    Map\u003cString,String\u003e colorSecretK8s\u003dCollections.singletonMap(\"five\",Base64.getEncoder().encodeToString(\"5\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"color-secret-k8s\",colorSecretK8s,Collections.singletonMap(\"color\",\"not-blue\"));\n    Map\u003cString,String\u003e greenSecret\u003dCollections.singletonMap(\"two\",Base64.getEncoder().encodeToString(\"2\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"green-secret\",greenSecret,Collections.singletonMap(\"color\",\"green\"));\n    Map\u003cString,String\u003e shapeSecretK8s\u003dCollections.singletonMap(\"six\",Base64.getEncoder().encodeToString(\"6\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"green-secret-k8s\",shapeSecretK8s,Collections.singletonMap(\"color\",\"green-k8s\"));\n    Map\u003cString,String\u003e shapeSecretProd\u003dCollections.singletonMap(\"seven\",Base64.getEncoder().encodeToString(\"7\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"green-secret-prod\",shapeSecretProd,Collections.singletonMap(\"color\",\"green-prod\"));\n    Map\u003cString,String\u003e redSecret\u003dCollections.singletonMap(\"three\",Base64.getEncoder().encodeToString(\"3\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"red-secret\",redSecret,Collections.singletonMap(\"color\",\"not-red\"));\n    Map\u003cString,String\u003e yellowSecret\u003dCollections.singletonMap(\"four\",Base64.getEncoder().encodeToString(\"4\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"yellow-secret\",yellowSecret,Collections.singletonMap(\"color\",\"not-yellow\"));\n    Map\u003cString,String\u003e greenPurple\u003dCollections.singletonMap(\"eight\",Base64.getEncoder().encodeToString(\"8\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"green-purple-secret\",greenPurple,Map.of(\"color\",\"green\",\"shape\",\"round\"));\n    Map\u003cString,String\u003e greenPurpleK8s\u003dCollections.singletonMap(\"eight\",Base64.getEncoder().encodeToString(\"eight-ish\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"green-purple-secret-k8s\",greenPurpleK8s,Map.of(\"color\",\"black\"));\n  }\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data,  Map\u003cString,String\u003e labels){\n    mockClient.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withNewMetadata().withName(name).withLabels(labels).endMetadata().addToData(data).build()).create();\n  }\n  /** \n * \u003cpre\u003e this one is taken from : \"blue.one\". We find \"color-secret\" by labels, and \"color-secrets-k8s\" exists, but \"includeProfileSpecificSources\u003dfalse\", thus not taken. Since \"explicitPrefix\u003dblue\", we take \"blue.one\" \u003c/pre\u003e\n */\n  @Test void testBlue(){\n    this.webClient.get().uri(\"/labeled-secret/profile/blue\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"1\"));\n  }\n  /** \n * \u003cpre\u003e this one is taken from : \"green-purple-secret.green-purple-secret-k8s.green-secret.green-secret-k8s.green-secret-prod\". We find \"green-secret\" by labels, also \"green-secrets-k8s\" and \"green-secrets-prod\" exists, because \"includeProfileSpecificSources\u003dtrue\" is set. Also \"green-purple-secret\" and \"green-purple-secret-k8s\" are found. \u003c/pre\u003e\n */\n  @Test void testGreen(){\n    this.webClient.get().uri(\"/labeled-secret/profile/green\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"2#6#7#eight-ish\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class LabeledSecretWithProfileTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  /** \n * \u003cpre\u003e - secret with name \"color-secret\", with labels: \"{color: blue}\" and \"explicitPrefix: blue\" - secret with name \"green-secret\", with labels: \"{color: green}\" and \"explicitPrefix: blue-again\" - secret with name \"red-secret\", with labels \"{color: not-red}\" and \"useNameAsPrefix: true\" - secret with name \"yellow-secret\" with labels \"{color: not-yellow}\" and useNameAsPrefix: true - secret with name \"color-secret-k8s\", with labels : \"{color: not-blue}\" - secret with name \"green-secret-k8s\", with labels : \"{color: green-k8s}\" - secret with name \"green-secret-prod\", with labels : \"{color: green-prod}\" # a test that proves order: first read non-profile based secrets, thus profile based # secrets override non-profile ones. - secret with name \"green-purple-secret\", labels \"{color: green, shape: round}\", data: \"{eight: 8}\" - secret with name \"green-purple-secret-k8s\", labels \"{color: black}\", data: \"{eight: eight-ish}\" \u003c/pre\u003e\n */\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data,  Map\u003cString,String\u003e labels);\n  /** \n * \u003cpre\u003e this one is taken from : \"blue.one\". We find \"color-secret\" by labels, and \"color-secrets-k8s\" exists, but \"includeProfileSpecificSources\u003dfalse\", thus not taken. Since \"explicitPrefix\u003dblue\", we take \"blue.one\" \u003c/pre\u003e\n */\n  @Test void testBlue();\n  /** \n * \u003cpre\u003e this one is taken from : \"green-purple-secret.green-purple-secret-k8s.green-secret.green-secret-k8s.green-secret-prod\". We find \"green-secret\" by labels, also \"green-secrets-k8s\" and \"green-secrets-prod\" exists, because \"includeProfileSpecificSources\u003dtrue\" is set. Also \"green-purple-secret\" and \"green-purple-secret-k8s\" are found. \u003c/pre\u003e\n */\n  @Test void testGreen();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_profile/controller/LabeledSecretWithProfileController.java",
        "name": "LabeledSecretWithProfileController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_profile.controller.LabeledSecretWithProfileController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class LabeledSecretWithProfileController {\n  private final Blue blue;\n  private final Green green;\n  public LabeledSecretWithProfileController(  Blue blue,  Green green){\n    this.blue\u003dblue;\n    this.green\u003dgreen;\n  }\n  @GetMapping(\"/labeled-secret/profile/blue\") public String blue(){\n    return blue.getOne();\n  }\n  @GetMapping(\"/labeled-secret/profile/green\") public String green(){\n    return green.getTwo() + \"#\" + green.getSix()+ \"#\"+ green.getSeven()+ \"#\"+ green.getEight();\n  }\n}\n",
        "abstract": "@RestController public class LabeledSecretWithProfileController {\n  private final Blue blue;\n  private final Green green;\n  public LabeledSecretWithProfileController(  Blue blue,  Green green);\n  @GetMapping(\"/labeled-secret/profile/blue\") public String blue();\n  @GetMapping(\"/labeled-secret/profile/green\") public String green();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_profile/LabeledSecretWithProfileApp.java",
        "name": "LabeledSecretWithProfileApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({Blue.class,Green.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_profile.LabeledSecretWithProfileApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({Blue.class,Green.class}) public class LabeledSecretWithProfileApp {\n  public static void main(  String[] args){\n    SpringApplication.run(LabeledSecretWithProfileApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({Blue.class,Green.class}) public class LabeledSecretWithProfileApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_secret_with_profile/LabeledSecretWithProfileBootstrapTests.java",
        "name": "LabeledSecretWithProfileBootstrapTests",
        "modifiers": "@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_secret_with_profile.LabeledSecretWithProfileBootstrapTests",
        "extend": "LabeledSecretWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledSecretWithProfileBootstrapTests extends LabeledSecretWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledSecretWithProfileBootstrapTests extends LabeledSecretWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/KubernetesConfigConfigurationTest.java",
        "name": "KubernetesConfigConfigurationTest",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.KubernetesConfigConfigurationTest",
        "extend": "KubernetesConfigTestBase",
        "implements": "",
        "raw": "/** \n * @author Ryan Dawson\n * @author Kris Iyer - Add tests for #643\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class KubernetesConfigConfigurationTest extends KubernetesConfigTestBase {\n  private static KubernetesClient mockClient;\n  @Test public void kubernetesBootstrapWhenKubernetesDefaultEnabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.bootstrap.enabled\u003dtrue\");\n    assertThat(getContext().containsBean(\"configMapPropertySourceLocator\")).isTrue();\n    assertThat(getContext().containsBean(\"secretsPropertySourceLocator\")).isTrue();\n  }\n  @Test public void kubernetesConfigDataWhenKubernetesDefaultEnabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.config.import\u003dkubernetes:\");\n    assertThat(getContext().containsBean(\"configDataConfigMapPropertySourceLocator\")).isTrue();\n    assertThat(getContext().containsBean(\"configDataSecretsPropertySourceLocator\")).isTrue();\n  }\n  @Test public void kubernetesWhenKubernetesDisabled(){\n    setup(KubernetesClientTestConfiguration.class);\n    assertThat(getContext().containsBean(\"configMapPropertySourceLocator\")).isFalse();\n    assertThat(getContext().containsBean(\"secretsPropertySourceLocator\")).isFalse();\n  }\n  @Test public void kubernetesWhenKubernetesConfigAndSecretDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\");\n    assertThat(getContext().containsBean(\"configMapPropertySourceLocator\")).isFalse();\n    assertThat(getContext().containsBean(\"secretsPropertySourceLocator\")).isFalse();\n  }\n  @Test public void kubernetesBootstrapWhenKubernetesConfigEnabledButSecretDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.config.enabled\u003dtrue\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\");\n    assertThat(getContext().containsBean(\"configMapPropertySourceLocator\")).isTrue();\n    assertThat(getContext().containsBean(\"secretsPropertySourceLocator\")).isFalse();\n  }\n  @Test public void kubernetesConfigDataWhenKubernetesConfigEnabledButSecretDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.config.enabled\u003dtrue\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\");\n    assertThat(getContext().containsBean(\"configDataConfigMapPropertySourceLocator\")).isTrue();\n    assertThat(getContext().containsBean(\"configDataSecretsPropertySourceLocator\")).isFalse();\n  }\n  @Test public void kubernetesBootstrapWhenKubernetesConfigDisabledButSecretEnabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\");\n    assertThat(getContext().containsBean(\"configMapPropertySourceLocator\")).isFalse();\n    assertThat(getContext().containsBean(\"secretsPropertySourceLocator\")).isTrue();\n  }\n  @Test public void kubernetesConfigDataWhenKubernetesConfigDisabledButSecretEnabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\");\n    assertThat(getContext().containsBean(\"configDataConfigMapPropertySourceLocator\")).isFalse();\n    assertThat(getContext().containsBean(\"configDataSecretsPropertySourceLocator\")).isTrue();\n  }\n  @Test public void kubernetesBootstrapConfigWhenKubernetesEnabledAndKubernetesConfigEnabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.config.enabled\u003dtrue\",\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\");\n    assertThat(getContext().containsBean(\"configMapPropertySourceLocator\")).isTrue();\n    assertThat(getContext().containsBean(\"secretsPropertySourceLocator\")).isTrue();\n  }\n  @Test public void kubernetesConfigDataConfigWhenKubernetesEnabledAndKubernetesConfigEnabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.config.enabled\u003dtrue\",\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\");\n    assertThat(getContext().containsBean(\"configDataConfigMapPropertySourceLocator\")).isTrue();\n    assertThat(getContext().containsBean(\"configDataSecretsPropertySourceLocator\")).isTrue();\n  }\n  @Test public void kubernetesConfigWhenKubernetesEnabledAndKubernetesConfigDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.config.enabled\u003dfalse\");\n    assertThat(getContext().containsBean(\"configMapPropertySourceLocator\")).isFalse();\n  }\n@Configuration(proxyBeanMethods\u003dfalse) private static class KubernetesClientTestConfiguration {\n    @ConditionalOnMissingBean(KubernetesClient.class) @Bean KubernetesClient kubernetesClient(){\n      return mockClient;\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Dawson\n * @author Kris Iyer - Add tests for #643\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class KubernetesConfigConfigurationTest extends KubernetesConfigTestBase {\n  private static KubernetesClient mockClient;\n  @Test public void kubernetesBootstrapWhenKubernetesDefaultEnabled();\n  @Test public void kubernetesConfigDataWhenKubernetesDefaultEnabled();\n  @Test public void kubernetesWhenKubernetesDisabled();\n  @Test public void kubernetesWhenKubernetesConfigAndSecretDisabled();\n  @Test public void kubernetesBootstrapWhenKubernetesConfigEnabledButSecretDisabled();\n  @Test public void kubernetesConfigDataWhenKubernetesConfigEnabledButSecretDisabled();\n  @Test public void kubernetesBootstrapWhenKubernetesConfigDisabledButSecretEnabled();\n  @Test public void kubernetesConfigDataWhenKubernetesConfigDisabledButSecretEnabled();\n  @Test public void kubernetesBootstrapConfigWhenKubernetesEnabledAndKubernetesConfigEnabled();\n  @Test public void kubernetesConfigDataConfigWhenKubernetesEnabledAndKubernetesConfigEnabled();\n  @Test public void kubernetesConfigWhenKubernetesEnabledAndKubernetesConfigDisabled();\n@Configuration(proxyBeanMethods\u003dfalse) private static class KubernetesClientTestConfiguration {\n    @ConditionalOnMissingBean(KubernetesClient.class) @Bean KubernetesClient kubernetesClient();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/BootstrapKubernetesEnabledOnPurpose.java",
        "name": "BootstrapKubernetesEnabledOnPurpose",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.BootstrapKubernetesEnabledOnPurpose",
        "extend": "KubernetesEnabledOnPurpose",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapKubernetesEnabledOnPurpose extends KubernetesEnabledOnPurpose {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapKubernetesEnabledOnPurpose extends KubernetesEnabledOnPurpose {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/ConfigDataKubernetesDisabled.java",
        "name": "ConfigDataKubernetesDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.ConfigDataKubernetesDisabled",
        "extend": "KubernetesDisabled",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ConfigDataKubernetesDisabled extends KubernetesDisabled {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ConfigDataKubernetesDisabled extends KubernetesDisabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/ConfigDataKubernetesEnabledSecretsAndConfigDisabled.java",
        "name": "ConfigDataKubernetesEnabledSecretsAndConfigDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.config.import\u003dkubernetes:\",\"spring.main.cloud-platform\u003dKUBERNETES\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.ConfigDataKubernetesEnabledSecretsAndConfigDisabled",
        "extend": "KubernetesEnabledSecretsAndConfigDisabled",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.config.import\u003dkubernetes:\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ConfigDataKubernetesEnabledSecretsAndConfigDisabled extends KubernetesEnabledSecretsAndConfigDisabled {\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.config.import\u003dkubernetes:\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ConfigDataKubernetesEnabledSecretsAndConfigDisabled extends KubernetesEnabledSecretsAndConfigDisabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/BootstrapKubernetesEnabledSecretsDisabled.java",
        "name": "BootstrapKubernetesEnabledSecretsDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.BootstrapKubernetesEnabledSecretsDisabled",
        "extend": "KubernetesEnabledSecretsDisabled",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapKubernetesEnabledSecretsDisabled extends KubernetesEnabledSecretsDisabled {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapKubernetesEnabledSecretsDisabled extends KubernetesEnabledSecretsDisabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/KubernetesDisabled.java",
        "name": "KubernetesDisabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.KubernetesDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class KubernetesDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void configAndSecretsBeansAreNotPresent(){\n    assertThat(context.getBeanNamesForType(Fabric8ConfigMapPropertySourceLocator.class)).hasSize(0);\n    assertThat(context.getBeanNamesForType(Fabric8SecretsPropertySourceLocator.class)).hasSize(0);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class KubernetesDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void configAndSecretsBeansAreNotPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/ConfigDataKubernetesEnabledConfigDisabled.java",
        "name": "ConfigDataKubernetesEnabledConfigDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.ConfigDataKubernetesEnabledConfigDisabled",
        "extend": "KubernetesEnabledConfigDisabled",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) class ConfigDataKubernetesEnabledConfigDisabled extends KubernetesEnabledConfigDisabled {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) class ConfigDataKubernetesEnabledConfigDisabled extends KubernetesEnabledConfigDisabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/BoostrapKubernetesEnabledConfigDisabled.java",
        "name": "BoostrapKubernetesEnabledConfigDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.BoostrapKubernetesEnabledConfigDisabled",
        "extend": "KubernetesEnabledConfigDisabled",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BoostrapKubernetesEnabledConfigDisabled extends KubernetesEnabledConfigDisabled {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BoostrapKubernetesEnabledConfigDisabled extends KubernetesEnabledConfigDisabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/KubernetesEnabledOnPurpose.java",
        "name": "KubernetesEnabledOnPurpose",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.KubernetesEnabledOnPurpose",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class KubernetesEnabledOnPurpose {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void configAndSecretsBeansArePresent(){\n    assertThat(context.getBeanNamesForType(Fabric8ConfigMapPropertySourceLocator.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(Fabric8SecretsPropertySourceLocator.class)).hasSize(1);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class KubernetesEnabledOnPurpose {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void configAndSecretsBeansArePresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/KubernetesEnabledSecretsAndConfigDisabled.java",
        "name": "KubernetesEnabledSecretsAndConfigDisabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.KubernetesEnabledSecretsAndConfigDisabled",
        "extend": "",
        "implements": "",
        "raw": "abstract class KubernetesEnabledSecretsAndConfigDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void secretsOnlyPresent(){\n    assertThat(context.getBeanNamesForType(Fabric8ConfigMapPropertySourceLocator.class)).hasSize(0);\n    assertThat(context.getBeanNamesForType(Fabric8SecretsPropertySourceLocator.class)).hasSize(0);\n  }\n}\n",
        "abstract": "abstract class KubernetesEnabledSecretsAndConfigDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void secretsOnlyPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/Fabric8BootstrapConfigurationNotInsideK8s.java",
        "name": "Fabric8BootstrapConfigurationNotInsideK8s",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.Fabric8BootstrapConfigurationNotInsideK8s",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class) class Fabric8BootstrapConfigurationNotInsideK8s {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void bothMissing(){\n    assertThat(context.getBeanNamesForType(Fabric8ConfigMapPropertySourceLocator.class)).hasSize(0);\n    assertThat(context.getBeanNamesForType(Fabric8SecretsPropertySourceLocator.class)).hasSize(0);\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class) class Fabric8BootstrapConfigurationNotInsideK8s {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void bothMissing();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/BootstrapKubernetesDisabled.java",
        "name": "BootstrapKubernetesDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.BootstrapKubernetesDisabled",
        "extend": "KubernetesDisabled",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapKubernetesDisabled extends KubernetesDisabled {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapKubernetesDisabled extends KubernetesDisabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/BootstrapKubernetesEnabledSecretsAndConfigDisabled.java",
        "name": "BootstrapKubernetesEnabledSecretsAndConfigDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.BootstrapKubernetesEnabledSecretsAndConfigDisabled",
        "extend": "KubernetesEnabledSecretsAndConfigDisabled",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapKubernetesEnabledSecretsAndConfigDisabled extends KubernetesEnabledSecretsAndConfigDisabled {\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapKubernetesEnabledSecretsAndConfigDisabled extends KubernetesEnabledSecretsAndConfigDisabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/KubernetesEnabledSecretsDisabled.java",
        "name": "KubernetesEnabledSecretsDisabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.KubernetesEnabledSecretsDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class KubernetesEnabledSecretsDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void secretsOnlyPresent(){\n    assertThat(context.getBeanNamesForType(Fabric8ConfigMapPropertySourceLocator.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(Fabric8SecretsPropertySourceLocator.class)).hasSize(0);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class KubernetesEnabledSecretsDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void secretsOnlyPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/ConfigDataKubernetesEnabledOnPurpose.java",
        "name": "ConfigDataKubernetesEnabledOnPurpose",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.ConfigDataKubernetesEnabledOnPurpose",
        "extend": "KubernetesEnabledOnPurpose",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) class ConfigDataKubernetesEnabledOnPurpose extends KubernetesEnabledOnPurpose {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) class ConfigDataKubernetesEnabledOnPurpose extends KubernetesEnabledOnPurpose {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/ConfigDataKubernetesEnabledSecretsDisabled.java",
        "name": "ConfigDataKubernetesEnabledSecretsDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.ConfigDataKubernetesEnabledSecretsDisabled",
        "extend": "KubernetesEnabledSecretsDisabled",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) class ConfigDataKubernetesEnabledSecretsDisabled extends KubernetesEnabledSecretsDisabled {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) class ConfigDataKubernetesEnabledSecretsDisabled extends KubernetesEnabledSecretsDisabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/Fabric8BootstrapConfigurationInsideK8s.java",
        "name": "Fabric8BootstrapConfigurationInsideK8s",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003dabc\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.Fabric8BootstrapConfigurationInsideK8s",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003dabc\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class Fabric8BootstrapConfigurationInsideK8s {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void bothPresent(){\n    assertThat(context.getBeanNamesForType(Fabric8ConfigMapPropertySourceLocator.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(Fabric8SecretsPropertySourceLocator.class)).hasSize(1);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003dabc\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class Fabric8BootstrapConfigurationInsideK8s {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void bothPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/kubernetes_enabled/ConfigDataKubernetesEnabled.java",
        "name": "ConfigDataKubernetesEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.kubernetes_enabled.ConfigDataKubernetesEnabled",
        "extend": "KubernetesEnabled",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) class ConfigDataKubernetesEnabled extends KubernetesEnabled {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) class ConfigDataKubernetesEnabled extends KubernetesEnabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/kubernetes_enabled/BootstrapKubernetesEnabled.java",
        "name": "BootstrapKubernetesEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.kubernetes_enabled.BootstrapKubernetesEnabled",
        "extend": "KubernetesEnabled",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapKubernetesEnabled extends KubernetesEnabled {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapKubernetesEnabled extends KubernetesEnabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/kubernetes_enabled/KubernetesEnabled.java",
        "name": "KubernetesEnabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.kubernetes_enabled.KubernetesEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class KubernetesEnabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void configAndSecretsBeansArePresent(){\n    assertThat(context.getBeanNamesForType(Fabric8ConfigMapPropertySourceLocator.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(Fabric8SecretsPropertySourceLocator.class)).hasSize(1);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class KubernetesEnabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void configAndSecretsBeansArePresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/bootstrap/KubernetesEnabledConfigDisabled.java",
        "name": "KubernetesEnabledConfigDisabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.bootstrap.KubernetesEnabledConfigDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class KubernetesEnabledConfigDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void secretsOnlyPresent(){\n    assertThat(context.getBeanNamesForType(Fabric8ConfigMapPropertySourceLocator.class)).hasSize(0);\n    assertThat(context.getBeanNamesForType(Fabric8SecretsPropertySourceLocator.class)).hasSize(1);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class KubernetesEnabledConfigDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void secretsOnlyPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/BoostrapConfigMapsTests.java",
        "name": "BoostrapConfigMapsTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.BoostrapConfigMapsTests",
        "extend": "ConfigMapsTests",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BoostrapConfigMapsTests extends ConfigMapsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BoostrapConfigMapsTests extends ConfigMapsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_profile/properties/One.java",
        "name": "One",
        "modifiers": "@ConfigurationProperties(\"one\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_profile.properties.One",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_profile/properties/Two.java",
        "name": "Two",
        "modifiers": "@ConfigurationProperties(\"two\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_profile.properties.Two",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_profile/properties/Three.java",
        "name": "Three",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"configmap-three\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_profile.properties.Three",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"configmap-three\") public class Three {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"configmap-three\") public class Three {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_profile/controller/NamedConfigMapWithProfileController.java",
        "name": "NamedConfigMapWithProfileController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_profile.controller.NamedConfigMapWithProfileController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class NamedConfigMapWithProfileController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedConfigMapWithProfileController(  One one,  Two two,  Three three){\n    this.one\u003done;\n    this.two\u003dtwo;\n    this.three\u003dthree;\n  }\n  @GetMapping(\"/named-configmap/profile/one\") public String one(){\n    return one.getProperty();\n  }\n  @GetMapping(\"/named-configmap/profile/two\") public String two(){\n    return two.getProperty();\n  }\n  @GetMapping(\"/named-configmap/profile/three\") public String three(){\n    return three.getProperty();\n  }\n}\n",
        "abstract": "@RestController public class NamedConfigMapWithProfileController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedConfigMapWithProfileController(  One one,  Two two,  Three three);\n  @GetMapping(\"/named-configmap/profile/one\") public String one();\n  @GetMapping(\"/named-configmap/profile/two\") public String two();\n  @GetMapping(\"/named-configmap/profile/three\") public String three();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_profile/NamedConfigMapWithProfileTests.java",
        "name": "NamedConfigMapWithProfileTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_profile.NamedConfigMapWithProfileTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class NamedConfigMapWithProfileTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    NamedConfigMapWithProfileTests.mockClient\u003dmockClient;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e one\u003dCollections.singletonMap(\"one.property\",\"one\");\n    Map\u003cString,String\u003e oneFromKubernetesProfile\u003dCollections.singletonMap(\"one.property\",\"one-from-k8s\");\n    createConfigmap(\"configmap-one\",one);\n    createConfigmap(\"configmap-one-k8s\",oneFromKubernetesProfile);\n    Map\u003cString,String\u003e two\u003dCollections.singletonMap(\"property\",\"two\");\n    Map\u003cString,String\u003e twoFromKubernetesProfile\u003dCollections.singletonMap(\"property\",\"two-from-k8s\");\n    createConfigmap(\"configmap-two\",two);\n    createConfigmap(\"configmap-two-k8s\",twoFromKubernetesProfile);\n    Map\u003cString,String\u003e three\u003dCollections.singletonMap(\"property\",\"three\");\n    Map\u003cString,String\u003e threeFromKubernetesProfile\u003dCollections.singletonMap(\"property\",\"three-from-k8s\");\n    createConfigmap(\"configmap-three\",three);\n    createConfigmap(\"configmap-three-k8s\",threeFromKubernetesProfile);\n  }\n  static void createConfigmap(  String name,  Map\u003cString,String\u003e data){\n    mockClient.configMaps().inNamespace(\"spring-k8s\").resource(new ConfigMapBuilder().withNewMetadata().withName(name).endMetadata().addToData(data).build()).create();\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[0].useNameAsPrefix\u003dfalse\u0027 \u0027spring.cloud.kubernetes.config.sources[0].includeProfileSpecificSources\u003dtrue\u0027 (\"one.property\", \"one-from-k8s\") As such: @ConfigurationProperties(\"one\"), value is overridden by the one that we read from the profile based source. \u003c/pre\u003e\n */\n  @Test void testOne(){\n    this.webClient.get().uri(\"/named-configmap/profile/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one-from-k8s\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[1].explicitPrefix\u003dtwo\u0027 \u0027spring.cloud.kubernetes.config.sources[1].includeProfileSpecificSources\u003dfalse\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\"). Even if there is a profile based source, we disabled reading it. \u003c/pre\u003e\n */\n  @Test void testTwo(){\n    this.webClient.get().uri(\"/named-configmap/profile/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[2].name\u003dconfigmap-three\u0027 \u0027spring.cloud.kubernetes.config.sources[1].includeProfileSpecificSources\u003dtrue\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"config-three\"), value is overridden by the one that we read from the profile based source \u003c/pre\u003e\n */\n  @Test void testThree(){\n    this.webClient.get().uri(\"/named-configmap/profile/three\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"three-from-k8s\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class NamedConfigMapWithProfileTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n  static void createConfigmap(  String name,  Map\u003cString,String\u003e data);\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[0].useNameAsPrefix\u003dfalse\u0027 \u0027spring.cloud.kubernetes.config.sources[0].includeProfileSpecificSources\u003dtrue\u0027 (\"one.property\", \"one-from-k8s\") As such: @ConfigurationProperties(\"one\"), value is overridden by the one that we read from the profile based source. \u003c/pre\u003e\n */\n  @Test void testOne();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[1].explicitPrefix\u003dtwo\u0027 \u0027spring.cloud.kubernetes.config.sources[1].includeProfileSpecificSources\u003dfalse\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\"). Even if there is a profile based source, we disabled reading it. \u003c/pre\u003e\n */\n  @Test void testTwo();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[2].name\u003dconfigmap-three\u0027 \u0027spring.cloud.kubernetes.config.sources[1].includeProfileSpecificSources\u003dtrue\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"config-three\"), value is overridden by the one that we read from the profile based source \u003c/pre\u003e\n */\n  @Test void testThree();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_profile/NamedConfigMapWithProfileApp.java",
        "name": "NamedConfigMapWithProfileApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_profile.NamedConfigMapWithProfileApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedConfigMapWithProfileApp {\n  public static void main(  String[] args){\n    SpringApplication.run(NamedConfigMapWithProfileApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedConfigMapWithProfileApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_profile/NamedConfigMapWithProfileBootstrapTests.java",
        "name": "NamedConfigMapWithProfileBootstrapTests",
        "modifiers": "@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-configmap-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_profile.NamedConfigMapWithProfileBootstrapTests",
        "extend": "NamedConfigMapWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-configmap-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedConfigMapWithProfileBootstrapTests extends NamedConfigMapWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-configmap-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedConfigMapWithProfileBootstrapTests extends NamedConfigMapWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_profile/NamedConfigMapWithProfileConfigDataTests.java",
        "name": "NamedConfigMapWithProfileConfigDataTests",
        "modifiers": "@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithProfileApp.class,properties\u003d{\"spring.application.name\u003dnamed-configmap-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-configmap-with-profile.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_profile.NamedConfigMapWithProfileConfigDataTests",
        "extend": "NamedConfigMapWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithProfileApp.class,properties\u003d{\"spring.application.name\u003dnamed-configmap-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-configmap-with-profile.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedConfigMapWithProfileConfigDataTests extends NamedConfigMapWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithProfileApp.class,properties\u003d{\"spring.application.name\u003dnamed-configmap-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-configmap-with-profile.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedConfigMapWithProfileConfigDataTests extends NamedConfigMapWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/secrets_with_labels/SecretsWithLabelsController.java",
        "name": "SecretsWithLabelsController",
        "modifiers": "@RestController",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.secrets_with_labels.SecretsWithLabelsController",
        "extend": "",
        "implements": "",
        "raw": "@RestController class SecretsWithLabelsController {\n  private final One one;\n  SecretsWithLabelsController(  One one){\n    this.one\u003done;\n  }\n  @GetMapping(\"secrets/labels/one\") String one(){\n    return one.getProperty();\n  }\n}\n",
        "abstract": "@RestController class SecretsWithLabelsController {\n  private final One one;\n  SecretsWithLabelsController(  One one);\n  @GetMapping(\"secrets/labels/one\") String one();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/secrets_with_labels/BootstrapSecretsWithLabelsTests.java",
        "name": "BootstrapSecretsWithLabelsTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSecretsWithLabelsApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsecret-with-labels-config\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.secrets_with_labels.BootstrapSecretsWithLabelsTests",
        "extend": "SecretsWithLabelsTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSecretsWithLabelsApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsecret-with-labels-config\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class BootstrapSecretsWithLabelsTests extends SecretsWithLabelsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSecretsWithLabelsApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsecret-with-labels-config\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class BootstrapSecretsWithLabelsTests extends SecretsWithLabelsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/secrets_with_labels/One.java",
        "name": "One",
        "modifiers": "@ConfigurationProperties(\"secret\")",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.secrets_with_labels.One",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"secret\") class One {\n  private String property;\n  String getProperty(){\n    return property;\n  }\n  void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"secret\") class One {\n  private String property;\n  String getProperty();\n  void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/secrets_with_labels/ConfigDataSecretsWithLabelsTests.java",
        "name": "ConfigDataSecretsWithLabelsTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSecretsWithLabelsApp.class,properties\u003d{\"spring.application.name\u003dsecret-with-labels-config\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./secret-with-labels-config.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.secrets_with_labels.ConfigDataSecretsWithLabelsTests",
        "extend": "SecretsWithLabelsTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSecretsWithLabelsApp.class,properties\u003d{\"spring.application.name\u003dsecret-with-labels-config\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./secret-with-labels-config.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class ConfigDataSecretsWithLabelsTests extends SecretsWithLabelsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSecretsWithLabelsApp.class,properties\u003d{\"spring.application.name\u003dsecret-with-labels-config\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./secret-with-labels-config.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class ConfigDataSecretsWithLabelsTests extends SecretsWithLabelsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/secrets_with_labels/SecretsWithLabelsTests.java",
        "name": "SecretsWithLabelsTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.secrets_with_labels.SecretsWithLabelsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class SecretsWithLabelsTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    SecretsWithLabelsTests.mockClient\u003dmockClient;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e two\u003dCollections.singletonMap(\"secret.property\",Base64.getEncoder().encodeToString(\"value\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"secret-two\",two);\n    Map\u003cString,String\u003e three\u003dCollections.singletonMap(\"secret.property\",Base64.getEncoder().encodeToString(\"diff-value\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"secret-three\",three);\n  }\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data){\n    mockClient.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withNewMetadata().withName(name).endMetadata().addToData(data).build()).create();\n  }\n  /** \n * \u003cpre\u003e 1. We have two secrets in a certain namespace: \"secret-two\" and \"secret-three\". 2. Both of the above configure the same secret data: \"secret.property\", but with different values : \"value\" and \"diff-value\" 3. In our configuration we want to read only \"secret-two\" (the one that stores \"value\" inside) 4. This test proves that we do not touch \"secret-three\" \u003c/pre\u003e\n */\n  @Test void testOne(){\n    this.webClient.get().uri(\"secrets/labels/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"value\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class SecretsWithLabelsTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data);\n  /** \n * \u003cpre\u003e 1. We have two secrets in a certain namespace: \"secret-two\" and \"secret-three\". 2. Both of the above configure the same secret data: \"secret.property\", but with different values : \"value\" and \"diff-value\" 3. In our configuration we want to read only \"secret-two\" (the one that stores \"value\" inside) 4. This test proves that we do not touch \"secret-three\" \u003c/pre\u003e\n */\n  @Test void testOne();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/secrets_with_labels/SecretsWithLabelsApp.java",
        "name": "SecretsWithLabelsApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({One.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.secrets_with_labels.SecretsWithLabelsApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({One.class}) class SecretsWithLabelsApp {\n  static void main(  String[] args){\n    SpringApplication.run(SecretsWithLabelsApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({One.class}) class SecretsWithLabelsApp {\n  static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8ConfigDataLocationResolverTests.java",
        "name": "Fabric8ConfigDataLocationResolverTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8ConfigDataLocationResolverTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass Fabric8ConfigDataLocationResolverTests {\n  private static final DeferredLogFactory FACTORY\u003dSupplier::get;\n  private static final ConfigDataLocationResolverContext RESOLVER_CONTEXT\u003dMockito.mock(ConfigDataLocationResolverContext.class);\n  private static final Fabric8ConfigDataLocationResolver RESOLVER\u003dnew Fabric8ConfigDataLocationResolver(FACTORY);\n  @Test void testBothMissing(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.config.enabled\",\"false\");\n    environment.setProperty(\"spring.cloud.kubernetes.secrets.enabled\",\"false\");\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    DefaultBootstrapContext context\u003dnew DefaultBootstrapContext();\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(context);\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertTrue(context.isRegistered(KubernetesClientProperties.class));\n    Assertions.assertTrue(context.isRegistered(Config.class));\n    Assertions.assertTrue(context.isRegistered(KubernetesClient.class));\n    Assertions.assertFalse(context.isRegistered(ConfigMapConfigProperties.class));\n    Assertions.assertFalse(context.isRegistered(SecretsConfigProperties.class));\n    Assertions.assertFalse(context.isRegistered(ConfigMapPropertySourceLocator.class));\n    Assertions.assertFalse(context.isRegistered(SecretsPropertySourceLocator.class));\n  }\n  @Test void testBothPresent(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    DefaultBootstrapContext context\u003dnew DefaultBootstrapContext();\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(context);\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertTrue(context.isRegistered(KubernetesClientProperties.class));\n    Assertions.assertTrue(context.isRegistered(Config.class));\n    Assertions.assertTrue(context.isRegistered(KubernetesClient.class));\n    Assertions.assertTrue(context.isRegistered(ConfigMapConfigProperties.class));\n    Assertions.assertTrue(context.isRegistered(SecretsConfigProperties.class));\n    Assertions.assertTrue(context.isRegistered(ConfigMapPropertySourceLocator.class));\n    Assertions.assertTrue(context.isRegistered(SecretsPropertySourceLocator.class));\n    ConfigMapPropertySourceLocator configMapPropertySourceLocator\u003dcontext.get(ConfigMapPropertySourceLocator.class);\n    Assertions.assertSame(Fabric8ConfigMapPropertySourceLocator.class,configMapPropertySourceLocator.getClass());\n    SecretsPropertySourceLocator secretsPropertySourceLocator\u003dcontext.get(SecretsPropertySourceLocator.class);\n    Assertions.assertSame(Fabric8SecretsPropertySourceLocator.class,secretsPropertySourceLocator.getClass());\n  }\n  /** \n * both ConfigMapConfigProperties and SecretsConfigProperties are enabled explicitly, as such they are both registered. It also means that ConfigMapPropertySourceLocator and SecretsPropertySourceLocator are registered too. Since retry is not enabled explicitly, we also assert the types to ensure that these are not retryable beans.\n */\n  @Test void testBothPresentExplicitly(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.config.enabled\",\"true\");\n    environment.setProperty(\"spring.cloud.kubernetes.secrets.enabled\",\"true\");\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    DefaultBootstrapContext context\u003dnew DefaultBootstrapContext();\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(context);\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertTrue(context.isRegistered(KubernetesClientProperties.class));\n    Assertions.assertTrue(context.isRegistered(Config.class));\n    Assertions.assertTrue(context.isRegistered(KubernetesClient.class));\n    Assertions.assertTrue(context.isRegistered(ConfigMapConfigProperties.class));\n    Assertions.assertTrue(context.isRegistered(SecretsConfigProperties.class));\n    ConfigMapPropertySourceLocator configMapPropertySourceLocator\u003dcontext.get(ConfigMapPropertySourceLocator.class);\n    Assertions.assertSame(Fabric8ConfigMapPropertySourceLocator.class,configMapPropertySourceLocator.getClass());\n    SecretsPropertySourceLocator secretsPropertySourceLocator\u003dcontext.get(SecretsPropertySourceLocator.class);\n    Assertions.assertSame(Fabric8SecretsPropertySourceLocator.class,secretsPropertySourceLocator.getClass());\n  }\n  @Test void testBothPresentAndRetryEnabled(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.config.retry.enabled\",\"true\");\n    environment.setProperty(\"spring.cloud.kubernetes.config.fail-fast\",\"true\");\n    environment.setProperty(\"spring.cloud.kubernetes.secrets.retry.enabled\",\"true\");\n    environment.setProperty(\"spring.cloud.kubernetes.secrets.fail-fast\",\"true\");\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    DefaultBootstrapContext context\u003dnew DefaultBootstrapContext();\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(context);\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertTrue(context.isRegistered(KubernetesClientProperties.class));\n    Assertions.assertTrue(context.isRegistered(Config.class));\n    Assertions.assertTrue(context.isRegistered(KubernetesClient.class));\n    Assertions.assertTrue(context.isRegistered(ConfigMapConfigProperties.class));\n    Assertions.assertTrue(context.isRegistered(SecretsConfigProperties.class));\n    Assertions.assertTrue(context.isRegistered(ConfigMapPropertySourceLocator.class));\n    Assertions.assertTrue(context.isRegistered(SecretsPropertySourceLocator.class));\n    ConfigMapPropertySourceLocator configMapPropertySourceLocator\u003dcontext.get(ConfigMapPropertySourceLocator.class);\n    Assertions.assertSame(ConfigDataRetryableConfigMapPropertySourceLocator.class,configMapPropertySourceLocator.getClass());\n    SecretsPropertySourceLocator secretsPropertySourceLocator\u003dcontext.get(SecretsPropertySourceLocator.class);\n    Assertions.assertSame(ConfigDataRetryableSecretsPropertySourceLocator.class,secretsPropertySourceLocator.getClass());\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass Fabric8ConfigDataLocationResolverTests {\n  private static final DeferredLogFactory FACTORY\u003dSupplier::get;\n  private static final ConfigDataLocationResolverContext RESOLVER_CONTEXT\u003dMockito.mock(ConfigDataLocationResolverContext.class);\n  private static final Fabric8ConfigDataLocationResolver RESOLVER\u003dnew Fabric8ConfigDataLocationResolver(FACTORY);\n  @Test void testBothMissing();\n  @Test void testBothPresent();\n  /** \n * both ConfigMapConfigProperties and SecretsConfigProperties are enabled explicitly, as such they are both registered. It also means that ConfigMapPropertySourceLocator and SecretsPropertySourceLocator are registered too. Since retry is not enabled explicitly, we also assert the types to ensure that these are not retryable beans.\n */\n  @Test void testBothPresentExplicitly();\n  @Test void testBothPresentAndRetryEnabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/BootstrapConfigMapsWithProfileExpressionTests.java",
        "name": "BootstrapConfigMapsWithProfileExpressionTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @ActiveProfiles({\"production\",\"us-east\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.BootstrapConfigMapsWithProfileExpressionTests",
        "extend": "ConfigMapsWithProfileExpressionTests",
        "implements": "",
        "raw": "/** \n * Tests reading property from YAML document specified by profile expression.\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @ActiveProfiles({\"production\",\"us-east\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class BootstrapConfigMapsWithProfileExpressionTests extends ConfigMapsWithProfileExpressionTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * Tests reading property from YAML document specified by profile expression.\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @ActiveProfiles({\"production\",\"us-east\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class BootstrapConfigMapsWithProfileExpressionTests extends ConfigMapsWithProfileExpressionTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/MissingActuatorTest.java",
        "name": "MissingActuatorTest",
        "modifiers": "@ExtendWith({SpringExtension.class,OutputCaptureExtension.class}) @ClassPathExclusions({\"spring-boot-actuator-autoconfigure-*.jar\",\"spring-boot-starter-actuator-*.jar\"}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.MissingActuatorTest",
        "extend": "",
        "implements": "",
        "raw": "@ExtendWith({SpringExtension.class,OutputCaptureExtension.class}) @ClassPathExclusions({\"spring-boot-actuator-autoconfigure-*.jar\",\"spring-boot-starter-actuator-*.jar\"}) public class MissingActuatorTest {\n  private static ConfigurableApplicationContext getApplicationContext(  String... properties){\n    return new SpringApplicationBuilder(Config.class).web(WebApplicationType.NONE).properties(properties).run();\n  }\n  @Test public void unknownClassProtected(  CapturedOutput capturedOutput){\n    try (ConfigurableApplicationContext context\u003dgetApplicationContext(\"debug\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\")){\n      String output\u003dcapturedOutput.toString();\n      assertThat(output).doesNotContain(\"Failed to introspect annotations on\" + \" [class org.springframework.cloud.autoconfigure.RefreshEndpointAutoConfiguration\").doesNotContain(\"TypeNotPresentExceptionProxy\");\n    }\n   }\n@Configuration(proxyBeanMethods\u003dfalse) @EnableAutoConfiguration static class Config {\n  }\n}\n",
        "abstract": "@ExtendWith({SpringExtension.class,OutputCaptureExtension.class}) @ClassPathExclusions({\"spring-boot-actuator-autoconfigure-*.jar\",\"spring-boot-starter-actuator-*.jar\"}) public class MissingActuatorTest {\n  private static ConfigurableApplicationContext getApplicationContext(  String... properties);\n  @Test public void unknownClassProtected(  CapturedOutput capturedOutput);\n@Configuration(proxyBeanMethods\u003dfalse) @EnableAutoConfiguration static class Config {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigDataMultipleSecretsTests.java",
        "name": "ConfigDataMultipleSecretsTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dMultiSecretsApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dmultiple-secrets\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./multiple-secrets.yml\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigDataMultipleSecretsTests",
        "extend": "MultipleSecretsTests",
        "implements": "",
        "raw": "/** \n * @author Haytham Mohamed\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dMultiSecretsApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dmultiple-secrets\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./multiple-secrets.yml\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataMultipleSecretsTests extends MultipleSecretsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author Haytham Mohamed\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dMultiSecretsApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dmultiple-secrets\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./multiple-secrets.yml\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataMultipleSecretsTests extends MultipleSecretsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/SecretsEnableRetryWithoutFailFastTest.java",
        "name": "SecretsEnableRetryWithoutFailFastTest",
        "modifiers": "@EnableKubernetesMockClient public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.SecretsEnableRetryWithoutFailFastTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@EnableKubernetesMockClient public class SecretsEnableRetryWithoutFailFastTest {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps/application\";\n  static KubernetesMockServer mockServer;\n  private ConfigurableApplicationContext context;\n  protected void setup(  String... env){\n    List\u003cString\u003e envList\u003d(env !\u003d null) ? new ArrayList\u003c\u003e(Arrays.asList(env)) : new ArrayList\u003c\u003e();\n    envList.add(\"spring.cloud.kubernetes.client.namespace\u003ddefault\");\n    String[] envArray\u003denvList.toArray(new String[0]);\n    context\u003dnew SpringApplicationBuilder(RetryConfiguration.class,PropertyPlaceholderAutoConfiguration.class,ConfigReloadAutoConfiguration.class,RefreshAutoConfiguration.class,EndpointAutoConfiguration.class,InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,ConfigurationPropertiesBindingPostProcessor.class,ConfigurationPropertiesRebinderAutoConfiguration.class,Fabric8BootstrapConfiguration.class,Fabric8RetryBootstrapConfiguration.class,KubernetesBootstrapConfiguration.class).web(org.springframework.boot.WebApplicationType.NONE).properties(envArray).run();\n  }\n  @AfterEach public void afterEach(){\n    if (this.context !\u003d null) {\n      this.context.close();\n      this.context\u003dnull;\n    }\n  }\n  @Test public void doesNotContainRetryableSecretsPropertySourceLocator() throws Exception {\n    mockServer.expect().withPath(API).andReturn(500,\"Internal Server Error\").once();\n    setup(\"debug\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.test.enable-retry\u003dtrue\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\");\n    assertThat(context.containsBean(\"retryableSecretsPropertySourceLocator\")).isFalse();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@EnableKubernetesMockClient public class SecretsEnableRetryWithoutFailFastTest {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps/application\";\n  static KubernetesMockServer mockServer;\n  private ConfigurableApplicationContext context;\n  protected void setup(  String... env);\n  @AfterEach public void afterEach();\n  @Test public void doesNotContainRetryableSecretsPropertySourceLocator() throws Exception;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/EventBasedConfigurationChangeDetectorTests.java",
        "name": "EventBasedConfigurationChangeDetectorTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.EventBasedConfigurationChangeDetectorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass EventBasedConfigurationChangeDetectorTests {\n  @SuppressWarnings({\"unchecked\",\"raw\"}) @Test void verifyConfigChangesAccountsForBootstrapPropertySources(){\n    MockEnvironment env\u003dnew MockEnvironment();\n    KubernetesClient k8sClient\u003dmock(KubernetesClient.class);\n    ConfigMap configMap\u003dnew ConfigMap();\n    configMap.setMetadata(new ObjectMetaBuilder().withName(\"myconfigmap\").build());\n    Map\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"foo\",\"bar\");\n    configMap.setData(data);\n    MixedOperation\u003cConfigMap,ConfigMapList,Resource\u003cConfigMap\u003e\u003e mixedOperation\u003dmock(MixedOperation.class);\n    when(k8sClient.configMaps()).thenReturn(mixedOperation);\n    NonNamespaceOperation nonNamespaceOperation\u003dmock(NonNamespaceOperation.class);\n    when(mixedOperation.inNamespace(\"default\")).thenReturn(nonNamespaceOperation);\n    when(nonNamespaceOperation.list()).thenReturn(new ConfigMapListBuilder().addToItems(configMap).build());\n    Resource\u003cConfigMap\u003e resource\u003dmock(Resource.class);\n    when(resource.get()).thenReturn(configMap);\n    when(k8sClient.getNamespace()).thenReturn(\"default\");\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(\"myconfigmap\",\"default\",true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(k8sClient,source,\"default\",env);\n    Fabric8ConfigMapPropertySource fabric8ConfigMapPropertySource\u003dnew Fabric8ConfigMapPropertySource(context);\n    env.getPropertySources().addFirst(new BootstrapPropertySource\u003c\u003e(fabric8ConfigMapPropertySource));\n    List\u003cFabric8ConfigMapPropertySource\u003e sources\u003dConfigReloadUtil.findPropertySources(Fabric8ConfigMapPropertySource.class,env);\n    assertThat(sources.size()).isEqualTo(1);\n    assertThat(sources.get(0).getProperty(\"foo\")).isEqualTo(\"bar\");\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass EventBasedConfigurationChangeDetectorTests {\n  @SuppressWarnings({\"unchecked\",\"raw\"}) @Test void verifyConfigChangesAccountsForBootstrapPropertySources();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/BootstrapCoreTestClientViaSystemProperties.java",
        "name": "BootstrapCoreTestClientViaSystemProperties",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(classes\u003dTestApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.application.name\u003dtestapp\",\"spring.cloud.kubernetes.client.namespace\u003dtestns\",\"spring.cloud.kubernetes.client.trustCerts\u003dtrue\",\"spring.cloud.kubernetes.config.namespace\u003dtestns\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.BootstrapCoreTestClientViaSystemProperties",
        "extend": "CoreTestClientViaSystemProperties",
        "implements": "",
        "raw": "@ExtendWith(SpringExtension.class) @SpringBootTest(classes\u003dTestApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.application.name\u003dtestapp\",\"spring.cloud.kubernetes.client.namespace\u003dtestns\",\"spring.cloud.kubernetes.client.trustCerts\u003dtrue\",\"spring.cloud.kubernetes.config.namespace\u003dtestns\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) public class BootstrapCoreTestClientViaSystemProperties extends CoreTestClientViaSystemProperties {\n}\n",
        "abstract": "@ExtendWith(SpringExtension.class) @SpringBootTest(classes\u003dTestApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.application.name\u003dtestapp\",\"spring.cloud.kubernetes.client.namespace\u003dtestns\",\"spring.cloud.kubernetes.client.trustCerts\u003dtrue\",\"spring.cloud.kubernetes.config.namespace\u003dtestns\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) public class BootstrapCoreTestClientViaSystemProperties extends CoreTestClientViaSystemProperties {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/example/GreetingController.java",
        "name": "GreetingController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.example.GreetingController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\n@RestController public class GreetingController {\n  private final GreetingProperties properties;\n  @Autowired public GreetingController(  GreetingProperties properties){\n    this.properties\u003dproperties;\n  }\n  @RequestMapping(\"/api/greeting\") public ResponseMessage greeting(  @RequestParam(value\u003d\"name\",defaultValue\u003d\"World\") String name){\n    return new ResponseMessage(String.format(this.properties.getGreeting(),name));\n  }\n  @RequestMapping(\"/api/farewell\") public ResponseMessage farewell(  @RequestParam(value\u003d\"name\",defaultValue\u003d\"World\") String name){\n    return new ResponseMessage(String.format(this.properties.getFarewell(),name));\n  }\n  @RequestMapping(\"/api/morning\") public ResponseMessage morning(  @RequestParam(value\u003d\"name\",defaultValue\u003d\"World\") String name){\n    return new ResponseMessage(String.format(this.properties.getMorning(),name));\n  }\n  @RequestMapping(\"/api/bonjour\") public ResponseMessage bonjour(  @RequestParam(value\u003d\"name\",defaultValue\u003d\"World\") String name){\n    return new ResponseMessage(String.format(this.properties.getBonjour(),name));\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\n@RestController public class GreetingController {\n  private final GreetingProperties properties;\n  @Autowired public GreetingController(  GreetingProperties properties);\n  @RequestMapping(\"/api/greeting\") public ResponseMessage greeting(  @RequestParam(value\u003d\"name\",defaultValue\u003d\"World\") String name);\n  @RequestMapping(\"/api/farewell\") public ResponseMessage farewell(  @RequestParam(value\u003d\"name\",defaultValue\u003d\"World\") String name);\n  @RequestMapping(\"/api/morning\") public ResponseMessage morning(  @RequestParam(value\u003d\"name\",defaultValue\u003d\"World\") String name);\n  @RequestMapping(\"/api/bonjour\") public ResponseMessage bonjour(  @RequestParam(value\u003d\"name\",defaultValue\u003d\"World\") String name);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/example/App.java",
        "name": "App",
        "modifiers": "@EnableConfigurationProperties(GreetingProperties.class) @SpringBootApplication public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.example.App",
        "extend": "",
        "implements": "",
        "raw": "/** \n */\n@EnableConfigurationProperties(GreetingProperties.class) @SpringBootApplication public class App {\n  public static void main(  String[] args){\n    SpringApplication.run(App.class,args);\n  }\n}\n",
        "abstract": "/** \n */\n@EnableConfigurationProperties(GreetingProperties.class) @SpringBootApplication public class App {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/example/GreetingProperties.java",
        "name": "GreetingProperties",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"bean\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.example.GreetingProperties",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"bean\") public class GreetingProperties {\n  private String greeting\u003d\"Hello, %s!\";\n  private String farewell\u003d\"Goodbye, %s!\";\n  private String morning\u003d\"Good morning, %s!\";\n  private String bonjour\u003d\"Bonjour, %s!\";\n  public String getGreeting(){\n    return this.greeting;\n  }\n  public void setGreeting(  String greeting){\n    this.greeting\u003dgreeting;\n  }\n  public String getFarewell(){\n    return this.farewell;\n  }\n  public void setFarewell(  String farewell){\n    this.farewell\u003dfarewell;\n  }\n  public String getMorning(){\n    return this.morning;\n  }\n  public void setMorning(  String morning){\n    this.morning\u003dmorning;\n  }\n  public String getBonjour(){\n    return this.bonjour;\n  }\n  public void setBonjour(  String bonjour){\n    this.bonjour\u003dbonjour;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"bean\") public class GreetingProperties {\n  private String greeting\u003d\"Hello, %s!\";\n  private String farewell\u003d\"Goodbye, %s!\";\n  private String morning\u003d\"Good morning, %s!\";\n  private String bonjour\u003d\"Bonjour, %s!\";\n  public String getGreeting();\n  public void setGreeting(  String greeting);\n  public String getFarewell();\n  public void setFarewell(  String farewell);\n  public String getMorning();\n  public void setMorning(  String morning);\n  public String getBonjour();\n  public void setBonjour(  String bonjour);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/example/ResponseMessage.java",
        "name": "ResponseMessage",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.example.ResponseMessage",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\npublic class ResponseMessage {\n  private final String content;\n  public ResponseMessage(){\n    this.content\u003dnull;\n  }\n  public ResponseMessage(  String content){\n    this.content\u003dcontent;\n  }\n  public String getContent(){\n    return this.content;\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\npublic class ResponseMessage {\n  private final String content;\n  public ResponseMessage();\n  public ResponseMessage(  String content);\n  public String getContent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_prefix/NamedConfigMapWithPrefixTests.java",
        "name": "NamedConfigMapWithPrefixTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_prefix.NamedConfigMapWithPrefixTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n * @author Ryan Baxter\n */\nabstract class NamedConfigMapWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    NamedConfigMapWithPrefixTests.mockClient\u003dmockClient;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e one\u003dnew HashMap\u003c\u003e();\n    one.put(\"one.property\",\"one\");\n    createConfigmap(\"config-map-one\",one);\n    Map\u003cString,String\u003e two\u003dnew HashMap\u003c\u003e();\n    two.put(\"property\",\"two\");\n    createConfigmap(\"config-map-two\",two);\n    Map\u003cString,String\u003e three\u003dnew HashMap\u003c\u003e();\n    three.put(\"property\",\"three\");\n    createConfigmap(\"config-map-three\",three);\n  }\n  static void createConfigmap(  String name,  Map\u003cString,String\u003e data){\n    mockClient.configMaps().inNamespace(\"spring-k8s\").resource(new ConfigMapBuilder().withNewMetadata().withName(name).endMetadata().addToData(data).build()).create();\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne(){\n    this.webClient.get().uri(\"/named-config-map/prefix/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo(){\n    this.webClient.get().uri(\"/named-config-map/prefix/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[2].name\u003dconfig-map-three\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"config-map-three\") \u003c/pre\u003e\n */\n  @Test void testThree(){\n    this.webClient.get().uri(\"/named-config-map/prefix/three\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"three\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n * @author Ryan Baxter\n */\nabstract class NamedConfigMapWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n  static void createConfigmap(  String name,  Map\u003cString,String\u003e data);\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[2].name\u003dconfig-map-three\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"config-map-three\") \u003c/pre\u003e\n */\n  @Test void testThree();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_prefix/properties/One.java",
        "name": "One",
        "modifiers": "@ConfigurationProperties(\"one\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_prefix.properties.One",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_prefix/properties/Two.java",
        "name": "Two",
        "modifiers": "@ConfigurationProperties(\"two\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_prefix.properties.Two",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_prefix/properties/Three.java",
        "name": "Three",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"config-map-three\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_prefix.properties.Three",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"config-map-three\") public class Three {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"config-map-three\") public class Three {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_prefix/NamedConfigMapWithPrefixConfigDataTests.java",
        "name": "NamedConfigMapWithPrefixConfigDataTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithPrefixApp.class,properties\u003d{\"spring.application.name\u003dconfig-map-name-as-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-config-map-with-prefix.yaml\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_prefix.NamedConfigMapWithPrefixConfigDataTests",
        "extend": "NamedConfigMapWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithPrefixApp.class,properties\u003d{\"spring.application.name\u003dconfig-map-name-as-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-config-map-with-prefix.yaml\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedConfigMapWithPrefixConfigDataTests extends NamedConfigMapWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithPrefixApp.class,properties\u003d{\"spring.application.name\u003dconfig-map-name-as-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-config-map-with-prefix.yaml\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedConfigMapWithPrefixConfigDataTests extends NamedConfigMapWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_prefix/NamedConfigMapWithPrefixApp.java",
        "name": "NamedConfigMapWithPrefixApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_prefix.NamedConfigMapWithPrefixApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedConfigMapWithPrefixApp {\n  public static void main(  String[] args){\n    SpringApplication.run(NamedConfigMapWithPrefixApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedConfigMapWithPrefixApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_prefix/controller/NamedConfigMapWithPrefixController.java",
        "name": "NamedConfigMapWithPrefixController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_prefix.controller.NamedConfigMapWithPrefixController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class NamedConfigMapWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedConfigMapWithPrefixController(  One one,  Two two,  Three three){\n    this.one\u003done;\n    this.two\u003dtwo;\n    this.three\u003dthree;\n  }\n  @GetMapping(\"/named-config-map/prefix/one\") public String one(){\n    return one.getProperty();\n  }\n  @GetMapping(\"/named-config-map/prefix/two\") public String two(){\n    return two.getProperty();\n  }\n  @GetMapping(\"/named-config-map/prefix/three\") public String three(){\n    return three.getProperty();\n  }\n}\n",
        "abstract": "@RestController public class NamedConfigMapWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedConfigMapWithPrefixController(  One one,  Two two,  Three three);\n  @GetMapping(\"/named-config-map/prefix/one\") public String one();\n  @GetMapping(\"/named-config-map/prefix/two\") public String two();\n  @GetMapping(\"/named-config-map/prefix/three\") public String three();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_config_map_with_prefix/NamedConfigMapWithPrefixBootstrapTests.java",
        "name": "NamedConfigMapWithPrefixBootstrapTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-config-map-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_config_map_with_prefix.NamedConfigMapWithPrefixBootstrapTests",
        "extend": "NamedConfigMapWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-config-map-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedConfigMapWithPrefixBootstrapTests extends NamedConfigMapWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-config-map-with-prefix\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedConfigMapWithPrefixBootstrapTests extends NamedConfigMapWithPrefixTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/LabeledConfigMapContextToSourceDataProviderTests.java",
        "name": "LabeledConfigMapContextToSourceDataProviderTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.LabeledConfigMapContextToSourceDataProviderTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class) class LabeledConfigMapContextToSourceDataProviderTests {\n  private static final String NAMESPACE\u003d\"default\";\n  private static final Map\u003cString,String\u003e LABELS\u003dnew LinkedHashMap\u003c\u003e();\n  private static final Map\u003cString,String\u003e RED_LABEL\u003dMap.of(\"color\",\"red\");\n  private static final Map\u003cString,String\u003e PINK_LABEL\u003dMap.of(\"color\",\"pink\");\n  private static final Map\u003cString,String\u003e BLUE_LABEL\u003dMap.of(\"color\",\"blue\");\n  private static KubernetesClient mockClient;\nstatic {\n    LABELS.put(\"label2\",\"value2\");\n    LABELS.put(\"label1\",\"value1\");\n  }\n  @BeforeAll static void beforeAll(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,NAMESPACE);\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterEach void afterEach(){\n    mockClient.configMaps().inNamespace(NAMESPACE).delete();\n    new Fabric8ConfigMapsCache().discardAll();\n  }\n  /** \n * we have a single config map deployed. it has two labels and these match against our queries.\n */\n  @Test void singleConfigMapMatchAgainstLabels(){\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"test-configmap\").withLabels(LABELS).endMetadata().addToData(\"name\",\"value\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(configMap).create();\n    NormalizedSource normalizedSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,LABELS,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(\"configmap.test-configmap.default\",sourceData.sourceName());\n    Assertions.assertEquals(Map.of(\"name\",\"value\"),sourceData.sourceData());\n  }\n  /** \n * we have three configmaps deployed. two of them have labels that match (color\u003dred), one does not (color\u003dblue).\n */\n  @Test void twoConfigMapsMatchAgainstLabels(){\n    ConfigMap redOne\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red-configmap\").withLabels(RED_LABEL).endMetadata().addToData(\"colorOne\",\"really-red\").build();\n    ConfigMap redTwo\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red-configmap-again\").withLabels(RED_LABEL).endMetadata().addToData(\"colorTwo\",\"really-red-again\").build();\n    ConfigMap blue\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"blue-configmap\").withLabels(BLUE_LABEL).endMetadata().addToData(\"color\",\"blue\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(redOne).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(redTwo).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(blue).create();\n    NormalizedSource normalizedSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,RED_LABEL,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red-configmap.red-configmap-again.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"colorOne\"),\"really-red\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"colorTwo\"),\"really-red-again\");\n  }\n  /** \n * one configmap deployed (pink), does not match our query (blue).\n */\n  @Test void configMapNoMatch(){\n    ConfigMap pink\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"pink-configmap\").withLabels(PINK_LABEL).endMetadata().addToData(\"color\",\"pink\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(pink).create();\n    NormalizedSource normalizedSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,BLUE_LABEL,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.color.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Collections.emptyMap());\n  }\n  /** \n * LabeledConfigMapContextToSourceDataProvider gets as input a Fabric8ConfigContext. This context has a namespace as well as a NormalizedSource, that has a namespace too. It is easy to get confused in code on which namespace to use. This test makes sure that we use the proper one.\n */\n  @Test void namespaceMatch(){\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"test-configmap\").withLabels(LABELS).endMetadata().addToData(\"name\",\"value\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(configMap).create();\n    NormalizedSource normalizedSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE + \"nope\",LABELS,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(\"configmap.test-configmap.default\",sourceData.sourceName());\n    Assertions.assertEquals(Map.of(\"name\",\"value\"),sourceData.sourceData());\n  }\n  /** \n * one configmap with name : \"blue-configmap\" and labels \"color\u003dblue\" is deployed. we search it with the same labels, find it, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided an explicit prefix).\n */\n  @Test void testWithPrefix(){\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"blue-configmap\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"what-color\",\"blue-color\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(configMap).create();\n    ConfigUtils.Prefix mePrefix\u003dConfigUtils.findPrefix(\"me\",false,false,\"irrelevant\");\n    NormalizedSource normalizedSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"blue\"),true,mePrefix,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(\"configmap.blue-configmap.default\",sourceData.sourceName());\n    Assertions.assertEquals(Map.of(\"me.what-color\",\"blue-color\"),sourceData.sourceData());\n  }\n  /** \n * two configmaps are deployed (name:blue-configmap, name:another-blue-configmap) and labels \"color\u003dblue\" (on both). we search with the same labels, find them, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided a delayed prefix). Also notice that the prefix is made up from both configmap names.\n */\n  @Test void testTwoConfigmapsWithPrefix(){\n    ConfigMap blueConfigMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"blue-configmap\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"first\",\"blue\").build();\n    ConfigMap anotherBlue\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"another-blue-configmap\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"second\",\"blue\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(blueConfigMap).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(anotherBlue).create();\n    NormalizedSource normalizedSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"blue\"),true,ConfigUtils.Prefix.DELAYED,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.another-blue-configmap.blue-configmap.default\");\n    Map\u003cString,Object\u003e properties\u003dsourceData.sourceData();\n    Assertions.assertEquals(2,properties.size());\n    Iterator\u003cString\u003e keys\u003dproperties.keySet().iterator();\n    String firstKey\u003dkeys.next();\n    String secondKey\u003dkeys.next();\n    if (firstKey.contains(\"first\")) {\n      Assertions.assertEquals(firstKey,\"another-blue-configmap.blue-configmap.first\");\n    }\n    Assertions.assertEquals(secondKey,\"another-blue-configmap.blue-configmap.second\");\n    Assertions.assertEquals(properties.get(firstKey),\"blue\");\n    Assertions.assertEquals(properties.get(secondKey),\"blue\");\n  }\n  /** \n * two configmaps are deployed: \"color-configmap\" with label: \"{color:blue}\" and \"color-configmap-k8s\" with no labels. We search by \"{color:red}\", do not find anything and thus have an empty SourceData. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsNoConfigmapsFound(){\n    ConfigMap colorConfigmap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"color-configmap\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"one\",\"1\").build();\n    ConfigMap colorConfigmapK8s\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"color-configmap-k8s\").endMetadata().addToData(\"two\",\"2\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(colorConfigmap).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(colorConfigmapK8s).create();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource normalizedSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"red\"),true,ConfigUtils.Prefix.DEFAULT,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,environment);\n    Fabric8ContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertTrue(sourceData.sourceData().isEmpty());\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.color.default\");\n  }\n  /** \n * two configmaps are deployed: \"color-configmap\" with label: \"{color:blue}\" and \"shape-configmap\" with label: \"{shape:round}\". We search by \"{color:blue}\" and find one configmap. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsOneConfigMapFound(){\n    ConfigMap colorConfigmap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"color-configmap\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"one\",\"1\").build();\n    ConfigMap shapeConfigmap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"shape-configmap\").endMetadata().addToData(\"two\",\"2\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(colorConfigmap).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(shapeConfigmap).create();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource normalizedSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"blue\"),true,ConfigUtils.Prefix.DEFAULT,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,environment);\n    Fabric8ContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),1);\n    Assertions.assertEquals(sourceData.sourceData().get(\"one\"),\"1\");\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.color-configmap.default\");\n  }\n  /** \n * two configmaps are deployed: \"color-configmap\" with label: \"{color:blue}\" and \"color-configmap-k8s\" with label: \"{color:red}\". We search by \"{color:blue}\" and find one configmap. Since profiles are enabled, we will also be reading \"color-configmap-k8s\", even if its labels do not match provided ones.\n */\n  @Test void searchWithLabelsOneConfigMapFoundAndOneFromProfileFound(){\n    ConfigMap colorConfigmap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"color-configmap\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"one\",\"1\").build();\n    ConfigMap colorConfigmapK8s\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"color-configmap-k8s\").withLabels(Collections.singletonMap(\"color\",\"red\")).endMetadata().addToData(\"two\",\"2\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(colorConfigmap).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(colorConfigmapK8s).create();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource normalizedSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"blue\"),true,ConfigUtils.Prefix.DELAYED,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,environment);\n    Fabric8ContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-configmap.color-configmap-k8s.one\"),\"1\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-configmap.color-configmap-k8s.two\"),\"2\");\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.color-configmap.color-configmap-k8s.default\");\n  }\n  /** \n * \u003cpre\u003e - configmap \"color-configmap\" with label \"{color:blue}\" - configmap \"shape-configmap\" with labels \"{color:blue, shape:round}\" - configmap \"no-fit\" with labels \"{tag:no-fit}\" - configmap \"color-configmap-k8s\" with label \"{color:red}\" - configmap \"shape-configmap-k8s\" with label \"{shape:triangle}\" \u003c/pre\u003e\n */\n  @Test void searchWithLabelsTwoConfigMapsFoundAndOneFromProfileFound(){\n    ConfigMap colorConfigMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"color-configmap\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"one\",\"1\").build();\n    ConfigMap shapeConfigmap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"shape-configmap\").withLabels(Map.of(\"color\",\"blue\",\"shape\",\"round\")).endMetadata().addToData(\"two\",\"2\").build();\n    ConfigMap noFit\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"no-fit\").withLabels(Map.of(\"tag\",\"no-fit\")).endMetadata().addToData(\"three\",\"3\").build();\n    ConfigMap colorConfigmapK8s\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"color-configmap-k8s\").withLabels(Map.of(\"color\",\"red\")).endMetadata().addToData(\"four\",\"4\").build();\n    ConfigMap shapeConfigmapK8s\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"shape-configmap-k8s\").withLabels(Map.of(\"shape\",\"triangle\")).endMetadata().addToData(\"five\",\"5\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(colorConfigMap).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(shapeConfigmap).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(noFit).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(colorConfigmapK8s).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(shapeConfigmapK8s).create();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource normalizedSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"blue\"),true,ConfigUtils.Prefix.DELAYED,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,environment);\n    Fabric8ContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),4);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-configmap.color-configmap-k8s.shape-configmap.shape-configmap-k8s.one\"),\"1\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-configmap.color-configmap-k8s.shape-configmap.shape-configmap-k8s.two\"),\"2\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-configmap.color-configmap-k8s.shape-configmap.shape-configmap-k8s.four\"),\"4\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-configmap.color-configmap-k8s.shape-configmap.shape-configmap-k8s.five\"),\"5\");\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.color-configmap.color-configmap-k8s.shape-configmap.shape-configmap-k8s.default\");\n  }\n  /** \n * \u003cpre\u003e - configmap \"red-configmap\" with label \"{color:red}\" - configmap \"green-configmap\" with labels \"{color:green}\" - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output){\n    ConfigMap redConfigMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"red-configmap\").withLabels(Collections.singletonMap(\"color\",\"red\")).endMetadata().addToData(\"one\",\"1\").build();\n    ConfigMap greenConfigmap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"green-configmap\").withLabels(Map.of(\"color\",\"green\")).endMetadata().addToData(\"two\",\"2\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(redConfigMap).create();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(greenConfigmap).create();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    NormalizedSource redNormalizedSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"red\"),true,ConfigUtils.Prefix.DELAYED,true);\n    Fabric8ConfigContext redContext\u003dnew Fabric8ConfigContext(mockClient,redNormalizedSource,NAMESPACE,environment);\n    Fabric8ContextToSourceData redData\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData redSourceData\u003dredData.apply(redContext);\n    Assertions.assertEquals(redSourceData.sourceData().size(),1);\n    Assertions.assertEquals(redSourceData.sourceData().get(\"red-configmap.one\"),\"1\");\n    Assertions.assertTrue(output.getAll().contains(\"Loaded all config maps in namespace \u0027\" + NAMESPACE + \"\u0027\"));\n    NormalizedSource greenNormalizedSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"green\"),true,ConfigUtils.Prefix.DELAYED,true);\n    Fabric8ConfigContext greenContext\u003dnew Fabric8ConfigContext(mockClient,greenNormalizedSource,NAMESPACE,environment);\n    Fabric8ContextToSourceData greenData\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData greenSourceData\u003dgreenData.apply(greenContext);\n    Assertions.assertEquals(greenSourceData.sourceData().size(),1);\n    Assertions.assertEquals(greenSourceData.sourceData().get(\"green-configmap.two\"),\"2\");\n    String[] out\u003doutput.getAll().split(\"Loaded all config maps in namespace\");\n    Assertions.assertEquals(out.length,2);\n    out\u003doutput.getAll().split(\"Loaded \\\\(from cache\\\\) all config maps in namespace\");\n    Assertions.assertEquals(out.length,2);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class) class LabeledConfigMapContextToSourceDataProviderTests {\n  private static final String NAMESPACE\u003d\"default\";\n  private static final Map\u003cString,String\u003e LABELS\u003dnew LinkedHashMap\u003c\u003e();\n  private static final Map\u003cString,String\u003e RED_LABEL\u003dMap.of(\"color\",\"red\");\n  private static final Map\u003cString,String\u003e PINK_LABEL\u003dMap.of(\"color\",\"pink\");\n  private static final Map\u003cString,String\u003e BLUE_LABEL\u003dMap.of(\"color\",\"blue\");\n  private static KubernetesClient mockClient;\nstatic {\n    LABELS.put(\"label2\",\"value2\");\n    LABELS.put(\"label1\",\"value1\");\n  }\n  @BeforeAll static void beforeAll();\n  @AfterEach void afterEach();\n  /** \n * we have a single config map deployed. it has two labels and these match against our queries.\n */\n  @Test void singleConfigMapMatchAgainstLabels();\n  /** \n * we have three configmaps deployed. two of them have labels that match (color\u003dred), one does not (color\u003dblue).\n */\n  @Test void twoConfigMapsMatchAgainstLabels();\n  /** \n * one configmap deployed (pink), does not match our query (blue).\n */\n  @Test void configMapNoMatch();\n  /** \n * LabeledConfigMapContextToSourceDataProvider gets as input a Fabric8ConfigContext. This context has a namespace as well as a NormalizedSource, that has a namespace too. It is easy to get confused in code on which namespace to use. This test makes sure that we use the proper one.\n */\n  @Test void namespaceMatch();\n  /** \n * one configmap with name : \"blue-configmap\" and labels \"color\u003dblue\" is deployed. we search it with the same labels, find it, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided an explicit prefix).\n */\n  @Test void testWithPrefix();\n  /** \n * two configmaps are deployed (name:blue-configmap, name:another-blue-configmap) and labels \"color\u003dblue\" (on both). we search with the same labels, find them, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided a delayed prefix). Also notice that the prefix is made up from both configmap names.\n */\n  @Test void testTwoConfigmapsWithPrefix();\n  /** \n * two configmaps are deployed: \"color-configmap\" with label: \"{color:blue}\" and \"color-configmap-k8s\" with no labels. We search by \"{color:red}\", do not find anything and thus have an empty SourceData. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsNoConfigmapsFound();\n  /** \n * two configmaps are deployed: \"color-configmap\" with label: \"{color:blue}\" and \"shape-configmap\" with label: \"{shape:round}\". We search by \"{color:blue}\" and find one configmap. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsOneConfigMapFound();\n  /** \n * two configmaps are deployed: \"color-configmap\" with label: \"{color:blue}\" and \"color-configmap-k8s\" with label: \"{color:red}\". We search by \"{color:blue}\" and find one configmap. Since profiles are enabled, we will also be reading \"color-configmap-k8s\", even if its labels do not match provided ones.\n */\n  @Test void searchWithLabelsOneConfigMapFoundAndOneFromProfileFound();\n  /** \n * \u003cpre\u003e - configmap \"color-configmap\" with label \"{color:blue}\" - configmap \"shape-configmap\" with labels \"{color:blue, shape:round}\" - configmap \"no-fit\" with labels \"{tag:no-fit}\" - configmap \"color-configmap-k8s\" with label \"{color:red}\" - configmap \"shape-configmap-k8s\" with label \"{shape:triangle}\" \u003c/pre\u003e\n */\n  @Test void searchWithLabelsTwoConfigMapsFoundAndOneFromProfileFound();\n  /** \n * \u003cpre\u003e - configmap \"red-configmap\" with label \"{color:red}\" - configmap \"green-configmap\" with labels \"{color:green}\" - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8SecretsPropertySourceMockTests.java",
        "name": "Fabric8SecretsPropertySourceMockTests",
        "modifiers": "@EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8SecretsPropertySourceMockTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * tests that are supposed to use EnableKubernetesMockClient only\n * @author wind57\n */\n@EnableKubernetesMockClient class Fabric8SecretsPropertySourceMockTests {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient client;\n  @Test void namedStrategyShouldThrowExceptionOnFailureWhenFailFastIsEnabled(){\n    final String name\u003d\"my-secret\";\n    final String namespace\u003d\"default\";\n    final String path\u003dString.format(\"/api/v1/namespaces/%s/secrets\",namespace);\n    NamedSecretNormalizedSource named\u003dnew NamedSecretNormalizedSource(name,namespace,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(client,named,namespace,new MockEnvironment());\n    mockServer.expect().withPath(path).andReturn(500,\"Internal Server Error\").always();\n    assertThatThrownBy(() -\u003e new Fabric8SecretsPropertySource(context)).isInstanceOf(IllegalStateException.class).hasMessageContaining(\"Failure executing: GET at: https://localhost:\").hasMessageContaining(\"api/v1/namespaces/default/secrets. Message: Internal Server Error.\");\n  }\n  @Test void labeledStrategyShouldThrowExceptionOnFailureWhenFailFastIsEnabled(){\n    final String namespace\u003d\"default\";\n    final Map\u003cString,String\u003e labels\u003dCollections.singletonMap(\"a\",\"b\");\n    final String path\u003dString.format(\"/api/v1/namespaces/%s/secrets\",namespace);\n    LabeledSecretNormalizedSource labeled\u003dnew LabeledSecretNormalizedSource(namespace,labels,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(client,labeled,\"default\",new MockEnvironment());\n    mockServer.expect().withPath(path).andReturn(500,\"Internal Server Error\").always();\n    assertThatThrownBy(() -\u003e new Fabric8SecretsPropertySource(context)).isInstanceOf(IllegalStateException.class).hasMessageContaining(\"api/v1/namespaces/default/secrets. Message: Internal Server Error.\");\n  }\n  @Test void namedStrategyShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled(){\n    final String name\u003d\"my-secret\";\n    final String namespace\u003d\"default\";\n    final String path\u003dString.format(\"/api/v1/namespaces/%s/secrets\",namespace);\n    NamedSecretNormalizedSource named\u003dnew NamedSecretNormalizedSource(name,namespace,false,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(client,named,\"default\",new MockEnvironment());\n    mockServer.expect().withPath(path).andReturn(500,\"Internal Server Error\").always();\n    assertThatNoException().isThrownBy(() -\u003e new Fabric8SecretsPropertySource(context));\n  }\n  @Test void labeledStrategyShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled(){\n    final String namespace\u003d\"default\";\n    final Map\u003cString,String\u003e labels\u003dCollections.singletonMap(\"a\",\"b\");\n    final String path\u003dString.format(\"/api/v1/namespaces/%s/secrets\",namespace);\n    LabeledSecretNormalizedSource labeled\u003dnew LabeledSecretNormalizedSource(namespace,labels,false,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(client,labeled,\"default\",new MockEnvironment());\n    mockServer.expect().withPath(path).andReturn(500,\"Internal Server Error\").always();\n    assertThatNoException().isThrownBy(() -\u003e new Fabric8SecretsPropertySource(context));\n  }\n}\n",
        "abstract": "/** \n * tests that are supposed to use EnableKubernetesMockClient only\n * @author wind57\n */\n@EnableKubernetesMockClient class Fabric8SecretsPropertySourceMockTests {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient client;\n  @Test void namedStrategyShouldThrowExceptionOnFailureWhenFailFastIsEnabled();\n  @Test void labeledStrategyShouldThrowExceptionOnFailureWhenFailFastIsEnabled();\n  @Test void namedStrategyShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled();\n  @Test void labeledStrategyShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retry/secrets_enabled/ConfigDataSecretsRetryEnabled.java",
        "name": "ConfigDataSecretsRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.max-attempts\u003d5\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retry.secrets_enabled.ConfigDataSecretsRetryEnabled",
        "extend": "SecretsRetryEnabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.max-attempts\u003d5\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataSecretsRetryEnabled extends SecretsRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @Autowired private ConfigDataRetryableSecretsPropertySourceLocator configDataRetryableSecretsPropertySourceLocator;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n  @BeforeEach public void beforeEach(){\n    psl\u003dconfigDataRetryableSecretsPropertySourceLocator;\n    verifiablePsl\u003dspy(configDataRetryableSecretsPropertySourceLocator.getSecretsPropertySourceLocator());\n    configDataRetryableSecretsPropertySourceLocator.setSecretsPropertySourceLocator(verifiablePsl);\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.max-attempts\u003d5\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataSecretsRetryEnabled extends SecretsRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @Autowired private ConfigDataRetryableSecretsPropertySourceLocator configDataRetryableSecretsPropertySourceLocator;\n  @BeforeAll static void setup();\n  @BeforeEach public void beforeEach();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retry/secrets_enabled/SecretsRetryEnabled.java",
        "name": "SecretsRetryEnabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retry.secrets_enabled.SecretsRetryEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\nabstract class SecretsRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final String LIST_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static KubernetesMockServer mockServer;\n  protected SecretsPropertySourceLocator psl;\n  protected SecretsPropertySourceLocator verifiablePsl;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer){\n    SecretsRetryEnabled.mockServer\u003dmockServer;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    mockServer.expect().withPath(LIST_API).andReturn(200,new SecretListBuilder().build()).once();\n  }\n  @Test void locateShouldNotRetryWhenThereIsNoFailure(){\n    Map\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"some.sensitive.prop\",Base64.getEncoder().encodeToString(\"theSensitiveValue\".getBytes()));\n    data.put(\"some.sensitive.number\",Base64.getEncoder().encodeToString(\"1\".getBytes()));\n    mockServer.expect().withPath(API).andReturn(200,new SecretListBuilder().withItems(new SecretBuilder().withNewMetadata().withName(\"my-secret\").endMetadata().addToData(data).build()).build()).once();\n    PropertySource\u003c?\u003e propertySource\u003dAssertions.assertDoesNotThrow(() -\u003e psl.locate(new MockEnvironment()));\n    verify(verifiablePsl,times(1)).locate(any());\n    assertThat(propertySource.getProperty(\"some.sensitive.prop\")).isEqualTo(\"theSensitiveValue\");\n    assertThat(propertySource.getProperty(\"some.sensitive.number\")).isEqualTo(\"1\");\n  }\n  @Test void locateShouldRetryAndRecover(){\n    Map\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"some.sensitive.prop\",Base64.getEncoder().encodeToString(\"theSensitiveValue\".getBytes()));\n    data.put(\"some.sensitive.number\",Base64.getEncoder().encodeToString(\"1\".getBytes()));\n    mockServer.expect().withPath(API).andReturn(500,\"Internal Server Error\").times(3);\n    mockServer.expect().withPath(API).andReturn(200,new SecretListBuilder().withItems(new SecretBuilder().withNewMetadata().withName(\"my-secret\").endMetadata().addToData(data).build()).build()).once();\n    PropertySource\u003c?\u003e propertySource\u003dAssertions.assertDoesNotThrow(() -\u003e psl.locate(new MockEnvironment()));\n    verify(verifiablePsl,times(4)).locate(any());\n    assertThat(propertySource.getProperty(\"some.sensitive.prop\")).isEqualTo(\"theSensitiveValue\");\n    assertThat(propertySource.getProperty(\"some.sensitive.number\")).isEqualTo(\"1\");\n  }\n  @Test void locateShouldRetryAndFail(){\n    mockServer.expect().withPath(API).andReturn(500,\"Internal Server Error\").times(5);\n    assertThatThrownBy(() -\u003e psl.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessageContaining(\"api/v1/namespaces/default/secrets. Message: Internal Server Error.\");\n    verify(verifiablePsl,times(5)).locate(any());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\nabstract class SecretsRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final String LIST_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static KubernetesMockServer mockServer;\n  protected SecretsPropertySourceLocator psl;\n  protected SecretsPropertySourceLocator verifiablePsl;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer);\n  @Test void locateShouldNotRetryWhenThereIsNoFailure();\n  @Test void locateShouldRetryAndRecover();\n  @Test void locateShouldRetryAndFail();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retry/secrets_enabled/BootstrapSecretsRetryEnabled.java",
        "name": "BootstrapSecretsRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.max-attempts\u003d5\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retry.secrets_enabled.BootstrapSecretsRetryEnabled",
        "extend": "SecretsRetryEnabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.max-attempts\u003d5\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BootstrapSecretsRetryEnabled extends SecretsRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n  @SpyBean private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @BeforeEach public void beforeEach(){\n    psl\u003dpropertySourceLocator;\n    verifiablePsl\u003dpropertySourceLocator;\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.max-attempts\u003d5\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BootstrapSecretsRetryEnabled extends SecretsRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup();\n  @SpyBean private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @BeforeEach public void beforeEach();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retry/BootstrapSecretsRetryDisabledButConfigRetryEnabled.java",
        "name": "BootstrapSecretsRetryDisabledButConfigRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retry.BootstrapSecretsRetryDisabledButConfigRetryEnabled",
        "extend": "SecretsRetryDisabledButConfigRetryEnabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BootstrapSecretsRetryDisabledButConfigRetryEnabled extends SecretsRetryDisabledButConfigRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n  @SpyBean private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @BeforeEach void beforeEach(){\n    psl\u003dpropertySourceLocator;\n    verifiablePsl\u003dpropertySourceLocator;\n  }\n  @Override protected void assertRetryBean(  ApplicationContext context){\n    assertThat(context.containsBean(\"kubernetesSecretsRetryInterceptor\")).isTrue();\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BootstrapSecretsRetryDisabledButConfigRetryEnabled extends SecretsRetryDisabledButConfigRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup();\n  @SpyBean private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @BeforeEach void beforeEach();\n  @Override protected void assertRetryBean(  ApplicationContext context);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retry/SecretsFailFastEnabledButRetryDisabled.java",
        "name": "SecretsFailFastEnabledButRetryDisabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retry.SecretsFailFastEnabledButRetryDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\nabstract class SecretsFailFastEnabledButRetryDisabled {\n  private static final String LIST_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  protected SecretsPropertySourceLocator psl;\n  protected SecretsPropertySourceLocator verifiablePsl;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer){\n    SecretsFailFastEnabledButRetryDisabled.mockClient\u003dmockClient;\n    SecretsFailFastEnabledButRetryDisabled.mockServer\u003dmockServer;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    mockServer.expect().withPath(LIST_API).andReturn(200,new SecretListBuilder().build()).always();\n  }\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying(){\n    mockServer.clearExpectations();\n    mockServer.expect().withPath(LIST_API).andReturn(500,\"Internal Server Error\").once();\n    assertThat(context.containsBean(\"kubernetesSecretsRetryInterceptor\")).isFalse();\n    assertThatThrownBy(() -\u003e psl.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessageContaining(\"api/v1/namespaces/default/secrets. Message: Internal Server Error\");\n    verify(verifiablePsl,times(1)).locate(any());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\nabstract class SecretsFailFastEnabledButRetryDisabled {\n  private static final String LIST_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  protected SecretsPropertySourceLocator psl;\n  protected SecretsPropertySourceLocator verifiablePsl;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer);\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retry/ConfigDataSecretsRetryDisabledButConfigRetryEnabled.java",
        "name": "ConfigDataSecretsRetryDisabledButConfigRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retry.ConfigDataSecretsRetryDisabledButConfigRetryEnabled",
        "extend": "SecretsRetryDisabledButConfigRetryEnabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataSecretsRetryDisabledButConfigRetryEnabled extends SecretsRetryDisabledButConfigRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @Autowired private Fabric8SecretsPropertySourceLocator secretsPropertySourceLocator;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n  @BeforeEach public void beforeEach(){\n    psl\u003dspy(secretsPropertySourceLocator);\n    verifiablePsl\u003dpsl;\n  }\n  @Override protected void assertRetryBean(  ApplicationContext context){\n    assertThat(context.containsBean(\"configDataSecretsPropertySourceLocator\")).isTrue();\n    assertThat(context.getBean(\"configDataSecretsPropertySourceLocator\")).isInstanceOf(Fabric8SecretsPropertySourceLocator.class);\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataSecretsRetryDisabledButConfigRetryEnabled extends SecretsRetryDisabledButConfigRetryEnabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @Autowired private Fabric8SecretsPropertySourceLocator secretsPropertySourceLocator;\n  @BeforeAll static void setup();\n  @BeforeEach public void beforeEach();\n  @Override protected void assertRetryBean(  ApplicationContext context);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retry/SecretsFailFastDisabled.java",
        "name": "SecretsFailFastDisabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retry.SecretsFailFastDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\nabstract class SecretsFailFastDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets/my-secret\";\n  private static final String LIST_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  protected SecretsPropertySourceLocator psl;\n  protected SecretsPropertySourceLocator verifiablePsl;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer){\n    SecretsFailFastDisabled.mockClient\u003dmockClient;\n    SecretsFailFastDisabled.mockServer\u003dmockServer;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    mockServer.expect().withPath(LIST_API).andReturn(200,new SecretListBuilder().build()).always();\n  }\n  @Test void locateShouldNotRetry(){\n    mockServer.expect().withPath(API).andReturn(500,\"Internal Server Error\").once();\n    Assertions.assertDoesNotThrow(() -\u003e psl.locate(new MockEnvironment()));\n    verify(verifiablePsl,times(1)).locate(any());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\nabstract class SecretsFailFastDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets/my-secret\";\n  private static final String LIST_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  protected SecretsPropertySourceLocator psl;\n  protected SecretsPropertySourceLocator verifiablePsl;\n  static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer);\n  @Test void locateShouldNotRetry();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retry/ConfigDataSecretsFailFastDisabled.java",
        "name": "ConfigDataSecretsFailFastDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retry.ConfigDataSecretsFailFastDisabled",
        "extend": "SecretsFailFastDisabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataSecretsFailFastDisabled extends SecretsFailFastDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n  @Autowired private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @BeforeEach public void beforeEach(){\n    psl\u003dspy(propertySourceLocator);\n    verifiablePsl\u003dpsl;\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataSecretsFailFastDisabled extends SecretsFailFastDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup();\n  @Autowired private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @BeforeEach public void beforeEach();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retry/SecretsRetryDisabledButConfigRetryEnabled.java",
        "name": "SecretsRetryDisabledButConfigRetryEnabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retry.SecretsRetryDisabledButConfigRetryEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\nabstract class SecretsRetryDisabledButConfigRetryEnabled {\n  private static final String SECRET_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final String CONFIG_MAP_API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  protected SecretsPropertySourceLocator psl;\n  protected SecretsPropertySourceLocator verifiablePsl;\n  protected static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer){\n    SecretsRetryDisabledButConfigRetryEnabled.mockClient\u003dmockClient;\n    SecretsRetryDisabledButConfigRetryEnabled.mockServer\u003dmockServer;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    mockServer.expect().withPath(SECRET_API).andReturn(200,new SecretListBuilder().build()).always();\n    mockServer.expect().withPath(CONFIG_MAP_API).andReturn(200,new ConfigMapListBuilder().build()).always();\n  }\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying(){\n    mockServer.clearExpectations();\n    mockServer.expect().withPath(SECRET_API).andReturn(500,\"Internal Server Error\").once();\n    assertRetryBean(context);\n    assertThatThrownBy(() -\u003e psl.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessageContaining(\"v1/namespaces/default/secrets. Message: Internal Server Error\");\n    verify(verifiablePsl,times(1)).locate(any());\n  }\n  protected abstract void assertRetryBean(  ApplicationContext context);\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\nabstract class SecretsRetryDisabledButConfigRetryEnabled {\n  private static final String SECRET_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final String CONFIG_MAP_API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  protected SecretsPropertySourceLocator psl;\n  protected SecretsPropertySourceLocator verifiablePsl;\n  protected static void setup(  KubernetesClient mockClient,  KubernetesMockServer mockServer);\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying();\n  protected abstract void assertRetryBean(  ApplicationContext context);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retry/BootstrapSecretsFailFastEnabledButRetryDisabled.java",
        "name": "BootstrapSecretsFailFastEnabledButRetryDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retry.BootstrapSecretsFailFastEnabledButRetryDisabled",
        "extend": "SecretsFailFastEnabledButRetryDisabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BootstrapSecretsFailFastEnabledButRetryDisabled extends SecretsFailFastEnabledButRetryDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n  @SpyBean private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @BeforeEach void beforeEach(){\n    psl\u003dpropertySourceLocator;\n    verifiablePsl\u003dpropertySourceLocator;\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BootstrapSecretsFailFastEnabledButRetryDisabled extends SecretsFailFastEnabledButRetryDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup();\n  @SpyBean private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @BeforeEach void beforeEach();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retry/BootstrapSecretsFailFastDisabled.java",
        "name": "BootstrapSecretsFailFastDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retry.BootstrapSecretsFailFastDisabled",
        "extend": "SecretsFailFastDisabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BootstrapSecretsFailFastDisabled extends SecretsFailFastDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n  @SpyBean private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @BeforeEach public void beforeEach(){\n    psl\u003dpropertySourceLocator;\n    verifiablePsl\u003dpropertySourceLocator;\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApplication.class) @EnableKubernetesMockClient class BootstrapSecretsFailFastDisabled extends SecretsFailFastDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup();\n  @SpyBean private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @BeforeEach public void beforeEach();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/retry/ConfigDataSecretsFailFastEnabledButRetryDisabled.java",
        "name": "ConfigDataSecretsFailFastEnabledButRetryDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"},classes\u003dApplication.class) @EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.retry.ConfigDataSecretsFailFastEnabledButRetryDisabled",
        "extend": "SecretsFailFastEnabledButRetryDisabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataSecretsFailFastEnabledButRetryDisabled extends SecretsFailFastEnabledButRetryDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup(){\n    setup(mockClient,mockServer);\n  }\n  @Autowired private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @BeforeEach void beforeEach(){\n    psl\u003dspy(propertySourceLocator);\n    verifiablePsl\u003dpsl;\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"},classes\u003dApplication.class) @EnableKubernetesMockClient class ConfigDataSecretsFailFastEnabledButRetryDisabled extends SecretsFailFastEnabledButRetryDisabled {\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setup();\n  @Autowired private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @BeforeEach void beforeEach();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8ConfigMapPropertySourceMockTests.java",
        "name": "Fabric8ConfigMapPropertySourceMockTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8ConfigMapPropertySourceMockTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass Fabric8ConfigMapPropertySourceMockTests {\n  private final KubernetesClient client\u003dMockito.mock(KubernetesClient.class);\n  @Test void constructorWithClientNamespaceMustNotFail(){\n    Mockito.when(client.getNamespace()).thenReturn(\"namespace\");\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(\"configmap\",null,false,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(client,source,\"\",new MockEnvironment());\n    assertThat(new Fabric8ConfigMapPropertySource(context)).isNotNull();\n  }\n  @Test void constructorWithNamespaceMustNotFail(){\n    Mockito.when(client.getNamespace()).thenReturn(null);\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(\"configMap\",null,false,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(client,source,\"\",new MockEnvironment());\n    assertThat(new Fabric8ConfigMapPropertySource(context)).isNotNull();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass Fabric8ConfigMapPropertySourceMockTests {\n  private final KubernetesClient client\u003dMockito.mock(KubernetesClient.class);\n  @Test void constructorWithClientNamespaceMustNotFail();\n  @Test void constructorWithNamespaceMustNotFail();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/LabeledSecretContextToSourceDataProviderTests.java",
        "name": "LabeledSecretContextToSourceDataProviderTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.LabeledSecretContextToSourceDataProviderTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Tests only for the happy-path scenarios. All others are tested elsewhere.\n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class) class LabeledSecretContextToSourceDataProviderTests {\n  private static final String NAMESPACE\u003d\"default\";\n  private static final Map\u003cString,String\u003e LABELS\u003dnew LinkedHashMap\u003c\u003e();\n  private static final Map\u003cString,String\u003e RED_LABEL\u003dMap.of(\"color\",\"red\");\n  private static final Map\u003cString,String\u003e PINK_LABEL\u003dMap.of(\"color\",\"pink\");\n  private static final Map\u003cString,String\u003e BLUE_LABEL\u003dMap.of(\"color\",\"blue\");\n  private static KubernetesClient mockClient;\nstatic {\n    LABELS.put(\"label2\",\"value2\");\n    LABELS.put(\"label1\",\"value1\");\n  }\n  @BeforeAll static void beforeAll(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,NAMESPACE);\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterEach void afterEach(){\n    mockClient.secrets().inNamespace(NAMESPACE).delete();\n    new Fabric8SecretsCache().discardAll();\n  }\n  /** \n * we have a single secret deployed. it has two labels and these match against our queries.\n */\n  @Test void singleSecretMatchAgainstLabels(){\n    Secret secret\u003dnew SecretBuilder().withNewMetadata().withName(\"test-secret\").withLabels(LABELS).endMetadata().addToData(\"secretName\",Base64.getEncoder().encodeToString(\"secretValue\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(secret).create();\n    NormalizedSource normalizedSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,LABELS,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(\"secret.test-secret.default\",sourceData.sourceName());\n    Assertions.assertEquals(Map.of(\"secretName\",\"secretValue\"),sourceData.sourceData());\n  }\n  /** \n * we have three secrets deployed. two of them have labels that match (color\u003dred), one does not (color\u003dblue).\n */\n  @Test void twoSecretsMatchAgainstLabels(){\n    Secret redOne\u003dnew SecretBuilder().withNewMetadata().withName(\"red-secret\").withLabels(RED_LABEL).endMetadata().addToData(\"colorOne\",Base64.getEncoder().encodeToString(\"really-red\".getBytes())).build();\n    Secret redTwo\u003dnew SecretBuilder().withNewMetadata().withName(\"red-secret-again\").withLabels(RED_LABEL).endMetadata().addToData(\"colorTwo\",Base64.getEncoder().encodeToString(\"really-red-again\".getBytes())).build();\n    Secret blue\u003dnew SecretBuilder().withNewMetadata().withName(\"blue-secret\").withLabels(BLUE_LABEL).endMetadata().addToData(\"color\",Base64.getEncoder().encodeToString(\"blue\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(redOne).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(redTwo).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(blue).create();\n    NormalizedSource normalizedSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,RED_LABEL,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.red-secret.red-secret-again.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"colorOne\"),\"really-red\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"colorTwo\"),\"really-red-again\");\n  }\n  /** \n * one secret deployed (pink), does not match our query (blue).\n */\n  @Test void secretNoMatch(){\n    Secret pink\u003dnew SecretBuilder().withNewMetadata().withName(\"pink-secret\").withLabels(PINK_LABEL).endMetadata().addToData(\"color\",Base64.getEncoder().encodeToString(\"pink\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(pink).create();\n    NormalizedSource normalizedSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,BLUE_LABEL,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.color.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Collections.emptyMap());\n  }\n  /** \n * LabeledSecretContextToSourceDataProvider gets as input a Fabric8ConfigContext. This context has a namespace as well as a NormalizedSource, that has a namespace too. It is easy to get confused in code on which namespace to use. This test makes sure that we use the proper one.\n */\n  @Test void namespaceMatch(){\n    Secret secret\u003dnew SecretBuilder().withNewMetadata().withName(\"test-secret\").withLabels(LABELS).endMetadata().addToData(\"secretName\",Base64.getEncoder().encodeToString(\"secretValue\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(secret).create();\n    NormalizedSource normalizedSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE + \"nope\",LABELS,true,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(\"secret.test-secret.default\",sourceData.sourceName());\n    Assertions.assertEquals(Map.of(\"secretName\",\"secretValue\"),sourceData.sourceData());\n  }\n  /** \n * one secret with name : \"blue-secret\" and labels \"color\u003dblue\" is deployed. we search it with the same labels, find it, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided an explicit prefix).\n */\n  @Test void testWithPrefix(){\n    Secret secret\u003dnew SecretBuilder().withNewMetadata().withName(\"blue-secret\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"what-color\",Base64.getEncoder().encodeToString(\"blue-color\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(secret).create();\n    ConfigUtils.Prefix mePrefix\u003dConfigUtils.findPrefix(\"me\",false,false,\"irrelevant\");\n    NormalizedSource normalizedSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"blue\"),true,mePrefix,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(\"secret.blue-secret.default\",sourceData.sourceName());\n    Assertions.assertEquals(Map.of(\"me.what-color\",\"blue-color\"),sourceData.sourceData());\n  }\n  /** \n * two secrets are deployed (name:blue-secret, name:another-blue-secret) and labels \"color\u003dblue\" (on both). we search with the same labels, find them, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided a delayed prefix). Also notice that the prefix is made up from both secret names.\n */\n  @Test void testTwoSecretsWithPrefix(){\n    Secret blueSecret\u003dnew SecretBuilder().withNewMetadata().withName(\"blue-secret\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"first\",Base64.getEncoder().encodeToString(\"blue\".getBytes())).build();\n    Secret anotherBlue\u003dnew SecretBuilder().withNewMetadata().withName(\"another-blue-secret\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"second\",Base64.getEncoder().encodeToString(\"blue\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(blueSecret).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(anotherBlue).create();\n    NormalizedSource normalizedSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"blue\"),true,ConfigUtils.Prefix.DELAYED,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.another-blue-secret.blue-secret.default\");\n    Map\u003cString,Object\u003e properties\u003dsourceData.sourceData();\n    Assertions.assertEquals(2,properties.size());\n    Iterator\u003cString\u003e keys\u003dproperties.keySet().iterator();\n    String firstKey\u003dkeys.next();\n    String secondKey\u003dkeys.next();\n    if (firstKey.contains(\"first\")) {\n      Assertions.assertEquals(firstKey,\"another-blue-secret.blue-secret.first\");\n    }\n    Assertions.assertEquals(secondKey,\"another-blue-secret.blue-secret.second\");\n    Assertions.assertEquals(properties.get(firstKey),\"blue\");\n    Assertions.assertEquals(properties.get(secondKey),\"blue\");\n  }\n  /** \n * two secrets are deployed: secret \"color-secret\" with label: \"{color:blue}\" and \"color-secret-k8s\" with no labels. We search by \"{color:red}\", do not find anything and thus have an empty SourceData. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsNoSecretFound(){\n    Secret colorSecret\u003dnew SecretBuilder().withNewMetadata().withName(\"color-secret\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"one\",Base64.getEncoder().encodeToString(\"1\".getBytes())).build();\n    Secret colorSecretK8s\u003dnew SecretBuilder().withNewMetadata().withName(\"color-secret-k8s\").endMetadata().addToData(\"two\",Base64.getEncoder().encodeToString(\"2\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(colorSecret).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(colorSecretK8s).create();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource normalizedSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"red\"),true,ConfigUtils.Prefix.DEFAULT,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,environment);\n    Fabric8ContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertTrue(sourceData.sourceData().isEmpty());\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.color.default\");\n  }\n  /** \n * two secrets are deployed: secret \"color-secret\" with label: \"{color:blue}\" and \"shape-secret\" with label: \"{shape:round}\". We search by \"{color:blue}\" and find one secret. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsOneSecretFound(){\n    Secret colorSecret\u003dnew SecretBuilder().withNewMetadata().withName(\"color-secret\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"one\",Base64.getEncoder().encodeToString(\"1\".getBytes())).build();\n    Secret shapeSecret\u003dnew SecretBuilder().withNewMetadata().withName(\"shape-secret\").endMetadata().addToData(\"two\",Base64.getEncoder().encodeToString(\"2\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(colorSecret).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(shapeSecret).create();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource normalizedSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"blue\"),true,ConfigUtils.Prefix.DEFAULT,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,environment);\n    Fabric8ContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),1);\n    Assertions.assertEquals(sourceData.sourceData().get(\"one\"),\"1\");\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.color-secret.default\");\n  }\n  /** \n * two secrets are deployed: secret \"color-secret\" with label: \"{color:blue}\" and \"color-secret-k8s\" with label: \"{color:red}\". We search by \"{color:blue}\" and find one secret. Since profiles are enabled, we will also be reading \"color-secret-k8s\", even if its labels do not match provided ones.\n */\n  @Test void searchWithLabelsOneSecretFoundAndOneFromProfileFound(){\n    Secret colorSecret\u003dnew SecretBuilder().withNewMetadata().withName(\"color-secret\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"one\",Base64.getEncoder().encodeToString(\"1\".getBytes())).build();\n    Secret colorSecretK8s\u003dnew SecretBuilder().withNewMetadata().withName(\"color-secret-k8s\").withLabels(Collections.singletonMap(\"color\",\"red\")).endMetadata().addToData(\"two\",Base64.getEncoder().encodeToString(\"2\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(colorSecret).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(colorSecretK8s).create();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource normalizedSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"blue\"),true,ConfigUtils.Prefix.DELAYED,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,environment);\n    Fabric8ContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-secret.color-secret-k8s.one\"),\"1\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-secret.color-secret-k8s.two\"),\"2\");\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.color-secret.color-secret-k8s.default\");\n  }\n  /** \n * \u003cpre\u003e - secret \"color-secret\" with label \"{color:blue}\" - secret \"shape-secret\" with labels \"{color:blue, shape:round}\" - secret \"no-fit\" with labels \"{tag:no-fit}\" - secret \"color-secret-k8s\" with label \"{color:red}\" - secret \"shape-secret-k8s\" with label \"{shape:triangle}\" \u003c/pre\u003e\n */\n  @Test void searchWithLabelsTwoSecretsFoundAndOneFromProfileFound(){\n    Secret colorSecret\u003dnew SecretBuilder().withNewMetadata().withName(\"color-secret\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"one\",Base64.getEncoder().encodeToString(\"1\".getBytes())).build();\n    Secret shapeSecret\u003dnew SecretBuilder().withNewMetadata().withName(\"shape-secret\").withLabels(Map.of(\"color\",\"blue\",\"shape\",\"round\")).endMetadata().addToData(\"two\",Base64.getEncoder().encodeToString(\"2\".getBytes())).build();\n    Secret noFit\u003dnew SecretBuilder().withNewMetadata().withName(\"no-fit\").withLabels(Map.of(\"tag\",\"no-fit\")).endMetadata().addToData(\"three\",Base64.getEncoder().encodeToString(\"3\".getBytes())).build();\n    Secret colorSecretK8s\u003dnew SecretBuilder().withNewMetadata().withName(\"color-secret-k8s\").withLabels(Map.of(\"color\",\"red\")).endMetadata().addToData(\"four\",Base64.getEncoder().encodeToString(\"4\".getBytes())).build();\n    Secret shapeSecretK8s\u003dnew SecretBuilder().withNewMetadata().withName(\"shape-secret-k8s\").withLabels(Map.of(\"shape\",\"triangle\")).endMetadata().addToData(\"five\",Base64.getEncoder().encodeToString(\"5\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(colorSecret).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(shapeSecret).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(noFit).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(colorSecretK8s).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(shapeSecretK8s).create();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource normalizedSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"blue\"),true,ConfigUtils.Prefix.DELAYED,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,environment);\n    Fabric8ContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),4);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-secret.color-secret-k8s.shape-secret.shape-secret-k8s.one\"),\"1\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-secret.color-secret-k8s.shape-secret.shape-secret-k8s.two\"),\"2\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-secret.color-secret-k8s.shape-secret.shape-secret-k8s.four\"),\"4\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-secret.color-secret-k8s.shape-secret.shape-secret-k8s.five\"),\"5\");\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.color-secret.color-secret-k8s.shape-secret.shape-secret-k8s.default\");\n  }\n  /** \n * yaml/properties gets special treatment\n */\n  @Test void testYaml(){\n    Secret colorSecret\u003dnew SecretBuilder().withNewMetadata().withName(\"color-secret\").withLabels(Collections.singletonMap(\"color\",\"blue\")).endMetadata().addToData(\"test.yaml\",Base64.getEncoder().encodeToString(\"color: blue\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(colorSecret).create();\n    NormalizedSource normalizedSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"blue\"),true,ConfigUtils.Prefix.DEFAULT,true);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,normalizedSource,NAMESPACE,new MockEnvironment());\n    Fabric8ContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),1);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color\"),\"blue\");\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.color-secret.default\");\n  }\n  /** \n * \u003cpre\u003e - secret \"red\" with label \"{color:red}\" - secret \"green\" with labels \"{color:green}\" - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output){\n    Secret red\u003dnew SecretBuilder().withNewMetadata().withName(\"red\").withLabels(Collections.singletonMap(\"color\",\"red\")).endMetadata().addToData(\"one\",Base64.getEncoder().encodeToString(\"1\".getBytes())).build();\n    Secret green\u003dnew SecretBuilder().withNewMetadata().withName(\"green\").withLabels(Map.of(\"color\",\"green\")).endMetadata().addToData(\"two\",Base64.getEncoder().encodeToString(\"2\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(red).create();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(green).create();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    NormalizedSource redNormalizedSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"red\"),true,ConfigUtils.Prefix.DELAYED,true);\n    Fabric8ConfigContext redContext\u003dnew Fabric8ConfigContext(mockClient,redNormalizedSource,NAMESPACE,environment);\n    Fabric8ContextToSourceData redData\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData redSourceData\u003dredData.apply(redContext);\n    Assertions.assertEquals(redSourceData.sourceData().size(),1);\n    Assertions.assertEquals(redSourceData.sourceData().get(\"red.one\"),\"1\");\n    Assertions.assertTrue(output.getAll().contains(\"Loaded all secrets in namespace \u0027\" + NAMESPACE + \"\u0027\"));\n    NormalizedSource greenNormalizedSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"green\"),true,ConfigUtils.Prefix.DELAYED,true);\n    Fabric8ConfigContext greenContext\u003dnew Fabric8ConfigContext(mockClient,greenNormalizedSource,NAMESPACE,environment);\n    Fabric8ContextToSourceData greenData\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData greenSourceData\u003dgreenData.apply(greenContext);\n    Assertions.assertEquals(greenSourceData.sourceData().size(),1);\n    Assertions.assertEquals(greenSourceData.sourceData().get(\"green.two\"),\"2\");\n    String[] out\u003doutput.getAll().split(\"Loaded all secrets in namespace\");\n    Assertions.assertEquals(out.length,2);\n    out\u003doutput.getAll().split(\"Loaded \\\\(from cache\\\\) all secrets in namespace\");\n    Assertions.assertEquals(out.length,2);\n  }\n}\n",
        "abstract": "/** \n * Tests only for the happy-path scenarios. All others are tested elsewhere.\n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class) class LabeledSecretContextToSourceDataProviderTests {\n  private static final String NAMESPACE\u003d\"default\";\n  private static final Map\u003cString,String\u003e LABELS\u003dnew LinkedHashMap\u003c\u003e();\n  private static final Map\u003cString,String\u003e RED_LABEL\u003dMap.of(\"color\",\"red\");\n  private static final Map\u003cString,String\u003e PINK_LABEL\u003dMap.of(\"color\",\"pink\");\n  private static final Map\u003cString,String\u003e BLUE_LABEL\u003dMap.of(\"color\",\"blue\");\n  private static KubernetesClient mockClient;\nstatic {\n    LABELS.put(\"label2\",\"value2\");\n    LABELS.put(\"label1\",\"value1\");\n  }\n  @BeforeAll static void beforeAll();\n  @AfterEach void afterEach();\n  /** \n * we have a single secret deployed. it has two labels and these match against our queries.\n */\n  @Test void singleSecretMatchAgainstLabels();\n  /** \n * we have three secrets deployed. two of them have labels that match (color\u003dred), one does not (color\u003dblue).\n */\n  @Test void twoSecretsMatchAgainstLabels();\n  /** \n * one secret deployed (pink), does not match our query (blue).\n */\n  @Test void secretNoMatch();\n  /** \n * LabeledSecretContextToSourceDataProvider gets as input a Fabric8ConfigContext. This context has a namespace as well as a NormalizedSource, that has a namespace too. It is easy to get confused in code on which namespace to use. This test makes sure that we use the proper one.\n */\n  @Test void namespaceMatch();\n  /** \n * one secret with name : \"blue-secret\" and labels \"color\u003dblue\" is deployed. we search it with the same labels, find it, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided an explicit prefix).\n */\n  @Test void testWithPrefix();\n  /** \n * two secrets are deployed (name:blue-secret, name:another-blue-secret) and labels \"color\u003dblue\" (on both). we search with the same labels, find them, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided a delayed prefix). Also notice that the prefix is made up from both secret names.\n */\n  @Test void testTwoSecretsWithPrefix();\n  /** \n * two secrets are deployed: secret \"color-secret\" with label: \"{color:blue}\" and \"color-secret-k8s\" with no labels. We search by \"{color:red}\", do not find anything and thus have an empty SourceData. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsNoSecretFound();\n  /** \n * two secrets are deployed: secret \"color-secret\" with label: \"{color:blue}\" and \"shape-secret\" with label: \"{shape:round}\". We search by \"{color:blue}\" and find one secret. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsOneSecretFound();\n  /** \n * two secrets are deployed: secret \"color-secret\" with label: \"{color:blue}\" and \"color-secret-k8s\" with label: \"{color:red}\". We search by \"{color:blue}\" and find one secret. Since profiles are enabled, we will also be reading \"color-secret-k8s\", even if its labels do not match provided ones.\n */\n  @Test void searchWithLabelsOneSecretFoundAndOneFromProfileFound();\n  /** \n * \u003cpre\u003e - secret \"color-secret\" with label \"{color:blue}\" - secret \"shape-secret\" with labels \"{color:blue, shape:round}\" - secret \"no-fit\" with labels \"{tag:no-fit}\" - secret \"color-secret-k8s\" with label \"{color:red}\" - secret \"shape-secret-k8s\" with label \"{shape:triangle}\" \u003c/pre\u003e\n */\n  @Test void searchWithLabelsTwoSecretsFoundAndOneFromProfileFound();\n  /** \n * yaml/properties gets special treatment\n */\n  @Test void testYaml();\n  /** \n * \u003cpre\u003e - secret \"red\" with label \"{color:red}\" - secret \"green\" with labels \"{color:green}\" - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/BootstrapConfigMapsWithProfilesNoActiveProfileTests.java",
        "name": "BootstrapConfigMapsWithProfilesNoActiveProfileTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-no-active-profiles-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.BootstrapConfigMapsWithProfilesNoActiveProfileTests",
        "extend": "ConfigMapsWithProfilesNoActiveProfileTests",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-no-active-profiles-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapConfigMapsWithProfilesNoActiveProfileTests extends ConfigMapsWithProfilesNoActiveProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-no-active-profiles-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapConfigMapsWithProfilesNoActiveProfileTests extends ConfigMapsWithProfilesNoActiveProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/BootstrapMultipleSecretsTests.java",
        "name": "BootstrapMultipleSecretsTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dMultiSecretsApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dmultiple-secrets\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.BootstrapMultipleSecretsTests",
        "extend": "MultipleSecretsTests",
        "implements": "",
        "raw": "/** \n * @author Haytham Mohamed\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dMultiSecretsApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dmultiple-secrets\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapMultipleSecretsTests extends MultipleSecretsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author Haytham Mohamed\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dMultiSecretsApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dmultiple-secrets\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapMultipleSecretsTests extends MultipleSecretsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_profile/properties/One.java",
        "name": "One",
        "modifiers": "@ConfigurationProperties(\"one\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_profile.properties.One",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_profile/properties/Two.java",
        "name": "Two",
        "modifiers": "@ConfigurationProperties(\"two\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_profile.properties.Two",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_profile/properties/Three.java",
        "name": "Three",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"secret-three\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_profile.properties.Three",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"secret-three\") public class Three {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"secret-three\") public class Three {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_profile/NamedSecretWithProfileTests.java",
        "name": "NamedSecretWithProfileTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_profile.NamedSecretWithProfileTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class NamedSecretWithProfileTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    NamedSecretWithProfileTests.mockClient\u003dmockClient;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e one\u003dCollections.singletonMap(\"one.property\",Base64.getEncoder().encodeToString(\"one\".getBytes(StandardCharsets.UTF_8)));\n    Map\u003cString,String\u003e oneFromKubernetesProfile\u003dCollections.singletonMap(\"one.property\",Base64.getEncoder().encodeToString(\"one-from-k8s\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"secret-one\",one);\n    createSecret(\"secret-one-k8s\",oneFromKubernetesProfile);\n    Map\u003cString,String\u003e two\u003dCollections.singletonMap(\"property\",Base64.getEncoder().encodeToString(\"two\".getBytes(StandardCharsets.UTF_8)));\n    Map\u003cString,String\u003e twoFromKubernetesProfile\u003dCollections.singletonMap(\"property\",Base64.getEncoder().encodeToString(\"two-from-k8s\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"secret-two\",two);\n    createSecret(\"secret-two-k8s\",twoFromKubernetesProfile);\n    Map\u003cString,String\u003e three\u003dCollections.singletonMap(\"property\",Base64.getEncoder().encodeToString(\"three\".getBytes(StandardCharsets.UTF_8)));\n    Map\u003cString,String\u003e threeFromKubernetesProfile\u003dCollections.singletonMap(\"property\",Base64.getEncoder().encodeToString(\"three-from-k8s\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"secret-three\",three);\n    createSecret(\"secret-three-k8s\",threeFromKubernetesProfile);\n  }\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data){\n    mockClient.secrets().inNamespace(\"spring-k8s\").resource(new SecretBuilder().withNewMetadata().withName(name).endMetadata().addToData(data).build()).create();\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].useNameAsPrefix\u003dfalse\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].includeProfileSpecificSources\u003dtrue\u0027 (\"one.property\", \"one-from-k8s\") As such: @ConfigurationProperties(\"one\"), value is overridden by the one that we read from the profile based source. \u003c/pre\u003e\n */\n  @Test void testOne(){\n    this.webClient.get().uri(\"/named-secret/profile/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one-from-k8s\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].explicitPrefix\u003dtwo\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].includeProfileSpecificSources\u003dfalse\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\"). Even if there is a profile based source, we disabled reading it. \u003c/pre\u003e\n */\n  @Test void testTwo(){\n    this.webClient.get().uri(\"/named-secret/profile/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[2].name\u003dsecret-three\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].includeProfileSpecificSources\u003dtrue\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"secret-three\"), value is overridden by the one that we read from * \t the profile based source \u003c/pre\u003e\n */\n  @Test void testThree(){\n    this.webClient.get().uri(\"/named-secret/profile/three\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"three-from-k8s\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class NamedSecretWithProfileTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data);\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].useNameAsPrefix\u003dfalse\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].includeProfileSpecificSources\u003dtrue\u0027 (\"one.property\", \"one-from-k8s\") As such: @ConfigurationProperties(\"one\"), value is overridden by the one that we read from the profile based source. \u003c/pre\u003e\n */\n  @Test void testOne();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].explicitPrefix\u003dtwo\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].includeProfileSpecificSources\u003dfalse\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\"). Even if there is a profile based source, we disabled reading it. \u003c/pre\u003e\n */\n  @Test void testTwo();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[2].name\u003dsecret-three\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].includeProfileSpecificSources\u003dtrue\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"secret-three\"), value is overridden by the one that we read from * \t the profile based source \u003c/pre\u003e\n */\n  @Test void testThree();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_profile/NamedSecretWithProfileBootstrapTests.java",
        "name": "NamedSecretWithProfileBootstrapTests",
        "modifiers": "@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_profile.NamedSecretWithProfileBootstrapTests",
        "extend": "NamedSecretWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedSecretWithProfileBootstrapTests extends NamedSecretWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedSecretWithProfileBootstrapTests extends NamedSecretWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_profile/NamedSecretWithProfileApp.java",
        "name": "NamedSecretWithProfileApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_profile.NamedSecretWithProfileApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedSecretWithProfileApp {\n  public static void main(  String[] args){\n    SpringApplication.run(NamedSecretWithProfileApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedSecretWithProfileApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_profile/controller/NamedSecretWithProfileController.java",
        "name": "NamedSecretWithProfileController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_profile.controller.NamedSecretWithProfileController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class NamedSecretWithProfileController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedSecretWithProfileController(  One one,  Two two,  Three three){\n    this.one\u003done;\n    this.two\u003dtwo;\n    this.three\u003dthree;\n  }\n  @GetMapping(\"/named-secret/profile/one\") public String one(){\n    return one.getProperty();\n  }\n  @GetMapping(\"/named-secret/profile/two\") public String two(){\n    return two.getProperty();\n  }\n  @GetMapping(\"/named-secret/profile/three\") public String three(){\n    return three.getProperty();\n  }\n}\n",
        "abstract": "@RestController public class NamedSecretWithProfileController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedSecretWithProfileController(  One one,  Two two,  Three three);\n  @GetMapping(\"/named-secret/profile/one\") public String one();\n  @GetMapping(\"/named-secret/profile/two\") public String two();\n  @GetMapping(\"/named-secret/profile/three\") public String three();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/named_secret_with_profile/NamedSecretWithProfileConfigDataTests.java",
        "name": "NamedSecretWithProfileConfigDataTests",
        "modifiers": "@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithProfileApp.class,properties\u003d{\"spring.application.name\u003dnamed-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-secret-with-profile.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.named_secret_with_profile.NamedSecretWithProfileConfigDataTests",
        "extend": "NamedSecretWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithProfileApp.class,properties\u003d{\"spring.application.name\u003dnamed-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-secret-with-profile.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedSecretWithProfileConfigDataTests extends NamedSecretWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithProfileApp.class,properties\u003d{\"spring.application.name\u003dnamed-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-secret-with-profile.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class NamedSecretWithProfileConfigDataTests extends NamedSecretWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigDataConfigMapsTests.java",
        "name": "ConfigDataConfigMapsTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigDataConfigMapsTests",
        "extend": "ConfigMapsTests",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsTests extends ConfigMapsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsTests extends ConfigMapsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigDataConfigMapsWithProfileExpressionTests.java",
        "name": "ConfigDataConfigMapsWithProfileExpressionTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @ActiveProfiles({\"production\",\"us-east\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigDataConfigMapsWithProfileExpressionTests",
        "extend": "ConfigMapsWithProfileExpressionTests",
        "implements": "",
        "raw": "/** \n * Tests reading property from YAML document specified by profile expression.\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @ActiveProfiles({\"production\",\"us-east\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsWithProfileExpressionTests extends ConfigMapsWithProfileExpressionTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * Tests reading property from YAML document specified by profile expression.\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003dconfigmap-with-profile-example\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @ActiveProfiles({\"production\",\"us-east\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsWithProfileExpressionTests extends ConfigMapsWithProfileExpressionTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/MultipleConfigMapsTests.java",
        "name": "MultipleConfigMapsTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dExampleApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dmultiplecms\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.MultipleConfigMapsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dExampleApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dmultiplecms\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) abstract class MultipleConfigMapsTests {\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e one\u003dnew HashMap\u003c\u003e();\n    one.put(\"bean.common-message\",\"c1\");\n    one.put(\"bean.message1\",\"m1\");\n    createConfigmap(mockClient,\"s1\",\"defnamespace\",one);\n    Map\u003cString,String\u003e two\u003dnew HashMap\u003c\u003e();\n    two.put(\"bean.common-message\",\"c2\");\n    two.put(\"bean.message2\",\"m2\");\n    createConfigmap(mockClient,\"defname\",\"s2\",two);\n    Map\u003cString,String\u003e three\u003dnew HashMap\u003c\u003e();\n    three.put(\"bean.common-message\",\"c3\");\n    three.put(\"bean.message3\",\"m3\");\n    createConfigmap(mockClient,\"othername\",\"othernamespace\",three);\n  }\n  private static void createConfigmap(  KubernetesClient client,  String configMapName,  String namespace,  Map\u003cString,String\u003e data){\n    client.configMaps().inNamespace(namespace).resource(new ConfigMapBuilder().withNewMetadata().withName(configMapName).endMetadata().addToData(data).build()).create();\n  }\n  @Test public void testCommonMessage(){\n    assertResponse(\"/common\",\"c3\");\n  }\n  @Test public void testMessage1(){\n    assertResponse(\"/m1\",\"m1\");\n  }\n  @Test public void testMessage2(){\n    assertResponse(\"/m2\",\"m2\");\n  }\n  @Test public void testMessage3(){\n    assertResponse(\"/m3\",\"m3\");\n  }\n  private void assertResponse(  String path,  String expectedMessage){\n    this.webClient.get().uri(path).exchange().expectStatus().isOk().expectBody().jsonPath(\"message\").isEqualTo(expectedMessage);\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dExampleApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dmultiplecms\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) abstract class MultipleConfigMapsTests {\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient);\n  private static void createConfigmap(  KubernetesClient client,  String configMapName,  String namespace,  Map\u003cString,String\u003e data);\n  @Test public void testCommonMessage();\n  @Test public void testMessage1();\n  @Test public void testMessage2();\n  @Test public void testMessage3();\n  private void assertResponse(  String path,  String expectedMessage);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigDataConfigMapsMixedTests.java",
        "name": "ConfigDataConfigMapsMixedTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003d\" + ConfigDataConfigMapsMixedTests.APPLICATION_NAME,\"spring.cloud.kubernetes.config.enableApi\u003dtrue\",\"spring.cloud.kubernetes.config.paths\u003d\" + ConfigDataConfigMapsMixedTests.FILE_NAME_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigDataConfigMapsMixedTests",
        "extend": "ConfigMapsMixedTests",
        "implements": "",
        "raw": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003d\" + ConfigDataConfigMapsMixedTests.APPLICATION_NAME,\"spring.cloud.kubernetes.config.enableApi\u003dtrue\",\"spring.cloud.kubernetes.config.paths\u003d\" + ConfigDataConfigMapsMixedTests.FILE_NAME_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsMixedTests extends ConfigMapsMixedTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass() throws IOException {\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003d\" + ConfigDataConfigMapsMixedTests.APPLICATION_NAME,\"spring.cloud.kubernetes.config.enableApi\u003dtrue\",\"spring.cloud.kubernetes.config.paths\u003d\" + ConfigDataConfigMapsMixedTests.FILE_NAME_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataConfigMapsMixedTests extends ConfigMapsMixedTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass() throws IOException;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/example2/ExampleApp.java",
        "name": "ExampleApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties(ExampleAppProps.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.example2.ExampleApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties(ExampleAppProps.class) public class ExampleApp {\n  public static void main(  String[] args){\n    SpringApplication.run(App.class,args);\n  }\n@RestController public static class Controller {\n    private final ExampleAppProps exampleAppProps;\n    public Controller(    ExampleAppProps exampleAppProps){\n      this.exampleAppProps\u003dexampleAppProps;\n    }\n    @GetMapping(\"/common\") public Response commonMessage(){\n      return new Response(this.exampleAppProps.getCommonMessage());\n    }\n    @GetMapping(\"/m1\") public Response message1(){\n      return new Response(this.exampleAppProps.getMessage1());\n    }\n    @GetMapping(\"/m2\") public Response message2(){\n      return new Response(this.exampleAppProps.getMessage2());\n    }\n    @GetMapping(\"/m3\") public Response message3(){\n      return new Response(this.exampleAppProps.getMessage3());\n    }\n  }\npublic static class Response {\n    private final String message;\n    public Response(    String message){\n      this.message\u003dmessage;\n    }\n    public String getMessage(){\n      return this.message;\n    }\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties(ExampleAppProps.class) public class ExampleApp {\n  public static void main(  String[] args);\n@RestController public static class Controller {\n    private final ExampleAppProps exampleAppProps;\n    public Controller(    ExampleAppProps exampleAppProps);\n    @GetMapping(\"/common\") public Response commonMessage();\n    @GetMapping(\"/m1\") public Response message1();\n    @GetMapping(\"/m2\") public Response message2();\n    @GetMapping(\"/m3\") public Response message3();\n  }\npublic static class Response {\n    private final String message;\n    public Response(    String message);\n    public String getMessage();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/example2/ExampleAppProps.java",
        "name": "ExampleAppProps",
        "modifiers": "@ConfigurationProperties(\"bean\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.example2.ExampleAppProps",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"bean\") public class ExampleAppProps {\n  private String commonMessage;\n  private String message1;\n  private String message2;\n  private String message3;\n  public String getCommonMessage(){\n    return this.commonMessage;\n  }\n  public void setCommonMessage(  String commonMessage){\n    this.commonMessage\u003dcommonMessage;\n  }\n  public String getMessage1(){\n    return this.message1;\n  }\n  public void setMessage1(  String message1){\n    this.message1\u003dmessage1;\n  }\n  public String getMessage2(){\n    return this.message2;\n  }\n  public void setMessage2(  String message2){\n    this.message2\u003dmessage2;\n  }\n  public String getMessage3(){\n    return this.message3;\n  }\n  public void setMessage3(  String message3){\n    this.message3\u003dmessage3;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"bean\") public class ExampleAppProps {\n  private String commonMessage;\n  private String message1;\n  private String message2;\n  private String message3;\n  public String getCommonMessage();\n  public void setCommonMessage(  String commonMessage);\n  public String getMessage1();\n  public void setMessage1(  String message1);\n  public String getMessage2();\n  public void setMessage2(  String message2);\n  public String getMessage3();\n  public void setMessage3(  String message3);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigMapsWithoutProfilesTests.java",
        "name": "ConfigMapsWithoutProfilesTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigMapsWithoutProfilesTests",
        "extend": "",
        "implements": "",
        "raw": "abstract class ConfigMapsWithoutProfilesTests {\n  private static final String APPLICATION_NAME\u003d\"configmap-without-profile-example\";\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    HashMap\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"application.yml\",ConfigMapTestUtil.readResourceFile(\"application-without-profiles.yaml\"));\n    mockClient.configMaps().inNamespace(\"test\").resource(new ConfigMapBuilder().withNewMetadata().withName(APPLICATION_NAME).endMetadata().addToData(data).build()).create();\n  }\n  @Test public void testGreetingEndpoint(){\n    this.webClient.get().uri(\"/api/greeting\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Hello ConfigMap, World!\");\n  }\n  @Test public void testFarewellEndpoint(){\n    this.webClient.get().uri(\"/api/farewell\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Goodbye ConfigMap, World!\");\n  }\n}\n",
        "abstract": "abstract class ConfigMapsWithoutProfilesTests {\n  private static final String APPLICATION_NAME\u003d\"configmap-without-profile-example\";\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient);\n  @Test public void testGreetingEndpoint();\n  @Test public void testFarewellEndpoint();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/EnableRetryBootstrapConfiguration.java",
        "name": "EnableRetryBootstrapConfiguration",
        "modifiers": "@Order(0) @Configuration @ConditionalOnProperty(\"spring.cloud.kubernetes.test.enable-retry\") @EnableRetry public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.EnableRetryBootstrapConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"spring.cloud.kubernetes.test.enable-retry\") @EnableRetry public class EnableRetryBootstrapConfiguration {\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"spring.cloud.kubernetes.test.enable-retry\") @EnableRetry public class EnableRetryBootstrapConfiguration {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/TestApplication.java",
        "name": "TestApplication",
        "modifiers": "@SpringBootApplication public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.TestApplication",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication public class TestApplication {\n  public static void main(  String[] args){\n    SpringApplication.run(TestApplication.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication public class TestApplication {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/reload/ConfigReloadAutoConfigurationTest.java",
        "name": "ConfigReloadAutoConfigurationTest",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.reload.ConfigReloadAutoConfigurationTest",
        "extend": "KubernetesConfigTestBase",
        "implements": "",
        "raw": "/** \n * @author Haytham MohamedTo test if either kubernetes, kubernetes.configmap, or reload is disabled, then the detector and update strategy beans won\u0027t be available.\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class ConfigReloadAutoConfigurationTest extends KubernetesConfigTestBase {\n  private static final String APPLICATION_NAME\u003d\"application\";\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    HashMap\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"bean.greeting\",\"Hello ConfigMap, %s!\");\n    ConfigMap configMap1\u003dnew ConfigMapBuilder().withNewMetadata().withName(APPLICATION_NAME).endMetadata().addToData(data).build();\n    mockClient.configMaps().inNamespace(\"test\").resource(configMap1).create();\n    ConfigMap configMap2\u003dnew ConfigMapBuilder().withNewMetadata().withName(APPLICATION_NAME).endMetadata().addToData(data).build();\n    mockClient.configMaps().inNamespace(\"spring\").resource(configMap2).create();\n  }\n  @BeforeEach void beforeEach(){\n    commonProperties\u003dnew String[]{\"spring.cloud.bootstrap.enabled\u003dtrue\"};\n  }\n  @Test void kubernetesConfigReloadDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dfalse\");\n    assertThat(this.getContext().containsBean(\"configurationChangeDetector\")).isFalse();\n    assertThat(this.getContext().containsBean(\"configurationUpdateStrategy\")).isFalse();\n  }\n  @Test void kubernetesConfigReloadWhenKubernetesConfigDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.config.enabled\u003dfalse\");\n    assertThat(this.getContext().containsBean(\"configurationChangeDetector\")).isFalse();\n    assertThat(this.getContext().containsBean(\"configurationUpdateStrategy\")).isFalse();\n  }\n  @Test void kubernetesConfigReloadWhenKubernetesDisabled(){\n    setup(KubernetesClientTestConfiguration.class);\n    assertThat(this.getContext().containsBean(\"configurationChangeDetector\")).isFalse();\n    assertThat(this.getContext().containsBean(\"configurationUpdateStrategy\")).isFalse();\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true by default - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabledByDefault(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dgetContext().getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    Assertions.assertTrue(map.values().iterator().next().getClass().isAssignableFrom(Fabric8EventBasedConfigMapChangeDetector.class));\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true by default - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003devent\",\"spring.main.cloud-platform\u003dKUBERNETES\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dgetContext().getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    Assertions.assertTrue(map.values().iterator().next().getClass().isAssignableFrom(Fabric8EventBasedConfigMapChangeDetector.class));\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003devent\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dfalse\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dgetContext().getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),0);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via poll reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsDisabledMonitoringSecretsDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003dpolling\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dfalse\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dgetContext().getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),0);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via poll reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true by default - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - config map polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsEnabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003dpolling\",\"spring.main.cloud-platform\u003dKUBERNETES\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dgetContext().getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    Assertions.assertTrue(map.values().iterator().next().getClass().isAssignableFrom(PollingConfigMapChangeDetector.class));\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsDisabledMonitoringSecretsEnabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dtrue\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dfalse\",\"spring.cloud.kubernetes.reload.mode\u003devent\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dgetContext().getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    Assertions.assertTrue(map.values().iterator().next().getClass().isAssignableFrom(Fabric8EventBasedSecretsChangeDetector.class));\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsDisabledMonitoringSecretsEnabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dtrue\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dfalse\",\"spring.cloud.kubernetes.reload.mode\u003dpolling\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dgetContext().getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    Assertions.assertTrue(map.values().iterator().next().getClass().isAssignableFrom(PollingSecretsChangeDetector.class));\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is true - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabledMonitoringSecretsEnabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dtrue\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003devent\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dgetContext().getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),2);\n    List\u003cConfigurationChangeDetector\u003e result\u003dmap.values().stream().sorted(Comparator.comparing(x -\u003e x.getClass().getName())).toList();\n    Assertions.assertEquals(result.get(0).getClass(),Fabric8EventBasedConfigMapChangeDetector.class);\n    Assertions.assertEquals(result.get(1).getClass(),Fabric8EventBasedSecretsChangeDetector.class);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is true - config map event watcher is not picked up - config map polling watcher is picked up - secrets event watcher is not picked up - secrets polling watcher is picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsEnabledMonitoringSecretsEnabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dtrue\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003dpolling\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dgetContext().getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),2);\n    List\u003cConfigurationChangeDetector\u003e result\u003dmap.values().stream().sorted(Comparator.comparing(x -\u003e x.getClass().getName())).toList();\n    Assertions.assertEquals(result.get(0).getClass(),PollingConfigMapChangeDetector.class);\n    Assertions.assertEquals(result.get(1).getClass(),PollingSecretsChangeDetector.class);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsDisabledMonitoringSecretsDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003devent\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dfalse\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dfalse\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dgetContext().getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),0);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via poll reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitorConfigMapsDisabledMonitoringSecretsDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003dpolling\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dfalse\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dfalse\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dgetContext().getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),0);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabledMonitoringSecretsDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003devent\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dtrue\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dfalse\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dgetContext().getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    List\u003cConfigurationChangeDetector\u003e result\u003dmap.values().stream().sorted(Comparator.comparing(x -\u003e x.getClass().getName())).toList();\n    Assertions.assertEquals(result.get(0).getClass(),Fabric8EventBasedConfigMapChangeDetector.class);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via polling reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is not picked up - config map polling watcher is picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsEnabledMonitoringSecretsDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003dpolling\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dtrue\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dfalse\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dgetContext().getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    List\u003cConfigurationChangeDetector\u003e result\u003dmap.values().stream().sorted(Comparator.comparing(x -\u003e x.getClass().getName())).toList();\n    Assertions.assertEquals(result.get(0).getClass(),PollingConfigMapChangeDetector.class);\n  }\n  @Test void kubernetesReloadEnabledButSecretDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.config.enabled\u003dtrue\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.reload.enabled\u003dtrue\");\n    assertThat(this.getContext().containsBean(\"configMapPropertySourceLocator\")).isTrue();\n    assertThat(this.getContext().containsBean(\"secretsPropertySourceLocator\")).isFalse();\n    assertThat(this.getContext().containsBean(\"configMapPropertyChangeEventWatcher\")).isTrue();\n    assertThat(this.getContext().containsBean(\"secretsPropertyChangeEventWatcher\")).isFalse();\n  }\n  @Test void kubernetesReloadEnabledButSecretAndConfigDisabled(){\n    setup(KubernetesClientTestConfiguration.class,\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.reload.enabled\u003dtrue\");\n    assertThat(this.getContext().containsBean(\"configMapPropertySourceLocator\")).isFalse();\n    assertThat(this.getContext().containsBean(\"secretsPropertySourceLocator\")).isFalse();\n    assertThat(this.getContext().containsBean(\"propertyChangeWatcher\")).isFalse();\n  }\n@Configuration(proxyBeanMethods\u003dfalse) private static class KubernetesClientTestConfiguration {\n    @ConditionalOnMissingBean(KubernetesClient.class) @Bean KubernetesClient kubernetesClient(){\n      return mockClient;\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Haytham MohamedTo test if either kubernetes, kubernetes.configmap, or reload is disabled, then the detector and update strategy beans won\u0027t be available.\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class ConfigReloadAutoConfigurationTest extends KubernetesConfigTestBase {\n  private static final String APPLICATION_NAME\u003d\"application\";\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n  @BeforeEach void beforeEach();\n  @Test void kubernetesConfigReloadDisabled();\n  @Test void kubernetesConfigReloadWhenKubernetesConfigDisabled();\n  @Test void kubernetesConfigReloadWhenKubernetesDisabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true by default - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabledByDefault();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true by default - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsDisabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via poll reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsDisabledMonitoringSecretsDisabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via poll reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true by default - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - config map polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsEnabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsDisabledMonitoringSecretsEnabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsDisabledMonitoringSecretsEnabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is true - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabledMonitoringSecretsEnabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is true - config map event watcher is not picked up - config map polling watcher is picked up - secrets event watcher is not picked up - secrets polling watcher is picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsEnabledMonitoringSecretsEnabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsDisabledMonitoringSecretsDisabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via poll reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitorConfigMapsDisabledMonitoringSecretsDisabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabledMonitoringSecretsDisabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via polling reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is not picked up - config map polling watcher is picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsEnabledMonitoringSecretsDisabled();\n  @Test void kubernetesReloadEnabledButSecretDisabled();\n  @Test void kubernetesReloadEnabledButSecretAndConfigDisabled();\n@Configuration(proxyBeanMethods\u003dfalse) private static class KubernetesClientTestConfiguration {\n    @ConditionalOnMissingBean(KubernetesClient.class) @Bean KubernetesClient kubernetesClient();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/Fabric8SecretsPropertySourceLocatorTests.java",
        "name": "Fabric8SecretsPropertySourceLocatorTests",
        "modifiers": "@EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.Fabric8SecretsPropertySourceLocatorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@EnableKubernetesMockClient class Fabric8SecretsPropertySourceLocatorTests {\n  KubernetesMockServer mockServer;\n  KubernetesClient mockClient;\n  @Test void locateShouldThrowExceptionOnFailureWhenFailFastIsEnabled(){\n    String name\u003d\"my-secret\";\n    String namespace\u003d\"default\";\n    String path\u003d\"/api/v1/namespaces/default/secrets\";\n    mockServer.expect().withPath(path).andReturn(500,\"Internal Server Error\").always();\n    SecretsConfigProperties configMapConfigProperties\u003dnew SecretsConfigProperties(true,Map.of(),List.of(),List.of(),true,name,namespace,false,true,true,RetryProperties.DEFAULT);\n    Fabric8SecretsPropertySourceLocator locator\u003dnew Fabric8SecretsPropertySourceLocator(mockClient,configMapConfigProperties,new KubernetesNamespaceProvider(new MockEnvironment()));\n    assertThatThrownBy(() -\u003e locator.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessageContaining(\"v1/namespaces/default/secrets. Message: Internal Server Error.\");\n  }\n  @Test void locateShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled(){\n    String name\u003d\"my-secret\";\n    String namespace\u003d\"default\";\n    String path\u003d\"/api/v1/namespaces/default/secrets/my-secret\";\n    mockServer.expect().withPath(path).andReturn(500,\"Internal Server Error\").always();\n    SecretsConfigProperties configMapConfigProperties\u003dnew SecretsConfigProperties(true,Map.of(),List.of(),List.of(),true,name,namespace,false,true,false,RetryProperties.DEFAULT);\n    Fabric8SecretsPropertySourceLocator locator\u003dnew Fabric8SecretsPropertySourceLocator(mockClient,configMapConfigProperties,new KubernetesNamespaceProvider(new MockEnvironment()));\n    assertThatNoException().isThrownBy(() -\u003e locator.locate(new MockEnvironment()));\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@EnableKubernetesMockClient class Fabric8SecretsPropertySourceLocatorTests {\n  KubernetesMockServer mockServer;\n  KubernetesClient mockClient;\n  @Test void locateShouldThrowExceptionOnFailureWhenFailFastIsEnabled();\n  @Test void locateShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sanitize_secrets/ConfigDataFabric8ConfigpropsEndpointTests.java",
        "name": "ConfigDataFabric8ConfigpropsEndpointTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sanitize_secrets.ConfigDataFabric8ConfigpropsEndpointTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass ConfigDataFabric8ConfigpropsEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class DefaultSettingsTest extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeConfigMapName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeSecretName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"management.endpoint.configprops.show-values\u003dNEVER\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class ExplicitNever extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeConfigMapName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeSecretName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithoutSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeConfigMapName\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeSecretName\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize-two.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeConfigMapName\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeSecretName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeSecretNameTwo\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass ConfigDataFabric8ConfigpropsEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class DefaultSettingsTest extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"management.endpoint.configprops.show-values\u003dNEVER\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class ExplicitNever extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithoutSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize-two.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sanitize_secrets/SanitizeApp.java",
        "name": "SanitizeApp",
        "modifiers": "@EnableConfigurationProperties(SanitizeProperties.class) @SpringBootApplication",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sanitize_secrets.SanitizeApp",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@EnableConfigurationProperties(SanitizeProperties.class) @SpringBootApplication class SanitizeApp {\n  public static void main(  String[] args){\n    SpringApplication.run(SanitizeApp.class,args);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@EnableConfigurationProperties(SanitizeProperties.class) @SpringBootApplication class SanitizeApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sanitize_secrets/BootstrapFabric8SanitizeEnvEndpointTests.java",
        "name": "BootstrapFabric8SanitizeEnvEndpointTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sanitize_secrets.BootstrapFabric8SanitizeEnvEndpointTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass BootstrapFabric8SanitizeEnvEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class DefaultSettingsTest extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.env.show-values\u003dNEVER\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class ExplicitNever extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithoutSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize-two\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretNameTwo\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass BootstrapFabric8SanitizeEnvEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class DefaultSettingsTest extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.env.show-values\u003dNEVER\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class ExplicitNever extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithoutSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize-two\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sanitize_secrets/ConfigDataFabric8SanitizeEnvEndpointTests.java",
        "name": "ConfigDataFabric8SanitizeEnvEndpointTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sanitize_secrets.ConfigDataFabric8SanitizeEnvEndpointTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass ConfigDataFabric8SanitizeEnvEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\",\"management.endpoints.web.exposure.include\u003d*\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class DefaultSettingsTest extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\",\"management.endpoint.env.show-values\u003dNEVER\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class ExplicitNever extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithoutSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize-two.yaml\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretNameTwo\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass ConfigDataFabric8SanitizeEnvEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\",\"management.endpoints.web.exposure.include\u003d*\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class DefaultSettingsTest extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\",\"management.endpoint.env.show-values\u003dNEVER\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class ExplicitNever extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithoutSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize-two.yaml\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sanitize_secrets/BootstrapFabric8SanitizeConfigpropsEndpointTests.java",
        "name": "BootstrapFabric8SanitizeConfigpropsEndpointTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sanitize_secrets.BootstrapFabric8SanitizeConfigpropsEndpointTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass BootstrapFabric8SanitizeConfigpropsEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class DefaultSettingsTest extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeConfigMapName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeSecretName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.configprops.show-values\u003dNEVER\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class ExplicitNever extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeConfigMapName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeSecretName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithoutSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeConfigMapName\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeSecretName\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize-two\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass(){\n      setUpBeforeClass(mockClient);\n    }\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeConfigMapName\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeSecretName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeSecretNameTwo\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass BootstrapFabric8SanitizeConfigpropsEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class DefaultSettingsTest extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.configprops.show-values\u003dNEVER\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class ExplicitNever extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithoutSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize-two\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @Nested class AlwaysWithSanitizingFunction extends Fabric8SecretsSanitize {\n    private static KubernetesClient mockClient;\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @BeforeAll static void setUpBeforeClass();\n    @Test void test();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sanitize_secrets/SanitizeProperties.java",
        "name": "SanitizeProperties",
        "modifiers": "@ConfigurationProperties(\"sanitize\")",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sanitize_secrets.SanitizeProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"sanitize\") class SanitizeProperties {\n  private String sanitizeSecretName;\n  private String sanitizeSecretNameTwo;\n  private String sanitizeConfigMapName;\n  public String getSanitizeSecretName(){\n    return sanitizeSecretName;\n  }\n  public void setSanitizeSecretName(  String sanitizeSecretName){\n    this.sanitizeSecretName\u003dsanitizeSecretName;\n  }\n  public String getSanitizeConfigMapName(){\n    return sanitizeConfigMapName;\n  }\n  public void setSanitizeConfigMapName(  String sanitizeConfigMapName){\n    this.sanitizeConfigMapName\u003dsanitizeConfigMapName;\n  }\n  public String getSanitizeSecretNameTwo(){\n    return sanitizeSecretNameTwo;\n  }\n  public void setSanitizeSecretNameTwo(  String sanitizeSecretNameTwo){\n    this.sanitizeSecretNameTwo\u003dsanitizeSecretNameTwo;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"sanitize\") class SanitizeProperties {\n  private String sanitizeSecretName;\n  private String sanitizeSecretNameTwo;\n  private String sanitizeConfigMapName;\n  public String getSanitizeSecretName();\n  public void setSanitizeSecretName(  String sanitizeSecretName);\n  public String getSanitizeConfigMapName();\n  public void setSanitizeConfigMapName(  String sanitizeConfigMapName);\n  public String getSanitizeSecretNameTwo();\n  public void setSanitizeSecretNameTwo(  String sanitizeSecretNameTwo);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sanitize_secrets/Fabric8SecretsSanitize.java",
        "name": "Fabric8SecretsSanitize",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sanitize_secrets.Fabric8SecretsSanitize",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class Fabric8SecretsSanitize {\n  private static final String NAMESPACE\u003d\"test\";\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,NAMESPACE);\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Secret secret\u003dnew SecretBuilder().withNewMetadata().withName(\"sanitize-secret\").endMetadata().addToData(\"sanitize.sanitizeSecretName\",Base64.getEncoder().encodeToString(\"sanitizeSecretValue\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(secret).create();\n    Secret secretTwo\u003dnew SecretBuilder().withNewMetadata().withName(\"sanitize-secret-two\").endMetadata().addToData(\"sanitize.sanitizeSecretNameTwo\",Base64.getEncoder().encodeToString(\"sanitizeSecretValueTwo\".getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(secretTwo).create();\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"sanitize-configmap\").endMetadata().addToData(\"sanitize.sanitizeConfigMapName\",\"sanitizeConfigMapValue\").build();\n    mockClient.configMaps().inNamespace(NAMESPACE).resource(configMap).create();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class Fabric8SecretsSanitize {\n  private static final String NAMESPACE\u003d\"test\";\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sanitize_secrets/SanitizeController.java",
        "name": "SanitizeController",
        "modifiers": "@RestController",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sanitize_secrets.SanitizeController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController class SanitizeController {\n  private final SanitizeProperties sanitizeProperties;\n  SanitizeController(  SanitizeProperties sanitizeProperties){\n    this.sanitizeProperties\u003dsanitizeProperties;\n  }\n  @GetMapping(\"/secret\") String secret(){\n    return sanitizeProperties.getSanitizeSecretName();\n  }\n  @GetMapping(\"/configmap\") String configmap(){\n    return sanitizeProperties.getSanitizeConfigMapName();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController class SanitizeController {\n  private final SanitizeProperties sanitizeProperties;\n  SanitizeController(  SanitizeProperties sanitizeProperties);\n  @GetMapping(\"/secret\") String secret();\n  @GetMapping(\"/configmap\") String configmap();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigMapsWithProfilesTests.java",
        "name": "ConfigMapsWithProfilesTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigMapsWithProfilesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\nabstract class ConfigMapsWithProfilesTests {\n  private static final String APPLICATION_NAME\u003d\"configmap-with-profile-example\";\n  @Autowired(required\u003dfalse) Config config;\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    HashMap\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"application.yml\",ConfigMapTestUtil.readResourceFile(\"application-with-profiles.yaml\"));\n    mockClient.configMaps().inNamespace(\"test\").resource(new ConfigMapBuilder().withNewMetadata().withName(APPLICATION_NAME).endMetadata().addToData(data).build()).create();\n  }\n  @Test public void testGreetingEndpoint(){\n    this.webClient.get().uri(\"/api/greeting\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Hello ConfigMap dev, World!\");\n  }\n  @Test public void testFarewellEndpoint(){\n    this.webClient.get().uri(\"/api/farewell\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Goodbye ConfigMap default, World!\");\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\nabstract class ConfigMapsWithProfilesTests {\n  private static final String APPLICATION_NAME\u003d\"configmap-with-profile-example\";\n  @Autowired(required\u003dfalse) Config config;\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient);\n  @Test public void testGreetingEndpoint();\n  @Test public void testFarewellEndpoint();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sources_order/Properties.java",
        "name": "Properties",
        "modifiers": "@ConfigurationProperties(\"my\")",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sources_order.Properties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"my\") class Properties {\n  private String key;\n  private String one;\n  private String two;\n  public String getKey(){\n    return key;\n  }\n  public void setKey(  String key){\n    this.key\u003dkey;\n  }\n  public String getOne(){\n    return one;\n  }\n  public void setOne(  String one){\n    this.one\u003done;\n  }\n  public String getTwo(){\n    return two;\n  }\n  public void setTwo(  String two){\n    this.two\u003dtwo;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"my\") class Properties {\n  private String key;\n  private String one;\n  private String two;\n  public String getKey();\n  public void setKey(  String key);\n  public String getOne();\n  public void setOne(  String one);\n  public String getTwo();\n  public void setTwo(  String two);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sources_order/SourcesOrderApp.java",
        "name": "SourcesOrderApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties(Properties.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sources_order.SourcesOrderApp",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties(Properties.class) class SourcesOrderApp {\n  static void main(  String[] args){\n    SpringApplication.run(SourcesOrderApp.class,args);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties(Properties.class) class SourcesOrderApp {\n  static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sources_order/SourcesOrderTests.java",
        "name": "SourcesOrderTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sources_order.SourcesOrderTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class SourcesOrderTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    SourcesOrderTests.mockClient\u003dmockClient;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e secretData\u003dnew HashMap\u003c\u003e();\n    secretData.put(\"my.key\",Base64.getEncoder().encodeToString(\"from-secret\".getBytes(StandardCharsets.UTF_8)));\n    secretData.put(\"my.one\",Base64.getEncoder().encodeToString(\"one\".getBytes(StandardCharsets.UTF_8)));\n    createSecret(\"my-secret\",secretData);\n    Map\u003cString,String\u003e configMapData\u003dnew HashMap\u003c\u003e();\n    configMapData.put(\"my.key\",\"from-configmap\");\n    configMapData.put(\"my.two\",\"two\");\n    createConfigmap(\"my-configmap\",configMapData);\n  }\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data){\n    mockClient.secrets().inNamespace(\"spring-k8s\").create(new SecretBuilder().withNewMetadata().withName(name).endMetadata().addToData(data).build());\n  }\n  private static void createConfigmap(  String name,  Map\u003cString,String\u003e data){\n    mockClient.configMaps().inNamespace(\"spring-k8s\").create(new ConfigMapBuilder().withNewMetadata().withName(name).endMetadata().addToData(data).build());\n  }\n  /** \n * \u003cpre\u003e 1. There is one secret deployed: my-secret. It has two properties: {my.one\u003done, my.key\u003dfrom-secret} 2. There is one configmap deployed: my-configmap. It has two properties: {my.two\u003dtwo, my.key\u003dfrom-configmap} We invoke three endpoints: /one, /two, /key. The first two prove that both the secret and configmap have been read, the last one proves that config maps have a higher precedence. \u003c/pre\u003e\n */\n  @Test void test(){\n    this.webClient.get().uri(\"/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one\"));\n    this.webClient.get().uri(\"/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n    this.webClient.get().uri(\"/key\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"from-configmap\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class SourcesOrderTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n  private static void createSecret(  String name,  Map\u003cString,String\u003e data);\n  private static void createConfigmap(  String name,  Map\u003cString,String\u003e data);\n  /** \n * \u003cpre\u003e 1. There is one secret deployed: my-secret. It has two properties: {my.one\u003done, my.key\u003dfrom-secret} 2. There is one configmap deployed: my-configmap. It has two properties: {my.two\u003dtwo, my.key\u003dfrom-configmap} We invoke three endpoints: /one, /two, /key. The first two prove that both the secret and configmap have been read, the last one proves that config maps have a higher precedence. \u003c/pre\u003e\n */\n  @Test void test();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sources_order/SourcesOrderController.java",
        "name": "SourcesOrderController",
        "modifiers": "@RestController",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sources_order.SourcesOrderController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController class SourcesOrderController {\n  private final Properties properties;\n  SourcesOrderController(  Properties properties){\n    this.properties\u003dproperties;\n  }\n  @GetMapping(\"/key\") String key(){\n    return properties.getKey();\n  }\n  @GetMapping(\"/one\") String one(){\n    return properties.getOne();\n  }\n  @GetMapping(\"/two\") String two(){\n    return properties.getTwo();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController class SourcesOrderController {\n  private final Properties properties;\n  SourcesOrderController(  Properties properties);\n  @GetMapping(\"/key\") String key();\n  @GetMapping(\"/one\") String one();\n  @GetMapping(\"/two\") String two();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sources_order/ConfigDataSourcesOrderTests.java",
        "name": "ConfigDataSourcesOrderTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.application.name\u003dsources-order\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./sources-order.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sources_order.ConfigDataSourcesOrderTests",
        "extend": "SourcesOrderTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.application.name\u003dsources-order\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./sources-order.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class ConfigDataSourcesOrderTests extends SourcesOrderTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUp(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.application.name\u003dsources-order\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./sources-order.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class ConfigDataSourcesOrderTests extends SourcesOrderTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUp();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/sources_order/BootstrapSourcesOrderTests.java",
        "name": "BootstrapSourcesOrderTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsources-order\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.sources_order.BootstrapSourcesOrderTests",
        "extend": "SourcesOrderTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsources-order\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class BootstrapSourcesOrderTests extends SourcesOrderTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUp(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsources-order\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class BootstrapSourcesOrderTests extends SourcesOrderTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUp();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/BootstrapConfigMapsMixedTests.java",
        "name": "BootstrapConfigMapsMixedTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003d\" + BootstrapConfigMapsMixedTests.APPLICATION_NAME,\"spring.cloud.kubernetes.config.enableApi\u003dtrue\",\"spring.cloud.kubernetes.config.paths\u003d\" + BootstrapConfigMapsMixedTests.FILE_NAME_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.BootstrapConfigMapsMixedTests",
        "extend": "ConfigMapsMixedTests",
        "implements": "",
        "raw": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003d\" + BootstrapConfigMapsMixedTests.APPLICATION_NAME,\"spring.cloud.kubernetes.config.enableApi\u003dtrue\",\"spring.cloud.kubernetes.config.paths\u003d\" + BootstrapConfigMapsMixedTests.FILE_NAME_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapConfigMapsMixedTests extends ConfigMapsMixedTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass() throws IOException {\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.application.name\u003d\" + BootstrapConfigMapsMixedTests.APPLICATION_NAME,\"spring.cloud.kubernetes.config.enableApi\u003dtrue\",\"spring.cloud.kubernetes.config.paths\u003d\" + BootstrapConfigMapsMixedTests.FILE_NAME_FULL_PATH,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BootstrapConfigMapsMixedTests extends ConfigMapsMixedTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass() throws IOException;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigMapsTest.java",
        "name": "ConfigMapsTest",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigMapsTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class ConfigMapsTest {\n  private static KubernetesClient mockClient;\n  @AfterEach void afterEach(){\n    new Fabric8ConfigMapsCache().discardAll();\n  }\n  @Test public void testConfigMapList(){\n    mockClient.configMaps().inNamespace(\"ns1\").resource(new ConfigMapBuilder().withNewMetadata().withName(\"empty\").endMetadata().build()).create();\n    ConfigMapList configMapList\u003dmockClient.configMaps().inNamespace(\"ns1\").list();\n    assertThat(configMapList).isNotNull();\n    assertThat(configMapList.getItems().size()).isEqualTo(1);\n    assertThat(configMapList.getItems().get(0).getData()).isEmpty();\n  }\n  @Test void testConfigMapGet(){\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(\"reload-example\").endMetadata().addToData(\"KEY\",\"123\").build();\n    mockClient.configMaps().inNamespace(\"ns2\").resource(configMap).create();\n    ConfigMapList configMapList\u003dmockClient.configMaps().inNamespace(\"ns2\").list();\n    assertThat(configMapList).isNotNull();\n    assertThat(configMapList.getItems().size()).isEqualTo(1);\n    assertThat(configMapList.getItems().get(0).getData().size()).isEqualTo(1);\n    Map\u003cString,String\u003e resultData\u003dconfigMapList.getItems().get(0).getData();\n    assertThat(resultData.get(\"KEY\")).isEqualTo(\"123\");\n  }\n  @Test void testConfigMapFromSingleApplicationProperties(){\n    String configMapName\u003d\"app-properties-test\";\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(configMapName).endMetadata().addToData(\"application.properties\",ConfigMapTestUtil.readResourceFile(\"application.properties\")).build();\n    mockClient.configMaps().inNamespace(\"test\").resource(configMap).create();\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(configMapName,\"test\",false,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,source,\"\",new MockEnvironment());\n    Fabric8ConfigMapPropertySource cmps\u003dnew Fabric8ConfigMapPropertySource(context);\n    assertThat(cmps.getProperty(\"dummy.property.string1\")).isEqualTo(\"a\");\n    assertThat(cmps.getProperty(\"dummy.property.int1\")).isEqualTo(\"1\");\n    assertThat(cmps.getProperty(\"dummy.property.bool1\")).isEqualTo(\"true\");\n  }\n  @Test void testConfigMapFromSingleApplicationYaml(){\n    String configMapName\u003d\"app-yaml-test\";\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(configMapName).endMetadata().addToData(\"application.yaml\",ConfigMapTestUtil.readResourceFile(\"application.yaml\")).build();\n    mockClient.configMaps().inNamespace(\"test\").resource(configMap).create();\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(configMapName,\"test\",false,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,source,\"\",new MockEnvironment());\n    Fabric8ConfigMapPropertySource cmps\u003dnew Fabric8ConfigMapPropertySource(context);\n    assertThat(cmps.getProperty(\"dummy.property.string2\")).isEqualTo(\"a\");\n    assertThat(cmps.getProperty(\"dummy.property.int2\")).isEqualTo(1);\n    assertThat(cmps.getProperty(\"dummy.property.bool2\")).isEqualTo(true);\n  }\n  @Test void testConfigMapFromSingleNonStandardFileName(){\n    String configMapName\u003d\"single-non-standard-test\";\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(configMapName).endMetadata().addToData(\"adhoc.yml\",ConfigMapTestUtil.readResourceFile(\"adhoc.yml\")).build();\n    mockClient.configMaps().inNamespace(\"test\").resource(configMap).create();\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(configMapName,\"test\",false,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,source,\"\",new MockEnvironment());\n    Fabric8ConfigMapPropertySource cmps\u003dnew Fabric8ConfigMapPropertySource(context);\n    assertThat(cmps.getProperty(\"dummy.property.string3\")).isEqualTo(\"a\");\n    assertThat(cmps.getProperty(\"dummy.property.int3\")).isEqualTo(1);\n    assertThat(cmps.getProperty(\"dummy.property.bool3\")).isEqualTo(true);\n  }\n  @Test void testConfigMapFromSingleInvalidPropertiesContent(){\n    String configMapName\u003d\"single-unparseable-properties-test\";\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(configMapName).endMetadata().addToData(\"application.properties\",\"somevalue\").build();\n    mockClient.configMaps().inNamespace(\"test\").resource(configMap).create();\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(configMapName,\"namespace\",false,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,source,\"\",new MockEnvironment());\n    Fabric8ConfigMapPropertySource cmps\u003dnew Fabric8ConfigMapPropertySource(context);\n  }\n  @Test void testConfigMapFromSingleInvalidYamlContent(){\n    String configMapName\u003d\"single-unparseable-yaml-test\";\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(configMapName).endMetadata().addToData(\"application.yaml\",\"somevalue\").build();\n    mockClient.configMaps().inNamespace(\"test\").resource(configMap).create();\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(configMapName,\"namespace\",false,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,source,\"\",new MockEnvironment());\n    Fabric8ConfigMapPropertySource cmps\u003dnew Fabric8ConfigMapPropertySource(context);\n  }\n  @Test void testConfigMapFromMultipleApplicationProperties(){\n    String configMapName\u003d\"app-multiple-properties-test\";\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(configMapName).endMetadata().addToData(\"application.properties\",ConfigMapTestUtil.readResourceFile(\"application.properties\")).addToData(\"adhoc.properties\",ConfigMapTestUtil.readResourceFile(\"adhoc.properties\")).build();\n    mockClient.configMaps().inNamespace(\"test\").resource(configMap).create();\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(configMapName,\"test\",false,false);\n    Fabric8ConfigContext context\u003dnew Fabric8ConfigContext(mockClient,source,\"\",new MockEnvironment());\n    Fabric8ConfigMapPropertySource cmps\u003dnew Fabric8ConfigMapPropertySource(context);\n    assertThat(cmps.getProperty(\"dummy.property.string1\")).isEqualTo(\"a\");\n    assertThat(cmps.getProperty(\"dummy.property.int1\")).isEqualTo(\"1\");\n    assertThat(cmps.getProperty(\"dummy.property.bool1\")).isEqualTo(\"true\");\n    assertThat(cmps.getProperty(\"dummy.property.bool2\")).isNull();\n    assertThat(cmps.getProperty(\"dummy.property.bool2\")).isNull();\n    assertThat(cmps.getProperty(\"dummy.property.bool2\")).isNull();\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class ConfigMapsTest {\n  private static KubernetesClient mockClient;\n  @AfterEach void afterEach();\n  @Test public void testConfigMapList();\n  @Test void testConfigMapGet();\n  @Test void testConfigMapFromSingleApplicationProperties();\n  @Test void testConfigMapFromSingleApplicationYaml();\n  @Test void testConfigMapFromSingleNonStandardFileName();\n  @Test void testConfigMapFromSingleInvalidPropertiesContent();\n  @Test void testConfigMapFromSingleInvalidYamlContent();\n  @Test void testConfigMapFromMultipleApplicationProperties();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/actuator/DisabledHealthTest.java",
        "name": "DisabledHealthTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dfalse\",\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.actuator.DisabledHealthTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dfalse\",\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\"}) class DisabledHealthTest {\n  @Autowired private ReactiveHealthContributorRegistry registry;\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  @Test void healthEndpointShouldContainKubernetes(){\n    this.webClient.get().uri(\"http://localhost:{port}/actuator/health\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"components.kubernetes\").doesNotExist();\n    Assertions.assertNull(registry.getContributor(\"kubernetes\"),\"reactive kubernetes contributor must NOT be present when \u0027management.health.kubernetes.enabled\u003dfalse\u0027\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dfalse\",\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\"}) class DisabledHealthTest {\n  @Autowired private ReactiveHealthContributorRegistry registry;\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  @Test void healthEndpointShouldContainKubernetes();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/actuator/EnabledHealthTest.java",
        "name": "EnabledHealthTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dtrue\",\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.actuator.EnabledHealthTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dtrue\",\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class EnabledHealthTest {\n  @Autowired private WebTestClient webClient;\n  @Autowired private ReactiveHealthContributorRegistry registry;\n  @LocalManagementPort private int port;\n  @Test void healthEndpointShouldContainKubernetes(){\n    this.webClient.get().uri(\"http://localhost:{port}/actuator/health\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"components.kubernetes\").exists();\n    Assertions.assertNotNull(registry.getContributor(\"kubernetes\"),\"reactive kubernetes contributor must be present when \u0027management.health.kubernetes.enabled\u003dtrue\u0027\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dtrue\",\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class EnabledHealthTest {\n  @Autowired private WebTestClient webClient;\n  @Autowired private ReactiveHealthContributorRegistry registry;\n  @LocalManagementPort private int port;\n  @Test void healthEndpointShouldContainKubernetes();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/CoreTestClientViaSystemProperties.java",
        "name": "CoreTestClientViaSystemProperties",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.CoreTestClientViaSystemProperties",
        "extend": "",
        "implements": "",
        "raw": "abstract class CoreTestClientViaSystemProperties {\n  @Autowired private KubernetesClient client;\n  @BeforeAll public static void setUpBeforeClass(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,\"masterURL\");\n  }\n  @Test public void kubernetesClientBeanShouldBeConfigurableViaSystemProperties(){\n    assertThat(client).isNotNull();\n    assertThat(client.getConfiguration().getMasterUrl()).isEqualTo(\"http://masterURL/\");\n  }\n}\n",
        "abstract": "abstract class CoreTestClientViaSystemProperties {\n  @Autowired private KubernetesClient client;\n  @BeforeAll public static void setUpBeforeClass();\n  @Test public void kubernetesClientBeanShouldBeConfigurableViaSystemProperties();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/secrets_property_source/Fabric8SecretsPropertySourceTest.java",
        "name": "Fabric8SecretsPropertySourceTest",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.secrets_property_source.Fabric8SecretsPropertySourceTest",
        "extend": "",
        "implements": "",
        "raw": "abstract class Fabric8SecretsPropertySourceTest {\n  private static final String NAMESPACE\u003d\"test\";\n  private static final String SECRET_VALUE\u003d\"secretValue\";\n  @Autowired private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @Autowired private Environment environment;\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,NAMESPACE);\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Secret secret\u003dnew SecretBuilder().withNewMetadata().withName(\"test-secret\").withLabels(singletonMap(\"foo\",\"bar\")).endMetadata().addToData(\"secretName\",Base64.getEncoder().encodeToString(SECRET_VALUE.getBytes())).build();\n    mockClient.secrets().inNamespace(NAMESPACE).resource(secret).create();\n  }\n  @Test void toStringShouldNotExposeSecretValues(){\n    PropertySource\u003c?\u003e propertySource\u003dthis.propertySourceLocator.locate(this.environment);\n    assertThat(propertySource.toString()).doesNotContain(SECRET_VALUE);\n    assertThat(propertySource.getProperty(\"secretName\")).isEqualTo(\"secretValue\");\n  }\n}\n",
        "abstract": "abstract class Fabric8SecretsPropertySourceTest {\n  private static final String NAMESPACE\u003d\"test\";\n  private static final String SECRET_VALUE\u003d\"secretValue\";\n  @Autowired private Fabric8SecretsPropertySourceLocator propertySourceLocator;\n  @Autowired private Environment environment;\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n  @Test void toStringShouldNotExposeSecretValues();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/secrets_property_source/ConfigDataFabric8SecretsPropertySourceTest.java",
        "name": "ConfigDataFabric8SecretsPropertySourceTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @TestPropertySource(\"classpath:/application-secrets.properties\") @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.secrets_property_source.ConfigDataFabric8SecretsPropertySourceTest",
        "extend": "Fabric8SecretsPropertySourceTest",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @TestPropertySource(\"classpath:/application-secrets.properties\") @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class ConfigDataFabric8SecretsPropertySourceTest extends Fabric8SecretsPropertySourceTest {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"}) @TestPropertySource(\"classpath:/application-secrets.properties\") @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class ConfigDataFabric8SecretsPropertySourceTest extends Fabric8SecretsPropertySourceTest {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/secrets_property_source/BoostrapFabric8SecretsPropertySourceTest.java",
        "name": "BoostrapFabric8SecretsPropertySourceTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @TestPropertySource(\"classpath:/application-secrets.properties\") @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.secrets_property_source.BoostrapFabric8SecretsPropertySourceTest",
        "extend": "Fabric8SecretsPropertySourceTest",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @TestPropertySource(\"classpath:/application-secrets.properties\") @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class BoostrapFabric8SecretsPropertySourceTest extends Fabric8SecretsPropertySourceTest {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @TestPropertySource(\"classpath:/application-secrets.properties\") @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class BoostrapFabric8SecretsPropertySourceTest extends Fabric8SecretsPropertySourceTest {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigMapsWithActiveProfilesNameTests.java",
        "name": "ConfigMapsWithActiveProfilesNameTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigMapsWithActiveProfilesNameTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ali Shahbour\n */\nabstract class ConfigMapsWithActiveProfilesNameTests {\n  private static final String APPLICATION_NAME\u003d\"configmap-with-active-profile-name-example\";\n  @Autowired(required\u003dfalse) Config config;\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    HashMap\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"application.yml\",readResourceFile(\"application-with-profiles.yaml\"));\n    mockClient.configMaps().inNamespace(\"test\").resource(new ConfigMapBuilder().withNewMetadata().withName(APPLICATION_NAME).endMetadata().addToData(data).build()).create();\n    HashMap\u003cString,String\u003e dataWithName\u003dnew HashMap\u003c\u003e();\n    dataWithName.put(\"application.yml\",readResourceFile(\"application-with-active-profiles-name.yaml\"));\n    mockClient.configMaps().inNamespace(\"test\").resource(new ConfigMapBuilder().withNewMetadata().withName(APPLICATION_NAME + \"-development\").endMetadata().addToData(dataWithName).build()).create();\n  }\n  @Test public void testGreetingEndpoint(){\n    this.webClient.get().uri(\"/api/greeting\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Hello ConfigMap Active Profile Name, World!\");\n  }\n  @Test public void testFarewellEndpoint(){\n    this.webClient.get().uri(\"/api/farewell\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Goodbye ConfigMap default, World!\");\n  }\n}\n",
        "abstract": "/** \n * @author Ali Shahbour\n */\nabstract class ConfigMapsWithActiveProfilesNameTests {\n  private static final String APPLICATION_NAME\u003d\"configmap-with-active-profile-name-example\";\n  @Autowired(required\u003dfalse) Config config;\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient);\n  @Test public void testGreetingEndpoint();\n  @Test public void testFarewellEndpoint();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigDataCoreTestClientViaSystemProperties.java",
        "name": "ConfigDataCoreTestClientViaSystemProperties",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(classes\u003dTestApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.application.name\u003dtestapp\",\"spring.cloud.kubernetes.client.namespace\u003dtestns\",\"spring.cloud.kubernetes.client.trustCerts\u003dtrue\",\"spring.cloud.kubernetes.config.namespace\u003dtestns\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.config.import\u003dkubernetes:\"}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigDataCoreTestClientViaSystemProperties",
        "extend": "CoreTestClientViaSystemProperties",
        "implements": "",
        "raw": "@ExtendWith(SpringExtension.class) @SpringBootTest(classes\u003dTestApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.application.name\u003dtestapp\",\"spring.cloud.kubernetes.client.namespace\u003dtestns\",\"spring.cloud.kubernetes.client.trustCerts\u003dtrue\",\"spring.cloud.kubernetes.config.namespace\u003dtestns\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.config.import\u003dkubernetes:\"}) public class ConfigDataCoreTestClientViaSystemProperties extends CoreTestClientViaSystemProperties {\n}\n",
        "abstract": "@ExtendWith(SpringExtension.class) @SpringBootTest(classes\u003dTestApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.application.name\u003dtestapp\",\"spring.cloud.kubernetes.client.namespace\u003dtestns\",\"spring.cloud.kubernetes.client.trustCerts\u003dtrue\",\"spring.cloud.kubernetes.config.namespace\u003dtestns\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.config.import\u003dkubernetes:\"}) public class ConfigDataCoreTestClientViaSystemProperties extends CoreTestClientViaSystemProperties {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigDataMultipleConfigMapsTests.java",
        "name": "ConfigDataMultipleConfigMapsTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dExampleApp.class,properties\u003d{\"spring.application.name\u003dmultiplecms\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./multiplecms.yml\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigDataMultipleConfigMapsTests",
        "extend": "MultipleConfigMapsTests",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dExampleApp.class,properties\u003d{\"spring.application.name\u003dmultiplecms\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./multiplecms.yml\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataMultipleConfigMapsTests extends MultipleConfigMapsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dExampleApp.class,properties\u003d{\"spring.application.name\u003dmultiplecms\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./multiplecms.yml\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class ConfigDataMultipleConfigMapsTests extends MultipleConfigMapsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/HealthIndicatorTest.java",
        "name": "HealthIndicatorTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoint.health.show-details\u003dalways\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.HealthIndicatorTest",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoint.health.show-details\u003dalways\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class HealthIndicatorTest {\n  private static KubernetesClient mockClient;\n  @LocalManagementPort private int port;\n  @Autowired private WebTestClient webClient;\n  @BeforeAll static void setUpBeforeClass(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @Test void healthEndpointShouldContainKubernetes(){\n    this.webClient.get().uri(\"http://localhost:{port}/actuator/health\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"components.kubernetes\").exists();\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoint.health.show-details\u003dalways\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class HealthIndicatorTest {\n  private static KubernetesClient mockClient;\n  @LocalManagementPort private int port;\n  @Autowired private WebTestClient webClient;\n  @BeforeAll static void setUpBeforeClass();\n  @Test void healthEndpointShouldContainKubernetes();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_profile/properties/Green.java",
        "name": "Green",
        "modifiers": "@ConfigurationProperties(\"green-configmap.green-configmap-k8s.green-configmap-prod.green-purple-configmap.green-purple-configmap-k8s\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_profile.properties.Green",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"green-configmap.green-configmap-k8s.green-configmap-prod.green-purple-configmap.green-purple-configmap-k8s\") public class Green {\n  private String two;\n  private String six;\n  private String seven;\n  private String eight;\n  public String getTwo(){\n    return two;\n  }\n  public void setTwo(  String two){\n    this.two\u003dtwo;\n  }\n  public String getSix(){\n    return six;\n  }\n  public void setSix(  String six){\n    this.six\u003dsix;\n  }\n  public String getSeven(){\n    return seven;\n  }\n  public void setSeven(  String seven){\n    this.seven\u003dseven;\n  }\n  public String getEight(){\n    return eight;\n  }\n  public void setEight(  String eight){\n    this.eight\u003deight;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"green-configmap.green-configmap-k8s.green-configmap-prod.green-purple-configmap.green-purple-configmap-k8s\") public class Green {\n  private String two;\n  private String six;\n  private String seven;\n  private String eight;\n  public String getTwo();\n  public void setTwo(  String two);\n  public String getSix();\n  public void setSix(  String six);\n  public String getSeven();\n  public void setSeven(  String seven);\n  public String getEight();\n  public void setEight(  String eight);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_profile/properties/Blue.java",
        "name": "Blue",
        "modifiers": "@ConfigurationProperties(\"blue\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_profile.properties.Blue",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"blue\") public class Blue {\n  private String one;\n  public String getOne(){\n    return one;\n  }\n  public void setOne(  String one){\n    this.one\u003done;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"blue\") public class Blue {\n  private String one;\n  public String getOne();\n  public void setOne(  String one);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_profile/LabeledConfigMapWithProfileBootstrapTests.java",
        "name": "LabeledConfigMapWithProfileBootstrapTests",
        "modifiers": "@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-configmap-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_profile.LabeledConfigMapWithProfileBootstrapTests",
        "extend": "LabeledConfigMapWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-configmap-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledConfigMapWithProfileBootstrapTests extends LabeledConfigMapWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-configmap-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledConfigMapWithProfileBootstrapTests extends LabeledConfigMapWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_profile/LabeledConfigMapWithProfileConfigDataTests.java",
        "name": "LabeledConfigMapWithProfileConfigDataTests",
        "modifiers": "@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithProfileApp.class,properties\u003d{\"spring.application.name\u003dlabeled-configmap-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-configmap-with-profile.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_profile.LabeledConfigMapWithProfileConfigDataTests",
        "extend": "LabeledConfigMapWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithProfileApp.class,properties\u003d{\"spring.application.name\u003dlabeled-configmap-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-configmap-with-profile.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledConfigMapWithProfileConfigDataTests extends LabeledConfigMapWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithProfileApp.class,properties\u003d{\"spring.application.name\u003dlabeled-configmap-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-configmap-with-profile.yaml\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class LabeledConfigMapWithProfileConfigDataTests extends LabeledConfigMapWithProfileTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_profile/controller/LabeledConfigMapWithProfileController.java",
        "name": "LabeledConfigMapWithProfileController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_profile.controller.LabeledConfigMapWithProfileController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class LabeledConfigMapWithProfileController {\n  private final Blue blue;\n  private final Green green;\n  public LabeledConfigMapWithProfileController(  Blue blue,  Green green){\n    this.blue\u003dblue;\n    this.green\u003dgreen;\n  }\n  @GetMapping(\"/labeled-configmap/profile/blue\") public String blue(){\n    return blue.getOne();\n  }\n  @GetMapping(\"/labeled-configmap/profile/green\") public String green(){\n    return green.getTwo() + \"#\" + green.getSix()+ \"#\"+ green.getSeven()+ \"#\"+ green.getEight();\n  }\n}\n",
        "abstract": "@RestController public class LabeledConfigMapWithProfileController {\n  private final Blue blue;\n  private final Green green;\n  public LabeledConfigMapWithProfileController(  Blue blue,  Green green);\n  @GetMapping(\"/labeled-configmap/profile/blue\") public String blue();\n  @GetMapping(\"/labeled-configmap/profile/green\") public String green();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_profile/LabeledConfigMapWithProfileApp.java",
        "name": "LabeledConfigMapWithProfileApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({Blue.class,Green.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_profile.LabeledConfigMapWithProfileApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({Blue.class,Green.class}) public class LabeledConfigMapWithProfileApp {\n  public static void main(  String[] args){\n    SpringApplication.run(LabeledConfigMapWithProfileApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({Blue.class,Green.class}) public class LabeledConfigMapWithProfileApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/labeled_config_map_with_profile/LabeledConfigMapWithProfileTests.java",
        "name": "LabeledConfigMapWithProfileTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.labeled_config_map_with_profile.LabeledConfigMapWithProfileTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class LabeledConfigMapWithProfileTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  /** \n * \u003cpre\u003e - configmap with name \"color-configmap\", with labels: \"{color: blue}\" and \"explicitPrefix: blue\" - configmap with name \"green-configmap\", with labels: \"{color: green}\" and \"explicitPrefix: blue-again\" - configmap with name \"red-configmap\", with labels \"{color: not-red}\" and \"useNameAsPrefix: true\" - configmap with name \"yellow-configmap\" with labels \"{color: not-yellow}\" and useNameAsPrefix: true - configmap with name \"color-configmap-k8s\", with labels : \"{color: not-blue}\" - configmap with name \"green-configmap-k8s\", with labels : \"{color: green-k8s}\" - configmap with name \"green-configmap-prod\", with labels : \"{color: green-prod}\" # a test that proves order: first read non-profile based configmaps, thus profile based # configmaps override non-profile ones. - configmap with name \"green-purple-configmap\", labels \"{color: green, shape: round}\", data: \"{eight: 8}\" - configmap with name \"green-purple-configmap-k8s\", labels \"{color: black}\", data: \"{eight: eight-ish}\" \u003c/pre\u003e\n */\n  static void setUpBeforeClass(  KubernetesClient mockClient){\n    LabeledConfigMapWithProfileTests.mockClient\u003dmockClient;\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e colorConfigMap\u003dCollections.singletonMap(\"one\",\"1\");\n    createConfigMap(\"color-configmap\",colorConfigMap,Collections.singletonMap(\"color\",\"blue\"));\n    Map\u003cString,String\u003e colorConfigMapK8s\u003dCollections.singletonMap(\"five\",\"5\");\n    createConfigMap(\"color-configmap-k8s\",colorConfigMapK8s,Collections.singletonMap(\"color\",\"not-blue\"));\n    Map\u003cString,String\u003e greenConfigMap\u003dCollections.singletonMap(\"two\",\"2\");\n    createConfigMap(\"green-configmap\",greenConfigMap,Collections.singletonMap(\"color\",\"green\"));\n    Map\u003cString,String\u003e greenConfigMapK8s\u003dCollections.singletonMap(\"six\",\"6\");\n    createConfigMap(\"green-configmap-k8s\",greenConfigMapK8s,Collections.singletonMap(\"color\",\"green-k8s\"));\n    Map\u003cString,String\u003e greenConfigMapProd\u003dCollections.singletonMap(\"seven\",\"7\");\n    createConfigMap(\"green-configmap-prod\",greenConfigMapProd,Collections.singletonMap(\"color\",\"green-prod\"));\n    Map\u003cString,String\u003e redConfigMap\u003dCollections.singletonMap(\"three\",\"3\");\n    createConfigMap(\"red-configmap\",redConfigMap,Collections.singletonMap(\"color\",\"not-red\"));\n    Map\u003cString,String\u003e yellowConfigMap\u003dCollections.singletonMap(\"four\",\"4\");\n    createConfigMap(\"yellow-configmap\",yellowConfigMap,Collections.singletonMap(\"color\",\"not-yellow\"));\n    Map\u003cString,String\u003e greenPurple\u003dCollections.singletonMap(\"eight\",\"8\");\n    createConfigMap(\"green-purple-configmap\",greenPurple,Map.of(\"color\",\"green\",\"shape\",\"round\"));\n    Map\u003cString,String\u003e greenPurpleK8s\u003dCollections.singletonMap(\"eight\",\"eight-ish\");\n    createConfigMap(\"green-purple-configmap-k8s\",greenPurpleK8s,Map.of(\"color\",\"black\"));\n  }\n  private static void createConfigMap(  String name,  Map\u003cString,String\u003e data,  Map\u003cString,String\u003e labels){\n    mockClient.configMaps().inNamespace(\"spring-k8s\").resource(new ConfigMapBuilder().withNewMetadata().withName(name).withLabels(labels).endMetadata().addToData(data).build()).create();\n  }\n  /** \n * \u003cpre\u003e this one is taken from : \"blue.one\". We find \"color-configmap\" by labels, and \"color-configmap-k8s\" exists, but \"includeProfileSpecificSources\u003dfalse\", thus not taken. Since \"explicitPrefix\u003dblue\", we take \"blue.one\" \u003c/pre\u003e\n */\n  @Test void testBlue(){\n    this.webClient.get().uri(\"/labeled-configmap/profile/blue\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"1\"));\n  }\n  /** \n * \u003cpre\u003e this one is taken from : \"green-configmap.green-configmap-k8s.green-configmap-prod.green-purple-configmap.green-purple-configmap-k8s\". We find \"green-configmap\" by labels, also \"green-configmap-k8s\" and \"green-configmap-prod\" exists, because \"includeProfileSpecificSources\u003dtrue\" is set. Also \"green-purple-configmap\" and \"green-purple-configmap-k8s\" are found. \u003c/pre\u003e\n */\n  @Test void testGreen(){\n    this.webClient.get().uri(\"/labeled-configmap/profile/green\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"2#6#7#eight-ish\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class LabeledConfigMapWithProfileTests {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  /** \n * \u003cpre\u003e - configmap with name \"color-configmap\", with labels: \"{color: blue}\" and \"explicitPrefix: blue\" - configmap with name \"green-configmap\", with labels: \"{color: green}\" and \"explicitPrefix: blue-again\" - configmap with name \"red-configmap\", with labels \"{color: not-red}\" and \"useNameAsPrefix: true\" - configmap with name \"yellow-configmap\" with labels \"{color: not-yellow}\" and useNameAsPrefix: true - configmap with name \"color-configmap-k8s\", with labels : \"{color: not-blue}\" - configmap with name \"green-configmap-k8s\", with labels : \"{color: green-k8s}\" - configmap with name \"green-configmap-prod\", with labels : \"{color: green-prod}\" # a test that proves order: first read non-profile based configmaps, thus profile based # configmaps override non-profile ones. - configmap with name \"green-purple-configmap\", labels \"{color: green, shape: round}\", data: \"{eight: 8}\" - configmap with name \"green-purple-configmap-k8s\", labels \"{color: black}\", data: \"{eight: eight-ish}\" \u003c/pre\u003e\n */\n  static void setUpBeforeClass(  KubernetesClient mockClient);\n  private static void createConfigMap(  String name,  Map\u003cString,String\u003e data,  Map\u003cString,String\u003e labels);\n  /** \n * \u003cpre\u003e this one is taken from : \"blue.one\". We find \"color-configmap\" by labels, and \"color-configmap-k8s\" exists, but \"includeProfileSpecificSources\u003dfalse\", thus not taken. Since \"explicitPrefix\u003dblue\", we take \"blue.one\" \u003c/pre\u003e\n */\n  @Test void testBlue();\n  /** \n * \u003cpre\u003e this one is taken from : \"green-configmap.green-configmap-k8s.green-configmap-prod.green-purple-configmap.green-purple-configmap-k8s\". We find \"green-configmap\" by labels, also \"green-configmap-k8s\" and \"green-configmap-prod\" exists, because \"includeProfileSpecificSources\u003dtrue\" is set. Also \"green-purple-configmap\" and \"green-purple-configmap-k8s\" are found. \u003c/pre\u003e\n */\n  @Test void testGreen();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigMapsMixedTests.java",
        "name": "ConfigMapsMixedTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigMapsMixedTests",
        "extend": "",
        "implements": "",
        "raw": "abstract class ConfigMapsMixedTests {\n  protected static final String FILES_ROOT_PATH\u003d\"/tmp/scktests\";\n  protected static final String FILE_NAME\u003d\"application-path.yaml\";\n  protected static final String FILE_NAME_FULL_PATH\u003dFILES_ROOT_PATH + \"/\" + FILE_NAME;\n  protected static final String APPLICATION_NAME\u003d\"configmap-mixed-example\";\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient) throws IOException {\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Files.createDirectories(Paths.get(FILES_ROOT_PATH));\n    ConfigMapTestUtil.createFileWithContent(FILE_NAME_FULL_PATH,ConfigMapTestUtil.readResourceFile(\"application-path.yaml\"));\n    HashMap\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"bean.morning\",\"Buenos Dias ConfigMap, %s\");\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(APPLICATION_NAME).endMetadata().addToData(data).build();\n    mockClient.configMaps().inNamespace(\"test\").resource(configMap).create();\n  }\n  @AfterAll public static void teardownAfterClass(){\n    newArrayList(FILE_NAME_FULL_PATH,FILES_ROOT_PATH).forEach(fn -\u003e {\n      try {\n        Files.delete(Paths.get(fn));\n      }\n catch (      IOException ignored) {\n      }\n    }\n);\n  }\n  @Test public void greetingInputShouldReturnPropertyFromFile(){\n    this.webClient.get().uri(\"/api/greeting\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Hello ConfigMap, World from path\");\n  }\n  @Test public void farewellInputShouldReturnPropertyFromFile(){\n    this.webClient.get().uri(\"/api/farewell\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Bye ConfigMap, World from path\");\n  }\n  @Test public void morningInputShouldReturnPropertyFromApi(){\n    this.webClient.get().uri(\"/api/morning\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Buenos Dias ConfigMap, World\");\n  }\n}\n",
        "abstract": "abstract class ConfigMapsMixedTests {\n  protected static final String FILES_ROOT_PATH\u003d\"/tmp/scktests\";\n  protected static final String FILE_NAME\u003d\"application-path.yaml\";\n  protected static final String FILE_NAME_FULL_PATH\u003dFILES_ROOT_PATH + \"/\" + FILE_NAME;\n  protected static final String APPLICATION_NAME\u003d\"configmap-mixed-example\";\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient) throws IOException;\n  @AfterAll public static void teardownAfterClass();\n  @Test public void greetingInputShouldReturnPropertyFromFile();\n  @Test public void farewellInputShouldReturnPropertyFromFile();\n  @Test public void morningInputShouldReturnPropertyFromApi();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/MultipleSecretsTests.java",
        "name": "MultipleSecretsTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.MultipleSecretsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Haytham Mohamed\n */\nabstract class MultipleSecretsTests {\n  private static final String DEFAULT_NAMESPACE\u003d\"ns1\";\n  private static final String ANOTHER_NAMESPACE\u003d\"ns2\";\n  private static final String SECRET_VALUE_1\u003d\"secretValue-1\";\n  private static final String SECRET_VALUE_2\u003d\"secretValue-2\";\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,DEFAULT_NAMESPACE);\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Map\u003cString,String\u003e metadata1\u003dnew HashMap\u003c\u003e();\n    metadata1.put(\"env\",\"env1\");\n    metadata1.put(\"version\",\"1.0\");\n    Secret secret1\u003dnew SecretBuilder().withNewMetadata().withName(\"name1\").withLabels(metadata1).endMetadata().addToData(\"secrets.secret1\",Base64.getEncoder().encodeToString(SECRET_VALUE_1.getBytes())).build();\n    mockClient.secrets().inNamespace(DEFAULT_NAMESPACE).resource(secret1).create();\n    Map\u003cString,String\u003e metadata2\u003dnew HashMap\u003c\u003e();\n    metadata2.put(\"env\",\"env2\");\n    metadata2.put(\"version\",\"2.0\");\n    Secret secret2\u003dnew SecretBuilder().withNewMetadata().withName(\"name2\").withLabels(metadata2).endMetadata().addToData(\"secrets.secret2\",Base64.getEncoder().encodeToString(SECRET_VALUE_2.getBytes())).build();\n    mockClient.secrets().inNamespace(ANOTHER_NAMESPACE).resource(secret2).create();\n  }\n  @Test public void testSecret1(){\n    assertResponse(\"/secret1\",SECRET_VALUE_1);\n  }\n  @Test public void testSecret2(){\n    assertResponse(\"/secret2\",SECRET_VALUE_2);\n  }\n  private void assertResponse(  String path,  String expectedMessage){\n    this.webClient.get().uri(path).exchange().expectStatus().isOk().expectBody().jsonPath(\"secret\").isEqualTo(expectedMessage);\n  }\n}\n",
        "abstract": "/** \n * @author Haytham Mohamed\n */\nabstract class MultipleSecretsTests {\n  private static final String DEFAULT_NAMESPACE\u003d\"ns1\";\n  private static final String ANOTHER_NAMESPACE\u003d\"ns2\";\n  private static final String SECRET_VALUE_1\u003d\"secretValue-1\";\n  private static final String SECRET_VALUE_2\u003d\"secretValue-2\";\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient);\n  @Test public void testSecret1();\n  @Test public void testSecret2();\n  private void assertResponse(  String path,  String expectedMessage);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/BoostrapMultipleConfigMapsTests.java",
        "name": "BoostrapMultipleConfigMapsTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dExampleApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dmultiplecms\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.BoostrapMultipleConfigMapsTests",
        "extend": "MultipleConfigMapsTests",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dExampleApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dmultiplecms\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BoostrapMultipleConfigMapsTests extends MultipleConfigMapsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass(){\n    setUpBeforeClass(mockClient);\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dExampleApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dmultiplecms\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) public class BoostrapMultipleConfigMapsTests extends MultipleConfigMapsTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll public static void setUpBeforeClass();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigMapsWithProfileExpressionTests.java",
        "name": "ConfigMapsWithProfileExpressionTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigMapsWithProfileExpressionTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Tests reading property from YAML document specified by profile expression.\n */\nabstract class ConfigMapsWithProfileExpressionTests {\n  private static final String APPLICATION_NAME\u003d\"configmap-with-profile-example\";\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    HashMap\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"application.yml\",ConfigMapTestUtil.readResourceFile(\"application-with-profiles.yaml\"));\n    mockClient.configMaps().inNamespace(\"test\").resource(new ConfigMapBuilder().withNewMetadata().withName(APPLICATION_NAME).endMetadata().addToData(data).build()).create();\n  }\n  @Test public void testGreetingEndpoint(){\n    this.webClient.get().uri(\"/api/greeting\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Hello ConfigMap production and us-east, World!\");\n  }\n}\n",
        "abstract": "/** \n * Tests reading property from YAML document specified by profile expression.\n */\nabstract class ConfigMapsWithProfileExpressionTests {\n  private static final String APPLICATION_NAME\u003d\"configmap-with-profile-example\";\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient);\n  @Test public void testGreetingEndpoint();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-config/src/test/java/org/springframework/cloud/kubernetes/fabric8/config/ConfigMapsWithProfilesNoActiveProfileTests.java",
        "name": "ConfigMapsWithProfilesNoActiveProfileTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.config.ConfigMapsWithProfilesNoActiveProfileTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Charles Moulliard\n */\nabstract class ConfigMapsWithProfilesNoActiveProfileTests {\n  private static final String APPLICATION_NAME\u003d\"configmap-with-profile-no-active-profiles-example\";\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    HashMap\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"application.yml\",readResourceFile(\"application-with-profiles.yaml\"));\n    mockClient.configMaps().inNamespace(\"test\").resource(new ConfigMapBuilder().withNewMetadata().withName(APPLICATION_NAME).endMetadata().addToData(data).build()).create();\n  }\n  @Test public void testGreetingEndpoint(){\n    this.webClient.get().uri(\"/api/greeting\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Hello ConfigMap default, World!\");\n  }\n  @Test public void testFarewellEndpoint(){\n    this.webClient.get().uri(\"/api/farewell\").exchange().expectStatus().isOk().expectBody().jsonPath(\"content\").isEqualTo(\"Goodbye ConfigMap default, World!\");\n  }\n}\n",
        "abstract": "/** \n * @author Charles Moulliard\n */\nabstract class ConfigMapsWithProfilesNoActiveProfileTests {\n  private static final String APPLICATION_NAME\u003d\"configmap-with-profile-no-active-profiles-example\";\n  @Autowired private WebTestClient webClient;\n  public static void setUpBeforeClass(  KubernetesClient mockClient);\n  @Test public void testGreetingEndpoint();\n  @Test public void testFarewellEndpoint();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesCatalogWatch.java",
        "name": "KubernetesCatalogWatch",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesCatalogWatch",
        "extend": "",
        "implements": "ApplicationEventPublisherAware",
        "raw": "/** \n * @author Oleg Vyukov\n */\npublic class KubernetesCatalogWatch implements ApplicationEventPublisherAware {\n  private static final String DISCOVERY_GROUP_VERSION\u003dDISCOVERY_GROUP + \"/\" + DISCOVERY_VERSION;\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesCatalogWatch.class));\n  private final Fabric8CatalogWatchContext context;\n  private Function\u003cFabric8CatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e stateGenerator;\n  private volatile List\u003cEndpointNameAndNamespace\u003e catalogEndpointsState\u003dnull;\n  private ApplicationEventPublisher publisher;\n  public KubernetesCatalogWatch(  KubernetesClient kubernetesClient,  KubernetesDiscoveryProperties properties,  KubernetesNamespaceProvider namespaceProvider){\n    context\u003dnew Fabric8CatalogWatchContext(kubernetesClient,properties,namespaceProvider);\n  }\n  @Override public void setApplicationEventPublisher(  ApplicationEventPublisher publisher){\n    this.publisher\u003dpublisher;\n  }\n  @Scheduled(fixedDelayString\u003d\"${\" + CATALOG_WATCH_PROPERTY_WITH_DEFAULT_VALUE + \"}\") public void catalogServicesWatch(){\n    try {\n      List\u003cEndpointNameAndNamespace\u003e currentState\u003dstateGenerator.apply(context);\n      if (!currentState.equals(catalogEndpointsState)) {\n        LOG.debug(() -\u003e \"Received endpoints update from kubernetesClient: \" + currentState);\n        publisher.publishEvent(new HeartbeatEvent(this,currentState));\n      }\n      catalogEndpointsState\u003dcurrentState;\n    }\n catch (    Exception e) {\n      LOG.error(e,() -\u003e \"Error watching Kubernetes Services\");\n    }\n  }\n  @PostConstruct void postConstruct(){\n    stateGenerator\u003dstateGenerator();\n  }\n  Function\u003cFabric8CatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e stateGenerator(){\n    Function\u003cFabric8CatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e localStateGenerator;\n    if (context.properties().useEndpointSlices()) {\n      KubernetesClient client\u003dcontext.kubernetesClient();\n      boolean found\u003dclient.getApiGroups().getGroups().stream().flatMap(x -\u003e x.getVersions().stream()).map(GroupVersionForDiscovery::getGroupVersion).filter(DISCOVERY_GROUP_VERSION::equals).findFirst().map(client::getApiResources).map(APIResourceList::getResources).map(x -\u003e x.stream().map(APIResource::getKind)).flatMap(x -\u003e x.filter(y -\u003e y.equals(ENDPOINT_SLICE)).findFirst()).isPresent();\n      if (!found) {\n        throw new IllegalArgumentException(\"EndpointSlices are not supported on the cluster\");\n      }\n else {\n        localStateGenerator\u003dnew Fabric8EndpointSliceV1CatalogWatch();\n      }\n    }\n else {\n      localStateGenerator\u003dnew Fabric8EndpointsCatalogWatch();\n    }\n    LOG.debug(() -\u003e \"stateGenerator is of type: \" + localStateGenerator.getClass().getSimpleName());\n    return localStateGenerator;\n  }\n}\n",
        "abstract": "/** \n * @author Oleg Vyukov\n */\npublic class KubernetesCatalogWatch implements ApplicationEventPublisherAware {\n  private static final String DISCOVERY_GROUP_VERSION\u003dDISCOVERY_GROUP + \"/\" + DISCOVERY_VERSION;\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesCatalogWatch.class));\n  private final Fabric8CatalogWatchContext context;\n  private Function\u003cFabric8CatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e stateGenerator;\n  private volatile List\u003cEndpointNameAndNamespace\u003e catalogEndpointsState\u003dnull;\n  private ApplicationEventPublisher publisher;\n  public KubernetesCatalogWatch(  KubernetesClient kubernetesClient,  KubernetesDiscoveryProperties properties,  KubernetesNamespaceProvider namespaceProvider);\n  @Override public void setApplicationEventPublisher(  ApplicationEventPublisher publisher);\n  @Scheduled(fixedDelayString\u003d\"${\" + CATALOG_WATCH_PROPERTY_WITH_DEFAULT_VALUE + \"}\") public void catalogServicesWatch();\n  @PostConstruct void postConstruct();\n  Function\u003cFabric8CatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e stateGenerator();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8DiscoveryServicesAdapter.java",
        "name": "Fabric8DiscoveryServicesAdapter",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8DiscoveryServicesAdapter",
        "extend": "",
        "implements": "Function\u003cKubernetesClient,List\u003cService\u003e\u003e",
        "raw": "/** \n * Adapts a  {@link KubernetesClientServicesFunction} to a Function that takes aKubernetesClient as input and returns a List of Services(s), plus adds functionality not supported by it.\n * @author wind57\n */\nfinal class Fabric8DiscoveryServicesAdapter implements Function\u003cKubernetesClient,List\u003cService\u003e\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8DiscoveryServicesAdapter.class));\n  private static final SpelExpressionParser PARSER\u003dnew SpelExpressionParser();\n  private static final SimpleEvaluationContext EVALUATION_CONTEXT\u003dSimpleEvaluationContext.forReadOnlyDataBinding().withInstanceMethods().build();\n  private final KubernetesClientServicesFunction function;\n  private final KubernetesDiscoveryProperties properties;\n  private final Predicate\u003cService\u003e filter;\n  Fabric8DiscoveryServicesAdapter(  KubernetesClientServicesFunction function,  KubernetesDiscoveryProperties properties,  Predicate\u003cService\u003e filter){\n    this.function\u003dfunction;\n    this.properties\u003dproperties;\n    if (filter \u003d\u003d null) {\n      this.filter\u003dfilter();\n    }\n else {\n      this.filter\u003dfilter;\n    }\n  }\n  @Override public List\u003cService\u003e apply(  KubernetesClient client){\n    if (!properties.namespaces().isEmpty()) {\n      LOG.debug(() -\u003e \"searching in namespaces : \" + properties.namespaces() + \" with filter : \"+ properties.filter());\n      List\u003cService\u003e services\u003dnew ArrayList\u003c\u003e();\n      properties.namespaces().forEach(namespace -\u003e services.addAll(client.services().inNamespace(namespace).withLabels(properties.serviceLabels()).list().getItems().stream().filter(filter).toList()));\n      return services;\n    }\n    return function.apply(client).list().getItems().stream().filter(filter).toList();\n  }\n  Predicate\u003cService\u003e filter(){\n    String spelExpression\u003dproperties.filter();\n    Predicate\u003cService\u003e predicate;\n    if (spelExpression \u003d\u003d null || spelExpression.isEmpty()) {\n      predicate\u003dservice -\u003e true;\n    }\n else {\n      Expression filterExpr\u003dPARSER.parseExpression(spelExpression);\n      predicate\u003dservice -\u003e {\n        Boolean include\u003dfilterExpr.getValue(EVALUATION_CONTEXT,service,Boolean.class);\n        return Optional.ofNullable(include).orElse(false);\n      }\n;\n    }\n    return predicate;\n  }\n}\n",
        "abstract": "/** \n * Adapts a  {@link KubernetesClientServicesFunction} to a Function that takes aKubernetesClient as input and returns a List of Services(s), plus adds functionality not supported by it.\n * @author wind57\n */\nfinal class Fabric8DiscoveryServicesAdapter implements Function\u003cKubernetesClient,List\u003cService\u003e\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8DiscoveryServicesAdapter.class));\n  private static final SpelExpressionParser PARSER\u003dnew SpelExpressionParser();\n  private static final SimpleEvaluationContext EVALUATION_CONTEXT\u003dSimpleEvaluationContext.forReadOnlyDataBinding().withInstanceMethods().build();\n  private final KubernetesClientServicesFunction function;\n  private final KubernetesDiscoveryProperties properties;\n  private final Predicate\u003cService\u003e filter;\n  Fabric8DiscoveryServicesAdapter(  KubernetesClientServicesFunction function,  KubernetesDiscoveryProperties properties,  Predicate\u003cService\u003e filter);\n  @Override public List\u003cService\u003e apply(  KubernetesClient client);\n  Predicate\u003cService\u003e filter();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesDiscoveryClient.java",
        "name": "KubernetesDiscoveryClient",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesDiscoveryClient",
        "extend": "",
        "implements": "DiscoveryClient EnvironmentAware",
        "raw": "/** \n * Fabric8 Kubernetes implementation of  {@link DiscoveryClient}.\n * @author Ioannis Canellos\n * @author Tim Ysewyn\n */\npublic class KubernetesDiscoveryClient implements DiscoveryClient, EnvironmentAware {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesDiscoveryClient.class));\n  private final KubernetesDiscoveryProperties properties;\n  private final KubernetesClientServicesFunction kubernetesClientServicesFunction;\n  private final ServicePortSecureResolver servicePortSecureResolver;\n  private final Fabric8DiscoveryServicesAdapter adapter;\n  private KubernetesClient client;\n  private KubernetesNamespaceProvider namespaceProvider;\n  public KubernetesDiscoveryClient(  KubernetesClient client,  KubernetesDiscoveryProperties kubernetesDiscoveryProperties,  KubernetesClientServicesFunction kubernetesClientServicesFunction){\n    this(client,kubernetesDiscoveryProperties,kubernetesClientServicesFunction,null,new ServicePortSecureResolver(kubernetesDiscoveryProperties));\n  }\n  KubernetesDiscoveryClient(  KubernetesClient client,  KubernetesDiscoveryProperties kubernetesDiscoveryProperties,  KubernetesClientServicesFunction kubernetesClientServicesFunction,  Predicate\u003cService\u003e filter,  ServicePortSecureResolver servicePortSecureResolver){\n    this.client\u003dclient;\n    this.properties\u003dkubernetesDiscoveryProperties;\n    this.servicePortSecureResolver\u003dservicePortSecureResolver;\n    this.kubernetesClientServicesFunction\u003dkubernetesClientServicesFunction;\n    this.adapter\u003dnew Fabric8DiscoveryServicesAdapter(kubernetesClientServicesFunction,kubernetesDiscoveryProperties,filter);\n  }\n  public KubernetesClient getClient(){\n    return this.client;\n  }\n  public void setClient(  KubernetesClient client){\n    this.client\u003dclient;\n  }\n  @Override public String description(){\n    return \"Fabric8 Kubernetes Discovery Client\";\n  }\n  @Override public List\u003cServiceInstance\u003e getInstances(  String serviceId){\n    Objects.requireNonNull(serviceId);\n    List\u003cEndpoints\u003e allEndpoints\u003dgetEndPointsList(serviceId).stream().toList();\n    List\u003cServiceInstance\u003e instances\u003dnew ArrayList\u003c\u003e();\n    for (    Endpoints endpoints : allEndpoints) {\n      instances.addAll(serviceInstances(endpoints,serviceId));\n    }\n    if (properties.includeExternalNameServices()) {\n      LOG.debug(() -\u003e \"Searching for \u0027ExternalName\u0027 type of services with serviceId : \" + serviceId);\n      List\u003cService\u003e services\u003dservices(properties,client,namespaceProvider,s -\u003e s.getSpec().getType().equals(EXTERNAL_NAME),Map.of(\"metadata.name\",serviceId),\"fabric8-discovery\");\n      for (      Service service : services) {\n        ServiceMetadata serviceMetadata\u003dserviceMetadata(service);\n        Map\u003cString,String\u003e serviceInstanceMetadata\u003dserviceInstanceMetadata(Map.of(),serviceMetadata,properties);\n        Fabric8InstanceIdHostPodNameSupplier supplierOne\u003dexternalName(service);\n        Fabric8PodLabelsAndAnnotationsSupplier supplierTwo\u003dexternalName();\n        ServiceInstance externalNameServiceInstance\u003dserviceInstance(null,serviceMetadata,supplierOne,supplierTwo,new ServicePortNameAndNumber(-1,null),serviceInstanceMetadata,properties);\n        instances.add(externalNameServiceInstance);\n      }\n    }\n    return instances;\n  }\n  public List\u003cEndpoints\u003e getEndPointsList(  String serviceId){\n    return endpoints(properties,client,namespaceProvider,\"fabric8-discovery\",serviceId,adapter.filter());\n  }\n  private List\u003cServiceInstance\u003e serviceInstances(  Endpoints endpoints,  String serviceId){\n    List\u003cEndpointSubset\u003e subsets\u003dendpoints.getSubsets();\n    if (subsets.isEmpty()) {\n      LOG.debug(() -\u003e \"serviceId : \" + serviceId + \" does not have any subsets\");\n      return List.of();\n    }\n    String namespace\u003dendpoints.getMetadata().getNamespace();\n    List\u003cServiceInstance\u003e instances\u003dnew ArrayList\u003c\u003e();\n    Service service\u003dclient.services().inNamespace(namespace).withName(serviceId).get();\n    ServiceMetadata serviceMetadata\u003dserviceMetadata(service);\n    Map\u003cString,Integer\u003e portsData\u003dendpointSubsetsPortData(subsets);\n    Map\u003cString,String\u003e serviceInstanceMetadata\u003dserviceInstanceMetadata(portsData,serviceMetadata,properties);\n    for (    EndpointSubset endpointSubset : subsets) {\n      Map\u003cString,Integer\u003e endpointsPortData\u003dendpointSubsetsPortData(List.of(endpointSubset));\n      ServicePortNameAndNumber portData\u003dendpointsPort(endpointsPortData,serviceMetadata,properties);\n      List\u003cEndpointAddress\u003e addresses\u003daddresses(endpointSubset,properties);\n      for (      EndpointAddress endpointAddress : addresses) {\n        Fabric8InstanceIdHostPodNameSupplier supplierOne\u003dnonExternalName(endpointAddress,service);\n        Fabric8PodLabelsAndAnnotationsSupplier supplierTwo\u003dnonExternalName(client,namespace);\n        ServiceInstance serviceInstance\u003dserviceInstance(servicePortSecureResolver,serviceMetadata,supplierOne,supplierTwo,portData,serviceInstanceMetadata,properties);\n        instances.add(serviceInstance);\n      }\n    }\n    return instances;\n  }\n  @Override public List\u003cString\u003e getServices(){\n    List\u003cString\u003e services\u003dadapter.apply(client).stream().map(s -\u003e s.getMetadata().getName()).distinct().toList();\n    LOG.debug(() -\u003e \"will return services : \" + services);\n    return services;\n  }\n  @Deprecated(forRemoval\u003dtrue) public List\u003cString\u003e getServices(  Predicate\u003cService\u003e filter){\n    return new Fabric8DiscoveryServicesAdapter(kubernetesClientServicesFunction,properties,filter).apply(client).stream().map(s -\u003e s.getMetadata().getName()).distinct().toList();\n  }\n  @Override public int getOrder(){\n    return properties.order();\n  }\n  @Deprecated(forRemoval\u003dtrue) @Override public final void setEnvironment(  Environment environment){\n    namespaceProvider\u003dnew KubernetesNamespaceProvider(environment);\n  }\n}\n",
        "abstract": "/** \n * Fabric8 Kubernetes implementation of  {@link DiscoveryClient}.\n * @author Ioannis Canellos\n * @author Tim Ysewyn\n */\npublic class KubernetesDiscoveryClient implements DiscoveryClient, EnvironmentAware {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesDiscoveryClient.class));\n  private final KubernetesDiscoveryProperties properties;\n  private final KubernetesClientServicesFunction kubernetesClientServicesFunction;\n  private final ServicePortSecureResolver servicePortSecureResolver;\n  private final Fabric8DiscoveryServicesAdapter adapter;\n  private KubernetesClient client;\n  private KubernetesNamespaceProvider namespaceProvider;\n  public KubernetesDiscoveryClient(  KubernetesClient client,  KubernetesDiscoveryProperties kubernetesDiscoveryProperties,  KubernetesClientServicesFunction kubernetesClientServicesFunction);\n  KubernetesDiscoveryClient(  KubernetesClient client,  KubernetesDiscoveryProperties kubernetesDiscoveryProperties,  KubernetesClientServicesFunction kubernetesClientServicesFunction,  Predicate\u003cService\u003e filter,  ServicePortSecureResolver servicePortSecureResolver);\n  public KubernetesClient getClient();\n  public void setClient(  KubernetesClient client);\n  @Override public String description();\n  @Override public List\u003cServiceInstance\u003e getInstances(  String serviceId);\n  public List\u003cEndpoints\u003e getEndPointsList(  String serviceId);\n  private List\u003cServiceInstance\u003e serviceInstances(  Endpoints endpoints,  String serviceId);\n  @Override public List\u003cString\u003e getServices();\n  @Deprecated(forRemoval\u003dtrue) public List\u003cString\u003e getServices(  Predicate\u003cService\u003e filter);\n  @Override public int getOrder();\n  @Deprecated(forRemoval\u003dtrue) @Override public final void setEnvironment(  Environment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesCatalogWatchAutoConfiguration.java",
        "name": "KubernetesCatalogWatchAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesCatalogWatcherEnabled @AutoConfigureAfter({Fabric8AutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesCatalogWatchAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Auto configuration for catalog watcher.\n * @author Tim Ysewyn\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesCatalogWatcherEnabled @AutoConfigureAfter({Fabric8AutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public class KubernetesCatalogWatchAutoConfiguration {\n  @Bean @ConditionalOnMissingBean public KubernetesCatalogWatch kubernetesCatalogWatch(  KubernetesClient client,  KubernetesDiscoveryProperties properties,  Environment environment){\n    return new KubernetesCatalogWatch(client,properties,new KubernetesNamespaceProvider(environment));\n  }\n}\n",
        "abstract": "/** \n * Auto configuration for catalog watcher.\n * @author Tim Ysewyn\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesCatalogWatcherEnabled @AutoConfigureAfter({Fabric8AutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public class KubernetesCatalogWatchAutoConfiguration {\n  @Bean @ConditionalOnMissingBean public KubernetesCatalogWatch kubernetesCatalogWatch(  KubernetesClient client,  KubernetesDiscoveryProperties properties,  Environment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8EndpointsCatalogWatch.java",
        "name": "Fabric8EndpointsCatalogWatch",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8EndpointsCatalogWatch",
        "extend": "",
        "implements": "Function\u003cFabric8CatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e",
        "raw": "/** \n * Implementation that is based on Endpoints.\n * @author wind57\n */\nfinal class Fabric8EndpointsCatalogWatch implements Function\u003cFabric8CatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e {\n  @Override public List\u003cEndpointNameAndNamespace\u003e apply(  Fabric8CatalogWatchContext context){\n    List\u003cEndpoints\u003e endpoints\u003dendpoints(context.properties(),context.kubernetesClient(),context.namespaceProvider(),\"catalog-watcher\",null,ALWAYS_TRUE);\n    Stream\u003cObjectReference\u003e references\u003dendpoints.stream().map(Endpoints::getSubsets).filter(Objects::nonNull).flatMap(List::stream).map(EndpointSubset::getAddresses).filter(Objects::nonNull).flatMap(List::stream).map(EndpointAddress::getTargetRef);\n    return Fabric8CatalogWatchContext.state(references);\n  }\n}\n",
        "abstract": "/** \n * Implementation that is based on Endpoints.\n * @author wind57\n */\nfinal class Fabric8EndpointsCatalogWatch implements Function\u003cFabric8CatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e {\n  @Override public List\u003cEndpointNameAndNamespace\u003e apply(  Fabric8CatalogWatchContext context);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8InstanceIdHostPodNameSupplier.java",
        "name": "Fabric8InstanceIdHostPodNameSupplier",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8InstanceIdHostPodNameSupplier",
        "extend": "",
        "implements": "Supplier\u003cInstanceIdHostPodName\u003e",
        "raw": "/** \n * computes instanceId, host and podName. All needed when calculating ServiceInstance.\n * @author wind57\n */\nfinal class Fabric8InstanceIdHostPodNameSupplier implements Supplier\u003cInstanceIdHostPodName\u003e {\n  private final EndpointAddress endpointAddress;\n  private final Service service;\n  private Fabric8InstanceIdHostPodNameSupplier(  EndpointAddress endpointAddress,  Service service){\n    this.endpointAddress\u003dendpointAddress;\n    this.service\u003dservice;\n  }\n  @Override public InstanceIdHostPodName get(){\n    return new InstanceIdHostPodName(instanceId(),host(),podName());\n  }\n  /** \n * to be used when .spec.type of the Service is !\u003d \u0027ExternalName\u0027.\n */\n  static Fabric8InstanceIdHostPodNameSupplier nonExternalName(  EndpointAddress endpointAddress,  Service service){\n    return new Fabric8InstanceIdHostPodNameSupplier(endpointAddress,service);\n  }\n  /** \n * to be used when .spec.type of the Service is \u003d\u003d \u0027ExternalName\u0027.\n */\n  static Fabric8InstanceIdHostPodNameSupplier externalName(  Service service){\n    return new Fabric8InstanceIdHostPodNameSupplier(null,service);\n  }\n  private String instanceId(){\n    return Optional.ofNullable(endpointAddress).map(EndpointAddress::getTargetRef).map(ObjectReference::getUid).orElseGet(() -\u003e service.getMetadata().getUid());\n  }\n  private String host(){\n    return Optional.ofNullable(endpointAddress).map(EndpointAddress::getIp).orElseGet(() -\u003e service.getSpec().getExternalName());\n  }\n  private String podName(){\n    return Optional.ofNullable(endpointAddress).map(EndpointAddress::getTargetRef).filter(objectReference -\u003e \"Pod\".equals(objectReference.getKind())).map(ObjectReference::getName).orElse(null);\n  }\n}\n",
        "abstract": "/** \n * computes instanceId, host and podName. All needed when calculating ServiceInstance.\n * @author wind57\n */\nfinal class Fabric8InstanceIdHostPodNameSupplier implements Supplier\u003cInstanceIdHostPodName\u003e {\n  private final EndpointAddress endpointAddress;\n  private final Service service;\n  private Fabric8InstanceIdHostPodNameSupplier(  EndpointAddress endpointAddress,  Service service);\n  @Override public InstanceIdHostPodName get();\n  /** \n * to be used when .spec.type of the Service is !\u003d \u0027ExternalName\u0027.\n */\n  static Fabric8InstanceIdHostPodNameSupplier nonExternalName(  EndpointAddress endpointAddress,  Service service);\n  /** \n * to be used when .spec.type of the Service is \u003d\u003d \u0027ExternalName\u0027.\n */\n  static Fabric8InstanceIdHostPodNameSupplier externalName(  Service service);\n  private String instanceId();\n  private String host();\n  private String podName();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/reactive/KubernetesReactiveDiscoveryClientAutoConfiguration.java",
        "name": "KubernetesReactiveDiscoveryClientAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesReactiveDiscovery @AutoConfigureBefore({SimpleReactiveDiscoveryClientAutoConfiguration.class,ReactiveCommonsClientAutoConfiguration.class}) @AutoConfigureAfter({ReactiveCompositeDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.reactive.KubernetesReactiveDiscoveryClientAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Auto configuration for reactive discovery client.\n * @author Tim Ysewyn\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesReactiveDiscovery @AutoConfigureBefore({SimpleReactiveDiscoveryClientAutoConfiguration.class,ReactiveCommonsClientAutoConfiguration.class}) @AutoConfigureAfter({ReactiveCompositeDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public class KubernetesReactiveDiscoveryClientAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesReactiveDiscoveryClientAutoConfiguration.class));\n  @Bean @ConditionalOnMissingBean public KubernetesClientServicesFunction servicesFunction(  KubernetesDiscoveryProperties properties,  Environment environment){\n    return KubernetesClientServicesFunctionProvider.servicesFunction(properties,environment);\n  }\n  @Bean @ConditionalOnMissingBean public KubernetesReactiveDiscoveryClient kubernetesReactiveDiscoveryClient(  KubernetesClient client,  KubernetesDiscoveryProperties properties,  KubernetesClientServicesFunction kubernetesClientServicesFunction){\n    return new KubernetesReactiveDiscoveryClient(client,properties,kubernetesClientServicesFunction);\n  }\n  /** \n * Post an event so that health indicator is initialized.\n */\n  @Bean @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.health.ReactiveHealthIndicator\") @ConditionalOnDiscoveryHealthIndicatorEnabled KubernetesDiscoveryClientHealthIndicatorInitializer reactiveIndicatorInitializer(  ApplicationEventPublisher applicationEventPublisher,  PodUtils\u003c?\u003e podUtils){\n    LOG.debug(() -\u003e \"Will publish InstanceRegisteredEvent from reactive implementation\");\n    return new KubernetesDiscoveryClientHealthIndicatorInitializer(podUtils,applicationEventPublisher);\n  }\n  @Bean @ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer public ReactiveDiscoveryClientHealthIndicator kubernetesReactiveDiscoveryClientHealthIndicator(  KubernetesReactiveDiscoveryClient client,  DiscoveryClientHealthIndicatorProperties properties){\n    return new ReactiveDiscoveryClientHealthIndicator(client,properties);\n  }\n}\n",
        "abstract": "/** \n * Auto configuration for reactive discovery client.\n * @author Tim Ysewyn\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesReactiveDiscovery @AutoConfigureBefore({SimpleReactiveDiscoveryClientAutoConfiguration.class,ReactiveCommonsClientAutoConfiguration.class}) @AutoConfigureAfter({ReactiveCompositeDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public class KubernetesReactiveDiscoveryClientAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesReactiveDiscoveryClientAutoConfiguration.class));\n  @Bean @ConditionalOnMissingBean public KubernetesClientServicesFunction servicesFunction(  KubernetesDiscoveryProperties properties,  Environment environment);\n  @Bean @ConditionalOnMissingBean public KubernetesReactiveDiscoveryClient kubernetesReactiveDiscoveryClient(  KubernetesClient client,  KubernetesDiscoveryProperties properties,  KubernetesClientServicesFunction kubernetesClientServicesFunction);\n  /** \n * Post an event so that health indicator is initialized.\n */\n  @Bean @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.health.ReactiveHealthIndicator\") @ConditionalOnDiscoveryHealthIndicatorEnabled KubernetesDiscoveryClientHealthIndicatorInitializer reactiveIndicatorInitializer(  ApplicationEventPublisher applicationEventPublisher,  PodUtils\u003c?\u003e podUtils);\n  @Bean @ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer public ReactiveDiscoveryClientHealthIndicator kubernetesReactiveDiscoveryClientHealthIndicator(  KubernetesReactiveDiscoveryClient client,  DiscoveryClientHealthIndicatorProperties properties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/reactive/KubernetesReactiveDiscoveryClient.java",
        "name": "KubernetesReactiveDiscoveryClient",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.reactive.KubernetesReactiveDiscoveryClient",
        "extend": "",
        "implements": "ReactiveDiscoveryClient",
        "raw": "/** \n * Kubernetes implementation of  {@link ReactiveDiscoveryClient}. Currently relies on the {@link KubernetesDiscoveryClient} for feature parity.\n * @author Tim Ysewyn\n */\npublic class KubernetesReactiveDiscoveryClient implements ReactiveDiscoveryClient {\n  private final KubernetesDiscoveryClient kubernetesDiscoveryClient;\n  public KubernetesReactiveDiscoveryClient(  KubernetesClient client,  KubernetesDiscoveryProperties properties,  KubernetesClientServicesFunction kubernetesClientServicesFunction){\n    this.kubernetesDiscoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,kubernetesClientServicesFunction);\n  }\n  @Override public String description(){\n    return \"Fabric8 Kubernetes Reactive Discovery Client\";\n  }\n  @Override public Flux\u003cServiceInstance\u003e getInstances(  String serviceId){\n    Assert.notNull(serviceId,\"[Assertion failed] - the object argument must not be null\");\n    return Flux.defer(() -\u003e Flux.fromIterable(kubernetesDiscoveryClient.getInstances(serviceId))).subscribeOn(Schedulers.boundedElastic());\n  }\n  @Override public Flux\u003cString\u003e getServices(){\n    return Flux.defer(() -\u003e Flux.fromIterable(kubernetesDiscoveryClient.getServices())).subscribeOn(Schedulers.boundedElastic());\n  }\n}\n",
        "abstract": "/** \n * Kubernetes implementation of  {@link ReactiveDiscoveryClient}. Currently relies on the {@link KubernetesDiscoveryClient} for feature parity.\n * @author Tim Ysewyn\n */\npublic class KubernetesReactiveDiscoveryClient implements ReactiveDiscoveryClient {\n  private final KubernetesDiscoveryClient kubernetesDiscoveryClient;\n  public KubernetesReactiveDiscoveryClient(  KubernetesClient client,  KubernetesDiscoveryProperties properties,  KubernetesClientServicesFunction kubernetesClientServicesFunction);\n  @Override public String description();\n  @Override public Flux\u003cServiceInstance\u003e getInstances(  String serviceId);\n  @Override public Flux\u003cString\u003e getServices();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesDiscoveryClientConfigClientBootstrapConfiguration.java",
        "name": "KubernetesDiscoveryClientConfigClientBootstrapConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(\"spring.cloud.config.discovery.enabled\") @Import({Fabric8AutoConfiguration.class,KubernetesDiscoveryClientAutoConfiguration.class}) @EnableConfigurationProperties({KubernetesDiscoveryProperties.class,KubernetesClientProperties.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesDiscoveryClientConfigClientBootstrapConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Bootstrap config for Kubernetes discovery config client.\n * @author Zhanwei Wang\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(\"spring.cloud.config.discovery.enabled\") @Import({Fabric8AutoConfiguration.class,KubernetesDiscoveryClientAutoConfiguration.class}) @EnableConfigurationProperties({KubernetesDiscoveryProperties.class,KubernetesClientProperties.class}) public class KubernetesDiscoveryClientConfigClientBootstrapConfiguration {\n}\n",
        "abstract": "/** \n * Bootstrap config for Kubernetes discovery config client.\n * @author Zhanwei Wang\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(\"spring.cloud.config.discovery.enabled\") @Import({Fabric8AutoConfiguration.class,KubernetesDiscoveryClientAutoConfiguration.class}) @EnableConfigurationProperties({KubernetesDiscoveryProperties.class,KubernetesClientProperties.class}) public class KubernetesDiscoveryClientConfigClientBootstrapConfiguration {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8ConfigServerBootstrapper.java",
        "name": "Fabric8ConfigServerBootstrapper",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8ConfigServerBootstrapper",
        "extend": "KubernetesConfigServerBootstrapper",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass Fabric8ConfigServerBootstrapper extends KubernetesConfigServerBootstrapper {\n  @Override public void initialize(  BootstrapRegistry registry){\n    if (hasConfigServerInstanceProvider()) {\n      return;\n    }\n    registry.registerIfAbsent(KubernetesDiscoveryProperties.class,context -\u003e {\n      if (!getDiscoveryEnabled(context)) {\n        return null;\n      }\n      return createKubernetesDiscoveryProperties(context);\n    }\n);\n    registry.registerIfAbsent(KubernetesClientProperties.class,context -\u003e {\n      if (!getDiscoveryEnabled(context)) {\n        return null;\n      }\n      return createKubernetesClientProperties(context);\n    }\n);\n    registry.registerIfAbsent(ConfigServerInstanceProvider.Function.class,context -\u003e {\n      if (!getDiscoveryEnabled(context)) {\n        return (id) -\u003e Collections.emptyList();\n      }\n      if (context.isRegistered(KubernetesDiscoveryClient.class)) {\n        KubernetesDiscoveryClient client\u003dcontext.get(KubernetesDiscoveryClient.class);\n        return client::getInstances;\n      }\n else {\n        PropertyResolver propertyResolver\u003dgetPropertyResolver(context);\n        Fabric8AutoConfiguration fabric8AutoConfiguration\u003dnew Fabric8AutoConfiguration();\n        Config config\u003dfabric8AutoConfiguration.kubernetesClientConfig(context.get(KubernetesClientProperties.class));\n        KubernetesClient kubernetesClient\u003dfabric8AutoConfiguration.kubernetesClient(config);\n        KubernetesDiscoveryProperties discoveryProperties\u003dcontext.get(KubernetesDiscoveryProperties.class);\n        KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(kubernetesClient,discoveryProperties,KubernetesClientServicesFunctionProvider.servicesFunction(discoveryProperties,new KubernetesNamespaceProvider(propertyResolver.get(KubernetesNamespaceProvider.NAMESPACE_PROPERTY,String.class,null))),null,new ServicePortSecureResolver(discoveryProperties));\n        return discoveryClient::getInstances;\n      }\n    }\n);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass Fabric8ConfigServerBootstrapper extends KubernetesConfigServerBootstrapper {\n  @Override public void initialize(  BootstrapRegistry registry);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesClientServicesFunction.java",
        "name": "KubernetesClientServicesFunction",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesClientServicesFunction",
        "extend": "",
        "implements": "Function\u003cKubernetesClient,FilterWatchListDeletable\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e\u003e",
        "raw": "/** \n * A regular java.util.function that is used to hide the complexity of the KubernetesClient interfaces. It\u0027s meant to be used to abstract things like: client.services() client.services().withLabel(\"key\", \"value\") client.services().withoutLabel(\"key\") The result of the application of the function can then be used for example to list the services like so: function.apply(client).list() See KubernetesDiscoveryClientAutoConfiguration.servicesFunction\n * @author Georgios Andrianakis\n */\npublic interface KubernetesClientServicesFunction extends Function\u003cKubernetesClient,FilterWatchListDeletable\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e\u003e {\n}\n",
        "abstract": "/** \n * A regular java.util.function that is used to hide the complexity of the KubernetesClient interfaces. It\u0027s meant to be used to abstract things like: client.services() client.services().withLabel(\"key\", \"value\") client.services().withoutLabel(\"key\") The result of the application of the function can then be used for example to list the services like so: function.apply(client).list() See KubernetesDiscoveryClientAutoConfiguration.servicesFunction\n * @author Georgios Andrianakis\n */\npublic interface KubernetesClientServicesFunction extends Function\u003cKubernetesClient,FilterWatchListDeletable\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e\u003e {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8KubernetesDiscoveryClientUtils.java",
        "name": "Fabric8KubernetesDiscoveryClientUtils",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8KubernetesDiscoveryClientUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class Fabric8KubernetesDiscoveryClientUtils {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8KubernetesDiscoveryClientUtils.class));\n  static final Predicate\u003cService\u003e ALWAYS_TRUE\u003dx -\u003e true;\n  private Fabric8KubernetesDiscoveryClientUtils(){\n  }\n  static List\u003cEndpoints\u003e endpoints(  KubernetesDiscoveryProperties properties,  KubernetesClient client,  KubernetesNamespaceProvider namespaceProvider,  String target,  @Nullable String serviceName,  Predicate\u003cService\u003e filter){\n    List\u003cEndpoints\u003e endpoints;\n    if (!properties.namespaces().isEmpty()) {\n      LOG.debug(() -\u003e \"discovering endpoints in namespaces : \" + properties.namespaces());\n      List\u003cEndpoints\u003e inner\u003dnew ArrayList\u003c\u003e(properties.namespaces().size());\n      properties.namespaces().forEach(namespace -\u003e inner.addAll(filteredEndpoints(client.endpoints().inNamespace(namespace).withNewFilter(),properties,serviceName)));\n      endpoints\u003dinner;\n    }\n else     if (properties.allNamespaces()) {\n      LOG.debug(() -\u003e \"discovering endpoints in all namespaces\");\n      endpoints\u003dfilteredEndpoints(client.endpoints().inAnyNamespace().withNewFilter(),properties,serviceName);\n    }\n else {\n      String namespace\u003dFabric8Utils.getApplicationNamespace(client,null,target,namespaceProvider);\n      LOG.debug(() -\u003e \"discovering endpoints in namespace : \" + namespace);\n      endpoints\u003dfilteredEndpoints(client.endpoints().inNamespace(namespace).withNewFilter(),properties,serviceName);\n    }\n    return withFilter(endpoints,properties,client,filter);\n  }\n  static List\u003cEndpoints\u003e withFilter(  List\u003cEndpoints\u003e endpoints,  KubernetesDiscoveryProperties properties,  KubernetesClient client,  Predicate\u003cService\u003e filter){\n    if (properties.filter() \u003d\u003d null || properties.filter().isBlank() || filter \u003d\u003d ALWAYS_TRUE) {\n      LOG.debug(() -\u003e \"filter not present\");\n      return endpoints;\n    }\n    List\u003cEndpoints\u003e result\u003dnew ArrayList\u003c\u003e();\n    Map\u003cString,List\u003cEndpoints\u003e\u003e endpointsByNamespace\u003dendpoints.stream().collect(Collectors.groupingBy(x -\u003e x.getMetadata().getNamespace()));\n    for (    Map.Entry\u003cString,List\u003cEndpoints\u003e\u003e entry : endpointsByNamespace.entrySet()) {\n      Set\u003cString\u003e filteredServiceNames\u003dclient.services().inNamespace(entry.getKey()).list().getItems().stream().filter(filter).map(service -\u003e service.getMetadata().getName()).collect(Collectors.toSet());\n      result.addAll(entry.getValue().stream().filter(endpoint -\u003e filteredServiceNames.contains(endpoint.getMetadata().getName())).toList());\n    }\n    return result;\n  }\n  /** \n * serviceName can be null, in which case the filter for \"metadata.name\" will not be applied.\n */\n  static List\u003cEndpoints\u003e filteredEndpoints(  FilterNested\u003cFilterWatchListDeletable\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e\u003e filterNested,  KubernetesDiscoveryProperties properties,  @Nullable String serviceName){\n    FilterNested\u003cFilterWatchListDeletable\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e\u003e partial\u003dfilterNested.withLabels(properties.serviceLabels());\n    if (serviceName !\u003d null) {\n      partial\u003dpartial.withField(\"metadata.name\",serviceName);\n    }\n    return partial.endFilter().list().getItems();\n  }\n  static List\u003cEndpointAddress\u003e addresses(  EndpointSubset endpointSubset,  KubernetesDiscoveryProperties properties){\n    List\u003cEndpointAddress\u003e addresses\u003dOptional.ofNullable(endpointSubset.getAddresses()).map(ArrayList::new).orElse(new ArrayList\u003c\u003e());\n    if (properties.includeNotReadyAddresses()) {\n      List\u003cEndpointAddress\u003e notReadyAddresses\u003dendpointSubset.getNotReadyAddresses();\n      if (CollectionUtils.isEmpty(notReadyAddresses)) {\n        return addresses;\n      }\n      addresses.addAll(notReadyAddresses);\n    }\n    return addresses;\n  }\n  static List\u003cService\u003e services(  KubernetesDiscoveryProperties properties,  KubernetesClient client,  KubernetesNamespaceProvider namespaceProvider,  Predicate\u003cService\u003e predicate,  Map\u003cString,String\u003e fieldFilters,  String target){\n    List\u003cService\u003e services;\n    if (properties.allNamespaces()) {\n      LOG.debug(() -\u003e \"discovering services in all namespaces\");\n      services\u003dfilteredServices(client.services().inAnyNamespace().withNewFilter(),properties,predicate,fieldFilters);\n    }\n else     if (!properties.namespaces().isEmpty()) {\n      LOG.debug(() -\u003e \"discovering services in namespaces : \" + properties.namespaces());\n      List\u003cService\u003e inner\u003dnew ArrayList\u003c\u003e(properties.namespaces().size());\n      properties.namespaces().forEach(namespace -\u003e inner.addAll(filteredServices(client.services().inNamespace(namespace).withNewFilter(),properties,predicate,fieldFilters)));\n      services\u003dinner;\n    }\n else {\n      String namespace\u003dFabric8Utils.getApplicationNamespace(client,null,target,namespaceProvider);\n      LOG.debug(() -\u003e \"discovering services in namespace : \" + namespace);\n      services\u003dfilteredServices(client.services().inNamespace(namespace).withNewFilter(),properties,predicate,fieldFilters);\n    }\n    return services;\n  }\n  /** \n * a service is allowed to have a single port defined without a name.\n */\n  static Map\u003cString,Integer\u003e endpointSubsetsPortData(  List\u003cEndpointSubset\u003e endpointSubsets){\n    return endpointSubsets.stream().flatMap(endpointSubset -\u003e endpointSubset.getPorts().stream()).collect(Collectors.toMap(endpointPort -\u003e hasText(endpointPort.getName()) ? endpointPort.getName() : UNSET_PORT_NAME,EndpointPort::getPort));\n  }\n  /** \n * serviceName can be null, in which case, such a filter will not be applied.\n */\n  private static List\u003cService\u003e filteredServices(  FilterNested\u003cFilterWatchListDeletable\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e\u003e filterNested,  KubernetesDiscoveryProperties properties,  Predicate\u003cService\u003e predicate,  @Nullable Map\u003cString,String\u003e fieldFilters){\n    FilterNested\u003cFilterWatchListDeletable\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e\u003e partial\u003dfilterNested.withLabels(properties.serviceLabels());\n    if (fieldFilters !\u003d null) {\n      partial\u003dpartial.withFields(fieldFilters);\n    }\n    return partial.endFilter().list().getItems().stream().filter(predicate).toList();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class Fabric8KubernetesDiscoveryClientUtils {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8KubernetesDiscoveryClientUtils.class));\n  static final Predicate\u003cService\u003e ALWAYS_TRUE\u003dx -\u003e true;\n  private Fabric8KubernetesDiscoveryClientUtils();\n  static List\u003cEndpoints\u003e endpoints(  KubernetesDiscoveryProperties properties,  KubernetesClient client,  KubernetesNamespaceProvider namespaceProvider,  String target,  @Nullable String serviceName,  Predicate\u003cService\u003e filter);\n  static List\u003cEndpoints\u003e withFilter(  List\u003cEndpoints\u003e endpoints,  KubernetesDiscoveryProperties properties,  KubernetesClient client,  Predicate\u003cService\u003e filter);\n  /** \n * serviceName can be null, in which case the filter for \"metadata.name\" will not be applied.\n */\n  static List\u003cEndpoints\u003e filteredEndpoints(  FilterNested\u003cFilterWatchListDeletable\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e\u003e filterNested,  KubernetesDiscoveryProperties properties,  @Nullable String serviceName);\n  static List\u003cEndpointAddress\u003e addresses(  EndpointSubset endpointSubset,  KubernetesDiscoveryProperties properties);\n  static List\u003cService\u003e services(  KubernetesDiscoveryProperties properties,  KubernetesClient client,  KubernetesNamespaceProvider namespaceProvider,  Predicate\u003cService\u003e predicate,  Map\u003cString,String\u003e fieldFilters,  String target);\n  /** \n * a service is allowed to have a single port defined without a name.\n */\n  static Map\u003cString,Integer\u003e endpointSubsetsPortData(  List\u003cEndpointSubset\u003e endpointSubsets);\n  /** \n * serviceName can be null, in which case, such a filter will not be applied.\n */\n  private static List\u003cService\u003e filteredServices(  FilterNested\u003cFilterWatchListDeletable\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e\u003e filterNested,  KubernetesDiscoveryProperties properties,  Predicate\u003cService\u003e predicate,  @Nullable Map\u003cString,String\u003e fieldFilters);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8EndpointSliceV1CatalogWatch.java",
        "name": "Fabric8EndpointSliceV1CatalogWatch",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8EndpointSliceV1CatalogWatch",
        "extend": "",
        "implements": "Function\u003cFabric8CatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e",
        "raw": "/** \n * Implementation that is based on EndpointSlice V1.\n * @author wind57\n */\nfinal class Fabric8EndpointSliceV1CatalogWatch implements Function\u003cFabric8CatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8EndpointSliceV1CatalogWatch.class));\n  @Override public List\u003cEndpointNameAndNamespace\u003e apply(  Fabric8CatalogWatchContext context){\n    List\u003cEndpointSlice\u003e endpointSlices;\n    KubernetesClient client\u003dcontext.kubernetesClient();\n    if (context.properties().allNamespaces()) {\n      LOG.debug(() -\u003e \"discovering endpoint slices in all namespaces\");\n      endpointSlices\u003dclient.discovery().v1().endpointSlices().inAnyNamespace().withLabels(context.properties().serviceLabels()).list().getItems();\n    }\n else     if (!context.properties().namespaces().isEmpty()) {\n      LOG.debug(() -\u003e \"discovering endpoint slices in \" + context.properties().namespaces());\n      List\u003cEndpointSlice\u003e inner\u003dnew ArrayList\u003c\u003e(context.properties().namespaces().size());\n      context.properties().namespaces().forEach(namespace -\u003e inner.addAll(endpointSlices(context,namespace,client)));\n      endpointSlices\u003dinner;\n    }\n else {\n      String namespace\u003dFabric8Utils.getApplicationNamespace(context.kubernetesClient(),null,\"catalog-watcher\",context.namespaceProvider());\n      LOG.debug(() -\u003e \"discovering endpoint slices in namespace : \" + namespace);\n      endpointSlices\u003dendpointSlices(context,namespace,client);\n    }\n    Stream\u003cObjectReference\u003e references\u003dendpointSlices.stream().map(EndpointSlice::getEndpoints).flatMap(List::stream).map(Endpoint::getTargetRef);\n    return Fabric8CatalogWatchContext.state(references);\n  }\n  private List\u003cEndpointSlice\u003e endpointSlices(  Fabric8CatalogWatchContext context,  String namespace,  KubernetesClient client){\n    return client.discovery().v1().endpointSlices().inNamespace(namespace).withLabels(context.properties().serviceLabels()).list().getItems();\n  }\n}\n",
        "abstract": "/** \n * Implementation that is based on EndpointSlice V1.\n * @author wind57\n */\nfinal class Fabric8EndpointSliceV1CatalogWatch implements Function\u003cFabric8CatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8EndpointSliceV1CatalogWatch.class));\n  @Override public List\u003cEndpointNameAndNamespace\u003e apply(  Fabric8CatalogWatchContext context);\n  private List\u003cEndpointSlice\u003e endpointSlices(  Fabric8CatalogWatchContext context,  String namespace,  KubernetesClient client);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesDiscoveryClientAutoConfiguration.java",
        "name": "KubernetesDiscoveryClientAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesBlockingDiscovery @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({Fabric8AutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesDiscoveryClientAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Auto configuration for discovery clients.\n * @author Mauricio Salatino\n * @author Tim Ysewyn\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesBlockingDiscovery @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({Fabric8AutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public class KubernetesDiscoveryClientAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesDiscoveryClientAutoConfiguration.class));\n  @Bean @ConditionalOnMissingBean public KubernetesClientServicesFunction servicesFunction(  KubernetesDiscoveryProperties properties,  Environment environment){\n    return KubernetesClientServicesFunctionProvider.servicesFunction(properties,environment);\n  }\n  @Bean @ConditionalOnMissingBean public KubernetesDiscoveryClient kubernetesDiscoveryClient(  KubernetesClient client,  KubernetesDiscoveryProperties properties,  KubernetesClientServicesFunction kubernetesClientServicesFunction){\n    return new KubernetesDiscoveryClient(client,properties,kubernetesClientServicesFunction,null,new ServicePortSecureResolver(properties));\n  }\n  @Bean @ConditionalOnSpringCloudKubernetesBlockingDiscoveryHealthInitializer public KubernetesDiscoveryClientHealthIndicatorInitializer indicatorInitializer(  ApplicationEventPublisher applicationEventPublisher,  PodUtils\u003c?\u003e podUtils){\n    LOG.debug(() -\u003e \"Will publish InstanceRegisteredEvent from blocking implementation\");\n    return new KubernetesDiscoveryClientHealthIndicatorInitializer(podUtils,applicationEventPublisher);\n  }\n}\n",
        "abstract": "/** \n * Auto configuration for discovery clients.\n * @author Mauricio Salatino\n * @author Tim Ysewyn\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesBlockingDiscovery @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({Fabric8AutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public class KubernetesDiscoveryClientAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesDiscoveryClientAutoConfiguration.class));\n  @Bean @ConditionalOnMissingBean public KubernetesClientServicesFunction servicesFunction(  KubernetesDiscoveryProperties properties,  Environment environment);\n  @Bean @ConditionalOnMissingBean public KubernetesDiscoveryClient kubernetesDiscoveryClient(  KubernetesClient client,  KubernetesDiscoveryProperties properties,  KubernetesClientServicesFunction kubernetesClientServicesFunction);\n  @Bean @ConditionalOnSpringCloudKubernetesBlockingDiscoveryHealthInitializer public KubernetesDiscoveryClientHealthIndicatorInitializer indicatorInitializer(  ApplicationEventPublisher applicationEventPublisher,  PodUtils\u003c?\u003e podUtils);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8PodLabelsAndAnnotationsSupplier.java",
        "name": "Fabric8PodLabelsAndAnnotationsSupplier",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8PodLabelsAndAnnotationsSupplier",
        "extend": "",
        "implements": "Function\u003cString,PodLabelsAndAnnotations\u003e",
        "raw": "/** \n * A way to get labels and annotations from a podName.\n * @author wind57\n */\nfinal class Fabric8PodLabelsAndAnnotationsSupplier implements Function\u003cString,PodLabelsAndAnnotations\u003e {\n  private final KubernetesClient client;\n  private final String namespace;\n  private Fabric8PodLabelsAndAnnotationsSupplier(  KubernetesClient client,  String namespace){\n    this.client\u003dclient;\n    this.namespace\u003dnamespace;\n  }\n  /** \n * to be used when .spec.type of the Service is !\u003d \u0027ExternalName\u0027.\n */\n  static Fabric8PodLabelsAndAnnotationsSupplier nonExternalName(  KubernetesClient client,  String namespace){\n    return new Fabric8PodLabelsAndAnnotationsSupplier(client,namespace);\n  }\n  /** \n * to be used when .spec.type of the Service is \u003d\u003d \u0027ExternalName\u0027.\n */\n  static Fabric8PodLabelsAndAnnotationsSupplier externalName(){\n    return new Fabric8PodLabelsAndAnnotationsSupplier(null,null);\n  }\n  @Override public PodLabelsAndAnnotations apply(  String podName){\n    ObjectMeta metadata\u003dOptional.ofNullable(client.pods().inNamespace(namespace).withName(podName).get()).map(Pod::getMetadata).orElse(new ObjectMeta());\n    return new PodLabelsAndAnnotations(metadata.getLabels(),metadata.getAnnotations());\n  }\n}\n",
        "abstract": "/** \n * A way to get labels and annotations from a podName.\n * @author wind57\n */\nfinal class Fabric8PodLabelsAndAnnotationsSupplier implements Function\u003cString,PodLabelsAndAnnotations\u003e {\n  private final KubernetesClient client;\n  private final String namespace;\n  private Fabric8PodLabelsAndAnnotationsSupplier(  KubernetesClient client,  String namespace);\n  /** \n * to be used when .spec.type of the Service is !\u003d \u0027ExternalName\u0027.\n */\n  static Fabric8PodLabelsAndAnnotationsSupplier nonExternalName(  KubernetesClient client,  String namespace);\n  /** \n * to be used when .spec.type of the Service is \u003d\u003d \u0027ExternalName\u0027.\n */\n  static Fabric8PodLabelsAndAnnotationsSupplier externalName();\n  @Override public PodLabelsAndAnnotations apply(  String podName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesClientServicesFunctionProvider.java",
        "name": "KubernetesClientServicesFunctionProvider",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesClientServicesFunctionProvider",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic final class KubernetesClientServicesFunctionProvider {\n  private KubernetesClientServicesFunctionProvider(){\n  }\n  public static KubernetesClientServicesFunction servicesFunction(  KubernetesDiscoveryProperties properties,  Environment environment){\n    if (properties.allNamespaces()) {\n      return (client) -\u003e client.services().inAnyNamespace().withLabels(properties.serviceLabels());\n    }\n    return client -\u003e {\n      String namespace\u003dFabric8Utils.getApplicationNamespace(client,null,\"discovery-service\",new KubernetesNamespaceProvider(environment));\n      return client.services().inNamespace(namespace).withLabels(properties.serviceLabels());\n    }\n;\n  }\n  @Deprecated(forRemoval\u003dtrue) public static KubernetesClientServicesFunction servicesFunction(  KubernetesDiscoveryProperties properties,  Binder binder,  BindHandler bindHandler){\n    return servicesFunction(properties,new KubernetesNamespaceProvider(binder,bindHandler));\n  }\n  public static KubernetesClientServicesFunction servicesFunction(  KubernetesDiscoveryProperties properties,  KubernetesNamespaceProvider namespaceProvider){\n    if (properties.allNamespaces()) {\n      return (client) -\u003e client.services().inAnyNamespace().withLabels(properties.serviceLabels());\n    }\n    return client -\u003e {\n      String namespace\u003dFabric8Utils.getApplicationNamespace(client,null,\"discovery-service\",namespaceProvider);\n      return client.services().inNamespace(namespace).withLabels(properties.serviceLabels());\n    }\n;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic final class KubernetesClientServicesFunctionProvider {\n  private KubernetesClientServicesFunctionProvider();\n  public static KubernetesClientServicesFunction servicesFunction(  KubernetesDiscoveryProperties properties,  Environment environment);\n  @Deprecated(forRemoval\u003dtrue) public static KubernetesClientServicesFunction servicesFunction(  KubernetesDiscoveryProperties properties,  Binder binder,  BindHandler bindHandler);\n  public static KubernetesClientServicesFunction servicesFunction(  KubernetesDiscoveryProperties properties,  KubernetesNamespaceProvider namespaceProvider);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8KubernetesDiscoveryClientServiceWithoutPortNameTests.java",
        "name": "Fabric8KubernetesDiscoveryClientServiceWithoutPortNameTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8KubernetesDiscoveryClientServiceWithoutPortNameTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8KubernetesDiscoveryClientServiceWithoutPortNameTests {\n  private static final String NAMESPACE\u003d\"spring-k8s\";\n  private static KubernetesClient mockClient;\n  @Test void testDiscoveryWithoutAServicePortName(){\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withPorts(new ServicePortBuilder().withPort(8080).build()).build()).withMetadata(new ObjectMetaBuilder().withName(\"no-port-name-service\").withNamespace(NAMESPACE).build()).withSpec(new ServiceSpecBuilder().withType(\"ClusterIP\").build()).build();\n    mockClient.services().inNamespace(NAMESPACE).resource(service).create();\n    Endpoints endpoints\u003dnew EndpointsBuilder().withSubsets(new EndpointSubsetBuilder().withPorts(new EndpointPortBuilder().withPort(8080).build()).withAddresses(new EndpointAddressBuilder().withIp(\"127.0.0.1\").build()).build()).withMetadata(new ObjectMetaBuilder().withName(\"no-port-name-service\").withNamespace(NAMESPACE).build()).build();\n    mockClient.endpoints().inNamespace(NAMESPACE).resource(endpoints).create();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(NAMESPACE),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,properties,a -\u003e null);\n    List\u003cServiceInstance\u003e serviceInstances\u003ddiscoveryClient.getInstances(\"no-port-name-service\");\n    Assertions.assertEquals(serviceInstances.size(),1);\n    Assertions.assertEquals(serviceInstances.get(0).getMetadata(),Map.of(\"port.\u003cunset\u003e\",\"8080\",\"k8s_namespace\",\"spring-k8s\",\"type\",\"ClusterIP\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8KubernetesDiscoveryClientServiceWithoutPortNameTests {\n  private static final String NAMESPACE\u003d\"spring-k8s\";\n  private static KubernetesClient mockClient;\n  @Test void testDiscoveryWithoutAServicePortName();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesDiscoveryClientAutoConfigurationApplicationContextTests.java",
        "name": "KubernetesDiscoveryClientAutoConfigurationApplicationContextTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesDiscoveryClientAutoConfigurationApplicationContextTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Test various conditionals for  {@link KubernetesDiscoveryClientAutoConfiguration}\n * @author wind57\n */\nclass KubernetesDiscoveryClientAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  @Test void discoveryEnabledDefault(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n    }\n);\n  }\n  @Test void discoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n    }\n);\n  }\n  @Test void discoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesClientServicesFunction.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesClientServicesFunction.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryBlockingEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryBlockingDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesClientServicesFunction.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryHealthIndicatorEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryHealthIndicatorDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryHealthIndicatorEnabledHealthIndicatorMissing(){\n    setupWithFilteredClassLoader(HealthIndicator.class,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n    }\n);\n  }\n  /** \n * reactive is disabled and should not impact blocking in any way\n */\n  @Test void reactiveDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n    }\n);\n  }\n  private void setup(  String... properties){\n    applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesDiscoveryClientAutoConfiguration.class,Fabric8AutoConfiguration.class,KubernetesCommonsAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class)).withPropertyValues(properties);\n  }\n  private void setupWithFilteredClassLoader(  Class\u003c?\u003e cls,  String... properties){\n    applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesDiscoveryClientAutoConfiguration.class,Fabric8AutoConfiguration.class,KubernetesCommonsAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class)).withClassLoader(new FilteredClassLoader(cls)).withPropertyValues(properties);\n  }\n}\n",
        "abstract": "/** \n * Test various conditionals for  {@link KubernetesDiscoveryClientAutoConfiguration}\n * @author wind57\n */\nclass KubernetesDiscoveryClientAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  @Test void discoveryEnabledDefault();\n  @Test void discoveryEnabled();\n  @Test void discoveryDisabled();\n  @Test void kubernetesDiscoveryEnabled();\n  @Test void kubernetesDiscoveryDisabled();\n  @Test void kubernetesDiscoveryBlockingEnabled();\n  @Test void kubernetesDiscoveryBlockingDisabled();\n  @Test void kubernetesDiscoveryHealthIndicatorEnabled();\n  @Test void kubernetesDiscoveryHealthIndicatorDisabled();\n  @Test void kubernetesDiscoveryHealthIndicatorEnabledHealthIndicatorMissing();\n  /** \n * reactive is disabled and should not impact blocking in any way\n */\n  @Test void reactiveDisabled();\n  private void setup(  String... properties);\n  private void setupWithFilteredClassLoader(  Class\u003c?\u003e cls,  String... properties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8DiscoveryServicesAdapterTests.java",
        "name": "Fabric8DiscoveryServicesAdapterTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8DiscoveryServicesAdapterTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8DiscoveryServicesAdapterTests {\n  private static KubernetesClient client;\n  private static MockedStatic\u003cFabric8Utils\u003e utils;\n  @BeforeEach void beforeEach(){\n    utils\u003dMockito.mockStatic(Fabric8Utils.class);\n  }\n  @AfterEach void afterEach(){\n    client.services().inAnyNamespace().delete();\n    utils.close();\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - labels \u003d {} - filter \u003d null - serviceA exists in namespaceA with labels \u003d {color\u003dred} - serviceB exists in namespaceB with labels \u003d {color\u003dblue} - we get both services as a result. \u003c/pre\u003e\n */\n  @Test void testAllNamespacesWithoutLabelsWithoutFilter(){\n    boolean allNamespaces\u003dtrue;\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    String spelFilter\u003dnull;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,allNamespaces,Set.of(),true,60L,false,spelFilter,Set.of(),labels,null,null,0,false);\n    Fabric8DiscoveryServicesAdapter adapter\u003dnew Fabric8DiscoveryServicesAdapter(new KubernetesDiscoveryClientAutoConfiguration().servicesFunction(properties,environment),properties,null);\n    service(\"namespaceA\",\"serviceA\",Map.of(\"color\",\"red\"));\n    service(\"namespaceB\",\"serviceB\",Map.of(\"color\",\"blue\"));\n    List\u003cService\u003e result\u003dadapter.apply(client);\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceA\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"namespaceA\");\n    Assertions.assertEquals(result.get(1).getMetadata().getName(),\"serviceB\");\n    Assertions.assertEquals(result.get(1).getMetadata().getNamespace(),\"namespaceB\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - labels \u003d {color\u003dred} - filter \u003d null - serviceA exists in namespaceA with labels \u003d {color\u003dred} - serviceB exists in namespaceB with labels \u003d {color\u003dblue} - we get only serviceA as a result. \u003c/pre\u003e\n */\n  @Test void testAllNamespacesWithLabelsWithoutFilter(){\n    boolean allNamespaces\u003dtrue;\n    Map\u003cString,String\u003e labels\u003dMap.of(\"color\",\"red\");\n    String spelFilter\u003dnull;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,allNamespaces,Set.of(),true,60L,false,spelFilter,Set.of(),labels,null,null,0,false);\n    Fabric8DiscoveryServicesAdapter adapter\u003dnew Fabric8DiscoveryServicesAdapter(new KubernetesDiscoveryClientAutoConfiguration().servicesFunction(properties,environment),properties,null);\n    service(\"namespaceA\",\"serviceA\",Map.of(\"color\",\"red\"));\n    service(\"namespaceB\",\"serviceB\",Map.of(\"color\",\"blue\"));\n    List\u003cService\u003e result\u003dadapter.apply(client);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceA\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"namespaceA\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - labels \u003d {} - filter \u003d \"#root.metadata.namespace matches \u0027^.+A$\u0027\" (ends in A) - serviceA exists in namespaceA with labels \u003d {color\u003dred} - serviceB exists in namespaceB with labels \u003d {color\u003dblue} - we get only serviceA as a result. \u003c/pre\u003e\n */\n  @Test void testAllNamespacesWithoutLabelsWithNamespaceFilter(){\n    boolean allNamespaces\u003dtrue;\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    String spelFilter\u003dnull;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,allNamespaces,Set.of(),true,60L,false,spelFilter,Set.of(),labels,null,null,0,false);\n    Fabric8DiscoveryServicesAdapter adapter\u003dnew Fabric8DiscoveryServicesAdapter(new KubernetesDiscoveryClientAutoConfiguration().servicesFunction(properties,environment),properties,null);\n    service(\"namespaceA\",\"serviceA\",Map.of(\"color\",\"red\"));\n    service(\"namespaceB\",\"serviceB\",Map.of(\"color\",\"blue\"));\n    List\u003cService\u003e result\u003dadapter.apply(client);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceA\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"namespaceA\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - labels \u003d {} - filter \u003d \"#root.metadata.namespace matches \u0027^namespace[A|B]$\u0027\" (namespaceA or namespaceB) - serviceA exists in namespaceA with labels \u003d {color\u003dred} - serviceB exists in namespaceB with labels \u003d {color\u003dblue} - serviceC exists in namespaceC with labels \u003d {color\u003dpurple} - we get only serviceA and serviceB as a result. \u003c/pre\u003e\n */\n  @Test void testAllNamespacesWithoutLabelsWithNamespacesFilter(){\n    boolean allNamespaces\u003dtrue;\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    String spelFilter\u003dnull;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,allNamespaces,Set.of(),true,60L,false,spelFilter,Set.of(),labels,null,null,0,false);\n    Fabric8DiscoveryServicesAdapter adapter\u003dnew Fabric8DiscoveryServicesAdapter(new KubernetesDiscoveryClientAutoConfiguration().servicesFunction(properties,environment),properties,null);\n    service(\"namespaceA\",\"serviceA\",Map.of(\"color\",\"red\"));\n    service(\"namespaceB\",\"serviceB\",Map.of(\"color\",\"blue\"));\n    service(\"namespaceC\",\"serviceC\",Map.of(\"color\",\"purple\"));\n    List\u003cService\u003e result\u003dadapter.apply(client);\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceA\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"namespaceA\");\n    Assertions.assertEquals(result.get(1).getMetadata().getName(),\"serviceB\");\n    Assertions.assertEquals(result.get(1).getMetadata().getNamespace(),\"namespaceB\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - specific namespace \u003d namespaceA - labels \u003d {} - serviceA exists in namespaceA with labels \u003d {color\u003dred} - serviceB exists in namespaceB with labels \u003d {color\u003dblue} - we get only serviceA as a result. \u003c/pre\u003e\n */\n  @Test void testSpecificNamespaceWithoutLabelsWithoutFilter(){\n    boolean allNamespaces\u003dfalse;\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    String spelFilter\u003dnull;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,allNamespaces,Set.of(),true,60L,false,spelFilter,Set.of(),labels,null,null,0,false);\n    Fabric8DiscoveryServicesAdapter adapter\u003dnew Fabric8DiscoveryServicesAdapter(new KubernetesDiscoveryClientAutoConfiguration().servicesFunction(properties,environment),properties,null);\n    utils.when(() -\u003e Fabric8Utils.getApplicationNamespace(Mockito.any(KubernetesClient.class),Mockito.nullable(String.class),Mockito.anyString(),Mockito.any(KubernetesNamespaceProvider.class))).thenReturn(\"namespaceA\");\n    service(\"namespaceA\",\"serviceA\",Map.of(\"color\",\"red\"));\n    service(\"namespaceB\",\"serviceB\",Map.of(\"color\",\"blue\"));\n    List\u003cService\u003e result\u003dadapter.apply(client);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceA\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"namespaceA\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - specific namespace \u003d namespaceA - labels \u003d {color \u003d purple} - serviceA exists in namespaceA with labels \u003d {color\u003dred} - serviceB exists in namespaceA with labels \u003d {color\u003dpurple} - serviceC exists in namespaceC with labels \u003d {color\u003dpurple} - we get only serviceB as a result, even if such labels are also present on a different service (but it\u0027s in a different namespace). \u003c/pre\u003e\n */\n  @Test void testSpecificNamespaceWithLabelsWithoutFilter(){\n    boolean allNamespaces\u003dfalse;\n    Map\u003cString,String\u003e labels\u003dMap.of(\"color\",\"purple\");\n    String spelFilter\u003dnull;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,allNamespaces,Set.of(),true,60L,false,spelFilter,Set.of(),labels,null,null,0,false);\n    Fabric8DiscoveryServicesAdapter adapter\u003dnew Fabric8DiscoveryServicesAdapter(new KubernetesDiscoveryClientAutoConfiguration().servicesFunction(properties,environment),properties,null);\n    utils.when(() -\u003e Fabric8Utils.getApplicationNamespace(Mockito.any(KubernetesClient.class),Mockito.nullable(String.class),Mockito.anyString(),Mockito.any(KubernetesNamespaceProvider.class))).thenReturn(\"namespaceA\");\n    service(\"namespaceA\",\"serviceA\",Map.of(\"color\",\"red\"));\n    service(\"namespaceA\",\"serviceB\",Map.of(\"color\",\"purple\"));\n    service(\"namespaceC\",\"serviceC\",Map.of(\"color\",\"purple\"));\n    List\u003cService\u003e result\u003dadapter.apply(client);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceB\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"namespaceA\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - specific namespace \u003d namespaceA - labels \u003d {} - filter \u003d \"#root.metadata.labels.containsKey(\"number\")\" (namespaceA or namespaceB) - serviceA exists in namespaceA with labels \u003d {color\u003dred, number\u003d1} - serviceB exists in namespaceA with labels \u003d {color\u003dpurple, cycle\u003dcreate} - serviceC exists in namespaceC with labels \u003d {color\u003dpurple, number\u003d1} - we get only serviceB as a result (because of the filter) even if such labels are also present on a different service (but it\u0027s in a different namespace). \u003c/pre\u003e\n */\n  @Test void testSpecificNamespaceWithoutLabelsWithFilter(){\n    boolean allNamespaces\u003dfalse;\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    String spelFilter\u003dnull.stripLeading();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,allNamespaces,Set.of(),true,60L,false,spelFilter,Set.of(),labels,null,null,0,false);\n    Fabric8DiscoveryServicesAdapter adapter\u003dnew Fabric8DiscoveryServicesAdapter(new KubernetesDiscoveryClientAutoConfiguration().servicesFunction(properties,environment),properties,null);\n    utils.when(() -\u003e Fabric8Utils.getApplicationNamespace(Mockito.any(KubernetesClient.class),Mockito.nullable(String.class),Mockito.anyString(),Mockito.any(KubernetesNamespaceProvider.class))).thenReturn(\"namespaceA\");\n    service(\"namespaceA\",\"serviceA\",Map.of(\"color\",\"red\",\"number\",\"1\"));\n    service(\"namespaceA\",\"serviceB\",Map.of(\"color\",\"purple\",\"cycle\",\"create\"));\n    service(\"namespaceC\",\"serviceC\",Map.of(\"color\",\"purple\",\"number\",\"1\"));\n    List\u003cService\u003e result\u003dadapter.apply(client);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceA\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"namespaceA\");\n    Assertions.assertEquals(result.get(0).getMetadata().getLabels(),Map.of(\"color\",\"red\",\"number\",\"1\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - some namespaces \u003d [namespaceA, namespaceB] - labels \u003d {} - filter \u003d null - serviceA exists in namespaceA with labels \u003d {} - serviceB exists in namespaceB with labels \u003d {} - serviceC exists in namespaceC with labels \u003d {} - we get serviceA and serviceB as a result, because their namespaces match. \u003c/pre\u003e\n */\n  @Test void testSomeNamespacesWithoutLabelsWithoutFilter(){\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e someNamespaces\u003dSet.of(\"namespaceA\",\"namespaceB\");\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    String spelFilter\u003dnull;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,allNamespaces,someNamespaces,true,60L,false,spelFilter,Set.of(),labels,null,null,0,false);\n    Fabric8DiscoveryServicesAdapter adapter\u003dnew Fabric8DiscoveryServicesAdapter(new KubernetesDiscoveryClientAutoConfiguration().servicesFunction(properties,environment),properties,null);\n    service(\"namespaceA\",\"serviceA\",Map.of());\n    service(\"namespaceB\",\"serviceB\",Map.of());\n    service(\"namespaceC\",\"serviceC\",Map.of());\n    List\u003cService\u003e result\u003dadapter.apply(client);\n    Assertions.assertEquals(result.size(),2);\n    result\u003dresult.stream().sorted(Comparator.comparing(x -\u003e x.getMetadata().getName())).toList();\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceA\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"namespaceA\");\n    Assertions.assertEquals(result.get(1).getMetadata().getName(),\"serviceB\");\n    Assertions.assertEquals(result.get(1).getMetadata().getNamespace(),\"namespaceB\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - some namespaces \u003d [namespaceA, namespaceB] - labels \u003d {color\u003dpurple} - filter \u003d null - serviceA exists in namespaceA with labels \u003d {color\u003dpurple} - serviceB exists in namespaceB with labels \u003d {color\u003dred} - serviceC exists in namespaceC with labels \u003d {color\u003dpurple} - we get serviceA as a result \u003c/pre\u003e\n */\n  @Test void testSomeNamespacesWithLabelsWithoutFilter(){\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e someNamespaces\u003dSet.of(\"namespaceA\",\"namespaceB\");\n    Map\u003cString,String\u003e labels\u003dMap.of(\"color\",\"purple\");\n    String spelFilter\u003dnull;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,allNamespaces,someNamespaces,true,60L,false,spelFilter,Set.of(),labels,null,null,0,false);\n    Fabric8DiscoveryServicesAdapter adapter\u003dnew Fabric8DiscoveryServicesAdapter(new KubernetesDiscoveryClientAutoConfiguration().servicesFunction(properties,environment),properties,null);\n    service(\"namespaceA\",\"serviceA\",Map.of(\"color\",\"purple\"));\n    service(\"namespaceB\",\"serviceB\",Map.of(\"color\",\"red\"));\n    service(\"namespaceC\",\"serviceC\",Map.of(\"color\",\"purple\"));\n    List\u003cService\u003e result\u003dadapter.apply(client);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceA\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"namespaceA\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - some namespaces \u003d [namespaceA, namespaceB] - labels \u003d {color\u003dpurple} - filter \u003d #root.metadata.labels.containsKey(\"number\") - serviceA exists in namespaceA with labels \u003d {color\u003dpurple} - serviceB exists in namespaceB with labels \u003d {color\u003dred} - serviceC exists in namespaceC with labels \u003d {color\u003dpurple} - we get serviceA as a result \u003c/pre\u003e\n */\n  @Test void testSomeNamespacesWithLabelsWithFilter(){\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e someNamespaces\u003dSet.of(\"namespaceA\",\"namespaceB\");\n    Map\u003cString,String\u003e labels\u003dMap.of(\"color\",\"purple\");\n    String spelFilter\u003dnull.stripLeading();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,allNamespaces,someNamespaces,true,60L,false,spelFilter,Set.of(),labels,null,null,0,false);\n    Fabric8DiscoveryServicesAdapter adapter\u003dnew Fabric8DiscoveryServicesAdapter(new KubernetesDiscoveryClientAutoConfiguration().servicesFunction(properties,environment),properties,null);\n    service(\"namespaceA\",\"serviceA\",Map.of(\"color\",\"purple\",\"number\",\"1\"));\n    service(\"namespaceB\",\"serviceB\",Map.of(\"color\",\"purple\",\"cycle\",\"create\"));\n    service(\"namespaceC\",\"serviceC\",Map.of(\"color\",\"purple\",\"number\",\"1\"));\n    List\u003cService\u003e result\u003dadapter.apply(client);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceA\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"namespaceA\");\n  }\n  private void service(  String namespace,  String name,  Map\u003cString,String\u003e labels){\n    client.services().inNamespace(namespace).resource(new ServiceBuilder().withNewMetadata().withName(name).withLabels(labels).and().build()).create();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8DiscoveryServicesAdapterTests {\n  private static KubernetesClient client;\n  private static MockedStatic\u003cFabric8Utils\u003e utils;\n  @BeforeEach void beforeEach();\n  @AfterEach void afterEach();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - labels \u003d {} - filter \u003d null - serviceA exists in namespaceA with labels \u003d {color\u003dred} - serviceB exists in namespaceB with labels \u003d {color\u003dblue} - we get both services as a result. \u003c/pre\u003e\n */\n  @Test void testAllNamespacesWithoutLabelsWithoutFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - labels \u003d {color\u003dred} - filter \u003d null - serviceA exists in namespaceA with labels \u003d {color\u003dred} - serviceB exists in namespaceB with labels \u003d {color\u003dblue} - we get only serviceA as a result. \u003c/pre\u003e\n */\n  @Test void testAllNamespacesWithLabelsWithoutFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - labels \u003d {} - filter \u003d \"#root.metadata.namespace matches \u0027^.+A$\u0027\" (ends in A) - serviceA exists in namespaceA with labels \u003d {color\u003dred} - serviceB exists in namespaceB with labels \u003d {color\u003dblue} - we get only serviceA as a result. \u003c/pre\u003e\n */\n  @Test void testAllNamespacesWithoutLabelsWithNamespaceFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - labels \u003d {} - filter \u003d \"#root.metadata.namespace matches \u0027^namespace[A|B]$\u0027\" (namespaceA or namespaceB) - serviceA exists in namespaceA with labels \u003d {color\u003dred} - serviceB exists in namespaceB with labels \u003d {color\u003dblue} - serviceC exists in namespaceC with labels \u003d {color\u003dpurple} - we get only serviceA and serviceB as a result. \u003c/pre\u003e\n */\n  @Test void testAllNamespacesWithoutLabelsWithNamespacesFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - specific namespace \u003d namespaceA - labels \u003d {} - serviceA exists in namespaceA with labels \u003d {color\u003dred} - serviceB exists in namespaceB with labels \u003d {color\u003dblue} - we get only serviceA as a result. \u003c/pre\u003e\n */\n  @Test void testSpecificNamespaceWithoutLabelsWithoutFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - specific namespace \u003d namespaceA - labels \u003d {color \u003d purple} - serviceA exists in namespaceA with labels \u003d {color\u003dred} - serviceB exists in namespaceA with labels \u003d {color\u003dpurple} - serviceC exists in namespaceC with labels \u003d {color\u003dpurple} - we get only serviceB as a result, even if such labels are also present on a different service (but it\u0027s in a different namespace). \u003c/pre\u003e\n */\n  @Test void testSpecificNamespaceWithLabelsWithoutFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - specific namespace \u003d namespaceA - labels \u003d {} - filter \u003d \"#root.metadata.labels.containsKey(\"number\")\" (namespaceA or namespaceB) - serviceA exists in namespaceA with labels \u003d {color\u003dred, number\u003d1} - serviceB exists in namespaceA with labels \u003d {color\u003dpurple, cycle\u003dcreate} - serviceC exists in namespaceC with labels \u003d {color\u003dpurple, number\u003d1} - we get only serviceB as a result (because of the filter) even if such labels are also present on a different service (but it\u0027s in a different namespace). \u003c/pre\u003e\n */\n  @Test void testSpecificNamespaceWithoutLabelsWithFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - some namespaces \u003d [namespaceA, namespaceB] - labels \u003d {} - filter \u003d null - serviceA exists in namespaceA with labels \u003d {} - serviceB exists in namespaceB with labels \u003d {} - serviceC exists in namespaceC with labels \u003d {} - we get serviceA and serviceB as a result, because their namespaces match. \u003c/pre\u003e\n */\n  @Test void testSomeNamespacesWithoutLabelsWithoutFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - some namespaces \u003d [namespaceA, namespaceB] - labels \u003d {color\u003dpurple} - filter \u003d null - serviceA exists in namespaceA with labels \u003d {color\u003dpurple} - serviceB exists in namespaceB with labels \u003d {color\u003dred} - serviceC exists in namespaceC with labels \u003d {color\u003dpurple} - we get serviceA as a result \u003c/pre\u003e\n */\n  @Test void testSomeNamespacesWithLabelsWithoutFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - some namespaces \u003d [namespaceA, namespaceB] - labels \u003d {color\u003dpurple} - filter \u003d #root.metadata.labels.containsKey(\"number\") - serviceA exists in namespaceA with labels \u003d {color\u003dpurple} - serviceB exists in namespaceB with labels \u003d {color\u003dred} - serviceC exists in namespaceC with labels \u003d {color\u003dpurple} - we get serviceA as a result \u003c/pre\u003e\n */\n  @Test void testSomeNamespacesWithLabelsWithFilter();\n  private void service(  String namespace,  String name,  Map\u003cString,String\u003e labels);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesCatalogWatchAutoConfigurationApplicationContextTests.java",
        "name": "KubernetesCatalogWatchAutoConfigurationApplicationContextTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesCatalogWatchAutoConfigurationApplicationContextTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesCatalogWatchAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  @Test void discoveryEnabledDefault(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(KubernetesCatalogWatch.class));\n  }\n  @Test void discoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(KubernetesCatalogWatch.class));\n  }\n  @Test void discoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e assertThat(context).doesNotHaveBean(KubernetesCatalogWatch.class));\n  }\n  @Test void kubernetesDiscoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(KubernetesCatalogWatch.class));\n  }\n  @Test void kubernetesDiscoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e assertThat(context).doesNotHaveBean(KubernetesCatalogWatch.class));\n  }\n  /** \n * both blocking and reactive configs are disabled, catalog watcher is disabled too.\n */\n  @Test void disableBlockingAndReactive(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesCatalogWatch.class);\n      assertThat(context).doesNotHaveBean(KubernetesClientServicesFunction.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  /** \n * blocking is disabled, reactive is enabled, catalog watcher is enabled.\n */\n  @Test void disableBlockingEnableReactive(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesCatalogWatch.class);\n      assertThat(context).doesNotHaveBean(KubernetesClientServicesFunction.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  /** \n * blocking is enabled, reactive is disabled, catalog watcher is enabled.\n */\n  @Test void enableBlockingDisableReactive(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dtrue\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesCatalogWatch.class);\n      assertThat(context).doesNotHaveBean(KubernetesClientServicesFunction.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  /** \n * spring.cloud.kubernetes.discovery.enabled is false, catalog watcher is disabled also.\n */\n  @Test void disableKubernetesDiscovery(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesCatalogWatch.class);\n      assertThat(context).doesNotHaveBean(KubernetesClientServicesFunction.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  private void setup(  String... properties){\n    applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesCatalogWatchAutoConfiguration.class,Fabric8AutoConfiguration.class,KubernetesCommonsAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class)).withPropertyValues(properties);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesCatalogWatchAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  @Test void discoveryEnabledDefault();\n  @Test void discoveryEnabled();\n  @Test void discoveryDisabled();\n  @Test void kubernetesDiscoveryEnabled();\n  @Test void kubernetesDiscoveryDisabled();\n  /** \n * both blocking and reactive configs are disabled, catalog watcher is disabled too.\n */\n  @Test void disableBlockingAndReactive();\n  /** \n * blocking is disabled, reactive is enabled, catalog watcher is enabled.\n */\n  @Test void disableBlockingEnableReactive();\n  /** \n * blocking is enabled, reactive is disabled, catalog watcher is enabled.\n */\n  @Test void enableBlockingDisableReactive();\n  /** \n * spring.cloud.kubernetes.discovery.enabled is false, catalog watcher is disabled also.\n */\n  @Test void disableKubernetesDiscovery();\n  private void setup(  String... properties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesDiscoveryClientUtilsTests.java",
        "name": "KubernetesDiscoveryClientUtilsTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesDiscoveryClientUtilsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryClientUtilsTests {\n  /** \n * \u003cpre\u003e - ready addresses are empty - not ready addresses are not included \u003c/pre\u003e\n */\n  @Test void testEmptyAddresses(){\n    boolean includeNotReadyAddresses\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,includeNotReadyAddresses,\"\",Set.of(),Map.of(),\"\",null,0,false,false);\n    EndpointSubset endpointSubset\u003dnew EndpointSubsetBuilder().build();\n    List\u003cEndpointAddress\u003e addresses\u003dFabric8KubernetesDiscoveryClientUtils.addresses(endpointSubset,properties);\n    Assertions.assertEquals(addresses.size(),0);\n  }\n  /** \n * \u003cpre\u003e - ready addresses has two entries - not ready addresses are not included \u003c/pre\u003e\n */\n  @Test void testReadyAddressesOnly(){\n    boolean includeNotReadyAddresses\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,includeNotReadyAddresses,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    EndpointSubset endpointSubset\u003dnew EndpointSubsetBuilder().withAddresses(new EndpointAddressBuilder().withHostname(\"one\").build(),new EndpointAddressBuilder().withHostname(\"two\").build()).build();\n    List\u003cEndpointAddress\u003e addresses\u003dFabric8KubernetesDiscoveryClientUtils.addresses(endpointSubset,properties);\n    Assertions.assertEquals(addresses.size(),2);\n  }\n  /** \n * \u003cpre\u003e - ready addresses has two entries - not ready addresses has a single entry, but we do not take it \u003c/pre\u003e\n */\n  @Test void testReadyAddressesTakenNotReadyAddressesNotTaken(){\n    boolean includeNotReadyAddresses\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,includeNotReadyAddresses,\"\",Set.of(),Map.of(),\"\",null,0,false,false);\n    EndpointSubset endpointSubset\u003dnew EndpointSubsetBuilder().withAddresses(new EndpointAddressBuilder().withHostname(\"one\").build(),new EndpointAddressBuilder().withHostname(\"two\").build()).withNotReadyAddresses(new EndpointAddressBuilder().withHostname(\"three\").build()).build();\n    List\u003cEndpointAddress\u003e addresses\u003dFabric8KubernetesDiscoveryClientUtils.addresses(endpointSubset,properties);\n    Assertions.assertEquals(addresses.size(),2);\n    List\u003cString\u003e hostNames\u003daddresses.stream().map(EndpointAddress::getHostname).sorted().toList();\n    Assertions.assertEquals(hostNames,List.of(\"one\",\"two\"));\n  }\n  /** \n * \u003cpre\u003e - ready addresses has two entries - not ready addresses has a single entry, but we do not take it \u003c/pre\u003e\n */\n  @Test void testBothAddressesTaken(){\n    boolean includeNotReadyAddresses\u003dtrue;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,includeNotReadyAddresses,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    EndpointSubset endpointSubset\u003dnew EndpointSubsetBuilder().withAddresses(new EndpointAddressBuilder().withHostname(\"one\").build(),new EndpointAddressBuilder().withHostname(\"two\").build()).withNotReadyAddresses(new EndpointAddressBuilder().withHostname(\"three\").build()).build();\n    List\u003cEndpointAddress\u003e addresses\u003dFabric8KubernetesDiscoveryClientUtils.addresses(endpointSubset,properties);\n    Assertions.assertEquals(addresses.size(),3);\n    List\u003cString\u003e hostNames\u003daddresses.stream().map(EndpointAddress::getHostname).sorted().toList();\n    Assertions.assertEquals(hostNames,List.of(\"one\",\"three\",\"two\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryClientUtilsTests {\n  /** \n * \u003cpre\u003e - ready addresses are empty - not ready addresses are not included \u003c/pre\u003e\n */\n  @Test void testEmptyAddresses();\n  /** \n * \u003cpre\u003e - ready addresses has two entries - not ready addresses are not included \u003c/pre\u003e\n */\n  @Test void testReadyAddressesOnly();\n  /** \n * \u003cpre\u003e - ready addresses has two entries - not ready addresses has a single entry, but we do not take it \u003c/pre\u003e\n */\n  @Test void testReadyAddressesTakenNotReadyAddressesNotTaken();\n  /** \n * \u003cpre\u003e - ready addresses has two entries - not ready addresses has a single entry, but we do not take it \u003c/pre\u003e\n */\n  @Test void testBothAddressesTaken();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesDiscoveryClientConfigClientBootstrapConfigurationTests.java",
        "name": "KubernetesDiscoveryClientConfigClientBootstrapConfigurationTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesDiscoveryClientConfigClientBootstrapConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Zhanwei Wang\n */\nclass KubernetesDiscoveryClientConfigClientBootstrapConfigurationTests {\n  private AnnotationConfigApplicationContext context;\n  @AfterEach void afterEach(){\n    if (context !\u003d null) {\n      if (context.getParent() !\u003d null) {\n        ((AnnotationConfigApplicationContext)context.getParent()).close();\n      }\n      context.close();\n    }\n  }\n  @Test void onWhenRequested(){\n    setup(\"server.port\u003d7000\",\"spring.cloud.config.discovery.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.enabled:true\",\"spring.application.name:test\",\"spring.cloud.config.discovery.service-id:configserver\");\n    Assertions.assertEquals(1,context.getParent().getBeanNamesForType(DiscoveryClient.class).length);\n    DiscoveryClient client\u003dcontext.getParent().getBean(DiscoveryClient.class);\n    verify(client,atLeast(2)).getInstances(\"configserver\");\n    ConfigClientProperties locator\u003dcontext.getBean(ConfigClientProperties.class);\n    Assertions.assertEquals(\"http://fake:8888/\",locator.getUri()[0]);\n  }\n  private void setup(  String... env){\n    AnnotationConfigApplicationContext parent\u003dnew AnnotationConfigApplicationContext();\n    TestPropertyValues.of(env).applyTo(parent);\n    parent.register(UtilAutoConfiguration.class,PropertyPlaceholderAutoConfiguration.class,EnvironmentKnobbler.class,KubernetesCommonsAutoConfiguration.class,KubernetesDiscoveryClientConfigClientBootstrapConfiguration.class,DiscoveryClientConfigServiceBootstrapConfiguration.class,ConfigClientProperties.class);\n    parent.refresh();\n    context\u003dnew AnnotationConfigApplicationContext();\n    context.setParent(parent);\n    context.register(PropertyPlaceholderAutoConfiguration.class,KubernetesCommonsAutoConfiguration.class,KubernetesDiscoveryClientAutoConfiguration.class);\n    context.refresh();\n  }\n@Configuration(proxyBeanMethods\u003dfalse) protected static class EnvironmentKnobbler {\n    @Bean KubernetesDiscoveryClient kubernetesDiscoveryClient(){\n      KubernetesDiscoveryClient client\u003dmock(KubernetesDiscoveryClient.class);\n      ServiceInstance instance\u003dnew DefaultServiceInstance(\"configserver1\",\"configserver\",\"fake\",8888,false);\n      given(client.getInstances(\"configserver\")).willReturn(Collections.singletonList(instance));\n      return client;\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Zhanwei Wang\n */\nclass KubernetesDiscoveryClientConfigClientBootstrapConfigurationTests {\n  private AnnotationConfigApplicationContext context;\n  @AfterEach void afterEach();\n  @Test void onWhenRequested();\n  private void setup(  String... env);\n@Configuration(proxyBeanMethods\u003dfalse) protected static class EnvironmentKnobbler {\n    @Bean KubernetesDiscoveryClient kubernetesDiscoveryClient();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8KubernetesCatalogWatchEndpointsTests.java",
        "name": "Fabric8KubernetesCatalogWatchEndpointsTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8KubernetesCatalogWatchEndpointsTests",
        "extend": "Fabric8EndpointsAndEndpointSlicesTests",
        "implements": "",
        "raw": "/** \n * Tests for endpoints based catalog watch\n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8KubernetesCatalogWatchEndpointsTests extends Fabric8EndpointsAndEndpointSlicesTests {\n  private static final Boolean ENDPOINT_SLICES\u003dfalse;\n  private static KubernetesClient mockClient;\n  @AfterEach void afterEach(){\n    mockClient.endpoints().inAnyNamespace().delete();\n    mockClient.services().inAnyNamespace().delete();\n  }\n  @Test @Override void testInSpecificNamespaceWithServiceLabels(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespaceWithLabels(\"namespaceA\",Map.of(\"color\",\"blue\"),ENDPOINT_SLICES);\n    endpoints(\"namespaceA\",Map.of(),\"podA\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpoints(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpoints(\"namespaceB\",Map.of(),\"podE\");\n    service(\"namespaceA\",Map.of(),\"podA\");\n    service(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    service(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    service(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    service(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podB\",\"namespaceA\")));\n  }\n  @Test @Override void testInSpecificNamespaceWithoutServiceLabels(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespaceWithLabels(\"namespaceA\",Map.of(),ENDPOINT_SLICES);\n    endpoints(\"namespaceA\",Map.of(),\"podA\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpoints(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpoints(\"namespaceB\",Map.of(),\"podE\");\n    service(\"namespaceA\",Map.of(),\"podA\");\n    service(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    service(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    service(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    service(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podA\",\"namespaceA\"),new EndpointNameAndNamespace(\"podB\",\"namespaceA\"),new EndpointNameAndNamespace(\"podC\",\"namespaceA\")));\n  }\n  @Test @Override void testInAllNamespacesWithServiceLabels(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInAllNamespacesWithLabels(Map.of(\"color\",\"blue\"),Set.of(),ENDPOINT_SLICES);\n    endpoints(\"namespaceA\",Map.of(),\"podA\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpoints(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpoints(\"namespaceB\",Map.of(),\"podE\");\n    service(\"namespaceA\",Map.of(),\"podA\");\n    service(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    service(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    service(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    service(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podB\",\"namespaceA\"),new EndpointNameAndNamespace(\"podD\",\"namespaceB\")));\n  }\n  @Test @Override void testInAllNamespacesWithoutServiceLabels(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInAllNamespacesWithLabels(Map.of(),Set.of(),ENDPOINT_SLICES);\n    endpoints(\"namespaceA\",Map.of(),\"podA\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpoints(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpoints(\"namespaceB\",Map.of(),\"podE\");\n    service(\"namespaceA\",Map.of(),\"podA\");\n    service(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    service(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    service(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    service(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podA\",\"namespaceA\"),new EndpointNameAndNamespace(\"podB\",\"namespaceA\"),new EndpointNameAndNamespace(\"podC\",\"namespaceA\"),new EndpointNameAndNamespace(\"podD\",\"namespaceB\"),new EndpointNameAndNamespace(\"podE\",\"namespaceB\")));\n  }\n  @Test @Override void testAllNamespacesTrueOtherBranchesNotCalled(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInAllNamespacesWithLabels(Map.of(\"color\",\"blue\"),Set.of(),ENDPOINT_SLICES);\n    endpoints(\"namespaceA\",Map.of(),\"podA\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpoints(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpoints(\"namespaceB\",Map.of(),\"podE\");\n    service(\"namespaceA\",Map.of(),\"podA\");\n    service(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    service(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    service(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    service(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podB\",\"namespaceA\"),new EndpointNameAndNamespace(\"podD\",\"namespaceB\")));\n  }\n  @Test @Override void testAllNamespacesFalseNamespacesPresent(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespacesWithLabels(Set.of(\"namespaceA\"),Map.of(\"color\",\"blue\"),ENDPOINT_SLICES);\n    endpoints(\"namespaceA\",Map.of(),\"podA\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpoints(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpoints(\"namespaceB\",Map.of(),\"podE\");\n    service(\"namespaceA\",Map.of(),\"podA\");\n    service(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    service(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    service(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    service(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podB\",\"namespaceA\")));\n  }\n  @Test @Override void testAllNamespacesFalseNamespacesNotPresent(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespaceWithLabels(\"namespaceA\",Map.of(\"color\",\"blue\"),ENDPOINT_SLICES);\n    endpoints(\"namespaceA\",Map.of(),\"podA\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpoints(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpoints(\"namespaceB\",Map.of(),\"podE\");\n    service(\"namespaceA\",Map.of(),\"podA\");\n    service(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    service(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    service(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    service(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podB\",\"namespaceA\")));\n  }\n  @Test @Override void testTwoNamespacesOutOfThree(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespacesWithLabels(Set.of(\"namespaceA\",\"namespaceB\"),Map.of(\"color\",\"blue\"),ENDPOINT_SLICES);\n    endpoints(\"namespaceA\",Map.of(),\"podA\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpoints(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpoints(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpoints(\"namespaceB\",Map.of(),\"podE\");\n    endpoints(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podF\");\n    endpoints(\"namespaceC\",Map.of(\"color\",\"blue\"),\"podO\");\n    service(\"namespaceA\",Map.of(),\"podA\");\n    service(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    service(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    service(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    service(\"namespaceB\",Map.of(),\"podE\");\n    service(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podF\");\n    service(\"namespaceC\",Map.of(\"color\",\"blue\"),\"podO\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podB\",\"namespaceA\"),new EndpointNameAndNamespace(\"podD\",\"namespaceB\"),new EndpointNameAndNamespace(\"podF\",\"namespaceB\")));\n  }\n  static KubernetesClient endpointsMockClient(){\n    return mockClient;\n  }\n}\n",
        "abstract": "/** \n * Tests for endpoints based catalog watch\n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8KubernetesCatalogWatchEndpointsTests extends Fabric8EndpointsAndEndpointSlicesTests {\n  private static final Boolean ENDPOINT_SLICES\u003dfalse;\n  private static KubernetesClient mockClient;\n  @AfterEach void afterEach();\n  @Test @Override void testInSpecificNamespaceWithServiceLabels();\n  @Test @Override void testInSpecificNamespaceWithoutServiceLabels();\n  @Test @Override void testInAllNamespacesWithServiceLabels();\n  @Test @Override void testInAllNamespacesWithoutServiceLabels();\n  @Test @Override void testAllNamespacesTrueOtherBranchesNotCalled();\n  @Test @Override void testAllNamespacesFalseNamespacesPresent();\n  @Test @Override void testAllNamespacesFalseNamespacesNotPresent();\n  @Test @Override void testTwoNamespacesOutOfThree();\n  static KubernetesClient endpointsMockClient();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesDiscoveryClientAutoConfigurationPropertiesTests.java",
        "name": "KubernetesDiscoveryClientAutoConfigurationPropertiesTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesDiscoveryClientAutoConfigurationPropertiesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Dawson\n * @author Tim Ysewyn\n */\nclass KubernetesDiscoveryClientAutoConfigurationPropertiesTests {\n  private ConfigurableApplicationContext context;\n  @AfterEach void afterEach(){\n    if (context !\u003d null) {\n      context.close();\n    }\n  }\n  @Test void kubernetesDiscoveryDisabled(){\n    setup(\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.catalog-services-watch.enabled\u003dfalse\");\n    assertThat(context.getBeanNamesForType(KubernetesDiscoveryClient.class)).isEmpty();\n  }\n  @Test void kubernetesDiscoveryWhenKubernetesDisabled(){\n    setup();\n    assertThat(context.getBeanNamesForType(KubernetesDiscoveryClient.class)).isEmpty();\n  }\n  @Test void kubernetesDiscoveryWhenDiscoveryDisabled(){\n    setup(\"spring.cloud.discovery.enabled\u003dfalse\");\n    assertThat(context.getBeanNamesForType(KubernetesDiscoveryClient.class)).isEmpty();\n  }\n  @Test void kubernetesDiscoveryDefaultEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\");\n    assertThat(context.getBeanNamesForType(KubernetesDiscoveryClient.class)).hasSize(1);\n  }\n  private void setup(  String... env){\n    List\u003cString\u003e envList\u003dnew ArrayList\u003c\u003e(Arrays.asList(env));\n    envList.add(\"spring.cloud.config.enabled\u003dfalse\");\n    context\u003dnew SpringApplicationBuilder(PropertyPlaceholderAutoConfiguration.class,KubernetesClientTestConfiguration.class,KubernetesDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class).web(org.springframework.boot.WebApplicationType.NONE).properties(envList.toArray(new String[0])).run();\n  }\n@Configuration(proxyBeanMethods\u003dfalse) static class KubernetesClientTestConfiguration {\n    @Bean KubernetesClient kubernetesClient(){\n      return mock(KubernetesClient.class);\n    }\n    @SuppressWarnings(\"unchecked\") @Bean PodUtils\u003c?\u003e podUtils(){\n      PodUtils\u003cPod\u003e podPodUtils\u003dmock(PodUtils.class);\n      when(podPodUtils.currentPod()).thenReturn(() -\u003e mock(Pod.class));\n      return podPodUtils;\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Dawson\n * @author Tim Ysewyn\n */\nclass KubernetesDiscoveryClientAutoConfigurationPropertiesTests {\n  private ConfigurableApplicationContext context;\n  @AfterEach void afterEach();\n  @Test void kubernetesDiscoveryDisabled();\n  @Test void kubernetesDiscoveryWhenKubernetesDisabled();\n  @Test void kubernetesDiscoveryWhenDiscoveryDisabled();\n  @Test void kubernetesDiscoveryDefaultEnabled();\n  private void setup(  String... env);\n@Configuration(proxyBeanMethods\u003dfalse) static class KubernetesClientTestConfiguration {\n    @Bean KubernetesClient kubernetesClient();\n    @SuppressWarnings(\"unchecked\") @Bean PodUtils\u003c?\u003e podUtils();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8KubernetesDiscoveryClientUtilsFilterTests.java",
        "name": "Fabric8KubernetesDiscoveryClientUtilsFilterTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8KubernetesDiscoveryClientUtilsFilterTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8KubernetesDiscoveryClientUtilsFilterTests {\n  private static KubernetesClient client;\n  private static final KubernetesDiscoveryProperties PROPERTIES\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),false,60L,false,\"some\",Set.of(),Map.of(),\"\",null,0,false);\n  @AfterEach void afterEach(){\n    client.endpoints().inAnyNamespace().delete();\n    client.services().inAnyNamespace().delete();\n  }\n  @Test void withFilterEmptyInput(){\n    List\u003cEndpoints\u003e result\u003dFabric8KubernetesDiscoveryClientUtils.withFilter(List.of(),PROPERTIES,client,ALWAYS_TRUE);\n    Assertions.assertEquals(result.size(),0);\n  }\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"namespace-a\", present - Service with name \"a\" and namespace \"namespace-not-a\" present As such, there is no match, empty result. \u003c/pre\u003e\n */\n  @Test void withFilterOneEndpointsNoMatchInService(){\n    Endpoints endpoints\u003dcreateEndpoints(\"a\",\"namespace-a\");\n    createService(\"a\",\"namespace-not-a\");\n    List\u003cEndpoints\u003e result\u003dFabric8KubernetesDiscoveryClientUtils.withFilter(List.of(endpoints),PROPERTIES,client,x -\u003e true);\n    Assertions.assertEquals(result.size(),0);\n  }\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"namespace-a\", present - Service with name \"a\" and namespace \"namespace-a\" present As such, there is a match. \u003c/pre\u003e\n */\n  @Test void withFilterOneEndpointsMatchInService(){\n    Endpoints endpoints\u003dcreateEndpoints(\"a\",\"namespace-a\");\n    createService(\"a\",\"namespace-a\");\n    List\u003cEndpoints\u003e result\u003dFabric8KubernetesDiscoveryClientUtils.withFilter(List.of(endpoints),PROPERTIES,client,ALWAYS_TRUE);\n    Assertions.assertEquals(result.size(),1);\n  }\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"namespace-a\", present - Endpoints with name : \"b\" and namespace \"namespace-b\", present - Service with name \"a\" and namespace \"namespace-a\" present As such, there is a match, single endpoints as result. \u003c/pre\u003e\n */\n  @Test void withFilterTwoEndpointsOneMatchInService(){\n    Endpoints endpointsA\u003dcreateEndpoints(\"a\",\"namespace-a\");\n    Endpoints endpointsB\u003dcreateEndpoints(\"b\",\"namespace-b\");\n    createService(\"a\",\"namespace-a\");\n    List\u003cEndpoints\u003e result\u003dFabric8KubernetesDiscoveryClientUtils.withFilter(List.of(endpointsA,endpointsB),PROPERTIES,client,x -\u003e true);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"a\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"namespace-a\");\n  }\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"namespace-a\", present - Endpoints with name : \"b\" and namespace \"namespace-b\", present - Service with name \"a\" and namespace \"namespace-a\" present - Predicate that we use is \"ALWAYS_TRUE\", so no service filter is applied As such, there is a match, single endpoints as result. This test is the same as above with the difference in the predicate. It simulates Fabric8EndpointsCatalogWatch::apply \u003c/pre\u003e\n */\n  @Test void withFilterTwoEndpointsOneMatchInServiceAlwaysTruePredicate(){\n    Endpoints endpointsA\u003dcreateEndpoints(\"a\",\"namespace-a\");\n    Endpoints endpointsB\u003dcreateEndpoints(\"b\",\"namespace-b\");\n    createService(\"a\",\"namespace-a\");\n    List\u003cEndpoints\u003e result\u003dFabric8KubernetesDiscoveryClientUtils.withFilter(List.of(endpointsA,endpointsB),PROPERTIES,client,ALWAYS_TRUE);\n    Assertions.assertEquals(result.size(),2);\n  }\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"namespace-a\", present - Endpoints with name : \"b\" and namespace \"namespace-b\", present - Service with name \"a\" and namespace \"namespace-a\" present - Service with name \"b\" and namespace \"namespace-b\" present - Service with name \"c\" and namespace \"namespace-c\" present As such, there are two matches. \u003c/pre\u003e\n */\n  @Test void withFilterTwoEndpointsAndThreeServices(){\n    Endpoints endpointsA\u003dcreateEndpoints(\"a\",\"namespace-a\");\n    Endpoints endpointsB\u003dcreateEndpoints(\"b\",\"namespace-b\");\n    createService(\"a\",\"namespace-a\");\n    createService(\"b\",\"namespace-b\");\n    createService(\"c\",\"namespace-c\");\n    List\u003cEndpoints\u003e result\u003dFabric8KubernetesDiscoveryClientUtils.withFilter(List.of(endpointsA,endpointsB),PROPERTIES,client,ALWAYS_TRUE);\n    Assertions.assertEquals(result.size(),2);\n    result\u003dresult.stream().sorted(Comparator.comparing(x -\u003e x.getMetadata().getName())).toList();\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"a\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"namespace-a\");\n    Assertions.assertEquals(result.get(1).getMetadata().getName(),\"b\");\n    Assertions.assertEquals(result.get(1).getMetadata().getNamespace(),\"namespace-b\");\n  }\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"namespace-a\", present - Endpoints with name : \"b\" and namespace \"namespace-b\", present - Service with name \"a\" and namespace \"namespace-a\" present - Service with name \"b\" and namespace \"namespace-b\" present - Service with name \"c\" and namespace \"namespace-c\" present As such, there are two matches. \u003c/pre\u003e\n */\n  @Test void withFilterSingleEndpointsMatchesFilter(){\n    Endpoints endpointsA\u003dcreateEndpoints(\"a\",\"namespace-a\");\n    createService(\"a\",\"namespace-a\");\n    List\u003cEndpoints\u003e result\u003dFabric8KubernetesDiscoveryClientUtils.withFilter(List.of(endpointsA),PROPERTIES,client,x -\u003e x.getMetadata().getNamespace().equals(\"namespace-a\"));\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"a\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"namespace-a\");\n  }\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a-1\" and namespace \"default\", present - Endpoints with name : \"b-1\" and namespace \"default\", present - Endpoints with name : \"c-2\" and namespace \"default\", present - Service with name \"a-1\" and namespace \"default\" present - Service with name \"b-1\" and namespace \"default\" present As such, there are two matches. \u003c/pre\u003e\n */\n  @Test void withFilterTwoEndpointsMatchesFilter(){\n    Endpoints endpointsA\u003dcreateEndpoints(\"a-1\",\"default\");\n    Endpoints endpointsB\u003dcreateEndpoints(\"b-1\",\"default\");\n    Endpoints endpointsC\u003dcreateEndpoints(\"c-2\",\"default\");\n    createService(\"a-1\",\"default\");\n    createService(\"b-1\",\"default\");\n    List\u003cEndpoints\u003e result\u003dFabric8KubernetesDiscoveryClientUtils.withFilter(List.of(endpointsA,endpointsB,endpointsC),PROPERTIES,client,x -\u003e x.getMetadata().getName().contains(\"1\"));\n    Assertions.assertEquals(result.size(),2);\n    result\u003dresult.stream().sorted(Comparator.comparing(x -\u003e x.getMetadata().getName())).toList();\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"a-1\");\n    Assertions.assertEquals(result.get(0).getMetadata().getNamespace(),\"default\");\n    Assertions.assertEquals(result.get(1).getMetadata().getName(),\"b-1\");\n    Assertions.assertEquals(result.get(1).getMetadata().getNamespace(),\"default\");\n  }\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"default\", present - Service with name \"a-1\" and namespace \"default\" present - Service with name \"b-1\" and namespace \"default\" present As such, there are two matches. \u003c/pre\u003e\n */\n  @Test void withFilterSingleEndpointsNoPredicateMatch(){\n    Endpoints endpointsA\u003dcreateEndpoints(\"a\",\"default\");\n    createService(\"a-1\",\"default\");\n    createService(\"b-1\",\"default\");\n    List\u003cEndpoints\u003e result\u003dFabric8KubernetesDiscoveryClientUtils.withFilter(List.of(endpointsA),PROPERTIES,client,x -\u003e !x.getMetadata().getName().contains(\"1\"));\n    Assertions.assertEquals(result.size(),0);\n  }\n  private Endpoints createEndpoints(  String name,  String namespace){\n    Endpoints endpoints\u003dnew EndpointsBuilder().withNewMetadata().withName(name).withNamespace(namespace).endMetadata().build();\n    client.endpoints().inNamespace(namespace).resource(endpoints).create();\n    return endpoints;\n  }\n  private void createService(  String name,  String namespace){\n    Service service\u003dnew ServiceBuilder().withNewMetadata().withName(name).withNamespace(namespace).endMetadata().build();\n    client.services().inNamespace(namespace).resource(service).create();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8KubernetesDiscoveryClientUtilsFilterTests {\n  private static KubernetesClient client;\n  private static final KubernetesDiscoveryProperties PROPERTIES\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),false,60L,false,\"some\",Set.of(),Map.of(),\"\",null,0,false);\n  @AfterEach void afterEach();\n  @Test void withFilterEmptyInput();\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"namespace-a\", present - Service with name \"a\" and namespace \"namespace-not-a\" present As such, there is no match, empty result. \u003c/pre\u003e\n */\n  @Test void withFilterOneEndpointsNoMatchInService();\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"namespace-a\", present - Service with name \"a\" and namespace \"namespace-a\" present As such, there is a match. \u003c/pre\u003e\n */\n  @Test void withFilterOneEndpointsMatchInService();\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"namespace-a\", present - Endpoints with name : \"b\" and namespace \"namespace-b\", present - Service with name \"a\" and namespace \"namespace-a\" present As such, there is a match, single endpoints as result. \u003c/pre\u003e\n */\n  @Test void withFilterTwoEndpointsOneMatchInService();\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"namespace-a\", present - Endpoints with name : \"b\" and namespace \"namespace-b\", present - Service with name \"a\" and namespace \"namespace-a\" present - Predicate that we use is \"ALWAYS_TRUE\", so no service filter is applied As such, there is a match, single endpoints as result. This test is the same as above with the difference in the predicate. It simulates Fabric8EndpointsCatalogWatch::apply \u003c/pre\u003e\n */\n  @Test void withFilterTwoEndpointsOneMatchInServiceAlwaysTruePredicate();\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"namespace-a\", present - Endpoints with name : \"b\" and namespace \"namespace-b\", present - Service with name \"a\" and namespace \"namespace-a\" present - Service with name \"b\" and namespace \"namespace-b\" present - Service with name \"c\" and namespace \"namespace-c\" present As such, there are two matches. \u003c/pre\u003e\n */\n  @Test void withFilterTwoEndpointsAndThreeServices();\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"namespace-a\", present - Endpoints with name : \"b\" and namespace \"namespace-b\", present - Service with name \"a\" and namespace \"namespace-a\" present - Service with name \"b\" and namespace \"namespace-b\" present - Service with name \"c\" and namespace \"namespace-c\" present As such, there are two matches. \u003c/pre\u003e\n */\n  @Test void withFilterSingleEndpointsMatchesFilter();\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a-1\" and namespace \"default\", present - Endpoints with name : \"b-1\" and namespace \"default\", present - Endpoints with name : \"c-2\" and namespace \"default\", present - Service with name \"a-1\" and namespace \"default\" present - Service with name \"b-1\" and namespace \"default\" present As such, there are two matches. \u003c/pre\u003e\n */\n  @Test void withFilterTwoEndpointsMatchesFilter();\n  /** \n * \u003cpre\u003e - Endpoints with name : \"a\" and namespace \"default\", present - Service with name \"a-1\" and namespace \"default\" present - Service with name \"b-1\" and namespace \"default\" present As such, there are two matches. \u003c/pre\u003e\n */\n  @Test void withFilterSingleEndpointsNoPredicateMatch();\n  private Endpoints createEndpoints(  String name,  String namespace);\n  private void createService(  String name,  String namespace);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesCatalogServicesWatchConfigurationTest.java",
        "name": "KubernetesCatalogServicesWatchConfigurationTest",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesCatalogServicesWatchConfigurationTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Oleg Vyukov\n * @author Tim Ysewyn\n */\nclass KubernetesCatalogServicesWatchConfigurationTest {\n  private ConfigurableApplicationContext context;\n  @AfterEach void close(){\n    if (context !\u003d null) {\n      context.close();\n    }\n  }\n  @Test void kubernetesCatalogWatchDisabled(){\n    setup(\"spring.cloud.kubernetes.discovery.catalog-services-watch.enabled\u003dfalse\");\n    assertThat(context.containsBean(\"kubernetesCatalogWatch\")).isFalse();\n  }\n  @Test void kubernetesCatalogWatchWhenKubernetesDisabled(){\n    setup();\n    assertThat(context.containsBean(\"kubernetesCatalogWatch\")).isFalse();\n  }\n  @Test void kubernetesCatalogWatchWhenServiceDiscoveryDisabled(){\n    setup(\"spring.cloud.discovery.enabled\u003dfalse\");\n    assertThat(context.containsBean(\"kubernetesCatalogWatch\")).isFalse();\n  }\n  @Test void kubernetesCatalogWatchDefaultEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.use-endpoint-slices\u003dfalse\");\n    assertThat(context.containsBean(\"kubernetesCatalogWatch\")).isTrue();\n  }\n  private void setup(  String... env){\n    List\u003cString\u003e envList\u003dnew ArrayList\u003c\u003e(Arrays.asList(env));\n    envList.add(\"spring.cloud.config.enabled\u003dfalse\");\n    context\u003dnew SpringApplicationBuilder(PropertyPlaceholderAutoConfiguration.class,KubernetesClientTestConfiguration.class,KubernetesCatalogWatchAutoConfiguration.class,KubernetesDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class).web(WebApplicationType.NONE).properties(envList.toArray(new String[0])).run();\n  }\n@Configuration(proxyBeanMethods\u003dfalse) static class KubernetesClientTestConfiguration {\n    @Bean KubernetesClient kubernetesClient(){\n      return mock(KubernetesClient.class);\n    }\n    @SuppressWarnings(\"unchecked\") @Bean PodUtils\u003c?\u003e podUtils(){\n      PodUtils\u003cPod\u003e podPodUtils\u003dmock(PodUtils.class);\n      when(podPodUtils.currentPod()).thenReturn(() -\u003e mock(Pod.class));\n      return podPodUtils;\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Oleg Vyukov\n * @author Tim Ysewyn\n */\nclass KubernetesCatalogServicesWatchConfigurationTest {\n  private ConfigurableApplicationContext context;\n  @AfterEach void close();\n  @Test void kubernetesCatalogWatchDisabled();\n  @Test void kubernetesCatalogWatchWhenKubernetesDisabled();\n  @Test void kubernetesCatalogWatchWhenServiceDiscoveryDisabled();\n  @Test void kubernetesCatalogWatchDefaultEnabled();\n  private void setup(  String... env);\n@Configuration(proxyBeanMethods\u003dfalse) static class KubernetesClientTestConfiguration {\n    @Bean KubernetesClient kubernetesClient();\n    @SuppressWarnings(\"unchecked\") @Bean PodUtils\u003c?\u003e podUtils();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8EndpointsAndEndpointSlicesTests.java",
        "name": "Fabric8EndpointsAndEndpointSlicesTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8EndpointsAndEndpointSlicesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * make sure that all the tests for endpoints are also handled by endpoint slices\n * @author wind57\n */\nabstract class Fabric8EndpointsAndEndpointSlicesTests {\n  static final KubernetesNamespaceProvider NAMESPACE_PROVIDER\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  static final ArgumentCaptor\u003cHeartbeatEvent\u003e HEARTBEAT_EVENT_ARGUMENT_CAPTOR\u003dArgumentCaptor.forClass(HeartbeatEvent.class);\n  static final ApplicationEventPublisher APPLICATION_EVENT_PUBLISHER\u003dMockito.mock(ApplicationEventPublisher.class);\n  @BeforeAll static void setUp(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient().getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterEach void afterEach(){\n    Mockito.reset(APPLICATION_EVENT_PUBLISHER);\n    mockClient().discovery().v1().endpointSlices().inAnyNamespace().delete();\n    mockClient().endpoints().inAnyNamespace().delete();\n  }\n  /** \n * \u003cpre\u003e - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We set the namespace to be \"namespaceA\" and search for labels {color\u003dblue} As a result only one pod is taken: podB \u003c/pre\u003e\n */\n  abstract void testInSpecificNamespaceWithServiceLabels();\n  /** \n * \u003cpre\u003e - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We set the namespace to be \"namespaceA\" and search without labels As a result we get three pods: - podA in namespaceA - podB in namespaceA - pocC in namespaceA \u003c/pre\u003e\n */\n  abstract void testInSpecificNamespaceWithoutServiceLabels();\n  /** \n * \u003cpre\u003e - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We search in all namespaces with labels {color\u003dblue} As a result two pods are taken: - podB in namespaceA - podD in namespaceB \u003c/pre\u003e\n */\n  abstract void testInAllNamespacesWithServiceLabels();\n  /** \n * \u003cpre\u003e - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We search in all namespaces without labels As a result we get all 5 pods \u003c/pre\u003e\n */\n  abstract void testInAllNamespacesWithoutServiceLabels();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - namespaces \u003d [namespaceB] - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We search with labels \u003d {color \u003d blue} Even if namespaces \u003d [namespaceB], we still take podB and podD, because all-namespace\u003dtrue \u003c/pre\u003e\n */\n  abstract void testAllNamespacesTrueOtherBranchesNotCalled();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - namespaces \u003d [namespaceA] - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We search with labels \u003d {color \u003d blue} Since namespaces \u003d [namespaceA], we wil take podB, because all-namespace\u003dfalse (podD is not part of the response) \u003c/pre\u003e\n */\n  abstract void testAllNamespacesFalseNamespacesPresent();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - namespaces \u003d [] - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We search with labels \u003d {color \u003d blue} Since namespaces \u003d [], we wil take podB, because all-namespace\u003dfalse (podD is not part of the response) \u003c/pre\u003e\n */\n  abstract void testAllNamespacesFalseNamespacesNotPresent();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - namespaces \u003d [namespaceA, namespaceB] - we have 7 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels - podF in namespaceB with labels {color\u003dblue} - podO in namespaceC with labels {color\u003dblue} We search with labels \u003d {color \u003d blue} Since namespaces \u003d [namespaceA, namespaceB], we wil take podB, podD and podF, but will not take podO \u003c/pre\u003e\n */\n  abstract void testTwoNamespacesOutOfThree();\n  KubernetesCatalogWatch createWatcherInAllNamespacesWithLabels(  Map\u003cString,String\u003e labels,  Set\u003cString\u003e namespaces,  boolean endpointSlices){\n    boolean allNamespaces\u003dtrue;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60,false,\"\",Set.of(),labels,\"\",null,0,endpointSlices);\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(mockClient(),properties,NAMESPACE_PROVIDER);\n    if (endpointSlices) {\n      watch\u003dMockito.spy(watch);\n      Mockito.doReturn(new Fabric8EndpointSliceV1CatalogWatch()).when(watch).stateGenerator();\n    }\n    watch.postConstruct();\n    watch.setApplicationEventPublisher(APPLICATION_EVENT_PUBLISHER);\n    return watch;\n  }\n  KubernetesCatalogWatch createWatcherInSpecificNamespaceWithLabels(  String namespace,  Map\u003cString,String\u003e labels,  boolean endpointSlices){\n    when(NAMESPACE_PROVIDER.getNamespace()).thenReturn(namespace);\n    boolean allNamespaces\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(namespace),true,60,false,\"\",Set.of(),labels,\"\",null,0,endpointSlices);\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(mockClient(),properties,NAMESPACE_PROVIDER);\n    if (endpointSlices) {\n      watch\u003dMockito.spy(watch);\n      Mockito.doReturn(new Fabric8EndpointSliceV1CatalogWatch()).when(watch).stateGenerator();\n    }\n    watch.postConstruct();\n    watch.setApplicationEventPublisher(APPLICATION_EVENT_PUBLISHER);\n    return watch;\n  }\n  KubernetesCatalogWatch createWatcherInSpecificNamespacesWithLabels(  Set\u003cString\u003e namespaces,  Map\u003cString,String\u003e labels,  boolean endpointSlices){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,namespaces,true,60,false,\"\",Set.of(),labels,\"\",null,0,false);\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(mockClient(),properties,NAMESPACE_PROVIDER);\n    if (endpointSlices) {\n      watch\u003dMockito.spy(watch);\n      Mockito.doReturn(new Fabric8EndpointSliceV1CatalogWatch()).when(watch).stateGenerator();\n    }\n    watch.setApplicationEventPublisher(APPLICATION_EVENT_PUBLISHER);\n    watch.postConstruct();\n    return watch;\n  }\n  void endpoints(  String namespace,  Map\u003cString,String\u003e labels,  String podName){\n    EndpointAddress endpointAddress\u003dnew EndpointAddressBuilder().withTargetRef(new ObjectReferenceBuilder().withName(podName).withNamespace(namespace).build()).build();\n    EndpointSubset endpointSubset\u003dnew EndpointSubsetBuilder().withAddresses(List.of(endpointAddress)).build();\n    Endpoints endpoints\u003dnew EndpointsBuilder().withMetadata(new ObjectMetaBuilder().withLabels(labels).withName(\"endpoints-\" + podName).build()).withSubsets(List.of(endpointSubset)).build();\n    mockClient().endpoints().inNamespace(namespace).resource(endpoints).create();\n  }\n  void service(  String namespace,  Map\u003cString,String\u003e labels,  String podName){\n    Service service\u003dnew ServiceBuilder().withMetadata(new ObjectMetaBuilder().withLabels(labels).withName(\"endpoints-\" + podName).build()).build();\n    mockClient().services().inNamespace(namespace).resource(service).create();\n  }\n  static void endpointSlice(  String namespace,  Map\u003cString,String\u003e labels,  String podName){\n    Endpoint endpoint\u003dnew EndpointBuilder().withTargetRef(new ObjectReferenceBuilder().withName(podName).withNamespace(namespace).build()).build();\n    EndpointSlice slice\u003dnew EndpointSliceBuilder().withMetadata(new ObjectMetaBuilder().withNamespace(namespace).withName(\"slice-\" + podName).withLabels(labels).build()).withEndpoints(endpoint).build();\n    mockClient().discovery().v1().endpointSlices().inNamespace(namespace).resource(slice).create();\n  }\n  static void invokeAndAssert(  KubernetesCatalogWatch watch,  List\u003cEndpointNameAndNamespace\u003e state){\n    watch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER,Mockito.atLeastOnce()).publishEvent(HEARTBEAT_EVENT_ARGUMENT_CAPTOR.capture());\n    HeartbeatEvent event\u003dHEARTBEAT_EVENT_ARGUMENT_CAPTOR.getValue();\n    assertThat(event.getValue()).isInstanceOf(List.class);\n    assertThat(event.getValue()).isEqualTo(state);\n  }\n  private static KubernetesClient mockClient(){\n    return Fabric8KubernetesCatalogWatchEndpointsTests.endpointsMockClient() !\u003d null ? Fabric8KubernetesCatalogWatchEndpointsTests.endpointsMockClient() : Fabric8KubernetesCatalogWatchEndpointSlicesTests.endpointSlicesMockClient();\n  }\n}\n",
        "abstract": "/** \n * make sure that all the tests for endpoints are also handled by endpoint slices\n * @author wind57\n */\nabstract class Fabric8EndpointsAndEndpointSlicesTests {\n  static final KubernetesNamespaceProvider NAMESPACE_PROVIDER\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  static final ArgumentCaptor\u003cHeartbeatEvent\u003e HEARTBEAT_EVENT_ARGUMENT_CAPTOR\u003dArgumentCaptor.forClass(HeartbeatEvent.class);\n  static final ApplicationEventPublisher APPLICATION_EVENT_PUBLISHER\u003dMockito.mock(ApplicationEventPublisher.class);\n  @BeforeAll static void setUp();\n  @AfterEach void afterEach();\n  /** \n * \u003cpre\u003e - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We set the namespace to be \"namespaceA\" and search for labels {color\u003dblue} As a result only one pod is taken: podB \u003c/pre\u003e\n */\n  abstract void testInSpecificNamespaceWithServiceLabels();\n  /** \n * \u003cpre\u003e - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We set the namespace to be \"namespaceA\" and search without labels As a result we get three pods: - podA in namespaceA - podB in namespaceA - pocC in namespaceA \u003c/pre\u003e\n */\n  abstract void testInSpecificNamespaceWithoutServiceLabels();\n  /** \n * \u003cpre\u003e - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We search in all namespaces with labels {color\u003dblue} As a result two pods are taken: - podB in namespaceA - podD in namespaceB \u003c/pre\u003e\n */\n  abstract void testInAllNamespacesWithServiceLabels();\n  /** \n * \u003cpre\u003e - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We search in all namespaces without labels As a result we get all 5 pods \u003c/pre\u003e\n */\n  abstract void testInAllNamespacesWithoutServiceLabels();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - namespaces \u003d [namespaceB] - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We search with labels \u003d {color \u003d blue} Even if namespaces \u003d [namespaceB], we still take podB and podD, because all-namespace\u003dtrue \u003c/pre\u003e\n */\n  abstract void testAllNamespacesTrueOtherBranchesNotCalled();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - namespaces \u003d [namespaceA] - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We search with labels \u003d {color \u003d blue} Since namespaces \u003d [namespaceA], we wil take podB, because all-namespace\u003dfalse (podD is not part of the response) \u003c/pre\u003e\n */\n  abstract void testAllNamespacesFalseNamespacesPresent();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - namespaces \u003d [] - we have 5 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels We search with labels \u003d {color \u003d blue} Since namespaces \u003d [], we wil take podB, because all-namespace\u003dfalse (podD is not part of the response) \u003c/pre\u003e\n */\n  abstract void testAllNamespacesFalseNamespacesNotPresent();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - namespaces \u003d [namespaceA, namespaceB] - we have 7 pods involved in this test - podA in namespaceA with no labels - podB in namespaceA with labels {color\u003dblue} - podC in namespaceA with labels {color\u003dred} - podD in namespaceB with labels {color\u003dblue} - podE in namespaceB with no labels - podF in namespaceB with labels {color\u003dblue} - podO in namespaceC with labels {color\u003dblue} We search with labels \u003d {color \u003d blue} Since namespaces \u003d [namespaceA, namespaceB], we wil take podB, podD and podF, but will not take podO \u003c/pre\u003e\n */\n  abstract void testTwoNamespacesOutOfThree();\n  KubernetesCatalogWatch createWatcherInAllNamespacesWithLabels(  Map\u003cString,String\u003e labels,  Set\u003cString\u003e namespaces,  boolean endpointSlices);\n  KubernetesCatalogWatch createWatcherInSpecificNamespaceWithLabels(  String namespace,  Map\u003cString,String\u003e labels,  boolean endpointSlices);\n  KubernetesCatalogWatch createWatcherInSpecificNamespacesWithLabels(  Set\u003cString\u003e namespaces,  Map\u003cString,String\u003e labels,  boolean endpointSlices);\n  void endpoints(  String namespace,  Map\u003cString,String\u003e labels,  String podName);\n  void service(  String namespace,  Map\u003cString,String\u003e labels,  String podName);\n  static void endpointSlice(  String namespace,  Map\u003cString,String\u003e labels,  String podName);\n  static void invokeAndAssert(  KubernetesCatalogWatch watch,  List\u003cEndpointNameAndNamespace\u003e state);\n  private static KubernetesClient mockClient();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8CatalogWatchContextTests.java",
        "name": "Fabric8CatalogWatchContextTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8CatalogWatchContextTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass Fabric8CatalogWatchContextTests {\n  @Test void stateWithASingleElementNameNotNull(){\n    Stream\u003cObjectReference\u003e referenceStream\u003dStream.of(new ObjectReferenceBuilder().withName(\"a\").withNamespace(\"default\").build());\n    List\u003cEndpointNameAndNamespace\u003e result\u003dFabric8CatalogWatchContext.state(referenceStream);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).endpointName(),\"a\");\n    Assertions.assertEquals(result.get(0).namespace(),\"default\");\n  }\n  @Test void stateWithASingleElementNameNull(){\n    Stream\u003cObjectReference\u003e referenceStream\u003dStream.of(new ObjectReferenceBuilder().withName(null).withNamespace(\"default\").build());\n    List\u003cEndpointNameAndNamespace\u003e result\u003dFabric8CatalogWatchContext.state(referenceStream);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertNull(result.get(0).endpointName());\n    Assertions.assertEquals(result.get(0).namespace(),\"default\");\n  }\n  @Test void stateWithTwoElementsNameNull(){\n    Stream\u003cObjectReference\u003e referenceStream\u003dStream.of(new ObjectReferenceBuilder().withName(null).withNamespace(\"defaultNull\").build(),new ObjectReferenceBuilder().withName(\"a\").withNamespace(\"defaultA\").build());\n    List\u003cEndpointNameAndNamespace\u003e result\u003dFabric8CatalogWatchContext.state(referenceStream);\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertEquals(result.get(0).endpointName(),\"a\");\n    Assertions.assertEquals(result.get(0).namespace(),\"defaultA\");\n    Assertions.assertNull(result.get(1).endpointName());\n    Assertions.assertEquals(result.get(1).namespace(),\"defaultNull\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass Fabric8CatalogWatchContextTests {\n  @Test void stateWithASingleElementNameNotNull();\n  @Test void stateWithASingleElementNameNull();\n  @Test void stateWithTwoElementsNameNull();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8InstanceIdHostPodNameSupplierTests.java",
        "name": "Fabric8InstanceIdHostPodNameSupplierTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8InstanceIdHostPodNameSupplierTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass Fabric8InstanceIdHostPodNameSupplierTests {\n  @Test void instanceIdNoEndpointAddress(){\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().build()).withMetadata(new ObjectMetaBuilder().withUid(\"123\").build()).build();\n    Fabric8InstanceIdHostPodNameSupplier supplier\u003dFabric8InstanceIdHostPodNameSupplier.externalName(service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.instanceId(),\"123\");\n  }\n  @Test void instanceIdWithEndpointAddress(){\n    EndpointAddress endpointAddress\u003dnew EndpointAddressBuilder().withTargetRef(new ObjectReferenceBuilder().withUid(\"456\").build()).build();\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().build()).withMetadata(new ObjectMetaBuilder().withUid(\"123\").build()).build();\n    Fabric8InstanceIdHostPodNameSupplier supplier\u003dFabric8InstanceIdHostPodNameSupplier.nonExternalName(endpointAddress,service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.instanceId(),\"456\");\n  }\n  @Test void hostNoEndpointAddress(){\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withExternalName(\"external-name\").build()).withMetadata(new ObjectMeta()).build();\n    Fabric8InstanceIdHostPodNameSupplier supplier\u003dFabric8InstanceIdHostPodNameSupplier.externalName(service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.host(),\"external-name\");\n  }\n  @Test void hostWithEndpointAddress(){\n    EndpointAddress endpointAddress\u003dnew EndpointAddressBuilder().withIp(\"127.0.0.1\").build();\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withExternalName(\"external-name\").build()).withMetadata(new ObjectMeta()).build();\n    Fabric8InstanceIdHostPodNameSupplier supplier\u003dFabric8InstanceIdHostPodNameSupplier.nonExternalName(endpointAddress,service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.host(),\"127.0.0.1\");\n  }\n  @Test void testPodNameIsNull(){\n    Service service\u003dnew ServiceBuilder().withMetadata(new ObjectMetaBuilder().withUid(\"123\").build()).withSpec(new ServiceSpecBuilder().withExternalName(\"external-name\").build()).build();\n    Fabric8InstanceIdHostPodNameSupplier supplier\u003dFabric8InstanceIdHostPodNameSupplier.externalName(service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertNull(result.podName());\n  }\n  @Test void podNameKindNotPod(){\n    EndpointAddress endpointAddress\u003dnew EndpointAddressBuilder().withTargetRef(new ObjectReferenceBuilder().withKind(\"Service\").build()).build();\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withExternalName(\"external-name\").build()).withMetadata(new ObjectMeta()).build();\n    Fabric8InstanceIdHostPodNameSupplier supplier\u003dFabric8InstanceIdHostPodNameSupplier.nonExternalName(endpointAddress,service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertNull(result.podName());\n  }\n  @Test void podNameKindIsPod(){\n    EndpointAddress endpointAddress\u003dnew EndpointAddressBuilder().withTargetRef(new ObjectReferenceBuilder().withKind(\"Pod\").withName(\"my-pod\").build()).build();\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withExternalName(\"external-name\").build()).withMetadata(new ObjectMeta()).build();\n    Fabric8InstanceIdHostPodNameSupplier supplier\u003dFabric8InstanceIdHostPodNameSupplier.nonExternalName(endpointAddress,service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.podName(),\"my-pod\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass Fabric8InstanceIdHostPodNameSupplierTests {\n  @Test void instanceIdNoEndpointAddress();\n  @Test void instanceIdWithEndpointAddress();\n  @Test void hostNoEndpointAddress();\n  @Test void hostWithEndpointAddress();\n  @Test void testPodNameIsNull();\n  @Test void podNameKindNotPod();\n  @Test void podNameKindIsPod();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8KubernetesCatalogWatchEndpointSlicesTests.java",
        "name": "Fabric8KubernetesCatalogWatchEndpointSlicesTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8KubernetesCatalogWatchEndpointSlicesTests",
        "extend": "Fabric8EndpointsAndEndpointSlicesTests",
        "implements": "",
        "raw": "/** \n * Some tests that use the fabric8 mock client, using EndpointSlices\n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8KubernetesCatalogWatchEndpointSlicesTests extends Fabric8EndpointsAndEndpointSlicesTests {\n  private static final Boolean ENDPOINT_SLICES\u003dtrue;\n  private static KubernetesClient mockClient;\n  @Test @Override void testInSpecificNamespaceWithServiceLabels(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespaceWithLabels(\"namespaceA\",Map.of(\"color\",\"blue\"),ENDPOINT_SLICES);\n    endpointSlice(\"namespaceA\",Map.of(),\"podA\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpointSlice(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpointSlice(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podB\",\"namespaceA\")));\n  }\n  @Test @Override void testInSpecificNamespaceWithoutServiceLabels(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespaceWithLabels(\"namespaceA\",Map.of(),ENDPOINT_SLICES);\n    endpointSlice(\"namespaceA\",Map.of(),\"podA\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpointSlice(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpointSlice(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podA\",\"namespaceA\"),new EndpointNameAndNamespace(\"podB\",\"namespaceA\"),new EndpointNameAndNamespace(\"podC\",\"namespaceA\")));\n  }\n  @Test @Override void testInAllNamespacesWithServiceLabels(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInAllNamespacesWithLabels(Map.of(\"color\",\"blue\"),Set.of(),ENDPOINT_SLICES);\n    endpointSlice(\"namespaceA\",Map.of(),\"podA\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpointSlice(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpointSlice(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podB\",\"namespaceA\"),new EndpointNameAndNamespace(\"podD\",\"namespaceB\")));\n  }\n  @Test @Override void testInAllNamespacesWithoutServiceLabels(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInAllNamespacesWithLabels(Map.of(),Set.of(),ENDPOINT_SLICES);\n    endpointSlice(\"namespaceA\",Map.of(),\"podA\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpointSlice(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpointSlice(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podA\",\"namespaceA\"),new EndpointNameAndNamespace(\"podB\",\"namespaceA\"),new EndpointNameAndNamespace(\"podC\",\"namespaceA\"),new EndpointNameAndNamespace(\"podD\",\"namespaceB\"),new EndpointNameAndNamespace(\"podE\",\"namespaceB\")));\n  }\n  @Test @Override void testAllNamespacesTrueOtherBranchesNotCalled(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInAllNamespacesWithLabels(Map.of(\"color\",\"blue\"),Set.of(\"B\"),ENDPOINT_SLICES);\n    endpointSlice(\"namespaceA\",Map.of(),\"podA\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpointSlice(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpointSlice(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podB\",\"namespaceA\"),new EndpointNameAndNamespace(\"podD\",\"namespaceB\")));\n  }\n  @Test @Override void testAllNamespacesFalseNamespacesPresent(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespacesWithLabels(Set.of(\"namespaceA\"),Map.of(\"color\",\"blue\"),ENDPOINT_SLICES);\n    endpointSlice(\"namespaceA\",Map.of(),\"podA\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpointSlice(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpointSlice(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podB\",\"namespaceA\")));\n  }\n  @Test @Override void testAllNamespacesFalseNamespacesNotPresent(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespaceWithLabels(\"namespaceA\",Map.of(\"color\",\"blue\"),ENDPOINT_SLICES);\n    endpointSlice(\"namespaceA\",Map.of(),\"podA\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpointSlice(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpointSlice(\"namespaceB\",Map.of(),\"podE\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podB\",\"namespaceA\")));\n  }\n  @Test @Override void testTwoNamespacesOutOfThree(){\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespacesWithLabels(Set.of(\"namespaceA\",\"namespaceB\"),Map.of(\"color\",\"blue\"),ENDPOINT_SLICES);\n    endpointSlice(\"namespaceA\",Map.of(),\"podA\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"blue\"),\"podB\");\n    endpointSlice(\"namespaceA\",Map.of(\"color\",\"red\"),\"podC\");\n    endpointSlice(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podD\");\n    endpointSlice(\"namespaceB\",Map.of(),\"podE\");\n    endpointSlice(\"namespaceB\",Map.of(\"color\",\"blue\"),\"podF\");\n    endpointSlice(\"namespaceC\",Map.of(\"color\",\"blue\"),\"podO\");\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"podB\",\"namespaceA\"),new EndpointNameAndNamespace(\"podD\",\"namespaceB\"),new EndpointNameAndNamespace(\"podF\",\"namespaceB\")));\n  }\n  static KubernetesClient endpointSlicesMockClient(){\n    return mockClient;\n  }\n}\n",
        "abstract": "/** \n * Some tests that use the fabric8 mock client, using EndpointSlices\n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8KubernetesCatalogWatchEndpointSlicesTests extends Fabric8EndpointsAndEndpointSlicesTests {\n  private static final Boolean ENDPOINT_SLICES\u003dtrue;\n  private static KubernetesClient mockClient;\n  @Test @Override void testInSpecificNamespaceWithServiceLabels();\n  @Test @Override void testInSpecificNamespaceWithoutServiceLabels();\n  @Test @Override void testInAllNamespacesWithServiceLabels();\n  @Test @Override void testInAllNamespacesWithoutServiceLabels();\n  @Test @Override void testAllNamespacesTrueOtherBranchesNotCalled();\n  @Test @Override void testAllNamespacesFalseNamespacesPresent();\n  @Test @Override void testAllNamespacesFalseNamespacesNotPresent();\n  @Test @Override void testTwoNamespacesOutOfThree();\n  static KubernetesClient endpointSlicesMockClient();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesDiscoveryClientFilterTest.java",
        "name": "KubernetesDiscoveryClientFilterTest",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesDiscoveryClientFilterTest",
        "extend": "",
        "implements": "",
        "raw": "class KubernetesDiscoveryClientFilterTest {\n  private final KubernetesClient kubernetesClient\u003dMockito.mock(KubernetesClient.class);\n  private final KubernetesClientServicesFunction kubernetesClientServicesFunction\u003dKubernetesClient::services;\n  private final MixedOperation\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e serviceOperation\u003dMockito.mock(MixedOperation.class);\n  @Test void testFilteredServices(){\n    List\u003cString\u003e springBootServiceNames\u003dArrays.asList(\"serviceA\",\"serviceB\");\n    List\u003cService\u003e services\u003dcreateSpringBootServiceByName(springBootServiceNames);\n    Service service\u003dnew Service();\n    ObjectMeta objectMeta\u003dnew ObjectMeta();\n    objectMeta.setName(\"ServiceNonSpringBoot\");\n    service.setMetadata(objectMeta);\n    services.add(service);\n    ServiceList serviceList\u003dnew ServiceList();\n    serviceList.setItems(services);\n    when(this.serviceOperation.list()).thenReturn(serviceList);\n    when(this.kubernetesClient.services()).thenReturn(this.serviceOperation);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,\"metadata.additionalProperties[\u0027spring-boot\u0027]\",Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesDiscoveryClient client\u003dnew KubernetesDiscoveryClient(this.kubernetesClient,properties,this.kubernetesClientServicesFunction);\n    List\u003cString\u003e filteredServices\u003dclient.getServices();\n    assertThat(filteredServices).isEqualTo(springBootServiceNames);\n  }\n  @Test void testFilteredServicesByPrefix(){\n    List\u003cString\u003e springBootServiceNames\u003dArrays.asList(\"serviceA\",\"serviceB\",\"serviceC\");\n    List\u003cService\u003e services\u003dcreateSpringBootServiceByName(springBootServiceNames);\n    Service service\u003dnew Service();\n    ObjectMeta objectMeta\u003dnew ObjectMeta();\n    objectMeta.setName(\"anotherService\");\n    service.setMetadata(objectMeta);\n    services.add(service);\n    ServiceList serviceList\u003dnew ServiceList();\n    serviceList.setItems(services);\n    when(this.serviceOperation.list()).thenReturn(serviceList);\n    when(this.kubernetesClient.services()).thenReturn(this.serviceOperation);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,\"metadata.name.startsWith(\u0027service\u0027)\",Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesDiscoveryClient client\u003dnew KubernetesDiscoveryClient(this.kubernetesClient,properties,this.kubernetesClientServicesFunction);\n    List\u003cString\u003e filteredServices\u003dclient.getServices();\n    assertThat(filteredServices).isEqualTo(springBootServiceNames);\n  }\n  @Test void testNoExpression(){\n    List\u003cString\u003e springBootServiceNames\u003dArrays.asList(\"serviceA\",\"serviceB\",\"serviceC\");\n    List\u003cService\u003e services\u003dcreateSpringBootServiceByName(springBootServiceNames);\n    ServiceList serviceList\u003dnew ServiceList();\n    serviceList.setItems(services);\n    when(this.serviceOperation.list()).thenReturn(serviceList);\n    when(this.kubernetesClient.services()).thenReturn(this.serviceOperation);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,\"\",Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesDiscoveryClient client\u003dnew KubernetesDiscoveryClient(this.kubernetesClient,properties,this.kubernetesClientServicesFunction);\n    List\u003cString\u003e filteredServices\u003dclient.getServices();\n    assertThat(filteredServices).isEqualTo(springBootServiceNames);\n  }\n  private List\u003cService\u003e createSpringBootServiceByName(  List\u003cString\u003e serviceNames){\n    List\u003cService\u003e serviceCollection\u003dnew ArrayList\u003c\u003e(serviceNames.size());\n    for (    String serviceName : serviceNames) {\n      Service service\u003dnew Service();\n      ObjectMeta objectMeta\u003dnew ObjectMeta();\n      objectMeta.setName(serviceName);\n      objectMeta.setAdditionalProperty(\"spring-boot\",\"true\");\n      service.setMetadata(objectMeta);\n      serviceCollection.add(service);\n    }\n    return serviceCollection;\n  }\n}\n",
        "abstract": "class KubernetesDiscoveryClientFilterTest {\n  private final KubernetesClient kubernetesClient\u003dMockito.mock(KubernetesClient.class);\n  private final KubernetesClientServicesFunction kubernetesClientServicesFunction\u003dKubernetesClient::services;\n  private final MixedOperation\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e serviceOperation\u003dMockito.mock(MixedOperation.class);\n  @Test void testFilteredServices();\n  @Test void testFilteredServicesByPrefix();\n  @Test void testNoExpression();\n  private List\u003cService\u003e createSpringBootServiceByName(  List\u003cString\u003e serviceNames);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesDiscoveryClientAutoConfigurationTests.java",
        "name": "KubernetesDiscoveryClientAutoConfigurationTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dWebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.use-endpoint-slices\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesDiscoveryClientAutoConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dWebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.use-endpoint-slices\u003dfalse\"}) class KubernetesDiscoveryClientAutoConfigurationTests {\n  @Autowired private DiscoveryClient discoveryClient;\n  @Test void kubernetesDiscoveryClientCreated(){\n    assertThat(this.discoveryClient).isInstanceOf(CompositeDiscoveryClient.class);\n    CompositeDiscoveryClient composite\u003d(CompositeDiscoveryClient)this.discoveryClient;\n    assertThat(composite.getDiscoveryClients().stream().anyMatch(dc -\u003e dc instanceof KubernetesDiscoveryClient)).isTrue();\n  }\n@SpringBootApplication protected static class TestConfig {\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dWebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.use-endpoint-slices\u003dfalse\"}) class KubernetesDiscoveryClientAutoConfigurationTests {\n  @Autowired private DiscoveryClient discoveryClient;\n  @Test void kubernetesDiscoveryClientCreated();\n@SpringBootApplication protected static class TestConfig {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/reactive/KubernetesReactiveDiscoveryClientTests.java",
        "name": "KubernetesReactiveDiscoveryClientTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.reactive.KubernetesReactiveDiscoveryClientTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Tim Ysewyn\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class KubernetesReactiveDiscoveryClientTests {\n  private static KubernetesMockServer kubernetesServer;\n  private static KubernetesClient kubernetesClient;\n  @BeforeEach void beforeEach(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,kubernetesClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterEach void afterEach(){\n    kubernetesServer.clearExpectations();\n  }\n  @Test void verifyDefaults(){\n    ReactiveDiscoveryClient client\u003dnew KubernetesReactiveDiscoveryClient(kubernetesClient,KubernetesDiscoveryProperties.DEFAULT,KubernetesClient::services);\n    assertThat(client.description()).isEqualTo(\"Fabric8 Kubernetes Reactive Discovery Client\");\n    assertThat(client.getOrder()).isEqualTo(ReactiveDiscoveryClient.DEFAULT_ORDER);\n  }\n  @Test void shouldReturnFluxOfServices(){\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/services\").andReturn(200,new ServiceListBuilder().addNewItem().withNewMetadata().withName(\"s1\").withLabels(Map.of(\"label\",\"value\")).endMetadata().endItem().addNewItem().withNewMetadata().withName(\"s2\").withLabels(Map.of(\"label\",\"value\",\"label2\",\"value2\")).endMetadata().endItem().addNewItem().withNewMetadata().withName(\"s3\").endMetadata().endItem().build()).once();\n    ReactiveDiscoveryClient client\u003dnew KubernetesReactiveDiscoveryClient(kubernetesClient,KubernetesDiscoveryProperties.DEFAULT,KubernetesClient::services);\n    Flux\u003cString\u003e services\u003dclient.getServices();\n    StepVerifier.create(services).expectNext(\"s1\",\"s2\",\"s3\").expectComplete().verify();\n  }\n  @Test void shouldReturnEmptyFluxOfServicesWhenNoInstancesFound(){\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/services\").andReturn(200,new ServiceListBuilder().build()).once();\n    ReactiveDiscoveryClient client\u003dnew KubernetesReactiveDiscoveryClient(kubernetesClient,KubernetesDiscoveryProperties.DEFAULT,KubernetesClient::services);\n    Flux\u003cString\u003e services\u003dclient.getServices();\n    StepVerifier.create(services).expectNextCount(0).expectComplete().verify();\n  }\n  @Test void shouldReturnEmptyFluxForNonExistingService(){\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/endpoints?fieldSelector\u003dmetadata.name%3Dnonexistent-service\").andReturn(200,new EndpointsBuilder().build()).once();\n    ReactiveDiscoveryClient client\u003dnew KubernetesReactiveDiscoveryClient(kubernetesClient,KubernetesDiscoveryProperties.DEFAULT,KubernetesClient::services);\n    Flux\u003cServiceInstance\u003e instances\u003dclient.getInstances(\"nonexistent-service\");\n    StepVerifier.create(instances).expectNextCount(0).expectComplete().verify();\n  }\n  @Test void shouldReturnEmptyFluxWhenServiceHasNoSubsets(){\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/services\").andReturn(200,new ServiceListBuilder().addNewItem().withNewMetadata().withName(\"existing-service\").withLabels(Map.of(\"label\",\"value\")).endMetadata().endItem().build()).once();\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/endpoints?fieldSelector\u003dmetadata.name%3Dexisting-service\").andReturn(200,new EndpointsBuilder().build()).once();\n    ReactiveDiscoveryClient client\u003dnew KubernetesReactiveDiscoveryClient(kubernetesClient,KubernetesDiscoveryProperties.DEFAULT,KubernetesClient::services);\n    Flux\u003cServiceInstance\u003e instances\u003dclient.getInstances(\"existing-service\");\n    StepVerifier.create(instances).expectNextCount(0).expectComplete().verify();\n  }\n  @Test void shouldReturnFlux(){\n    ServiceList services\u003dnew ServiceListBuilder().addNewItem().withNewMetadata().withName(\"existing-service\").withNamespace(\"test\").withLabels(Map.of(\"label\",\"value\")).endMetadata().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).endItem().build();\n    Endpoints endPoint\u003dnew EndpointsBuilder().withNewMetadata().withName(\"existing-service\").withNamespace(\"test\").withLabels(Map.of(\"label\",\"value\")).endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"uid1\").endTargetRef().endAddress().addNewPort(\"http\",\"http_tcp\",80,\"TCP\").endSubset().build();\n    List\u003cEndpoints\u003e endpointsList\u003dnew ArrayList\u003c\u003e();\n    endpointsList.add(endPoint);\n    EndpointsList endpoints\u003dnew EndpointsList();\n    endpoints.setItems(endpointsList);\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/endpoints?fieldSelector\u003dmetadata.name%3Dexisting-service\").andReturn(200,endpoints).once();\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/services/existing-service\").andReturn(200,services.getItems().get(0)).once();\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/services\").andReturn(200,services).once();\n    ReactiveDiscoveryClient client\u003dnew KubernetesReactiveDiscoveryClient(kubernetesClient,KubernetesDiscoveryProperties.DEFAULT,KubernetesClient::services);\n    Flux\u003cServiceInstance\u003e instances\u003dclient.getInstances(\"existing-service\");\n    StepVerifier.create(instances).expectNextCount(1).expectComplete().verify();\n  }\n  @Test void shouldReturnFluxWithPrefixedMetadata(){\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/services\").andReturn(200,new ServiceListBuilder().addNewItem().withNewMetadata().withName(\"existing-service\").withLabels(Map.of(\"label\",\"value\")).endMetadata().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).endItem().build()).once();\n    Endpoints endPoint\u003dnew EndpointsBuilder().withNewMetadata().withName(\"existing-service\").withNamespace(\"test\").endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"uid1\").endTargetRef().endAddress().addNewPort(\"http\",\"http_tcp\",80,\"TCP\").endSubset().build();\n    List\u003cEndpoints\u003e endpointsList\u003dnew ArrayList\u003c\u003e();\n    endpointsList.add(endPoint);\n    EndpointsList endpoints\u003dnew EndpointsList();\n    endpoints.setItems(endpointsList);\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/endpoints?fieldSelector\u003dmetadata.name%3Dexisting-service\").andReturn(200,endpoints).once();\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/services/existing-service\").andReturn(200,new ServiceBuilder().withNewMetadata().withName(\"existing-service\").withLabels(Map.of(\"label\",\"value\")).endMetadata().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).build()).once();\n    ReactiveDiscoveryClient client\u003dnew KubernetesReactiveDiscoveryClient(kubernetesClient,KubernetesDiscoveryProperties.DEFAULT,KubernetesClient::services);\n    Flux\u003cServiceInstance\u003e instances\u003dclient.getInstances(\"existing-service\");\n    StepVerifier.create(instances).expectNextCount(1).expectComplete().verify();\n  }\n  @Test void shouldReturnFluxWhenServiceHasMultiplePortsAndPrimaryPortNameIsSet(){\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/services\").andReturn(200,new ServiceListBuilder().addNewItem().withNewMetadata().withName(\"existing-service\").withLabels(Map.of(\"label\",\"value\")).endMetadata().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).endItem().build()).once();\n    Endpoints endPoint\u003dnew EndpointsBuilder().withNewMetadata().withName(\"existing-service\").withNamespace(\"test\").endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"uid1\").endTargetRef().endAddress().addNewPort(\"http\",\"http_tcp\",80,\"TCP\").addNewPort(\"https\",\"https_tcp\",443,\"TCP\").endSubset().build();\n    List\u003cEndpoints\u003e endpointsList\u003dnew ArrayList\u003c\u003e();\n    endpointsList.add(endPoint);\n    EndpointsList endpoints\u003dnew EndpointsList();\n    endpoints.setItems(endpointsList);\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/endpoints?fieldSelector\u003dmetadata.name%3Dexisting-service\").andReturn(200,endpoints).once();\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/services/existing-service\").andReturn(200,new ServiceBuilder().withNewMetadata().withName(\"existing-service\").withLabels(Map.of(\"label\",\"value\")).endMetadata().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).build()).once();\n    ReactiveDiscoveryClient client\u003dnew KubernetesReactiveDiscoveryClient(kubernetesClient,KubernetesDiscoveryProperties.DEFAULT,KubernetesClient::services);\n    Flux\u003cServiceInstance\u003e instances\u003dclient.getInstances(\"existing-service\");\n    StepVerifier.create(instances).expectNextCount(1).expectComplete().verify();\n  }\n  @Test void shouldReturnFluxOfServicesAcrossAllNamespaces(){\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/services\").andReturn(200,new ServiceListBuilder().addNewItem().withNewMetadata().withName(\"existing-service\").withLabels(Map.of(\"label\",\"value\")).endMetadata().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).endItem().build()).once();\n    Endpoints endpoints\u003dnew EndpointsBuilder().withNewMetadata().withName(\"existing-service\").withNamespace(\"test\").endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"uid1\").endTargetRef().endAddress().addNewPort(\"http\",\"http_tcp\",80,\"TCP\").addNewPort(\"https\",\"https_tcp\",443,\"TCP\").endSubset().build();\n    EndpointsList endpointsList\u003dnew EndpointsList();\n    endpointsList.setItems(singletonList(endpoints));\n    kubernetesServer.expect().get().withPath(\"/api/v1/endpoints?fieldSelector\u003dmetadata.name%3Dexisting-service\").andReturn(200,endpointsList).once();\n    kubernetesServer.expect().get().withPath(\"/api/v1/namespaces/test/services/existing-service\").andReturn(200,new ServiceBuilder().withNewMetadata().withName(\"existing-service\").withLabels(Map.of(\"label\",\"value\")).endMetadata().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).build()).once();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),\"https_tcp\",Metadata.DEFAULT,0,true);\n    ReactiveDiscoveryClient client\u003dnew KubernetesReactiveDiscoveryClient(kubernetesClient,properties,KubernetesClient::services);\n    Flux\u003cServiceInstance\u003e instances\u003dclient.getInstances(\"existing-service\");\n    StepVerifier.create(instances).expectNextCount(1).expectComplete().verify();\n  }\n}\n",
        "abstract": "/** \n * @author Tim Ysewyn\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class KubernetesReactiveDiscoveryClientTests {\n  private static KubernetesMockServer kubernetesServer;\n  private static KubernetesClient kubernetesClient;\n  @BeforeEach void beforeEach();\n  @AfterEach void afterEach();\n  @Test void verifyDefaults();\n  @Test void shouldReturnFluxOfServices();\n  @Test void shouldReturnEmptyFluxOfServicesWhenNoInstancesFound();\n  @Test void shouldReturnEmptyFluxForNonExistingService();\n  @Test void shouldReturnEmptyFluxWhenServiceHasNoSubsets();\n  @Test void shouldReturnFlux();\n  @Test void shouldReturnFluxWithPrefixedMetadata();\n  @Test void shouldReturnFluxWhenServiceHasMultiplePortsAndPrimaryPortNameIsSet();\n  @Test void shouldReturnFluxOfServicesAcrossAllNamespaces();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/reactive/KubernetesReactiveDiscoveryClientAutoConfigurationTests.java",
        "name": "KubernetesReactiveDiscoveryClientAutoConfigurationTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.reactive.KubernetesReactiveDiscoveryClientAutoConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Tim Ysewyn\n */\nclass KubernetesReactiveDiscoveryClientAutoConfigurationTests {\n  private final ApplicationContextRunner contextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(UtilAutoConfiguration.class,ReactiveCommonsClientAutoConfiguration.class,KubernetesCommonsAutoConfiguration.class,Fabric8AutoConfiguration.class,KubernetesDiscoveryClientAutoConfiguration.class,KubernetesReactiveDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class));\n  @Test void shouldWorkWithDefaults(){\n    contextRunner.withPropertyValues(\"spring.main.cloud-platform\u003dKUBERNETES\").run(context -\u003e {\n      assertThat(context).hasSingleBean(ReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n  @Test void shouldNotHaveDiscoveryClientWhenDiscoveryDisabled(){\n    contextRunner.withPropertyValues(\"spring.cloud.discovery.enabled\u003dfalse\").run(context -\u003e {\n      assertThat(context).doesNotHaveBean(\"kubernetesReactiveDiscoveryClient\");\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n  @Test void shouldNotHaveDiscoveryClientWhenReactiveDiscoveryDisabled(){\n    contextRunner.withPropertyValues(\"spring.cloud.discovery.reactive.enabled\u003dfalse\").run(context -\u003e {\n      assertThat(context).doesNotHaveBean(\"kubernetesReactiveDiscoveryClient\");\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n  @Test void shouldNotHaveDiscoveryClientWhenKubernetesDisabled(){\n    contextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(\"kubernetesReactiveDiscoveryClient\");\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n  @Test void shouldNotHaveDiscoveryClientWhenKubernetesDiscoveryDisabled(){\n    contextRunner.withPropertyValues(\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\").run(context -\u003e {\n      assertThat(context).doesNotHaveBean(\"kubernetesReactiveDiscoveryClient\");\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n  @Test void worksWithoutWebflux(){\n    contextRunner.withClassLoader(new FilteredClassLoader(\"org.springframework.web.reactive\")).run(context -\u003e {\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n  @Test void worksWithoutActuator(){\n    contextRunner.withPropertyValues(\"spring.main.cloud-platform\u003dKUBERNETES\").withClassLoader(new FilteredClassLoader(\"org.springframework.boot.actuate\")).run(context -\u003e {\n      assertThat(context).hasSingleBean(ReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n}\n",
        "abstract": "/** \n * @author Tim Ysewyn\n */\nclass KubernetesReactiveDiscoveryClientAutoConfigurationTests {\n  private final ApplicationContextRunner contextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(UtilAutoConfiguration.class,ReactiveCommonsClientAutoConfiguration.class,KubernetesCommonsAutoConfiguration.class,Fabric8AutoConfiguration.class,KubernetesDiscoveryClientAutoConfiguration.class,KubernetesReactiveDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class));\n  @Test void shouldWorkWithDefaults();\n  @Test void shouldNotHaveDiscoveryClientWhenDiscoveryDisabled();\n  @Test void shouldNotHaveDiscoveryClientWhenReactiveDiscoveryDisabled();\n  @Test void shouldNotHaveDiscoveryClientWhenKubernetesDisabled();\n  @Test void shouldNotHaveDiscoveryClientWhenKubernetesDiscoveryDisabled();\n  @Test void worksWithoutWebflux();\n  @Test void worksWithoutActuator();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/reactive/KubernetesReactiveDiscoveryClientAutoConfigurationApplicationContextTests.java",
        "name": "KubernetesReactiveDiscoveryClientAutoConfigurationApplicationContextTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.reactive.KubernetesReactiveDiscoveryClientAutoConfigurationApplicationContextTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Test various conditionals for {@link KubernetesReactiveDiscoveryClientAutoConfiguration}\n * @author wind57\n */\nclass KubernetesReactiveDiscoveryClientAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  @Test void discoveryEnabledDefault(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n    }\n);\n  }\n  @Test void discoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n    }\n);\n  }\n  @Test void discoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).doesNotHaveBean(KubernetesClientServicesFunction.class);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).doesNotHaveBean(KubernetesClientServicesFunction.class);\n    }\n);\n  }\n  @Test void kubernetesReactiveDiscoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n    }\n);\n  }\n  @Test void kubernetesReactiveDiscoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).doesNotHaveBean(KubernetesClientServicesFunction.class);\n    }\n);\n  }\n  /** \n * blocking is disabled, and it should not impact reactive in any way.\n */\n  @Test void blockingDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n    }\n);\n  }\n  @Test void healthDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n    }\n);\n  }\n  @Test void healthEnabledClassNotPresent(){\n    setupWithFilteredClassLoader(\"org.springframework.boot.actuate.health.ReactiveHealthIndicator\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).hasSingleBean(KubernetesClientServicesFunction.class);\n    }\n);\n  }\n  private void setup(  String... properties){\n    applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(UtilAutoConfiguration.class,ReactiveCommonsClientAutoConfiguration.class,KubernetesCommonsAutoConfiguration.class,Fabric8AutoConfiguration.class,KubernetesReactiveDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class)).withPropertyValues(properties);\n  }\n  private void setupWithFilteredClassLoader(  String name,  String... properties){\n    applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(UtilAutoConfiguration.class,ReactiveCommonsClientAutoConfiguration.class,KubernetesCommonsAutoConfiguration.class,Fabric8AutoConfiguration.class,KubernetesReactiveDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class)).withClassLoader(new FilteredClassLoader(name)).withPropertyValues(properties);\n  }\n}\n",
        "abstract": "/** \n * Test various conditionals for {@link KubernetesReactiveDiscoveryClientAutoConfiguration}\n * @author wind57\n */\nclass KubernetesReactiveDiscoveryClientAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  @Test void discoveryEnabledDefault();\n  @Test void discoveryEnabled();\n  @Test void discoveryDisabled();\n  @Test void kubernetesDiscoveryEnabled();\n  @Test void kubernetesDiscoveryDisabled();\n  @Test void kubernetesReactiveDiscoveryEnabled();\n  @Test void kubernetesReactiveDiscoveryDisabled();\n  /** \n * blocking is disabled, and it should not impact reactive in any way.\n */\n  @Test void blockingDisabled();\n  @Test void healthDisabled();\n  @Test void healthEnabledClassNotPresent();\n  private void setup(  String... properties);\n  private void setupWithFilteredClassLoader(  String name,  String... properties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8KubernetesDiscoveryClientTests.java",
        "name": "Fabric8KubernetesDiscoveryClientTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8KubernetesDiscoveryClientTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class) class Fabric8KubernetesDiscoveryClientTests {\n  private static KubernetesClient client;\n  @AfterEach void afterEach(){\n    client.endpoints().inAnyNamespace().delete();\n    client.services().inAnyNamespace().delete();\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - there are no endpoints at all - as a result we get an empty list \u003c/pre\u003e\n */\n  @Test void testAllNamespacesEmpty(  CapturedOutput output){\n    boolean allNamespaces\u003dtrue;\n    Set\u003cString\u003e namespaces\u003dSet.of();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"serviceId\");\n    Assertions.assertEquals(result.size(),0);\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in all namespaces\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - one endpoints with labels : \"color\u003dblue\" and name \"blue-service\" exists - we search for labels : \"color\u003dblue\" and name \"blue-service\" - we find this endpoints \u003c/pre\u003e\n */\n  @Test void testAllNamespacesSingleEndpointsMatchExactLabels(  CapturedOutput output){\n    createEndpoints(\"default\",\"blue-service\",Map.of(\"color\",\"blue\"));\n    createService(\"default\",\"blue-service\",Map.of(\"color\",\"blue\"));\n    boolean allNamespaces\u003dtrue;\n    Set\u003cString\u003e namespaces\u003dSet.of();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"color\",\"blue\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"blue-service\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in all namespaces\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"blue-service\" exists - we search for labels : \"color\u003dblue\" and name \"blue-service\" - we find this endpoints \u003c/pre\u003e\n */\n  @Test void testAllNamespacesSingleEndpointsMatchPartialLabels(  CapturedOutput output){\n    createEndpoints(\"default\",\"blue-service\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createService(\"default\",\"blue-service\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    boolean allNamespaces\u003dtrue;\n    Set\u003cString\u003e namespaces\u003dSet.of();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"color\",\"blue\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"blue-service\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in all namespaces\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - one endpoints with labels : \"color\u003dred, shape\u003dround\" and name \"blue-service\" exists - we search for labels : \"color\u003dred\" and name \"blue-service\" - name matches, but labels don\u0027t, as such we do not find this endpoints \u003c/pre\u003e\n */\n  @Test void testAllNamespacesSingleEndpointsNameMatchesLabelsDont(  CapturedOutput output){\n    createEndpoints(\"default\",\"blue-service\",Map.of(\"color\",\"red\",\"shape\",\"round\"));\n    boolean allNamespaces\u003dtrue;\n    Set\u003cString\u003e namespaces\u003dSet.of();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"color\",\"blue\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"blue-service\");\n    Assertions.assertEquals(result.size(),0);\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in all namespaces\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-one\" exists - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-two\" exists - we search for labels : \"color\u003dblue\" and name \"service-one\" and find a single service \u003c/pre\u003e\n */\n  @Test void testAllNamespacesTwoEndpointsOneMatches(  CapturedOutput output){\n    createEndpoints(\"default\",\"service-one\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createEndpoints(\"default\",\"service-two\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createService(\"default\",\"service-one\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createService(\"default\",\"service-two\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    boolean allNamespaces\u003dtrue;\n    Set\u003cString\u003e namespaces\u003dSet.of();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"color\",\"blue\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"service-one\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in all namespaces\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-one\" exists in namespace \"a\" - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-one\" exists in namespace \"b\" - we search for labels : \"color\u003dblue\" and name \"service-one\" and find two services \u003c/pre\u003e\n */\n  @Test void testAllNamespacesTwoEndpointsInDifferentNamespaces(  CapturedOutput output){\n    createEndpoints(\"a\",\"service-one\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createEndpoints(\"b\",\"service-one\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createService(\"a\",\"service-one\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createService(\"b\",\"service-one\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    boolean allNamespaces\u003dtrue;\n    Set\u003cString\u003e namespaces\u003dSet.of();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"color\",\"blue\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"service-one\");\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertEquals(result.stream().map(Endpoints::getMetadata).map(ObjectMeta::getNamespace).sorted().toList(),List.of(\"a\",\"b\"));\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in all namespaces\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - there are no endpoints at all - as a result we get an empty list \u003c/pre\u003e\n */\n  @Test void testClientNamespaceEmpty(  CapturedOutput output){\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e namespaces\u003dSet.of();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"serviceId\");\n    Assertions.assertEquals(result.size(),0);\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in namespace : test\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - one endpoints with labels : \"color\u003dblue\" and name \"blue-service\" exists - we search for labels : \"color\u003dblue\" and name \"blue-service\" - we find this endpoints \u003c/pre\u003e\n */\n  @Test void testClientNamespaceSingleEndpointsMatchExactLabels(  CapturedOutput output){\n    createEndpoints(\"test\",\"blue-service\",Map.of(\"color\",\"blue\"));\n    createService(\"test\",\"blue-service\",Map.of(\"color\",\"blue\"));\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e namespaces\u003dSet.of();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"color\",\"blue\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"blue-service\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in namespace : test\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"blue-service\" exists - we search for labels : \"color\u003dblue\" and name \"blue-service\" - we find this endpoints \u003c/pre\u003e\n */\n  @Test void testClientNamespaceSingleEndpointsMatchPartialLabels(  CapturedOutput output){\n    createEndpoints(\"test\",\"blue-service\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createService(\"test\",\"blue-service\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e namespaces\u003dSet.of();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"color\",\"blue\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"blue-service\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in namespace : test\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - one endpoints with labels : \"color\u003dred, shape\u003dround\" and name \"blue-service\" exists - we search for labels : \"color\u003dred\" and name \"blue-service\" - name matches, but labels don\u0027t, as such we do not find this endpoints \u003c/pre\u003e\n */\n  @Test void testClientNamespaceSingleEndpointsNameMatchesLabelsDont(  CapturedOutput output){\n    createEndpoints(\"test\",\"blue-service\",Map.of(\"color\",\"red\",\"shape\",\"round\"));\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e namespaces\u003dSet.of();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"color\",\"blue\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"blue-service\");\n    Assertions.assertEquals(result.size(),0);\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in namespace : test\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-one\" exists - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-two\" exists - we search for labels : \"color\u003dblue\" and name \"service-one\" and find a single service \u003c/pre\u003e\n */\n  @Test void testClientNamespaceTwoEndpointsOneMatches(  CapturedOutput output){\n    createEndpoints(\"test\",\"service-one\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createEndpoints(\"test\",\"service-two\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createService(\"test\",\"service-one\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createService(\"test\",\"service-two\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e namespaces\u003dSet.of();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"color\",\"blue\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"service-one\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in namespace : test\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-one\" exists in namespace \"test\" - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-one\" exists in namespace \"b\" - we search for labels : \"color\u003dblue\" and name \"service-one\" and find one service \u003c/pre\u003e\n */\n  @Test void testClientNamespaceTwoEndpointsInDifferentNamespaces(  CapturedOutput output){\n    createEndpoints(\"test\",\"service-one\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createEndpoints(\"b\",\"service-one\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createService(\"test\",\"service-one\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createService(\"b\",\"service-one\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e namespaces\u003dSet.of();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"color\",\"blue\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"service-one\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.stream().map(Endpoints::getMetadata).map(ObjectMeta::getNamespace).sorted().toList(),List.of(\"test\"));\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in namespace : test\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false, selective namespaces \u003d [\"test\"] - there are no endpoints at all - as a result we get an empty list \u003c/pre\u003e\n */\n  @Test void testSelectiveNamespacesEmpty(  CapturedOutput output){\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e namespaces\u003dSet.of(\"test\");\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"serviceId\");\n    Assertions.assertEquals(result.size(),0);\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in namespaces : [test]\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false, selective namespaces \u003d [\"test\"] - one endpoints with labels : \"color\u003dblue\" and name \"blue-service\" exists in namespace \"test\" - we search for labels : \"color\u003dblue\" and name \"blue-service\" - we find this endpoints \u003c/pre\u003e\n */\n  @Test void testSelectiveNamespacesSingleEndpointsMatchExactLabels(  CapturedOutput output){\n    createEndpoints(\"test\",\"blue-service\",Map.of(\"color\",\"blue\"));\n    createService(\"test\",\"blue-service\",Map.of(\"color\",\"blue\"));\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e namespaces\u003dSet.of(\"test\");\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"color\",\"blue\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,x -\u003e true,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"blue-service\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in namespaces : [test]\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false, selective namespaces \u003d [\"a\", \"b\u0027] - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"blue-service\" exists in namespace \"a\" - one endpoints with labels : \"color\u003dblue, shape\u003drectangle\" and name \"blue-service\" exists in namespace \"b\" - we search for labels : \"color\u003dblue\" and name \"blue-service\" in namespace \"a\" - we find this endpoints \u003c/pre\u003e\n */\n  @Test void testSelectiveNamespacesMultipleNamespacesSingleMatch(  CapturedOutput output){\n    createEndpoints(\"a\",\"blue-service\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createEndpoints(\"b\",\"blue-service\",Map.of(\"color\",\"blue\",\"shape\",\"rectangle\"));\n    createService(\"a\",\"blue-service\",Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    createService(\"b\",\"blue-service\",Map.of(\"color\",\"blue\",\"shape\",\"rectangle\"));\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e namespaces\u003dSet.of(\"a\");\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"color\",\"blue\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"blue-service\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getLabels(),Map.of(\"color\",\"blue\",\"shape\",\"round\"));\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in namespaces : [a]\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false, selective namespaces \u003d [\"a\", \"b\u0027] - one endpoints with labels : \"color\u003dblue\" and name \"blue-service\" exists in namespace \"a\" - one endpoints with labels : \"color\u003dblue\" and name \"blue-service\" exists in namespace \"b\" - we search for labels : \"color\u003dblue\" and name \"blue-service\" in namespace \"a\" and \"b\" - we find both endpoints \u003c/pre\u003e\n */\n  @Test void testSelectiveNamespacesMultipleNamespacesAllMatch(  CapturedOutput output){\n    createEndpoints(\"a\",\"blue-service\",Map.of(\"color\",\"blue\"));\n    createEndpoints(\"b\",\"blue-service\",Map.of(\"color\",\"blue\"));\n    createService(\"a\",\"blue-service\",Map.of(\"color\",\"blue\"));\n    createService(\"b\",\"blue-service\",Map.of(\"color\",\"blue\"));\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e namespaces\u003dSet.of(\"a\",\"b\");\n    String namespacesAsString\u003dnamespaces.toString();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"color\",\"blue\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60L,false,\"\",Set.of(),serviceLabels,\"\",null,0,false,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cEndpoints\u003e result\u003ddiscoveryClient.getEndPointsList(\"blue-service\");\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertTrue(output.getOut().contains(\"discovering endpoints in namespaces : \" + namespacesAsString));\n  }\n  /** \n * \u003cpre\u003e - two services are present in two namespaces [a, b] - both are returned \u003c/pre\u003e\n */\n  @Test void testGetServicesWithExternalNameService(){\n    Service nonExternalNameService\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ClusterIP\").build()).withNewMetadata().withName(\"blue-service\").withNamespace(\"a\").endMetadata().build();\n    client.services().inNamespace(\"a\").resource(nonExternalNameService).create();\n    Service externalNameService\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").withExternalName(\"k8s-spring\").build()).withNewMetadata().withName(\"blue-service\").withNamespace(\"b\").endMetadata().build();\n    client.services().inNamespace(\"b\").resource(externalNameService).create();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(\"a\",\"b\"),true,60L,false,\"\",Set.of(),Map.of(),\"\",KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cString\u003e result\u003ddiscoveryClient.getServices();\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0),\"blue-service\");\n  }\n  @Test void testExternalNameService(){\n    Service externalNameService\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").withExternalName(\"k8s-spring-b\").build()).withNewMetadata().withLabels(Map.of(\"label-key\",\"label-value\")).withAnnotations(Map.of(\"abc\",\"def\")).withName(\"blue-service\").withNamespace(\"b\").endMetadata().build();\n    client.services().inNamespace(\"b\").resource(externalNameService).create();\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(true,\"labels-prefix-\",true,\"annotations-prefix-\",true,\"ports-prefix\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(\"a\",\"b\"),true,60L,false,\"\",Set.of(),Map.of(),\"\",metadata,0,false,true);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cServiceInstance\u003e result\u003ddiscoveryClient.getInstances(\"blue-service\");\n    Assertions.assertEquals(result.size(),1);\n    DefaultKubernetesServiceInstance externalNameServiceInstance\u003d(DefaultKubernetesServiceInstance)result.get(0);\n    Assertions.assertEquals(externalNameServiceInstance.getServiceId(),\"blue-service\");\n    Assertions.assertEquals(externalNameServiceInstance.getHost(),\"k8s-spring-b\");\n    Assertions.assertEquals(externalNameServiceInstance.getPort(),-1);\n    Assertions.assertFalse(externalNameServiceInstance.isSecure());\n    Assertions.assertEquals(externalNameServiceInstance.getUri().toASCIIString(),\"k8s-spring-b\");\n    Assertions.assertEquals(externalNameServiceInstance.getMetadata(),Map.of(\"k8s_namespace\",\"b\",\"labels-prefix-label-key\",\"label-value\",\"annotations-prefix-abc\",\"def\",\"type\",\"ExternalName\"));\n  }\n  @Test void testPodMetadata(){\n    Service nonExternalNameService\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ClusterIP\").build()).withNewMetadata().withName(\"blue-service\").withNamespace(\"a\").endMetadata().build();\n    client.services().inNamespace(\"a\").resource(nonExternalNameService).create();\n    client.endpoints().inNamespace(\"a\").resource(new EndpointsBuilder().withMetadata(new ObjectMetaBuilder().withName(\"blue-service\").build()).withSubsets(new EndpointSubsetBuilder().withPorts(new EndpointPortBuilder().withPort(8080).build()).withAddresses(new EndpointAddressBuilder().withIp(\"127.0.0.1\").withTargetRef(new ObjectReferenceBuilder().withKind(\"Pod\").withName(\"my-pod\").build()).build()).build()).build()).create();\n    client.pods().inNamespace(\"a\").resource(new PodBuilder().withMetadata(new ObjectMetaBuilder().withName(\"my-pod\").withLabels(Map.of(\"a\",\"b\")).withAnnotations(Map.of(\"c\",\"d\")).build()).build()).create();\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(true,\"labels-prefix-\",true,\"annotations-prefix-\",true,\"ports-prefix\",true,true);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(\"a\",\"b\"),true,60L,false,\"\",Set.of(),Map.of(),\"\",metadata,0,false,true);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(client,properties,null,null,null);\n    List\u003cServiceInstance\u003e result\u003ddiscoveryClient.getInstances(\"blue-service\");\n    Assertions.assertEquals(result.size(),1);\n    DefaultKubernetesServiceInstance serviceInstance\u003d(DefaultKubernetesServiceInstance)result.get(0);\n    Assertions.assertEquals(serviceInstance.getServiceId(),\"blue-service\");\n    Assertions.assertEquals(serviceInstance.getHost(),\"127.0.0.1\");\n    Assertions.assertEquals(serviceInstance.getPort(),8080);\n    Assertions.assertFalse(serviceInstance.isSecure());\n    Assertions.assertEquals(serviceInstance.getUri().toASCIIString(),\"http://127.0.0.1:8080\");\n    Assertions.assertEquals(serviceInstance.getMetadata(),Map.of(\"k8s_namespace\",\"a\",\"type\",\"ClusterIP\",\"ports-prefix\u003cunset\u003e\",\"8080\"));\n    Assertions.assertEquals(serviceInstance.podMetadata().get(\"labels\"),Map.of(\"a\",\"b\"));\n    Assertions.assertEquals(serviceInstance.podMetadata().get(\"annotations\"),Map.of(\"c\",\"d\"));\n  }\n  private void createEndpoints(  String namespace,  String name,  Map\u003cString,String\u003e labels){\n    client.endpoints().inNamespace(namespace).resource(new EndpointsBuilder().withMetadata(new ObjectMetaBuilder().withName(name).withLabels(labels).build()).build()).create();\n  }\n  private void createService(  String namespace,  String name,  Map\u003cString,String\u003e labels){\n    client.services().inNamespace(namespace).resource(new ServiceBuilder().withMetadata(new ObjectMetaBuilder().withName(name).withLabels(labels).build()).build()).create();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class) class Fabric8KubernetesDiscoveryClientTests {\n  private static KubernetesClient client;\n  @AfterEach void afterEach();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - there are no endpoints at all - as a result we get an empty list \u003c/pre\u003e\n */\n  @Test void testAllNamespacesEmpty(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - one endpoints with labels : \"color\u003dblue\" and name \"blue-service\" exists - we search for labels : \"color\u003dblue\" and name \"blue-service\" - we find this endpoints \u003c/pre\u003e\n */\n  @Test void testAllNamespacesSingleEndpointsMatchExactLabels(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"blue-service\" exists - we search for labels : \"color\u003dblue\" and name \"blue-service\" - we find this endpoints \u003c/pre\u003e\n */\n  @Test void testAllNamespacesSingleEndpointsMatchPartialLabels(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - one endpoints with labels : \"color\u003dred, shape\u003dround\" and name \"blue-service\" exists - we search for labels : \"color\u003dred\" and name \"blue-service\" - name matches, but labels don\u0027t, as such we do not find this endpoints \u003c/pre\u003e\n */\n  @Test void testAllNamespacesSingleEndpointsNameMatchesLabelsDont(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-one\" exists - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-two\" exists - we search for labels : \"color\u003dblue\" and name \"service-one\" and find a single service \u003c/pre\u003e\n */\n  @Test void testAllNamespacesTwoEndpointsOneMatches(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-one\" exists in namespace \"a\" - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-one\" exists in namespace \"b\" - we search for labels : \"color\u003dblue\" and name \"service-one\" and find two services \u003c/pre\u003e\n */\n  @Test void testAllNamespacesTwoEndpointsInDifferentNamespaces(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - there are no endpoints at all - as a result we get an empty list \u003c/pre\u003e\n */\n  @Test void testClientNamespaceEmpty(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - one endpoints with labels : \"color\u003dblue\" and name \"blue-service\" exists - we search for labels : \"color\u003dblue\" and name \"blue-service\" - we find this endpoints \u003c/pre\u003e\n */\n  @Test void testClientNamespaceSingleEndpointsMatchExactLabels(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"blue-service\" exists - we search for labels : \"color\u003dblue\" and name \"blue-service\" - we find this endpoints \u003c/pre\u003e\n */\n  @Test void testClientNamespaceSingleEndpointsMatchPartialLabels(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - one endpoints with labels : \"color\u003dred, shape\u003dround\" and name \"blue-service\" exists - we search for labels : \"color\u003dred\" and name \"blue-service\" - name matches, but labels don\u0027t, as such we do not find this endpoints \u003c/pre\u003e\n */\n  @Test void testClientNamespaceSingleEndpointsNameMatchesLabelsDont(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-one\" exists - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-two\" exists - we search for labels : \"color\u003dblue\" and name \"service-one\" and find a single service \u003c/pre\u003e\n */\n  @Test void testClientNamespaceTwoEndpointsOneMatches(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-one\" exists in namespace \"test\" - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"service-one\" exists in namespace \"b\" - we search for labels : \"color\u003dblue\" and name \"service-one\" and find one service \u003c/pre\u003e\n */\n  @Test void testClientNamespaceTwoEndpointsInDifferentNamespaces(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false, selective namespaces \u003d [\"test\"] - there are no endpoints at all - as a result we get an empty list \u003c/pre\u003e\n */\n  @Test void testSelectiveNamespacesEmpty(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false, selective namespaces \u003d [\"test\"] - one endpoints with labels : \"color\u003dblue\" and name \"blue-service\" exists in namespace \"test\" - we search for labels : \"color\u003dblue\" and name \"blue-service\" - we find this endpoints \u003c/pre\u003e\n */\n  @Test void testSelectiveNamespacesSingleEndpointsMatchExactLabels(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false, selective namespaces \u003d [\"a\", \"b\u0027] - one endpoints with labels : \"color\u003dblue, shape\u003dround\" and name \"blue-service\" exists in namespace \"a\" - one endpoints with labels : \"color\u003dblue, shape\u003drectangle\" and name \"blue-service\" exists in namespace \"b\" - we search for labels : \"color\u003dblue\" and name \"blue-service\" in namespace \"a\" - we find this endpoints \u003c/pre\u003e\n */\n  @Test void testSelectiveNamespacesMultipleNamespacesSingleMatch(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false, selective namespaces \u003d [\"a\", \"b\u0027] - one endpoints with labels : \"color\u003dblue\" and name \"blue-service\" exists in namespace \"a\" - one endpoints with labels : \"color\u003dblue\" and name \"blue-service\" exists in namespace \"b\" - we search for labels : \"color\u003dblue\" and name \"blue-service\" in namespace \"a\" and \"b\" - we find both endpoints \u003c/pre\u003e\n */\n  @Test void testSelectiveNamespacesMultipleNamespacesAllMatch(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - two services are present in two namespaces [a, b] - both are returned \u003c/pre\u003e\n */\n  @Test void testGetServicesWithExternalNameService();\n  @Test void testExternalNameService();\n  @Test void testPodMetadata();\n  private void createEndpoints(  String namespace,  String name,  Map\u003cString,String\u003e labels);\n  private void createService(  String namespace,  String name,  Map\u003cString,String\u003e labels);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8KubernetesDiscoveryClientTest.java",
        "name": "Fabric8KubernetesDiscoveryClientTest",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8KubernetesDiscoveryClientTest",
        "extend": "",
        "implements": "",
        "raw": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8KubernetesDiscoveryClientTest {\n  private KubernetesClient mockClient;\n  @BeforeEach void setup(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterEach void afterEach(){\n    mockClient.endpoints().inAnyNamespace().delete();\n    mockClient.services().inAnyNamespace().delete();\n  }\n  @Test void getInstancesShouldBeAbleToHandleEndpointsSingleAddress(){\n    Map\u003cString,String\u003e labels\u003dMap.of(\"l\",\"v\");\n    Endpoints endPoint\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(\"test\").withLabels(labels).endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"10\").endTargetRef().endAddress().addNewPort(\"http\",\"http_tcp\",80,\"TCP\").endSubset().build();\n    mockClient.endpoints().inNamespace(\"test\").resource(endPoint).create();\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).withNewMetadata().withName(\"endpoint\").withNamespace(\"test\").withLabels(labels).endMetadata().build();\n    mockClient.services().inNamespace(\"test\").resource(service).create();\n    DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,KubernetesDiscoveryProperties.DEFAULT,KubernetesClient::services,null,new ServicePortSecureResolver(KubernetesDiscoveryProperties.DEFAULT));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 !s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"10\")).hasSize(1);\n  }\n  @Test void getInstancesShouldBeAbleToHandleEndpointsSingleAddressAndMultiplePorts(){\n    Map\u003cString,String\u003e labels\u003dMap.of(\"l2\",\"v2\");\n    Endpoints endPoint\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(\"test\").withLabels(labels).endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"20\").endTargetRef().endAddress().addNewPort(\"mgmt\",\"mgmt_tcp\",900,\"TCP\").addNewPort(\"http\",\"http_tcp\",80,\"TCP\").endSubset().build();\n    mockClient.endpoints().inNamespace(\"test\").resource(endPoint).create();\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).withNewMetadata().withName(\"endpoint\").withNamespace(\"test\").withLabels(labels).withAnnotations(labels).endMetadata().build();\n    mockClient.services().inNamespace(\"test\").resource(service).create();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),labels,\"http_tcp\",Metadata.DEFAULT,0,true);\n    DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,properties,KubernetesClient::services,null,new ServicePortSecureResolver(properties));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 !s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"20\")).hasSize(1).filteredOn(s -\u003e 80 \u003d\u003d s.getPort()).hasSize(1);\n  }\n  @Test void getEndPointsListTest(){\n    Map\u003cString,String\u003e labels\u003dMap.of(\"l\",\"v\");\n    Endpoints endPoint\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(\"test\").withLabels(labels).endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"30\").endTargetRef().endAddress().addNewPort(\"http\",\"http_tcp\",80,\"TCP\").endSubset().build();\n    Service service\u003dnew ServiceBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(\"test\").endMetadata().build();\n    mockClient.endpoints().inNamespace(\"test\").resource(endPoint).create();\n    mockClient.services().inNamespace(\"test\").resource(service).create();\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,KubernetesDiscoveryProperties.DEFAULT,KubernetesClient::services,null,new ServicePortSecureResolver(KubernetesDiscoveryProperties.DEFAULT));\n    List\u003cEndpoints\u003e result_endpoints\u003ddiscoveryClient.getEndPointsList(\"endpoint\");\n    assertThat(result_endpoints).hasSize(1);\n  }\n  @Test void getEndPointsListTestAllNamespaces(){\n    String namespace1\u003d\"ns1\";\n    String namespace2\u003d\"ns2\";\n    Endpoints endPoint1\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(namespace1).endMetadata().build();\n    Endpoints endPoint2\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(namespace2).endMetadata().build();\n    Service service1\u003dnew ServiceBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(namespace1).endMetadata().build();\n    Service service2\u003dnew ServiceBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(namespace2).endMetadata().build();\n    mockClient.endpoints().inNamespace(namespace1).resource(endPoint1).create();\n    mockClient.endpoints().inNamespace(namespace2).resource(endPoint2).create();\n    mockClient.services().inNamespace(namespace1).resource(service1).create();\n    mockClient.services().inNamespace(namespace2).resource(service2).create();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,properties,KubernetesClient::services,x -\u003e true,new ServicePortSecureResolver(properties));\n    List\u003cEndpoints\u003e result_endpoints\u003ddiscoveryClient.getEndPointsList(\"endpoint\");\n    assertThat(result_endpoints).hasSize(2);\n  }\n  @Test void getEndPointsListShouldHandleNamespaces(){\n    String namespace1\u003d\"ns1\";\n    String namespace2\u003d\"ns2\";\n    String namespace3\u003d\"ns3\";\n    Endpoints endPoint1\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(namespace1).endMetadata().build();\n    Endpoints endPoint2\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(namespace2).endMetadata().build();\n    Endpoints endPoint3\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(namespace3).endMetadata().build();\n    Service service1\u003dnew ServiceBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(namespace1).endMetadata().build();\n    Service service2\u003dnew ServiceBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(namespace2).endMetadata().build();\n    Service service3\u003dnew ServiceBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(namespace3).endMetadata().build();\n    mockClient.endpoints().inNamespace(namespace1).resource(endPoint1).create();\n    mockClient.endpoints().inNamespace(namespace2).resource(endPoint2).create();\n    mockClient.endpoints().inNamespace(namespace3).resource(endPoint3).create();\n    mockClient.services().inNamespace(namespace1).resource(service1).create();\n    mockClient.services().inNamespace(namespace2).resource(service2).create();\n    mockClient.services().inNamespace(namespace3).resource(service3).create();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(namespace1,namespace3),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,properties,KubernetesClient::services,null,new ServicePortSecureResolver(properties));\n    List\u003cEndpoints\u003e result_endpoints\u003ddiscoveryClient.getEndPointsList(\"endpoint\");\n    assertThat(result_endpoints).hasSize(2);\n    assertThat(result_endpoints.stream().map(Endpoints::getMetadata).map(ObjectMeta::getNamespace).collect(Collectors.toList())).containsOnly(namespace1,namespace3);\n  }\n  @Test void getInstancesShouldBeAbleToHandleEndpointsMultipleAddresses(){\n    Map\u003cString,String\u003e labels\u003dMap.of(\"l1\",\"v1\");\n    Endpoints endPoint\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(\"test\").withLabels(labels).endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"40\").endTargetRef().endAddress().addNewAddress().withIp(\"ip2\").withNewTargetRef().withUid(\"50\").endTargetRef().endAddress().addNewPort(\"https\",\"https_tcp\",443,\"TCP\").endSubset().build();\n    mockClient.endpoints().inNamespace(\"test\").resource(endPoint).create();\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).withNewMetadata().withName(\"endpoint\").withNamespace(\"test\").withLabels(labels).endMetadata().build();\n    mockClient.services().inNamespace(\"test\").resource(service).create();\n    Metadata metadata\u003dnew Metadata(false,null,false,null,true,\"port.\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(443,8443),labels,null,metadata,0,true);\n    DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,properties,KubernetesClient::services,null,new ServicePortSecureResolver(properties));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint\");\n    assertThat(instances).hasSize(2).filteredOn(ServiceInstance::isSecure).extracting(ServiceInstance::getHost).containsOnly(\"ip1\",\"ip2\");\n  }\n  @Test void getServicesShouldReturnAllServicesWhenNoLabelsAreAppliedToTheClient(){\n    Map\u003cString,String\u003e service1Labels\u003dCollections.singletonMap(\"label\",\"value\");\n    Service service1\u003dnew ServiceBuilder().withNewMetadata().withName(\"s1\").withNamespace(\"test\").withLabels(service1Labels).endMetadata().build();\n    Map\u003cString,String\u003e service2Labels\u003dMap.of(\"label\",\"value\",\"label2\",\"value2\");\n    Service service2\u003dnew ServiceBuilder().withNewMetadata().withName(\"s2\").withNamespace(\"test\").withLabels(service2Labels).endMetadata().build();\n    Service service3\u003dnew ServiceBuilder().withNewMetadata().withName(\"s3\").withNamespace(\"test\").endMetadata().build();\n    mockClient.services().inNamespace(\"test\").resource(service1).create();\n    mockClient.services().inNamespace(\"test\").resource(service2).create();\n    mockClient.services().inNamespace(\"test\").resource(service3).create();\n    DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,KubernetesDiscoveryProperties.DEFAULT,KubernetesClient::services,null,new ServicePortSecureResolver(KubernetesDiscoveryProperties.DEFAULT));\n    List\u003cString\u003e services\u003ddiscoveryClient.getServices();\n    assertThat(services).containsOnly(\"s1\",\"s2\",\"s3\");\n  }\n  @Test void getServicesShouldReturnOnlyMatchingServicesWhenLabelsAreAppliedToTheClient(){\n    Map\u003cString,String\u003e service1Labels\u003dCollections.singletonMap(\"label\",\"value\");\n    Service service1\u003dnew ServiceBuilder().withNewMetadata().withName(\"s1\").withNamespace(\"test\").withLabels(service1Labels).endMetadata().build();\n    Map\u003cString,String\u003e service2Labels\u003dMap.of(\"label\",\"value\",\"label2\",\"value2\");\n    Service service2\u003dnew ServiceBuilder().withNewMetadata().withName(\"s2\").withNamespace(\"test\").withLabels(service2Labels).endMetadata().build();\n    mockClient.services().inNamespace(\"test\").resource(service1).create();\n    mockClient.services().inNamespace(\"test\").resource(service2).create();\n    DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,KubernetesDiscoveryProperties.DEFAULT,client -\u003e client.services().withLabels(Collections.singletonMap(\"label\",\"value\")),null,new ServicePortSecureResolver(KubernetesDiscoveryProperties.DEFAULT));\n    List\u003cString\u003e services\u003ddiscoveryClient.getServices();\n    assertThat(services).containsOnly(\"s1\",\"s2\");\n  }\n  @Test void getServicesShouldReturnServicesInNamespaces(){\n    String nameSpace1\u003d\"ns1\";\n    String nameSpace2\u003d\"ns2\";\n    String nameSpace3\u003d\"ns3\";\n    Service service1\u003dnew ServiceBuilder().withNewMetadata().withName(\"s1\").withNamespace(nameSpace1).endMetadata().build();\n    Service service2\u003dnew ServiceBuilder().withNewMetadata().withName(\"s2\").withNamespace(nameSpace2).endMetadata().build();\n    Service service3\u003dnew ServiceBuilder().withNewMetadata().withName(\"s3\").withNamespace(nameSpace3).endMetadata().build();\n    mockClient.services().inNamespace(nameSpace1).resource(service1).create();\n    mockClient.services().inNamespace(nameSpace2).resource(service2).create();\n    mockClient.services().inNamespace(nameSpace3).resource(service3).create();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(nameSpace1,nameSpace2),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,properties,KubernetesClient::services,null,new ServicePortSecureResolver(properties));\n    List\u003cString\u003e services\u003ddiscoveryClient.getServices();\n    assertThat(services).containsOnly(\"s1\",\"s2\");\n  }\n  @Test void getInstancesShouldBeAbleToHandleEndpointsFromMultipleNamespaces(){\n    Endpoints endPoints1\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(\"test\").endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"60\").endTargetRef().endAddress().addNewPort(\"http\",\"http_tcp\",80,\"TCP\").endSubset().build();\n    Endpoints endPoints2\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint\").withNamespace(\"test2\").endMetadata().addNewSubset().addNewAddress().withIp(\"ip2\").withNewTargetRef().withUid(\"70\").endTargetRef().endAddress().addNewPort(\"http\",\"http_tcp\",80,\"TCP\").endSubset().build();\n    mockClient.endpoints().inNamespace(\"test\").resource(endPoints1).create();\n    mockClient.endpoints().inNamespace(\"test2\").resource(endPoints2).create();\n    Service service1\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).withNewMetadata().withName(\"endpoint\").withNamespace(\"test\").withLabels(Collections.singletonMap(\"l\",\"v\")).endMetadata().build();\n    Service service2\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).withNewMetadata().withName(\"endpoint\").withNamespace(\"test2\").withLabels(Collections.singletonMap(\"l\",\"v\")).endMetadata().build();\n    mockClient.services().inNamespace(\"test\").resource(service1).create();\n    mockClient.services().inNamespace(\"test2\").resource(service2).create();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,Metadata.DEFAULT,0,true);\n    DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,properties,KubernetesClient::services,null,new ServicePortSecureResolver(properties));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint\");\n    assertThat(instances).hasSize(2);\n    assertThat(instances).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 !s.isSecure()).hasSize(1);\n    assertThat(instances).filteredOn(s -\u003e s.getHost().equals(\"ip2\") \u0026\u0026 !s.isSecure()).hasSize(1);\n    assertThat(instances).filteredOn(s -\u003e s.getServiceId().contains(\"endpoint\") \u0026\u0026 ((KubernetesServiceInstance)s).getNamespace().equals(\"test\")).hasSize(1);\n    assertThat(instances).filteredOn(s -\u003e s.getServiceId().contains(\"endpoint\") \u0026\u0026 ((KubernetesServiceInstance)s).getNamespace().equals(\"test2\")).hasSize(1);\n    assertThat(instances).filteredOn(s -\u003e s.getInstanceId().equals(\"60\")).hasSize(1);\n    assertThat(instances).filteredOn(s -\u003e s.getInstanceId().equals(\"70\")).hasSize(1);\n  }\n  @Test void instanceWithoutSubsetsShouldBeSkipped(){\n    Endpoints endPoint\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint1\").withNamespace(\"test\").withLabels(Collections.emptyMap()).endMetadata().build();\n    mockClient.endpoints().inNamespace(\"test\").resource(endPoint).create();\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,KubernetesDiscoveryProperties.DEFAULT,KubernetesClient::services,null,new ServicePortSecureResolver(KubernetesDiscoveryProperties.DEFAULT));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint1\");\n    assertThat(instances).isEmpty();\n  }\n  @Test void getInstancesShouldBeAbleToHandleEndpointsSingleAddressAndMultiplePortsUsingPrimaryPortNameLabel(){\n    Map\u003cString,String\u003e labels\u003dMap.of(\"primary-port-name\",\"https\");\n    Endpoints endPoint1\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint2\").withNamespace(\"test\").withLabels(labels).endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"80\").endTargetRef().endAddress().addNewPort(\"http\",\"https\",443,\"TCP\").addNewPort(\"http\",\"http\",80,\"TCP\").endSubset().build();\n    mockClient.endpoints().inNamespace(\"test\").resource(endPoint1).create();\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).withNewMetadata().withName(\"endpoint2\").withNamespace(\"test\").withLabels(labels).withAnnotations(labels).endMetadata().build();\n    mockClient.services().inNamespace(\"test\").resource(service).create();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),null,Metadata.DEFAULT,0,true);\n    DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,properties,KubernetesClient::services,null,new ServicePortSecureResolver(properties));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint2\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"80\")).hasSize(1).filteredOn(s -\u003e 443 \u003d\u003d s.getPort()).hasSize(1);\n  }\n  @Test void instanceWithMultiplePortsAndMisconfiguredPrimaryPortNameInLabelWithoutFallbackShouldLogWarning(){\n    Map\u003cString,String\u003e labels\u003dMap.of(\"primary-port-name\",\"oops\");\n    Endpoints endPoint1\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint3\").withNamespace(\"test\").withLabels(labels).endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"90\").endTargetRef().endAddress().addNewPort(\"http\",\"https1\",443,\"TCP\").addNewPort(\"http\",\"https2\",8443,\"TCP\").addNewPort(\"http\",\"http1\",80,\"TCP\").addNewPort(\"http\",\"http2\",8080,\"TCP\").endSubset().build();\n    mockClient.endpoints().inNamespace(\"test\").resource(endPoint1).create();\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).withNewMetadata().withName(\"endpoint3\").withNamespace(\"test\").withLabels(labels).withAnnotations(labels).endMetadata().build();\n    mockClient.services().inNamespace(\"test\").resource(service).create();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),null,Metadata.DEFAULT,0,true);\n    DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,properties,KubernetesClient::services,null,new ServicePortSecureResolver(properties));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint3\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"90\")).hasSize(1).hasSize(1);\n  }\n  @Test void instanceWithMultiplePortsAndMisconfiguredGenericPrimaryPortNameWithoutFallbackShouldLogWarning(){\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    Endpoints endPoint\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint4\").withNamespace(\"test\").withLabels(labels).endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"100\").endTargetRef().endAddress().addNewPort(\"http\",\"https1\",443,\"TCP\").addNewPort(\"http\",\"https2\",8443,\"TCP\").addNewPort(\"http\",\"http1\",80,\"TCP\").addNewPort(\"http\",\"http2\",8080,\"TCP\").endSubset().build();\n    mockClient.endpoints().inNamespace(\"test\").resource(endPoint).create();\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).withNewMetadata().withName(\"endpoint4\").withNamespace(\"test\").withLabels(labels).withAnnotations(labels).endMetadata().build();\n    mockClient.services().inNamespace(\"test\").resource(service).create();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),\"oops\",Metadata.DEFAULT,0,true);\n    DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,properties,KubernetesClient::services,null,new ServicePortSecureResolver(properties));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint4\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"100\")).hasSize(1).hasSize(1);\n  }\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedShouldFallBackToHttps(){\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    Endpoints endPoint1\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint5\").withNamespace(\"test\").withLabels(labels).endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"110\").endTargetRef().endAddress().addNewPort(\"http\",\"https\",443,\"TCP\").addNewPort(\"http\",\"http\",80,\"TCP\").endSubset().build();\n    mockClient.endpoints().inNamespace(\"test\").resource(endPoint1).create();\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).withNewMetadata().withName(\"endpoint5\").withNamespace(\"test\").withLabels(labels).withAnnotations(labels).endMetadata().build();\n    mockClient.services().inNamespace(\"test\").resource(service).create();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),null,Metadata.DEFAULT,0,true);\n    DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,properties,KubernetesClient::services,null,new ServicePortSecureResolver(properties));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint5\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"110\")).hasSize(1).filteredOn(s -\u003e 443 \u003d\u003d s.getPort()).hasSize(1);\n  }\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedOrHttpsPortShouldFallBackToHttp(){\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    Endpoints endPoint1\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint5\").withNamespace(\"test\").withLabels(labels).endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"120\").endTargetRef().endAddress().addNewPort(\"http\",\"https1\",443,\"TCP\").addNewPort(\"http\",\"https2\",8443,\"TCP\").addNewPort(\"http\",\"http\",80,\"TCP\").endSubset().build();\n    mockClient.endpoints().inNamespace(\"test\").resource(endPoint1).create();\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).withNewMetadata().withName(\"endpoint5\").withNamespace(\"test\").withLabels(labels).withAnnotations(labels).endMetadata().build();\n    mockClient.services().inNamespace(\"test\").resource(service).create();\n    DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,KubernetesDiscoveryProperties.DEFAULT,KubernetesClient::services,null,new ServicePortSecureResolver(KubernetesDiscoveryProperties.DEFAULT));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint5\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 !s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"120\")).hasSize(1).filteredOn(s -\u003e 80 \u003d\u003d s.getPort()).hasSize(1);\n  }\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedShouldLogWarning(){\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    Endpoints endPoint1\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint5\").withNamespace(\"test\").withLabels(labels).endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"130\").endTargetRef().endAddress().addNewPort(\"http\",\"https\",443,\"TCP\").addNewPort(\"http\",\"http\",80,\"TCP\").endSubset().build();\n    mockClient.endpoints().inNamespace(\"test\").resource(endPoint1).create();\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").build()).withNewMetadata().withName(\"endpoint5\").withNamespace(\"test\").withLabels(labels).withAnnotations(labels).endMetadata().build();\n    mockClient.services().inNamespace(\"test\").resource(service).create();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,true,null,Set.of(443,8443),Map.of(),null,Metadata.DEFAULT,0,true);\n    DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,properties,KubernetesClient::services,null,new ServicePortSecureResolver(properties));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint5\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"130\")).hasSize(1).filteredOn(s -\u003e 443 \u003d\u003d s.getPort()).hasSize(1);\n  }\n  @Test public void instanceWithoutPorts(){\n    Map\u003cString,String\u003e labels\u003dnew HashMap\u003c\u003e();\n    Endpoints endPoint1\u003dnew EndpointsBuilder().withNewMetadata().withName(\"endpoint5\").withNamespace(\"test\").withLabels(labels).endMetadata().addNewSubset().addNewAddress().withIp(\"ip1\").withNewTargetRef().withUid(\"130\").endTargetRef().endAddress().endSubset().build();\n    mockClient.endpoints().inNamespace(\"test\").create(endPoint1);\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ClusterIP\").build()).withNewMetadata().withName(\"endpoint5\").withNamespace(\"test\").withLabels(labels).withAnnotations(labels).endMetadata().build();\n    mockClient.services().inNamespace(\"test\").create(service);\n    final KubernetesDiscoveryProperties properties\u003dKubernetesDiscoveryProperties.DEFAULT;\n    final DiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(mockClient,properties,KubernetesClient::services,null,new ServicePortSecureResolver(properties));\n    final List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint5\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 !s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getUri().toASCIIString().equals(\"http://ip1\")).filteredOn(s -\u003e s.getInstanceId().equals(\"130\")).hasSize(1).filteredOn(s -\u003e 0 \u003d\u003d s.getPort()).hasSize(1);\n  }\n}\n",
        "abstract": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8KubernetesDiscoveryClientTest {\n  private KubernetesClient mockClient;\n  @BeforeEach void setup();\n  @AfterEach void afterEach();\n  @Test void getInstancesShouldBeAbleToHandleEndpointsSingleAddress();\n  @Test void getInstancesShouldBeAbleToHandleEndpointsSingleAddressAndMultiplePorts();\n  @Test void getEndPointsListTest();\n  @Test void getEndPointsListTestAllNamespaces();\n  @Test void getEndPointsListShouldHandleNamespaces();\n  @Test void getInstancesShouldBeAbleToHandleEndpointsMultipleAddresses();\n  @Test void getServicesShouldReturnAllServicesWhenNoLabelsAreAppliedToTheClient();\n  @Test void getServicesShouldReturnOnlyMatchingServicesWhenLabelsAreAppliedToTheClient();\n  @Test void getServicesShouldReturnServicesInNamespaces();\n  @Test void getInstancesShouldBeAbleToHandleEndpointsFromMultipleNamespaces();\n  @Test void instanceWithoutSubsetsShouldBeSkipped();\n  @Test void getInstancesShouldBeAbleToHandleEndpointsSingleAddressAndMultiplePortsUsingPrimaryPortNameLabel();\n  @Test void instanceWithMultiplePortsAndMisconfiguredPrimaryPortNameInLabelWithoutFallbackShouldLogWarning();\n  @Test void instanceWithMultiplePortsAndMisconfiguredGenericPrimaryPortNameWithoutFallbackShouldLogWarning();\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedShouldFallBackToHttps();\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedOrHttpsPortShouldFallBackToHttp();\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedShouldLogWarning();\n  @Test public void instanceWithoutPorts();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8KubernetesCatalogWatchEndpointSlicesSupportTests.java",
        "name": "Fabric8KubernetesCatalogWatchEndpointSlicesSupportTests",
        "modifiers": "@EnableKubernetesMockClient",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8KubernetesCatalogWatchEndpointSlicesSupportTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Tests that only assert the needed support for EndpointSlices in the cluster.\n * @author wind57\n */\n@EnableKubernetesMockClient class Fabric8KubernetesCatalogWatchEndpointSlicesSupportTests {\n  private static final KubernetesNamespaceProvider NAMESPACE_PROVIDER\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeEach void beforeEach(){\n    mockServer.clearExpectations();\n  }\n  @Test void testEndpointSlicesEnabledButNotSupportedViaApiGroups(){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,\"\",Set.of(),Map.of(),\"\",null,0,true);\n    APIGroupList groupList\u003dnew APIGroupListBuilder().build();\n    mockServer.expect().withPath(\"/apis\").andReturn(200,groupList).always();\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(mockClient,properties,NAMESPACE_PROVIDER);\n    IllegalArgumentException ex\u003dAssertions.assertThrows(IllegalArgumentException.class,watch::postConstruct);\n    Assertions.assertEquals(\"EndpointSlices are not supported on the cluster\",ex.getMessage());\n  }\n  /** \n * \u003cpre\u003e - endpoint slices are enabled, but are not supported by the cluster, as such we will fail with an IllegalArgumentException - ApiVersions is empty \u003c/pre\u003e\n */\n  @Test void testEndpointSlicesEnabledButNotSupportedViaApiVersions(){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,\"\",Set.of(),Map.of(),\"\",null,0,true);\n    GroupVersionForDiscovery forDiscovery\u003dnew GroupVersionForDiscoveryBuilder().withGroupVersion(\"discovery.k8s.io/v1\").build();\n    APIGroup apiGroup\u003dnew APIGroupBuilder().withApiVersion(\"v1\").withVersions(forDiscovery).build();\n    APIGroupList groupList\u003dnew APIGroupListBuilder().withGroups(apiGroup).build();\n    mockServer.expect().withPath(\"/apis\").andReturn(200,groupList).always();\n    APIResourceList apiResourceList\u003dnew APIResourceListBuilder().build();\n    mockServer.expect().withPath(\"/apis/discovery.k8s.io/v1\").andReturn(200,apiResourceList).always();\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(mockClient,properties,NAMESPACE_PROVIDER);\n    IllegalArgumentException ex\u003dAssertions.assertThrows(IllegalArgumentException.class,watch::postConstruct);\n    Assertions.assertEquals(\"EndpointSlices are not supported on the cluster\",ex.getMessage());\n  }\n  /** \n * endpoint slices are disabled via properties, as such we will use a catalog watch based on Endpoints\n */\n  @Test void testEndpointsSupport(){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(mockClient,properties,NAMESPACE_PROVIDER);\n    Assertions.assertEquals(Fabric8EndpointsCatalogWatch.class,watch.stateGenerator().getClass());\n  }\n  /** \n * endpoint slices are enabled via properties and supported by the cluster, as such we will use a catalog watch based on Endpoint Slices\n */\n  @Test void testEndpointSlicesSupport(){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,\"\",Set.of(),Map.of(),\"\",null,0,true);\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(mockClient,properties,NAMESPACE_PROVIDER);\n    GroupVersionForDiscovery forDiscovery\u003dnew GroupVersionForDiscoveryBuilder().withGroupVersion(\"discovery.k8s.io/v1\").build();\n    APIGroup apiGroup\u003dnew APIGroupBuilder().withApiVersion(\"v1\").withVersions(forDiscovery).build();\n    APIGroupList groupList\u003dnew APIGroupListBuilder().withGroups(apiGroup).build();\n    mockServer.expect().withPath(\"/apis\").andReturn(200,groupList).always();\n    APIResource apiResource\u003dnew APIResourceBuilder().withGroup(\"discovery.k8s.io/v1\").withKind(\"EndpointSlice\").build();\n    APIResourceList apiResourceList\u003dnew APIResourceListBuilder().withResources(apiResource).build();\n    mockServer.expect().withPath(\"/apis/discovery.k8s.io/v1\").andReturn(200,apiResourceList).always();\n    Assertions.assertEquals(Fabric8EndpointSliceV1CatalogWatch.class,watch.stateGenerator().getClass());\n  }\n}\n",
        "abstract": "/** \n * Tests that only assert the needed support for EndpointSlices in the cluster.\n * @author wind57\n */\n@EnableKubernetesMockClient class Fabric8KubernetesCatalogWatchEndpointSlicesSupportTests {\n  private static final KubernetesNamespaceProvider NAMESPACE_PROVIDER\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  private static KubernetesMockServer mockServer;\n  private static KubernetesClient mockClient;\n  @BeforeEach void beforeEach();\n  @Test void testEndpointSlicesEnabledButNotSupportedViaApiGroups();\n  /** \n * \u003cpre\u003e - endpoint slices are enabled, but are not supported by the cluster, as such we will fail with an IllegalArgumentException - ApiVersions is empty \u003c/pre\u003e\n */\n  @Test void testEndpointSlicesEnabledButNotSupportedViaApiVersions();\n  /** \n * endpoint slices are disabled via properties, as such we will use a catalog watch based on Endpoints\n */\n  @Test void testEndpointsSupport();\n  /** \n * endpoint slices are enabled via properties and supported by the cluster, as such we will use a catalog watch based on Endpoint Slices\n */\n  @Test void testEndpointSlicesSupport();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8PodLabelsAndAnnotationsSupplierTests.java",
        "name": "Fabric8PodLabelsAndAnnotationsSupplierTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8PodLabelsAndAnnotationsSupplierTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8PodLabelsAndAnnotationsSupplierTests {\n  private static final String NAMESPACE\u003d\"spring-k8s\";\n  private static final String POD_NAME\u003d\"my-pod\";\n  private static KubernetesClient client;\n  @AfterEach void afterEach(){\n    client.pods().inAnyNamespace().delete();\n  }\n  @Test void noObjetMeta(){\n    client.pods().inNamespace(NAMESPACE).resource(new PodBuilder().withMetadata(new ObjectMetaBuilder().withName(POD_NAME).build()).build()).create();\n    PodLabelsAndAnnotations result\u003dFabric8PodLabelsAndAnnotationsSupplier.nonExternalName(client,NAMESPACE).apply(POD_NAME);\n    Assertions.assertNotNull(result);\n    Assertions.assertTrue(result.labels().isEmpty());\n    Assertions.assertTrue(result.annotations().isEmpty());\n  }\n  @Test void labelsAndAnnotationsPresent(){\n    client.pods().inNamespace(NAMESPACE).resource(new PodBuilder().withMetadata(new ObjectMetaBuilder().withName(POD_NAME).withLabels(Map.of(\"a\",\"b\")).withAnnotations(Map.of(\"c\",\"d\")).build()).build()).create();\n    PodLabelsAndAnnotations result\u003dFabric8PodLabelsAndAnnotationsSupplier.nonExternalName(client,NAMESPACE).apply(POD_NAME);\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.labels(),Map.of(\"a\",\"b\"));\n    Assertions.assertEquals(result.annotations(),Map.of(\"c\",\"d\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8PodLabelsAndAnnotationsSupplierTests {\n  private static final String NAMESPACE\u003d\"spring-k8s\";\n  private static final String POD_NAME\u003d\"my-pod\";\n  private static KubernetesClient client;\n  @AfterEach void afterEach();\n  @Test void noObjetMeta();\n  @Test void labelsAndAnnotationsPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesDiscoveryClientFilterMetadataTest.java",
        "name": "KubernetesDiscoveryClientFilterMetadataTest",
        "modifiers": "@SuppressWarnings(\"unchecked\")",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesDiscoveryClientFilterMetadataTest",
        "extend": "",
        "implements": "",
        "raw": "@SuppressWarnings(\"unchecked\") class KubernetesDiscoveryClientFilterMetadataTest {\n  private static final KubernetesClient CLIENT\u003dMockito.mock(KubernetesClient.class);\n  private final MixedOperation\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e serviceOperation\u003dMockito.mock(MixedOperation.class);\n  private final MixedOperation\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e endpointsOperation\u003dMockito.mock(MixedOperation.class);\n  private final ServiceResource\u003cService\u003e serviceResource\u003dMockito.mock(ServiceResource.class);\n  private final FilterWatchListDeletable\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e filter\u003dMockito.mock(FilterWatchListDeletable.class);\n  private final FilterNested\u003cFilterWatchListDeletable\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e\u003e filterNested\u003dMockito.mock(FilterNested.class);\n  @Test void testAllExtraMetadataDisabled(){\n    String serviceId\u003d\"s\";\n    Metadata metadata\u003dnew Metadata(false,null,false,null,false,null);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(CLIENT,properties,a -\u003e null);\n    discoveryClient.setEnvironment(withClientNamespace());\n    setupServiceWithLabelsAndAnnotationsAndPorts(serviceId,\"ns\",Map.of(\"l1\",\"lab\"),Map.of(\"l1\",\"lab\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).isEqualTo(Map.of(\"k8s_namespace\",\"ns\",\"type\",\"ClusterIP\"));\n  }\n  @Test void testLabelsEnabled(){\n    String serviceId\u003d\"s\";\n    Metadata metadata\u003dnew Metadata(true,null,false,null,false,null);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(CLIENT,properties,a -\u003e null);\n    discoveryClient.setEnvironment(withClientNamespace());\n    setupServiceWithLabelsAndAnnotationsAndPorts(serviceId,\"ns\",Map.of(\"l1\",\"v1\",\"l2\",\"v2\"),Map.of(\"l1\",\"lab\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"l1\",\"v1\"),entry(\"l2\",\"v2\"),entry(\"k8s_namespace\",\"ns\"),entry(\"type\",\"ClusterIP\"));\n  }\n  @Test void testLabelsEnabledWithPrefix(){\n    String serviceId\u003d\"s\";\n    Metadata metadata\u003dnew Metadata(true,\"l_\",false,null,false,null);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(CLIENT,properties,a -\u003e null);\n    discoveryClient.setEnvironment(withClientNamespace());\n    setupServiceWithLabelsAndAnnotationsAndPorts(serviceId,\"ns\",Map.of(\"l1\",\"v1\",\"l2\",\"v2\"),Map.of(\"l1\",\"lab\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"l_l1\",\"v1\"),entry(\"l_l2\",\"v2\"),entry(\"k8s_namespace\",\"ns\"),entry(\"type\",\"ClusterIP\"));\n  }\n  @Test void testAnnotationsEnabled(){\n    String serviceId\u003d\"s\";\n    Metadata metadata\u003dnew Metadata(false,null,true,null,false,null);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(CLIENT,properties,a -\u003e null);\n    discoveryClient.setEnvironment(withClientNamespace());\n    setupServiceWithLabelsAndAnnotationsAndPorts(serviceId,\"ns\",Map.of(\"l1\",\"v1\"),Map.of(\"a1\",\"v1\",\"a2\",\"v2\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"a1\",\"v1\"),entry(\"a2\",\"v2\"),entry(\"k8s_namespace\",\"ns\"),entry(\"type\",\"ClusterIP\"));\n  }\n  @Test void testAnnotationsEnabledWithPrefix(){\n    String serviceId\u003d\"s\";\n    Metadata metadata\u003dnew Metadata(false,null,true,\"a_\",false,null);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(CLIENT,properties,a -\u003e null);\n    discoveryClient.setEnvironment(withClientNamespace());\n    setupServiceWithLabelsAndAnnotationsAndPorts(serviceId,\"ns\",Map.of(\"l1\",\"v1\"),Map.of(\"a1\",\"v1\",\"a2\",\"v2\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"a_a1\",\"v1\"),entry(\"a_a2\",\"v2\"),entry(\"k8s_namespace\",\"ns\"),entry(\"type\",\"ClusterIP\"));\n  }\n  @Test void testPortsEnabled(){\n    String serviceId\u003d\"s\";\n    Metadata metadata\u003dnew Metadata(false,null,false,null,true,null);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(CLIENT,properties,a -\u003e null);\n    discoveryClient.setEnvironment(withClientNamespace());\n    setupServiceWithLabelsAndAnnotationsAndPorts(serviceId,\"test\",Map.of(\"l1\",\"v1\"),Map.of(\"a1\",\"v1\",\"a2\",\"v2\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"http\",\"80\"),entry(\"k8s_namespace\",\"test\"),entry(\"\u003cunset\u003e\",\"5555\"),entry(\"type\",\"ClusterIP\"));\n  }\n  @Test void testPortsEnabledWithPrefix(){\n    String serviceId\u003d\"s\";\n    Metadata metadata\u003dnew Metadata(false,null,false,null,true,\"p_\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(CLIENT,properties,a -\u003e null);\n    discoveryClient.setEnvironment(withClientNamespace());\n    setupServiceWithLabelsAndAnnotationsAndPorts(serviceId,\"ns\",Map.of(\"l1\",\"v1\"),Map.of(\"a1\",\"v1\",\"a2\",\"v2\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"p_http\",\"80\"),entry(\"k8s_namespace\",\"ns\"),entry(\"p_\u003cunset\u003e\",\"5555\"),entry(\"type\",\"ClusterIP\"));\n  }\n  @Test void testLabelsAndAnnotationsAndPortsEnabledWithPrefix(){\n    String serviceId\u003d\"s\";\n    Metadata metadata\u003dnew Metadata(true,\"l_\",true,\"a_\",true,\"p_\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(CLIENT,properties,a -\u003e null);\n    discoveryClient.setEnvironment(withClientNamespace());\n    setupServiceWithLabelsAndAnnotationsAndPorts(serviceId,\"ns\",Map.of(\"l1\",\"la1\"),Map.of(\"a1\",\"an1\",\"a2\",\"an2\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"a_a1\",\"an1\"),entry(\"a_a2\",\"an2\"),entry(\"l_l1\",\"la1\"),entry(\"p_http\",\"80\"),entry(\"k8s_namespace\",\"ns\"),entry(\"type\",\"ClusterIP\"),entry(\"p_\u003cunset\u003e\",\"5555\"));\n  }\n  private void setupServiceWithLabelsAndAnnotationsAndPorts(  String serviceId,  String namespace,  Map\u003cString,String\u003e labels,  Map\u003cString,String\u003e annotations,  Map\u003cInteger,String\u003e ports){\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ClusterIP\").withPorts(getServicePorts(ports)).build()).withNewMetadata().withNamespace(namespace).withLabels(labels).withAnnotations(annotations).endMetadata().build();\n    when(serviceOperation.withName(serviceId)).thenReturn(serviceResource);\n    when(serviceResource.get()).thenReturn(service);\n    when(CLIENT.services()).thenReturn(serviceOperation);\n    when(CLIENT.services().inNamespace(anyString())).thenReturn(serviceOperation);\n    when(serviceOperation.list()).thenReturn(new ServiceListBuilder().withItems(new ServiceBuilder().withNewMetadata().withName(serviceId).withNamespace(namespace).endMetadata().build()).build());\n    ObjectMeta objectMeta\u003dnew ObjectMeta();\n    objectMeta.setNamespace(namespace);\n    objectMeta.setName(serviceId);\n    Endpoints endpoints\u003dnew EndpointsBuilder().withMetadata(objectMeta).addNewSubset().addAllToPorts(getEndpointPorts(ports)).addNewAddress().endAddress().endSubset().build();\n    when(CLIENT.endpoints()).thenReturn(endpointsOperation);\n    when(endpointsOperation.inNamespace(Mockito.anyString())).thenReturn(endpointsOperation);\n    when(endpointsOperation.withNewFilter()).thenReturn(filterNested);\n    EndpointsList endpointsList\u003dnew EndpointsList(null,Collections.singletonList(endpoints),null,null);\n    when(filter.list()).thenReturn(endpointsList);\n    when(filterNested.withLabels(anyMap())).thenReturn(filterNested);\n    when(filterNested.withField(eq(\"metadata.name\"),eq(serviceId))).thenReturn(filterNested);\n    when(filterNested.endFilter()).thenReturn(filter);\n  }\n  private List\u003cServicePort\u003e getServicePorts(  Map\u003cInteger,String\u003e ports){\n    return ports.entrySet().stream().map(e -\u003e {\n      ServicePortBuilder servicePortBuilder\u003dnew ServicePortBuilder();\n      servicePortBuilder.withPort(e.getKey());\n      if (!Strings.isNullOrEmpty(e.getValue())) {\n        servicePortBuilder.withName(e.getValue());\n      }\n      return servicePortBuilder.build();\n    }\n).collect(toList());\n  }\n  private List\u003cEndpointPort\u003e getEndpointPorts(  Map\u003cInteger,String\u003e ports){\n    return ports.entrySet().stream().map(e -\u003e {\n      EndpointPortBuilder endpointPortBuilder\u003dnew EndpointPortBuilder();\n      endpointPortBuilder.withPort(e.getKey());\n      if (!Strings.isNullOrEmpty(e.getValue())) {\n        endpointPortBuilder.withName(e.getValue());\n      }\n      return endpointPortBuilder.build();\n    }\n).collect(toList());\n  }\n  private static Environment withClientNamespace(){\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setProperty(\"spring.cloud.kubernetes.client.namespace\",\"test\");\n    return mockEnvironment;\n  }\n}\n",
        "abstract": "@SuppressWarnings(\"unchecked\") class KubernetesDiscoveryClientFilterMetadataTest {\n  private static final KubernetesClient CLIENT\u003dMockito.mock(KubernetesClient.class);\n  private final MixedOperation\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e serviceOperation\u003dMockito.mock(MixedOperation.class);\n  private final MixedOperation\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e endpointsOperation\u003dMockito.mock(MixedOperation.class);\n  private final ServiceResource\u003cService\u003e serviceResource\u003dMockito.mock(ServiceResource.class);\n  private final FilterWatchListDeletable\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e filter\u003dMockito.mock(FilterWatchListDeletable.class);\n  private final FilterNested\u003cFilterWatchListDeletable\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e\u003e filterNested\u003dMockito.mock(FilterNested.class);\n  @Test void testAllExtraMetadataDisabled();\n  @Test void testLabelsEnabled();\n  @Test void testLabelsEnabledWithPrefix();\n  @Test void testAnnotationsEnabled();\n  @Test void testAnnotationsEnabledWithPrefix();\n  @Test void testPortsEnabled();\n  @Test void testPortsEnabledWithPrefix();\n  @Test void testLabelsAndAnnotationsAndPortsEnabledWithPrefix();\n  private void setupServiceWithLabelsAndAnnotationsAndPorts(  String serviceId,  String namespace,  Map\u003cString,String\u003e labels,  Map\u003cString,String\u003e annotations,  Map\u003cInteger,String\u003e ports);\n  private List\u003cServicePort\u003e getServicePorts(  Map\u003cInteger,String\u003e ports);\n  private List\u003cEndpointPort\u003e getEndpointPorts(  Map\u003cInteger,String\u003e ports);\n  private static Environment withClientNamespace();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8KubernetesDiscoveryClientUtilsTests.java",
        "name": "Fabric8KubernetesDiscoveryClientUtilsTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8KubernetesDiscoveryClientUtilsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8KubernetesDiscoveryClientUtilsTests {\n  private static KubernetesClient client;\n  @AfterEach void afterEach(){\n    client.services().inAnyNamespace().delete();\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - serviceA present in namespace \"A\" - serviceB present in namespace \"B\" - no filters are applied, so both are present \u003c/pre\u003e\n */\n  @Test void testServicesAllNamespacesNoFilters(){\n    boolean allNamespaces\u003dtrue;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    service(\"serviceA\",\"A\",Map.of());\n    service(\"serviceB\",\"B\",Map.of());\n    List\u003cService\u003e result\u003dservices(properties,client,null,x -\u003e true,null,\"fabric8-discovery\");\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertEquals(result.stream().map(s -\u003e s.getMetadata().getName()).sorted().toList(),List.of(\"serviceA\",\"serviceB\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - serviceA present in namespace \"A\" - serviceB present in namespace \"B\" - we search only for \"serviceA\" filter, so only one is returned \u003c/pre\u003e\n */\n  @Test void testServicesAllNamespacesNameFilter(){\n    boolean allNamespaces\u003dtrue;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    service(\"serviceA\",\"A\",Map.of());\n    service(\"serviceB\",\"B\",Map.of());\n    List\u003cService\u003e result\u003dservices(properties,client,null,x -\u003e true,Map.of(\"metadata.name\",\"serviceA\"),\"fabric8-discovery\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceA\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - serviceA present in namespace \"A\" - serviceB present in namespace \"B\" - we search with a filter where a label with name \"letter\" and value \"b\" is present \u003c/pre\u003e\n */\n  @Test void testServicesAllNamespacesPredicateFilter(){\n    boolean allNamespaces\u003dtrue;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    service(\"serviceA\",\"A\",Map.of(\"letter\",\"a\"));\n    service(\"serviceB\",\"B\",Map.of(\"letter\",\"b\"));\n    List\u003cService\u003e result\u003dservices(properties,client,null,x -\u003e x.getMetadata().getLabels().equals(Map.of(\"letter\",\"b\")),null,\"fabric8-discovery\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceB\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - selective namespaces : [A, B] - serviceA present in namespace \"A\" - serviceB present in namespace \"B\" - serviceC present in namespace \"C\" - we search in namespaces [A, B], as such two services are returned \u003c/pre\u003e\n */\n  @Test void testServicesSelectiveNamespacesNoFilters(){\n    boolean allNamespaces\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(\"A\",\"B\"),true,60L,false,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    service(\"serviceA\",\"A\",Map.of());\n    service(\"serviceB\",\"B\",Map.of());\n    service(\"serviceC\",\"C\",Map.of());\n    List\u003cService\u003e result\u003dservices(properties,client,null,x -\u003e true,null,\"fabric8-discovery\");\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertEquals(result.stream().map(x -\u003e x.getMetadata().getName()).sorted().toList(),List.of(\"serviceA\",\"serviceB\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - selective namespaces : [A, B] - serviceA present in namespace \"A\" - serviceB present in namespace \"B\" - serviceC present in namespace \"C\" - we search in namespaces [A, B] with name filter \u003d \"serviceA\", so we get a single result \u003c/pre\u003e\n */\n  @Test void testServicesSelectiveNamespacesNameFilter(){\n    boolean allNamespaces\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(\"A\",\"B\"),true,60L,false,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    service(\"serviceA\",\"A\",Map.of());\n    service(\"serviceB\",\"B\",Map.of());\n    service(\"serviceC\",\"C\",Map.of());\n    List\u003cService\u003e result\u003dservices(properties,client,null,x -\u003e true,Map.of(\"metadata.name\",\"serviceA\"),\"fabric8-discovery\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceA\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - selective namespaces : [A, B] - serviceA present in namespace \"A\" with labels [letter, a] - serviceB present in namespace \"B\" with labels [letter, b] - serviceC present in namespace \"C\" with labels [letter, c] - we search in namespaces [A, B] with predicate filter \u003d [letter, b], so we get a single result \u003c/pre\u003e\n */\n  @Test void testServicesSelectiveNamespacesPredicateFilter(){\n    boolean allNamespaces\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(\"A\",\"B\"),true,60L,false,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    service(\"serviceA\",\"A\",Map.of(\"letter\",\"a\"));\n    service(\"serviceB\",\"B\",Map.of(\"letter\",\"b\"));\n    service(\"serviceC\",\"C\",Map.of(\"letter\",\"c\"));\n    List\u003cService\u003e result\u003dservices(properties,client,null,x -\u003e x.getMetadata().getLabels().equals(Map.of(\"letter\",\"b\")),null,\"fabric8-discovery\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceB\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - selective namespaces : [] - namespace from kubernetes namespace provider \u003d [A] - serviceA present in namespace \"A\" - serviceB present in namespace \"B\" - serviceC present in namespace \"C\" - we search in namespaces [A], as such we get one service \u003c/pre\u003e\n */\n  @Test void testServicesNamespaceProviderNoFilters(){\n    boolean allNamespaces\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    service(\"serviceA\",\"A\",Map.of());\n    service(\"serviceB\",\"B\",Map.of());\n    service(\"serviceC\",\"C\",Map.of());\n    List\u003cService\u003e result\u003dservices(properties,client,namespaceProvider(\"A\"),x -\u003e true,null,\"fabric8-discovery\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceA\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - selective namespaces : [] - namespace from kubernetes namespace provider \u003d [A] - serviceA present in namespace \"A\" - serviceB present in namespace \"A\" - we search in namespaces [A] with name filter \u003d \"serviceA\", so we get a single result \u003c/pre\u003e\n */\n  @Test void testServicesNamespaceProviderNameFilter(){\n    boolean allNamespaces\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    service(\"serviceA\",\"A\",Map.of());\n    service(\"serviceB\",\"A\",Map.of());\n    List\u003cService\u003e result\u003dservices(properties,client,namespaceProvider(\"A\"),x -\u003e true,Map.of(\"metadata.name\",\"serviceA\"),\"fabric8-discovery\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceA\");\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - selective namespaces : [] - namespace from kubernetes namespace provider \u003d [A] - serviceA present in namespace \"A\" - serviceB present in namespace \"A\" - we search in namespaces [A] with predicate filter \u003d [letter, b], so we get a single result \u003c/pre\u003e\n */\n  @Test void testServicesNamespaceProviderPredicateFilter(){\n    boolean allNamespaces\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    service(\"serviceA\",\"A\",Map.of(\"letter\",\"a\"));\n    service(\"serviceB\",\"A\",Map.of(\"letter\",\"b\"));\n    List\u003cService\u003e result\u003dservices(properties,client,namespaceProvider(\"A\"),x -\u003e x.getMetadata().getLabels().equals(Map.of(\"letter\",\"b\")),null,\"fabric8-discovery\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"serviceB\");\n  }\n  @Test void testExternalName(){\n    Service service\u003dnew ServiceBuilder().withSpec(new ServiceSpecBuilder().withType(\"ExternalName\").withExternalName(\"k8s-spring\").build()).withNewMetadata().withName(\"external-name-service\").and().build();\n    client.services().inNamespace(\"test\").resource(service).create();\n    boolean allNamespaces\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    List\u003cService\u003e result\u003dservices(properties,client,namespaceProvider(\"test\"),x -\u003e x.getSpec().getType().equals(\"ExternalName\"),Map.of(),\"fabric8-discovery\");\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getMetadata().getName(),\"external-name-service\");\n  }\n  @Test void testPortsDataOne(){\n    List\u003cEndpointSubset\u003e endpointSubsets\u003dList.of(new EndpointSubsetBuilder().withPorts(new EndpointPortBuilder().withPort(8081).withName(\"\").build()).build(),new EndpointSubsetBuilder().withPorts(new EndpointPortBuilder().withPort(8080).withName(\"https\").build()).build());\n    Map\u003cString,Integer\u003e portsData\u003dendpointSubsetsPortData(endpointSubsets);\n    Assertions.assertEquals(portsData.size(),2);\n    Assertions.assertEquals(portsData.get(\"https\"),8080);\n    Assertions.assertEquals(portsData.get(\"\u003cunset\u003e\"),8081);\n  }\n  @Test void testPortsDataTwo(){\n    List\u003cEndpointSubset\u003e endpointSubsets\u003dList.of(new EndpointSubsetBuilder().withPorts(new EndpointPortBuilder().withPort(8081).withName(\"http\").build()).build(),new EndpointSubsetBuilder().withPorts(new EndpointPortBuilder().withPort(8080).withName(\"https\").build()).build());\n    Map\u003cString,Integer\u003e portsData\u003dendpointSubsetsPortData(endpointSubsets);\n    Assertions.assertEquals(portsData.size(),2);\n    Assertions.assertEquals(portsData.get(\"https\"),8080);\n    Assertions.assertEquals(portsData.get(\"http\"),8081);\n  }\n  @Test void endpointSubsetPortsDataWithoutPorts(){\n    EndpointSubset endpointSubset\u003dnew EndpointSubsetBuilder().build();\n    Map\u003cString,Integer\u003e result\u003dendpointSubsetsPortData(List.of(endpointSubset));\n    Assertions.assertEquals(result.size(),0);\n  }\n  @Test void endpointSubsetPortsDataSinglePort(){\n    EndpointSubset endpointSubset\u003dnew EndpointSubsetBuilder().withPorts(new EndpointPortBuilder().withName(\"name\").withPort(80).build()).build();\n    Map\u003cString,Integer\u003e result\u003dendpointSubsetsPortData(List.of(endpointSubset));\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(\"name\"),80);\n  }\n  @Test void endpointSubsetPortsDataSinglePortNoName(){\n    EndpointSubset endpointSubset\u003dnew EndpointSubsetBuilder().withPorts(new EndpointPortBuilder().withPort(80).build()).build();\n    Map\u003cString,Integer\u003e result\u003dendpointSubsetsPortData(List.of(endpointSubset));\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(\"\u003cunset\u003e\"),80);\n  }\n  private void service(  String name,  String namespace,  Map\u003cString,String\u003e labels){\n    Service service\u003dnew ServiceBuilder().withNewMetadata().withName(name).withLabels(labels).withNamespace(namespace).and().build();\n    client.services().inNamespace(namespace).resource(service).create();\n  }\n  private KubernetesNamespaceProvider namespaceProvider(  String namespace){\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setProperty(\"spring.cloud.kubernetes.client.namespace\",namespace);\n    return new KubernetesNamespaceProvider(mockEnvironment);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8KubernetesDiscoveryClientUtilsTests {\n  private static KubernetesClient client;\n  @AfterEach void afterEach();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - serviceA present in namespace \"A\" - serviceB present in namespace \"B\" - no filters are applied, so both are present \u003c/pre\u003e\n */\n  @Test void testServicesAllNamespacesNoFilters();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - serviceA present in namespace \"A\" - serviceB present in namespace \"B\" - we search only for \"serviceA\" filter, so only one is returned \u003c/pre\u003e\n */\n  @Test void testServicesAllNamespacesNameFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - serviceA present in namespace \"A\" - serviceB present in namespace \"B\" - we search with a filter where a label with name \"letter\" and value \"b\" is present \u003c/pre\u003e\n */\n  @Test void testServicesAllNamespacesPredicateFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - selective namespaces : [A, B] - serviceA present in namespace \"A\" - serviceB present in namespace \"B\" - serviceC present in namespace \"C\" - we search in namespaces [A, B], as such two services are returned \u003c/pre\u003e\n */\n  @Test void testServicesSelectiveNamespacesNoFilters();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - selective namespaces : [A, B] - serviceA present in namespace \"A\" - serviceB present in namespace \"B\" - serviceC present in namespace \"C\" - we search in namespaces [A, B] with name filter \u003d \"serviceA\", so we get a single result \u003c/pre\u003e\n */\n  @Test void testServicesSelectiveNamespacesNameFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - selective namespaces : [A, B] - serviceA present in namespace \"A\" with labels [letter, a] - serviceB present in namespace \"B\" with labels [letter, b] - serviceC present in namespace \"C\" with labels [letter, c] - we search in namespaces [A, B] with predicate filter \u003d [letter, b], so we get a single result \u003c/pre\u003e\n */\n  @Test void testServicesSelectiveNamespacesPredicateFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - selective namespaces : [] - namespace from kubernetes namespace provider \u003d [A] - serviceA present in namespace \"A\" - serviceB present in namespace \"B\" - serviceC present in namespace \"C\" - we search in namespaces [A], as such we get one service \u003c/pre\u003e\n */\n  @Test void testServicesNamespaceProviderNoFilters();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - selective namespaces : [] - namespace from kubernetes namespace provider \u003d [A] - serviceA present in namespace \"A\" - serviceB present in namespace \"A\" - we search in namespaces [A] with name filter \u003d \"serviceA\", so we get a single result \u003c/pre\u003e\n */\n  @Test void testServicesNamespaceProviderNameFilter();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - selective namespaces : [] - namespace from kubernetes namespace provider \u003d [A] - serviceA present in namespace \"A\" - serviceB present in namespace \"A\" - we search in namespaces [A] with predicate filter \u003d [letter, b], so we get a single result \u003c/pre\u003e\n */\n  @Test void testServicesNamespaceProviderPredicateFilter();\n  @Test void testExternalName();\n  @Test void testPortsDataOne();\n  @Test void testPortsDataTwo();\n  @Test void endpointSubsetPortsDataWithoutPorts();\n  @Test void endpointSubsetPortsDataSinglePort();\n  @Test void endpointSubsetPortsDataSinglePortNoName();\n  private void service(  String name,  String namespace,  Map\u003cString,String\u003e labels);\n  private KubernetesNamespaceProvider namespaceProvider(  String namespace);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/KubernetesCatalogWatchTest.java",
        "name": "KubernetesCatalogWatchTest",
        "modifiers": "@SuppressWarnings({\"unchecked\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesCatalogWatchTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Oleg Vyukov\n */\n@SuppressWarnings({\"unchecked\"}) class KubernetesCatalogWatchTest {\n  private static final KubernetesClient CLIENT\u003dMockito.mock(KubernetesClient.class);\n  private final KubernetesNamespaceProvider namespaceProvider\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  private KubernetesCatalogWatch kubernetesCatalogWatch;\n  private static final ApplicationEventPublisher APPLICATION_EVENT_PUBLISHER\u003dMockito.mock(ApplicationEventPublisher.class);\n  private static final MixedOperation\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e MIXED_OPERATION\u003dMockito.mock(MixedOperation.class);\n  private static final NonNamespaceOperation\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e NON_NAMESPACE_OPERATION\u003dMockito.mock(NonNamespaceOperation.class);\n  private static final FilterWatchListDeletable\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e FILTER_WATCH_LIST_DELETABLE\u003dMockito.mock(FilterWatchListDeletable.class);\n  private static final FilterNested\u003cFilterWatchListDeletable\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e\u003e FILTER_NESTED\u003dMockito.mock(FilterNested.class);\n  private static final ArgumentCaptor\u003cHeartbeatEvent\u003e HEARTBEAT_EVENT_ARGUMENT_CAPTOR\u003dArgumentCaptor.forClass(HeartbeatEvent.class);\n  @AfterEach void afterEach(){\n    Mockito.reset(APPLICATION_EVENT_PUBLISHER,CLIENT,MIXED_OPERATION,FILTER_WATCH_LIST_DELETABLE,NON_NAMESPACE_OPERATION);\n  }\n  @Test void testRandomOrderChangePods(){\n    createInSpecificNamespaceWatcher();\n    when(FILTER_WATCH_LIST_DELETABLE.list()).thenReturn(createSingleEndpointEndpointListByPodName(\"test\",\"api-pod\",\"other-pod\")).thenReturn(createSingleEndpointEndpointListByPodName(\"test\",\"other-pod\",\"api-pod\"));\n    mockServicesCall(\"api-pod\",\"test\");\n    mockServicesCall(\"other-pod\",\"test\");\n    kubernetesCatalogWatch.catalogServicesWatch();\n    kubernetesCatalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(any(HeartbeatEvent.class));\n  }\n  @Test void testRandomOrderChangePodsAllNamespaces(){\n    createInAllNamespaceWatcher();\n    when(FILTER_WATCH_LIST_DELETABLE.list()).thenReturn(createSingleEndpointEndpointListByPodName(\"test\",\"api-pod\",\"other-pod\")).thenReturn(createSingleEndpointEndpointListByPodName(\"test\",\"other-pod\",\"api-pod\"));\n    mockServicesCall(\"api-pod\",\"test\");\n    mockServicesCall(\"other-pod\",\"test\");\n    kubernetesCatalogWatch.catalogServicesWatch();\n    kubernetesCatalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(any(HeartbeatEvent.class));\n  }\n  @Test void testRandomOrderChangeServices(){\n    createInSpecificNamespaceWatcher();\n    when(FILTER_WATCH_LIST_DELETABLE.list()).thenReturn(createEndpointsListByServiceName(\"test\",\"api-service\",\"other-service\")).thenReturn(createEndpointsListByServiceName(\"test\",\"other-service\",\"api-service\"));\n    mockServicesCall(\"api-service\",\"test\");\n    mockServicesCall(\"other-service\",\"test\");\n    kubernetesCatalogWatch.catalogServicesWatch();\n    kubernetesCatalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(any(HeartbeatEvent.class));\n  }\n  @Test void testRandomOrderChangeServicesAllNamespaces(){\n    createInAllNamespaceWatcher();\n    when(FILTER_WATCH_LIST_DELETABLE.list()).thenReturn(createEndpointsListByServiceName(\"test\",\"api-service\",\"other-service\")).thenReturn(createEndpointsListByServiceName(\"test\",\"other-service\",\"api-service\"));\n    mockServicesCall(\"api-service\",\"test\");\n    mockServicesCall(\"other-service\",\"test\");\n    kubernetesCatalogWatch.catalogServicesWatch();\n    kubernetesCatalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(any(HeartbeatEvent.class));\n  }\n  @Test void testEventBody(){\n    createInSpecificNamespaceWatcher();\n    when(FILTER_WATCH_LIST_DELETABLE.list()).thenReturn(createSingleEndpointListWithNamespace(\"default\",\"other-pod\",\"api-pod\",\"other-pod\"));\n    mockServicesCall(\"api-pod\",\"default\");\n    mockServicesCall(\"other-pod\",\"default\");\n    kubernetesCatalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(HEARTBEAT_EVENT_ARGUMENT_CAPTOR.capture());\n    HeartbeatEvent event\u003dHEARTBEAT_EVENT_ARGUMENT_CAPTOR.getValue();\n    assertThat(event.getValue()).isInstanceOf(List.class);\n    List\u003cEndpointNameAndNamespace\u003e expectedOutput\u003dList.of(new EndpointNameAndNamespace(\"api-pod\",\"default\"),new EndpointNameAndNamespace(\"other-pod\",\"default\"));\n    assertThat(event.getValue()).isEqualTo(expectedOutput);\n  }\n  @Test void testEventBodyAllNamespaces(){\n    createInAllNamespaceWatcher();\n    when(FILTER_WATCH_LIST_DELETABLE.list()).thenReturn(createSingleEndpointListWithNamespace(\"default\",\"other-pod\",\"api-pod\",\"other-pod\"));\n    mockServicesCall(\"api-pod\",\"default\");\n    mockServicesCall(\"other-pod\",\"default\");\n    kubernetesCatalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(HEARTBEAT_EVENT_ARGUMENT_CAPTOR.capture());\n    HeartbeatEvent event\u003dHEARTBEAT_EVENT_ARGUMENT_CAPTOR.getValue();\n    assertThat(event.getValue()).isInstanceOf(List.class);\n    List\u003cEndpointNameAndNamespace\u003e expectedOutput\u003dList.of(new EndpointNameAndNamespace(\"api-pod\",\"default\"),new EndpointNameAndNamespace(\"other-pod\",\"default\"));\n    assertThat(event.getValue()).isEqualTo(expectedOutput);\n  }\n  @Test void testEndpointsWithoutSubsets(){\n    createInSpecificNamespaceWatcher();\n    EndpointsList endpoints\u003dcreateSingleEndpointEndpointListWithoutSubsets(\"name\",\"test\");\n    mockServicesCall(\"name\",\"test\");\n    when(FILTER_WATCH_LIST_DELETABLE.list()).thenReturn(endpoints);\n    kubernetesCatalogWatch.catalogServicesWatch();\n    kubernetesCatalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(any(HeartbeatEvent.class));\n  }\n  @Test void testEndpointsWithoutSubsetsAllNamespaces(){\n    createInAllNamespaceWatcher();\n    EndpointsList endpoints\u003dcreateSingleEndpointEndpointListWithoutSubsets(\"name\",\"test\");\n    mockServicesCall(\"name\",\"test\");\n    when(FILTER_WATCH_LIST_DELETABLE.list()).thenReturn(endpoints);\n    kubernetesCatalogWatch.catalogServicesWatch();\n    kubernetesCatalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(any(HeartbeatEvent.class));\n  }\n  @Test void testEndpointsWithoutAddresses(){\n    createInSpecificNamespaceWatcher();\n    EndpointsList endpoints\u003dcreateSingleEndpointEndpointListByPodName(\"test\",\"api-pod\");\n    mockServicesCall(\"api-pod\",\"test\");\n    endpoints.getItems().get(0).getSubsets().get(0).setAddresses(null);\n    when(FILTER_WATCH_LIST_DELETABLE.list()).thenReturn(endpoints);\n    kubernetesCatalogWatch.catalogServicesWatch();\n    kubernetesCatalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(any(HeartbeatEvent.class));\n  }\n  @Test void testEndpointsWithoutAddressesAllNamespaces(){\n    createInAllNamespaceWatcher();\n    EndpointsList endpoints\u003dcreateSingleEndpointEndpointListByPodName(\"test\",\"api-pod\");\n    mockServicesCall(\"api-pod\",\"test\");\n    endpoints.getItems().get(0).getSubsets().get(0).setAddresses(null);\n    when(FILTER_WATCH_LIST_DELETABLE.list()).thenReturn(endpoints);\n    kubernetesCatalogWatch.catalogServicesWatch();\n    kubernetesCatalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(any(HeartbeatEvent.class));\n  }\n  @Test void testEndpointsWithoutTargetRefs(){\n    createInSpecificNamespaceWatcher();\n    EndpointsList endpoints\u003dcreateSingleEndpointEndpointListByPodName(\"test\",\"api-pod\");\n    mockServicesCall(\"api-pod\",\"test\");\n    endpoints.getItems().get(0).getSubsets().get(0).getAddresses().get(0).setTargetRef(null);\n    when(FILTER_WATCH_LIST_DELETABLE.list()).thenReturn(endpoints);\n    kubernetesCatalogWatch.catalogServicesWatch();\n    kubernetesCatalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(any(HeartbeatEvent.class));\n  }\n  @Test void testEndpointsWithoutTargetRefsAllNamespaces(){\n    createInAllNamespaceWatcher();\n    EndpointsList endpoints\u003dcreateSingleEndpointEndpointListByPodName(\"test\",\"api-pod\");\n    mockServicesCall(\"api-pod\",\"test\");\n    endpoints.getItems().get(0).getSubsets().get(0).getAddresses().get(0).setTargetRef(null);\n    when(FILTER_WATCH_LIST_DELETABLE.list()).thenReturn(endpoints);\n    kubernetesCatalogWatch.catalogServicesWatch();\n    kubernetesCatalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(any(HeartbeatEvent.class));\n  }\n  private EndpointsList createEndpointsListByServiceName(  String namespace,  String... serviceNames){\n    List\u003cEndpoints\u003e endpoints\u003dstream(serviceNames).map(s -\u003e createEndpointsByPodName(namespace,s + \"-singlePodUniqueId\")).collect(Collectors.toList());\n    EndpointsList endpointsList\u003dnew EndpointsList();\n    endpointsList.setItems(endpoints);\n    return endpointsList;\n  }\n  private EndpointsList createSingleEndpointEndpointListWithoutSubsets(  String name,  String namespace){\n    Endpoints endpoints\u003dnew EndpointsBuilder().withNewMetadata().withName(name).withNamespace(namespace).endMetadata().build();\n    EndpointsList endpointsList\u003dnew EndpointsList();\n    endpointsList.setItems(Collections.singletonList(endpoints));\n    return endpointsList;\n  }\n  private EndpointsList createSingleEndpointEndpointListByPodName(  String namespace,  String... podNames){\n    Endpoints endpoints\u003dnew Endpoints();\n    endpoints.setSubsets(createSubsetsByPodName(podNames));\n    endpoints.setMetadata(new ObjectMetaBuilder().withNamespace(namespace).build());\n    EndpointsList endpointsList\u003dnew EndpointsList();\n    endpointsList.setItems(Collections.singletonList(endpoints));\n    return endpointsList;\n  }\n  private EndpointsList createSingleEndpointListWithNamespace(  String namespace,  String endpointsName,  String... podNames){\n    Endpoints endpoints\u003dnew EndpointsBuilder().withNewMetadata().withNamespace(namespace).withName(endpointsName).and().build();\n    endpoints.setSubsets(createSubsetsWithNamespace(namespace,podNames));\n    EndpointsList endpointsList\u003dnew EndpointsList();\n    endpointsList.setItems(Collections.singletonList(endpoints));\n    return endpointsList;\n  }\n  private Endpoints createEndpointsByPodName(  String namespace,  String podName){\n    Endpoints endpoints\u003dnew EndpointsBuilder().withNewMetadata().withNamespace(namespace).and().build();\n    endpoints.setSubsets(createSubsetsByPodName(podName));\n    return endpoints;\n  }\n  private List\u003cEndpointSubset\u003e createSubsetsByPodName(  String... names){\n    EndpointSubset endpointSubset\u003dnew EndpointSubset();\n    endpointSubset.setAddresses(createEndpointAddressByPodNames(names));\n    return Collections.singletonList(endpointSubset);\n  }\n  private List\u003cEndpointSubset\u003e createSubsetsWithNamespace(  String namespace,  String... names){\n    EndpointSubset endpointSubset\u003dnew EndpointSubset();\n    endpointSubset.setAddresses(createEndpointAddressWithNamespace(names,namespace));\n    return Collections.singletonList(endpointSubset);\n  }\n  private List\u003cEndpointAddress\u003e createEndpointAddressByPodNames(  String[] names){\n    return stream(names).map(name -\u003e {\n      ObjectReference podRef\u003dnew ObjectReference();\n      podRef.setName(name);\n      EndpointAddress endpointAddress\u003dnew EndpointAddress();\n      endpointAddress.setTargetRef(podRef);\n      return endpointAddress;\n    }\n).toList();\n  }\n  private List\u003cEndpointAddress\u003e createEndpointAddressWithNamespace(  String[] names,  String namespace){\n    return stream(names).map(name -\u003e {\n      ObjectReference podRef\u003dnew ObjectReference();\n      podRef.setName(name);\n      podRef.setNamespace(namespace);\n      EndpointAddress endpointAddress\u003dnew EndpointAddress();\n      endpointAddress.setTargetRef(podRef);\n      return endpointAddress;\n    }\n).toList();\n  }\n  private void createInAllNamespaceWatcher(){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    kubernetesCatalogWatch\u003dnew KubernetesCatalogWatch(CLIENT,properties,namespaceProvider);\n    kubernetesCatalogWatch.setApplicationEventPublisher(APPLICATION_EVENT_PUBLISHER);\n    kubernetesCatalogWatch.postConstruct();\n    when(CLIENT.endpoints()).thenReturn(MIXED_OPERATION);\n    when(MIXED_OPERATION.inAnyNamespace()).thenReturn(MIXED_OPERATION);\n    when(MIXED_OPERATION.withLabels(Map.of())).thenReturn(MIXED_OPERATION);\n    when(MIXED_OPERATION.withNewFilter()).thenReturn(FILTER_NESTED);\n    when(FILTER_NESTED.withLabels(Map.of())).thenReturn(FILTER_NESTED);\n    when(FILTER_NESTED.endFilter()).thenReturn(FILTER_WATCH_LIST_DELETABLE);\n  }\n  private void createInSpecificNamespaceWatcher(){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    kubernetesCatalogWatch\u003dnew KubernetesCatalogWatch(CLIENT,properties,namespaceProvider);\n    kubernetesCatalogWatch.setApplicationEventPublisher(APPLICATION_EVENT_PUBLISHER);\n    kubernetesCatalogWatch.postConstruct();\n    when(namespaceProvider.getNamespace()).thenReturn(\"catalog-watcher-namespace\");\n    when(CLIENT.endpoints()).thenReturn(MIXED_OPERATION);\n    when(MIXED_OPERATION.inNamespace(\"catalog-watcher-namespace\")).thenReturn(NON_NAMESPACE_OPERATION);\n    when(NON_NAMESPACE_OPERATION.withNewFilter()).thenReturn(FILTER_NESTED);\n    when(FILTER_NESTED.withLabels(Map.of())).thenReturn(FILTER_NESTED);\n    when(FILTER_NESTED.endFilter()).thenReturn(FILTER_WATCH_LIST_DELETABLE);\n  }\n  private void mockServicesCall(  String name,  String namespace){\n    MixedOperation\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e mixedOperation\u003dMockito.mock(MixedOperation.class);\n    NonNamespaceOperation\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e nonNamespaceOperation\u003dMockito.mock(NonNamespaceOperation.class);\n    when(CLIENT.services()).thenReturn(mixedOperation);\n    when(mixedOperation.inNamespace(namespace)).thenReturn(nonNamespaceOperation);\n    when(nonNamespaceOperation.list()).thenReturn(new ServiceListBuilder().withItems(new ServiceBuilder().withNewMetadata().withName(name).withNamespace(namespace).endMetadata().build()).build());\n  }\n}\n",
        "abstract": "/** \n * @author Oleg Vyukov\n */\n@SuppressWarnings({\"unchecked\"}) class KubernetesCatalogWatchTest {\n  private static final KubernetesClient CLIENT\u003dMockito.mock(KubernetesClient.class);\n  private final KubernetesNamespaceProvider namespaceProvider\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  private KubernetesCatalogWatch kubernetesCatalogWatch;\n  private static final ApplicationEventPublisher APPLICATION_EVENT_PUBLISHER\u003dMockito.mock(ApplicationEventPublisher.class);\n  private static final MixedOperation\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e MIXED_OPERATION\u003dMockito.mock(MixedOperation.class);\n  private static final NonNamespaceOperation\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e NON_NAMESPACE_OPERATION\u003dMockito.mock(NonNamespaceOperation.class);\n  private static final FilterWatchListDeletable\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e FILTER_WATCH_LIST_DELETABLE\u003dMockito.mock(FilterWatchListDeletable.class);\n  private static final FilterNested\u003cFilterWatchListDeletable\u003cEndpoints,EndpointsList,Resource\u003cEndpoints\u003e\u003e\u003e FILTER_NESTED\u003dMockito.mock(FilterNested.class);\n  private static final ArgumentCaptor\u003cHeartbeatEvent\u003e HEARTBEAT_EVENT_ARGUMENT_CAPTOR\u003dArgumentCaptor.forClass(HeartbeatEvent.class);\n  @AfterEach void afterEach();\n  @Test void testRandomOrderChangePods();\n  @Test void testRandomOrderChangePodsAllNamespaces();\n  @Test void testRandomOrderChangeServices();\n  @Test void testRandomOrderChangeServicesAllNamespaces();\n  @Test void testEventBody();\n  @Test void testEventBodyAllNamespaces();\n  @Test void testEndpointsWithoutSubsets();\n  @Test void testEndpointsWithoutSubsetsAllNamespaces();\n  @Test void testEndpointsWithoutAddresses();\n  @Test void testEndpointsWithoutAddressesAllNamespaces();\n  @Test void testEndpointsWithoutTargetRefs();\n  @Test void testEndpointsWithoutTargetRefsAllNamespaces();\n  private EndpointsList createEndpointsListByServiceName(  String namespace,  String... serviceNames);\n  private EndpointsList createSingleEndpointEndpointListWithoutSubsets(  String name,  String namespace);\n  private EndpointsList createSingleEndpointEndpointListByPodName(  String namespace,  String... podNames);\n  private EndpointsList createSingleEndpointListWithNamespace(  String namespace,  String endpointsName,  String... podNames);\n  private Endpoints createEndpointsByPodName(  String namespace,  String podName);\n  private List\u003cEndpointSubset\u003e createSubsetsByPodName(  String... names);\n  private List\u003cEndpointSubset\u003e createSubsetsWithNamespace(  String namespace,  String... names);\n  private List\u003cEndpointAddress\u003e createEndpointAddressByPodNames(  String[] names);\n  private List\u003cEndpointAddress\u003e createEndpointAddressWithNamespace(  String[] names,  String namespace);\n  private void createInAllNamespaceWatcher();\n  private void createInSpecificNamespaceWatcher();\n  private void mockServicesCall(  String name,  String namespace);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/discovery/Fabric8ConfigServerBootstrapperTests.java",
        "name": "Fabric8ConfigServerBootstrapperTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.discovery.Fabric8ConfigServerBootstrapperTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8ConfigServerBootstrapperTests {\n  private static WireMockServer wireMockServer;\n  private KubernetesClient mockClient;\n  private ConfigurableApplicationContext context;\n  @BeforeEach public void before() throws JsonProcessingException {\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n    Endpoints endPoint\u003dnew EndpointsBuilder().withNewMetadata().withName(\"spring-cloud-kubernetes-configserver\").withNamespace(\"test\").withLabels(new HashMap\u003c\u003e()).endMetadata().addNewSubset().addNewAddress().withHostname(\"localhost\").withIp(\"localhost\").withNewTargetRef().withUid(\"10\").endTargetRef().endAddress().addNewPort(\"http\",\"http_tcp\",wireMockServer.port(),\"TCP\").endSubset().build();\n    mockClient.endpoints().inNamespace(\"test\").create(endPoint);\n    Service service\u003dnew ServiceBuilder().withNewMetadata().withName(\"spring-cloud-kubernetes-configserver\").withNamespace(\"test\").withLabels(new HashMap\u003c\u003e()).endMetadata().withSpec(new ServiceSpecBuilder().withType(\"NodePort\").build()).build();\n    mockClient.services().inNamespace(\"test\").create(service);\n    Environment environment\u003dnew Environment(\"test\",\"default\");\n    Map\u003cString,Object\u003e properties\u003dnew HashMap\u003c\u003e();\n    properties.put(\"hello\",\"world\");\n    org.springframework.cloud.config.environment.PropertySource p\u003dnew PropertySource(\"p1\",properties);\n    environment.add(p);\n    ObjectMapper objectMapper\u003dnew ObjectMapper();\n    stubFor(get(\"/application/default\").willReturn(aResponse().withStatus(200).withBody(objectMapper.writeValueAsString(environment)).withHeader(\"content-type\",\"application/json\")));\n  }\n  @AfterEach public void after(){\n    wireMockServer.stop();\n    mockClient.close();\n    context.close();\n  }\n  @Test void testBootstrapper(){\n    this.context\u003dsetup().run();\n    verify(getRequestedFor(urlEqualTo(\"/application/default\")));\n    assertThat(this.context.getEnvironment().getProperty(\"hello\")).isEqualTo(\"world\");\n  }\n  SpringApplicationBuilder setup(  String... env){\n    SpringApplicationBuilder builder\u003dnew SpringApplicationBuilder(TestConfig.class).properties(addDefaultEnv(env));\n    builder.addBootstrapRegistryInitializer(new Fabric8ConfigServerBootstrapper());\n    return builder;\n  }\n  private String[] addDefaultEnv(  String[] env){\n    Set\u003cString\u003e set\u003dnew LinkedHashSet\u003c\u003e();\n    if (env !\u003d null \u0026\u0026 env.length \u003e 0) {\n      set.addAll(Arrays.asList(env));\n    }\n    set.add(\"spring.cloud.config.discovery.enabled\u003dtrue\");\n    set.add(\"spring.config.import\u003doptional:configserver:\");\n    set.add(\"spring.cloud.config.discovery.service-id\u003dspring-cloud-kubernetes-configserver\");\n    set.add(\"spring.cloud.kubernetes.client.namespace\u003dtest\");\n    set.add(\"server.port\u003d0\");\n    return set.toArray(new String[0]);\n  }\n@SpringBootConfiguration @EnableAutoConfiguration static class TestConfig {\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8ConfigServerBootstrapperTests {\n  private static WireMockServer wireMockServer;\n  private KubernetesClient mockClient;\n  private ConfigurableApplicationContext context;\n  @BeforeEach public void before() throws JsonProcessingException;\n  @AfterEach public void after();\n  @Test void testBootstrapper();\n  SpringApplicationBuilder setup(  String... env);\n  private String[] addDefaultEnv(  String[] env);\n@SpringBootConfiguration @EnableAutoConfiguration static class TestConfig {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/main/java/org/springframework/cloud/kubernetes/fabric8/Fabric8AutoConfiguration.java",
        "name": "Fabric8AutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @AutoConfigureAfter(KubernetesCommonsAutoConfiguration.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.Fabric8AutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Auto configuration for Kubernetes.\n * @author Ioannis Canellos\n * @author Eddú Meléndez\n * @author Tim Ysewyn\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @AutoConfigureAfter(KubernetesCommonsAutoConfiguration.class) public class Fabric8AutoConfiguration {\n  private static \u003cD\u003eD or(  D left,  D right){\n    return left !\u003d null ? left : right;\n  }\n  private static Integer orDurationInt(  Duration left,  Integer right){\n    return left !\u003d null ? (int)left.toMillis() : right;\n  }\n  private static Long orDurationLong(  Duration left,  Long right){\n    return left !\u003d null ? left.toMillis() : right;\n  }\n  @Bean @ConditionalOnMissingBean(Config.class) public Config kubernetesClientConfig(  KubernetesClientProperties kubernetesClientProperties){\n    Config base\u003dConfig.autoConfigure(null);\n    ConfigBuilder builder\u003dnew ConfigBuilder(base).withMasterUrl(or(kubernetesClientProperties.masterUrl(),base.getMasterUrl())).withApiVersion(or(kubernetesClientProperties.apiVersion(),base.getApiVersion())).withNamespace(or(kubernetesClientProperties.namespace(),base.getNamespace())).withUsername(or(kubernetesClientProperties.username(),base.getUsername())).withPassword(or(kubernetesClientProperties.password(),base.getPassword())).withOauthToken(or(kubernetesClientProperties.oauthToken(),base.getOauthToken())).withCaCertFile(or(kubernetesClientProperties.caCertFile(),base.getCaCertFile())).withCaCertData(or(kubernetesClientProperties.caCertData(),base.getCaCertData())).withClientKeyFile(or(kubernetesClientProperties.clientKeyFile(),base.getClientKeyFile())).withClientKeyData(or(kubernetesClientProperties.clientKeyData(),base.getClientKeyData())).withClientCertFile(or(kubernetesClientProperties.clientCertFile(),base.getClientCertFile())).withClientCertData(or(kubernetesClientProperties.clientCertData(),base.getClientCertData())).withClientKeyAlgo(or(kubernetesClientProperties.clientKeyAlgo(),base.getClientKeyAlgo())).withClientKeyPassphrase(or(kubernetesClientProperties.clientKeyPassphrase(),base.getClientKeyPassphrase())).withConnectionTimeout(orDurationInt(kubernetesClientProperties.connectionTimeout(),base.getConnectionTimeout())).withRequestTimeout(orDurationInt(kubernetesClientProperties.requestTimeout(),base.getRequestTimeout())).withTrustCerts(or(kubernetesClientProperties.trustCerts(),base.isTrustCerts())).withHttpProxy(or(kubernetesClientProperties.httpProxy(),base.getHttpProxy())).withHttpsProxy(or(kubernetesClientProperties.httpsProxy(),base.getHttpsProxy())).withProxyUsername(or(kubernetesClientProperties.proxyUsername(),base.getProxyUsername())).withProxyPassword(or(kubernetesClientProperties.proxyPassword(),base.getProxyPassword())).withNoProxy(or(kubernetesClientProperties.noProxy(),base.getNoProxy())).withRequestRetryBackoffLimit(0);\n    String userAgent\u003dor(base.getUserAgent(),KubernetesClientProperties.DEFAULT_USER_AGENT);\n    if (!kubernetesClientProperties.userAgent().equals(KubernetesClientProperties.DEFAULT_USER_AGENT)) {\n      userAgent\u003dkubernetesClientProperties.userAgent();\n    }\n    return builder.withUserAgent(userAgent).build();\n  }\n  @Bean @ConditionalOnMissingBean public KubernetesClient kubernetesClient(  Config config){\n    return new KubernetesClientBuilder().withConfig(config).build();\n  }\n  @Bean @ConditionalOnMissingBean public Fabric8PodUtils kubernetesPodUtils(  KubernetesClient client){\n    return new Fabric8PodUtils(client);\n  }\n}\n",
        "abstract": "/** \n * Auto configuration for Kubernetes.\n * @author Ioannis Canellos\n * @author Eddú Meléndez\n * @author Tim Ysewyn\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @AutoConfigureAfter(KubernetesCommonsAutoConfiguration.class) public class Fabric8AutoConfiguration {\n  private static \u003cD\u003eD or(  D left,  D right);\n  private static Integer orDurationInt(  Duration left,  Integer right);\n  private static Long orDurationLong(  Duration left,  Long right);\n  @Bean @ConditionalOnMissingBean(Config.class) public Config kubernetesClientConfig(  KubernetesClientProperties kubernetesClientProperties);\n  @Bean @ConditionalOnMissingBean public KubernetesClient kubernetesClient(  Config config);\n  @Bean @ConditionalOnMissingBean public Fabric8PodUtils kubernetesPodUtils(  KubernetesClient client);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/main/java/org/springframework/cloud/kubernetes/fabric8/Fabric8PodUtils.java",
        "name": "Fabric8PodUtils",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.Fabric8PodUtils",
        "extend": "",
        "implements": "PodUtils\u003cPod\u003e",
        "raw": "/** \n * Utility class to work with pods.\n * @author Ioannis Canellos\n */\npublic class Fabric8PodUtils implements PodUtils\u003cPod\u003e {\n  /** \n * HOSTNAME environment variable name.\n */\n  public static final String HOSTNAME\u003d\"HOSTNAME\";\n  /** \n * KUBERNETES_SERVICE_HOST environment variable name.\n */\n  public static final String KUBERNETES_SERVICE_HOST\u003d\"KUBERNETES_SERVICE_HOST\";\n  private static final Log LOG\u003dLogFactory.getLog(Fabric8PodUtils.class);\n  private final KubernetesClient client;\n  private final String hostName;\n  private final String serviceHost;\n  private final Supplier\u003cPod\u003e current;\n  public Fabric8PodUtils(  KubernetesClient client){\n    if (client \u003d\u003d null) {\n      throw new IllegalArgumentException(\"Must provide an instance of KubernetesClient\");\n    }\n    this.client\u003dclient;\n    this.hostName\u003dEnvReader.getEnv(HOSTNAME);\n    this.serviceHost\u003dEnvReader.getEnv(KUBERNETES_SERVICE_HOST);\n    this.current\u003dLazilyInstantiate.using(this::internalGetPod);\n  }\n  @Override public Supplier\u003cPod\u003e currentPod(){\n    return this.current;\n  }\n  @Override public boolean isInsideKubernetes(){\n    return currentPod().get() !\u003d null;\n  }\n  private Pod internalGetPod(){\n    try {\n      if (isServiceHostEnvVarPresent() \u0026\u0026 isHostNameEnvVarPresent() \u0026\u0026 isServiceAccountFound()) {\n        return this.client.pods().withName(this.hostName).get();\n      }\n    }\n catch (    Throwable t) {\n      LOG.warn(\"Failed to get pod with name:[\" + this.hostName + \"]. You should look into this if things aren\u0027t\"+ \" working as you expect. Are you missing serviceaccount permissions?\",t);\n    }\n    return null;\n  }\n  private boolean isServiceHostEnvVarPresent(){\n    return StringUtils.hasLength(serviceHost);\n  }\n  private boolean isHostNameEnvVarPresent(){\n    return StringUtils.hasLength(hostName);\n  }\n  private boolean isServiceAccountFound(){\n    boolean serviceAccountPathPresent\u003dPaths.get(Config.KUBERNETES_SERVICE_ACCOUNT_TOKEN_PATH).toFile().exists();\n    if (!serviceAccountPathPresent) {\n      LOG.warn(\"serviceaccount path not present, did you disable it via \u0027automountServiceAccountToken : false\u0027?\" + \" Major functionalities will not work without that property being set\");\n    }\n    return serviceAccountPathPresent \u0026\u0026 Paths.get(Config.KUBERNETES_SERVICE_ACCOUNT_CA_CRT_PATH).toFile().exists();\n  }\n}\n",
        "abstract": "/** \n * Utility class to work with pods.\n * @author Ioannis Canellos\n */\npublic class Fabric8PodUtils implements PodUtils\u003cPod\u003e {\n  /** \n * HOSTNAME environment variable name.\n */\n  public static final String HOSTNAME\u003d\"HOSTNAME\";\n  /** \n * KUBERNETES_SERVICE_HOST environment variable name.\n */\n  public static final String KUBERNETES_SERVICE_HOST\u003d\"KUBERNETES_SERVICE_HOST\";\n  private static final Log LOG\u003dLogFactory.getLog(Fabric8PodUtils.class);\n  private final KubernetesClient client;\n  private final String hostName;\n  private final String serviceHost;\n  private final Supplier\u003cPod\u003e current;\n  public Fabric8PodUtils(  KubernetesClient client);\n  @Override public Supplier\u003cPod\u003e currentPod();\n  @Override public boolean isInsideKubernetes();\n  private Pod internalGetPod();\n  private boolean isServiceHostEnvVarPresent();\n  private boolean isHostNameEnvVarPresent();\n  private boolean isServiceAccountFound();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/main/java/org/springframework/cloud/kubernetes/fabric8/Fabric8ActuatorConfiguration.java",
        "name": "Fabric8ActuatorConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesHealthIndicatorEnabled public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.Fabric8ActuatorConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesHealthIndicatorEnabled public class Fabric8ActuatorConfiguration {\n  @Bean @ConditionalOnEnabledHealthIndicator(\"kubernetes\") public Fabric8HealthIndicator kubernetesHealthIndicator(  PodUtils\u003cPod\u003e podUtils){\n    return new Fabric8HealthIndicator(podUtils);\n  }\n  @Bean @ConditionalOnEnabledInfoContributor(\"kubernetes\") public Fabric8InfoContributor kubernetesInfoContributor(  PodUtils\u003cPod\u003e podUtils){\n    return new Fabric8InfoContributor(podUtils);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesHealthIndicatorEnabled public class Fabric8ActuatorConfiguration {\n  @Bean @ConditionalOnEnabledHealthIndicator(\"kubernetes\") public Fabric8HealthIndicator kubernetesHealthIndicator(  PodUtils\u003cPod\u003e podUtils);\n  @Bean @ConditionalOnEnabledInfoContributor(\"kubernetes\") public Fabric8InfoContributor kubernetesInfoContributor(  PodUtils\u003cPod\u003e podUtils);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/main/java/org/springframework/cloud/kubernetes/fabric8/Fabric8Utils.java",
        "name": "Fabric8Utils",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.Fabric8Utils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Utility class related to Fabric8 Client. It resides in this module because it is supposed to be re-used in fabric8 specific ones (like config or discovery)\n * @author wind57\n */\npublic final class Fabric8Utils {\n  private Fabric8Utils(){\n  }\n  public static ServiceMetadata serviceMetadata(  Service service){\n    ObjectMeta metadata\u003dservice.getMetadata();\n    ServiceSpec serviceSpec\u003dservice.getSpec();\n    return new ServiceMetadata(metadata.getName(),metadata.getNamespace(),serviceSpec.getType(),metadata.getLabels(),metadata.getAnnotations());\n  }\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8Utils.class));\n  /** \n * this method does the namespace resolution. Namespace is being searched according to the order below. \u003cpre\u003e 1. from incoming namespace, which can be null. 2. from a property \u0027spring.cloud.kubernetes.client.namespace\u0027, if such is present. 3. from a String residing in a file denoted by `spring.cloud.kubernetes.client.serviceAccountNamespacePath` property, if such is present. 4. from a String residing in `/var/run/secrets/kubernetes.io/serviceaccount/namespace` file, if such is present (kubernetes default path) 5. from KubernetesClient::getNamespace, which is implementation specific. \u003c/pre\u003e If any of the above fail, we throw a  {@link NamespaceResolutionFailedException}.\n * @param namespace normalized namespace\n * @param configurationTarget Config Map/Secret\n * @param provider the provider which computes the namespace\n * @param client fabric8 Kubernetes client\n * @return application namespace\n * @throws NamespaceResolutionFailedException when namespace could not be resolved\n */\n  public static String getApplicationNamespace(  KubernetesClient client,  @Nullable String namespace,  String configurationTarget,  KubernetesNamespaceProvider provider){\n    if (StringUtils.hasText(namespace)) {\n      LOG.debug(configurationTarget + \" namespace : \" + namespace);\n      return namespace;\n    }\n    if (provider !\u003d null) {\n      String providerNamespace\u003dprovider.getNamespace();\n      if (StringUtils.hasText(providerNamespace)) {\n        LOG.debug(() -\u003e configurationTarget + \" namespace from provider : \" + providerNamespace);\n        return providerNamespace;\n      }\n    }\n    String clientNamespace\u003dclient.getNamespace();\n    LOG.debug(() -\u003e configurationTarget + \" namespace from client : \" + clientNamespace);\n    if (clientNamespace \u003d\u003d null) {\n      throw new NamespaceResolutionFailedException(\"unresolved namespace\");\n    }\n    return clientNamespace;\n  }\n}\n",
        "abstract": "/** \n * Utility class related to Fabric8 Client. It resides in this module because it is supposed to be re-used in fabric8 specific ones (like config or discovery)\n * @author wind57\n */\npublic final class Fabric8Utils {\n  private Fabric8Utils();\n  public static ServiceMetadata serviceMetadata(  Service service);\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8Utils.class));\n  /** \n * this method does the namespace resolution. Namespace is being searched according to the order below. \u003cpre\u003e 1. from incoming namespace, which can be null. 2. from a property \u0027spring.cloud.kubernetes.client.namespace\u0027, if such is present. 3. from a String residing in a file denoted by `spring.cloud.kubernetes.client.serviceAccountNamespacePath` property, if such is present. 4. from a String residing in `/var/run/secrets/kubernetes.io/serviceaccount/namespace` file, if such is present (kubernetes default path) 5. from KubernetesClient::getNamespace, which is implementation specific. \u003c/pre\u003e If any of the above fail, we throw a  {@link NamespaceResolutionFailedException}.\n * @param namespace normalized namespace\n * @param configurationTarget Config Map/Secret\n * @param provider the provider which computes the namespace\n * @param client fabric8 Kubernetes client\n * @return application namespace\n * @throws NamespaceResolutionFailedException when namespace could not be resolved\n */\n  public static String getApplicationNamespace(  KubernetesClient client,  @Nullable String namespace,  String configurationTarget,  KubernetesNamespaceProvider provider);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/main/java/org/springframework/cloud/kubernetes/fabric8/Fabric8InfoContributor.java",
        "name": "Fabric8InfoContributor",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.Fabric8InfoContributor",
        "extend": "AbstractKubernetesInfoContributor",
        "implements": "",
        "raw": "/** \n * Kubernetes implementation of  {@link InfoContributor}.\n * @author Mark Anderson\n */\npublic class Fabric8InfoContributor extends AbstractKubernetesInfoContributor {\n  private final PodUtils\u003cPod\u003e utils;\n  public Fabric8InfoContributor(  PodUtils\u003cPod\u003e utils){\n    this.utils\u003dutils;\n  }\n  @Override public Map\u003cString,Object\u003e getDetails(){\n    Pod current\u003dthis.utils.currentPod().get();\n    if (current !\u003d null) {\n      Map\u003cString,Object\u003e details\u003dCollectionUtils.newHashMap(7);\n      details.put(INSIDE,true);\n      ObjectMeta metadata\u003dcurrent.getMetadata();\n      details.put(NAMESPACE,metadata.getNamespace());\n      details.put(POD_NAME,metadata.getName());\n      PodStatus status\u003dcurrent.getStatus();\n      details.put(POD_IP,status.getPodIP());\n      details.put(HOST_IP,status.getHostIP());\n      PodSpec spec\u003dcurrent.getSpec();\n      details.put(SERVICE_ACCOUNT,spec.getServiceAccountName());\n      details.put(NODE_NAME,spec.getNodeName());\n      return details;\n    }\n    return Collections.singletonMap(INSIDE,false);\n  }\n}\n",
        "abstract": "/** \n * Kubernetes implementation of  {@link InfoContributor}.\n * @author Mark Anderson\n */\npublic class Fabric8InfoContributor extends AbstractKubernetesInfoContributor {\n  private final PodUtils\u003cPod\u003e utils;\n  public Fabric8InfoContributor(  PodUtils\u003cPod\u003e utils);\n  @Override public Map\u003cString,Object\u003e getDetails();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/main/java/org/springframework/cloud/kubernetes/fabric8/profile/Fabric8ProfileEnvironmentPostProcessor.java",
        "name": "Fabric8ProfileEnvironmentPostProcessor",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.profile.Fabric8ProfileEnvironmentPostProcessor",
        "extend": "AbstractKubernetesProfileEnvironmentPostProcessor",
        "implements": "",
        "raw": "public class Fabric8ProfileEnvironmentPostProcessor extends AbstractKubernetesProfileEnvironmentPostProcessor {\n  @Override protected boolean isInsideKubernetes(  Environment environment){\n    try (KubernetesClient client\u003dnew KubernetesClientBuilder().build()){\n      Fabric8PodUtils podUtils\u003dnew Fabric8PodUtils(client);\n      return environment.containsProperty(Fabric8PodUtils.KUBERNETES_SERVICE_HOST) || podUtils.isInsideKubernetes();\n    }\n   }\n}\n",
        "abstract": "public class Fabric8ProfileEnvironmentPostProcessor extends AbstractKubernetesProfileEnvironmentPostProcessor {\n  @Override protected boolean isInsideKubernetes(  Environment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/main/java/org/springframework/cloud/kubernetes/fabric8/Fabric8HealthIndicator.java",
        "name": "Fabric8HealthIndicator",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.Fabric8HealthIndicator",
        "extend": "AbstractKubernetesHealthIndicator",
        "implements": "",
        "raw": "/** \n * Kubernetes implementation of  {@link AbstractHealthIndicator}.\n * @author Ioannis Canellos\n * @author Eddú Meléndez\n */\npublic class Fabric8HealthIndicator extends AbstractKubernetesHealthIndicator {\n  private final PodUtils\u003cPod\u003e utils;\n  public Fabric8HealthIndicator(  PodUtils\u003cPod\u003e utils){\n    this.utils\u003dutils;\n  }\n  @Override protected Map\u003cString,Object\u003e getDetails(){\n    Pod current\u003dthis.utils.currentPod().get();\n    if (current !\u003d null) {\n      Map\u003cString,Object\u003e details\u003dCollectionUtils.newHashMap(8);\n      details.put(INSIDE,true);\n      ObjectMeta metadata\u003dcurrent.getMetadata();\n      details.put(NAMESPACE,metadata.getNamespace());\n      details.put(POD_NAME,metadata.getName());\n      details.put(LABELS,metadata.getLabels());\n      PodStatus status\u003dcurrent.getStatus();\n      details.put(POD_IP,status.getPodIP());\n      details.put(HOST_IP,status.getHostIP());\n      PodSpec spec\u003dcurrent.getSpec();\n      details.put(SERVICE_ACCOUNT,spec.getServiceAccountName());\n      details.put(NODE_NAME,spec.getNodeName());\n      return details;\n    }\n    return Collections.singletonMap(INSIDE,false);\n  }\n}\n",
        "abstract": "/** \n * Kubernetes implementation of  {@link AbstractHealthIndicator}.\n * @author Ioannis Canellos\n * @author Eddú Meléndez\n */\npublic class Fabric8HealthIndicator extends AbstractKubernetesHealthIndicator {\n  private final PodUtils\u003cPod\u003e utils;\n  public Fabric8HealthIndicator(  PodUtils\u003cPod\u003e utils);\n  @Override protected Map\u003cString,Object\u003e getDetails();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/Fabric8InsideHealthIndicatorTest.java",
        "name": "Fabric8InsideHealthIndicatorTest",
        "modifiers": "@Import(Fabric8InsideHealthIndicatorTest.KubernetesActuatorTestConfiguration.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.endpoint.health.show-details\u003dalways\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.Fabric8InsideHealthIndicatorTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57test to see if proper fields are set in health when it is running inside the container\n */\n@Import(Fabric8InsideHealthIndicatorTest.KubernetesActuatorTestConfiguration.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.endpoint.health.show-details\u003dalways\"}) class Fabric8InsideHealthIndicatorTest {\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  /** \n * \u003cpre\u003e \"stubKubernetes\": { \"status\": \"UP\", \"details\": { \"nodeName\": \"nodeName\", \"podIp\": \"10.1.1.1\", \"hostIp\": \"192.168.10.3\", \"namespace\": \"namespace\", \"podName\": \"pod\", \"serviceAccount\": \"serviceAccountName\", \"inside\": true, \"labels\": { \"labelName\": \"labelValue\" } } \u003c/pre\u003e\n */\n  @Test void test(){\n    this.webClient.get().uri(\"http://localhost:{port}/actuator/health\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"components.stubKubernetes.status\").isEqualTo(\"UP\").jsonPath(\"components.stubKubernetes.details.nodeName\").isEqualTo(\"nodeName\").jsonPath(\"components.stubKubernetes.details.podIp\").isEqualTo(\"10.1.1.1\").jsonPath(\"components.stubKubernetes.details.hostIp\").isEqualTo(\"192.160.10.3\").jsonPath(\"components.stubKubernetes.details.namespace\").isEqualTo(\"namespace\").jsonPath(\"components.stubKubernetes.details.podName\").isEqualTo(\"pod\").jsonPath(\"components.stubKubernetes.details.serviceAccount\").isEqualTo(\"serviceAccountName\").jsonPath(\"components.stubKubernetes.details.inside\").isEqualTo(\"true\").jsonPath(\"components.stubKubernetes.details.labels.labelName\").isEqualTo(\"labelValue\");\n  }\n  private static Pod stubPod(){\n    PodStatus status\u003dnew PodStatus();\n    status.setPodIP(\"10.1.1.1\");\n    status.setHostIP(\"192.160.10.3\");\n    PodSpec spec\u003dnew PodSpec();\n    spec.setServiceAccountName(\"serviceAccountName\");\n    spec.setNodeName(\"nodeName\");\n    return new PodBuilder().withNewMetadata().withName(\"pod\").withNamespace(\"namespace\").withLabels(Collections.singletonMap(\"labelName\",\"labelValue\")).endMetadata().withStatus(status).withSpec(spec).build();\n  }\n@Configuration static class KubernetesActuatorTestConfiguration {\n    @Primary @Bean public Fabric8HealthIndicator stubKubernetesHealthIndicator(){\n      @SuppressWarnings(\"unchecked\") PodUtils\u003cPod\u003e utils\u003dMockito.mock(PodUtils.class);\n      Mockito.when(utils.currentPod()).thenReturn(Fabric8InsideHealthIndicatorTest::stubPod);\n      return new Fabric8HealthIndicator(utils);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57test to see if proper fields are set in health when it is running inside the container\n */\n@Import(Fabric8InsideHealthIndicatorTest.KubernetesActuatorTestConfiguration.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.endpoint.health.show-details\u003dalways\"}) class Fabric8InsideHealthIndicatorTest {\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  /** \n * \u003cpre\u003e \"stubKubernetes\": { \"status\": \"UP\", \"details\": { \"nodeName\": \"nodeName\", \"podIp\": \"10.1.1.1\", \"hostIp\": \"192.168.10.3\", \"namespace\": \"namespace\", \"podName\": \"pod\", \"serviceAccount\": \"serviceAccountName\", \"inside\": true, \"labels\": { \"labelName\": \"labelValue\" } } \u003c/pre\u003e\n */\n  @Test void test();\n  private static Pod stubPod();\n@Configuration static class KubernetesActuatorTestConfiguration {\n    @Primary @Bean public Fabric8HealthIndicator stubKubernetesHealthIndicator();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/Fabric8HealthIndicatorDisabledTest.java",
        "name": "Fabric8HealthIndicatorDisabledTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.Fabric8HealthIndicatorDisabledTest",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8HealthIndicatorDisabledTest {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  @BeforeAll static void setUpBeforeClass(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n  }\n  @Test void healthEndpointShouldContainKubernetes(){\n    this.webClient.get().uri(\"http://localhost:{port}/actuator/health\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"components.kubernetes\").doesNotExist();\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dfalse\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8HealthIndicatorDisabledTest {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  @BeforeAll static void setUpBeforeClass();\n  @Test void healthEndpointShouldContainKubernetes();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/Fabric8NotInsideHealthIndicatorTest.java",
        "name": "Fabric8NotInsideHealthIndicatorTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoint.health.show-details\u003dalways\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.Fabric8NotInsideHealthIndicatorTest",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoint.health.show-details\u003dalways\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8NotInsideHealthIndicatorTest {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  @BeforeAll static void setUpBeforeClass(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterAll static void afterClass(){\n    System.clearProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY);\n    System.clearProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY);\n    System.clearProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY);\n    System.clearProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY);\n    System.clearProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY);\n    System.clearProperty(Config.KUBERNETES_HTTP2_DISABLE);\n  }\n  /** \n * \u003cpre\u003e \"kubernetes\":{ \"status\":\"UP\", \"details\":{ \"inside\":\"false\" } } \u003c/pre\u003e\n */\n  @Test void healthEndpointShouldContainKubernetes(){\n    this.webClient.get().uri(\"http://localhost:{port}/actuator/health\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"components.kubernetes.status\").isEqualTo(\"UP\").jsonPath(\"components.kubernetes.details.inside\").isEqualTo(\"false\");\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoint.health.show-details\u003dalways\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8NotInsideHealthIndicatorTest {\n  private static KubernetesClient mockClient;\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  @BeforeAll static void setUpBeforeClass();\n  @AfterAll static void afterClass();\n  /** \n * \u003cpre\u003e \"kubernetes\":{ \"status\":\"UP\", \"details\":{ \"inside\":\"false\" } } \u003c/pre\u003e\n */\n  @Test void healthEndpointShouldContainKubernetes();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/Fabric8InsideInfoContributorTest.java",
        "name": "Fabric8InsideInfoContributorTest",
        "modifiers": "@Import(Fabric8InsideInfoContributorTest.InfoContributorTestConfig.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003dinfo\",\"management.endpoint.info.show-details\u003dalways\",\"management.info.kubernetes.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.Fabric8InsideInfoContributorTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57test proper fields being set in /actuator/info\n */\n@Import(Fabric8InsideInfoContributorTest.InfoContributorTestConfig.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003dinfo\",\"management.endpoint.info.show-details\u003dalways\",\"management.info.kubernetes.enabled\u003dtrue\"}) class Fabric8InsideInfoContributorTest {\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  /** \n * \u003cpre\u003e \"kubernetes\": { \"nodeName\": \"nodeName\", \"podIp\": \"10.1.1.1\", \"hostIp\": \"192.160.10.3\", \"namespace\": \"namespace\", \"podName\": \"pod\", \"serviceAccount\": \"serviceAccountName\", \"inside\": true } \u003c/pre\u003e\n */\n  @Test void test(){\n    this.webClient.get().uri(\"http://localhost:{port}/actuator/info\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"kubernetes.nodeName\").isEqualTo(\"nodeName\").jsonPath(\"kubernetes.podIp\").isEqualTo(\"10.1.1.1\").jsonPath(\"kubernetes.hostIp\").isEqualTo(\"192.160.10.3\").jsonPath(\"kubernetes.namespace\").isEqualTo(\"namespace\").jsonPath(\"kubernetes.podName\").isEqualTo(\"pod\").jsonPath(\"kubernetes.serviceAccount\").isEqualTo(\"serviceAccountName\").jsonPath(\"kubernetes.inside\").isEqualTo(\"true\");\n  }\n  private static Pod stubPod(){\n    PodStatus status\u003dnew PodStatus();\n    status.setPodIP(\"10.1.1.1\");\n    status.setHostIP(\"192.160.10.3\");\n    PodSpec spec\u003dnew PodSpec();\n    spec.setServiceAccountName(\"serviceAccountName\");\n    spec.setNodeName(\"nodeName\");\n    return new PodBuilder().withNewMetadata().withName(\"pod\").withNamespace(\"namespace\").endMetadata().withStatus(status).withSpec(spec).build();\n  }\n@Configuration static class InfoContributorTestConfig {\n    @Bean public Fabric8PodUtils fabric8PodUtils(){\n      Fabric8PodUtils utils\u003dMockito.mock(Fabric8PodUtils.class);\n      Mockito.when(utils.currentPod()).thenReturn(Fabric8InsideInfoContributorTest::stubPod);\n      return utils;\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57test proper fields being set in /actuator/info\n */\n@Import(Fabric8InsideInfoContributorTest.InfoContributorTestConfig.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003dinfo\",\"management.endpoint.info.show-details\u003dalways\",\"management.info.kubernetes.enabled\u003dtrue\"}) class Fabric8InsideInfoContributorTest {\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  /** \n * \u003cpre\u003e \"kubernetes\": { \"nodeName\": \"nodeName\", \"podIp\": \"10.1.1.1\", \"hostIp\": \"192.160.10.3\", \"namespace\": \"namespace\", \"podName\": \"pod\", \"serviceAccount\": \"serviceAccountName\", \"inside\": true } \u003c/pre\u003e\n */\n  @Test void test();\n  private static Pod stubPod();\n@Configuration static class InfoContributorTestConfig {\n    @Bean public Fabric8PodUtils fabric8PodUtils();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/Fabric8NotInsideInfoContributorTest.java",
        "name": "Fabric8NotInsideInfoContributorTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003dinfo\",\"management.endpoint.info.show-details\u003dalways\",\"management.info.kubernetes.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.Fabric8NotInsideInfoContributorTest",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003dinfo\",\"management.endpoint.info.show-details\u003dalways\",\"management.info.kubernetes.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8NotInsideInfoContributorTest {\n  private static KubernetesClient client;\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  /** \n * \u003cpre\u003e \"kubernetes\":{ \"inside\":false } \u003c/pre\u003e\n */\n  @Test void infoEndpointShouldContainKubernetes(){\n    this.webClient.get().uri(\"http://localhost:{port}/actuator/info\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"kubernetes.inside\").isEqualTo(\"false\");\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003dinfo\",\"management.endpoint.info.show-details\u003dalways\",\"management.info.kubernetes.enabled\u003dtrue\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8NotInsideInfoContributorTest {\n  private static KubernetesClient client;\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  /** \n * \u003cpre\u003e \"kubernetes\":{ \"inside\":false } \u003c/pre\u003e\n */\n  @Test void infoEndpointShouldContainKubernetes();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/Fabric8PodUtilsTest.java",
        "name": "Fabric8PodUtilsTest",
        "modifiers": "@SuppressWarnings(\"unchecked\")",
        "qualified_name": "org.springframework.cloud.kubernetes.Fabric8PodUtilsTest",
        "extend": "",
        "implements": "",
        "raw": "@SuppressWarnings(\"unchecked\") class Fabric8PodUtilsTest {\n  private static final String KUBERNETES_SERVICE_HOST\u003dFabric8PodUtils.KUBERNETES_SERVICE_HOST;\n  private static final String HOSTNAME\u003dFabric8PodUtils.HOSTNAME;\n  private static final String SERVICE_ACCOUNT_TOKEN_PATH\u003dConfig.KUBERNETES_SERVICE_ACCOUNT_TOKEN_PATH;\n  private static final String SERVICE_ACCOUNT_CERT_PATH\u003dConfig.KUBERNETES_SERVICE_ACCOUNT_CA_CRT_PATH;\n  private static final String POD_HOSTNAME\u003d\"pod-hostname\";\n  private static final String HOST\u003d\"10.1.1.1\";\n  private final KubernetesClient client\u003dMockito.mock(KubernetesClient.class);\n  private final Path tokenPath\u003dMockito.mock(Path.class);\n  private final File tokenFile\u003dMockito.mock(File.class);\n  private final Path certPath\u003dMockito.mock(Path.class);\n  private final File certFile\u003dMockito.mock(File.class);\n  private final MixedOperation\u003cPod,PodList,PodResource\u003e mixed\u003dMockito.mock(MixedOperation.class);\n  private final Pod pod\u003dMockito.mock(Pod.class);\n  private final PodResource podResource\u003dMockito.mock(PodResource.class);\n  private MockedStatic\u003cEnvReader\u003e envReader;\n  private MockedStatic\u003cPaths\u003e paths;\n  @BeforeEach void before(){\n    envReader\u003dMockito.mockStatic(EnvReader.class);\n    paths\u003dMockito.mockStatic(Paths.class);\n  }\n  @AfterEach void after(){\n    envReader.close();\n    paths.close();\n  }\n  @Test void constructorThrowsIllegalArgumentExceptionWhenKubeClientNull(){\n    Assertions.assertThrows(IllegalArgumentException.class,() -\u003e new Fabric8PodUtils(null));\n  }\n  @Test void serviceHostNotPresent(){\n    mockHost(null);\n    Fabric8PodUtils util\u003dnew Fabric8PodUtils(client);\n    Supplier\u003cPod\u003e sup\u003dutil.currentPod();\n    Assertions.assertNull(sup.get());\n    Assertions.assertFalse(util.isInsideKubernetes());\n  }\n  @Test void hostnameNotPresent(){\n    mockHost(HOST);\n    mockHostname(null);\n    Fabric8PodUtils util\u003dnew Fabric8PodUtils(client);\n    Supplier\u003cPod\u003e sup\u003dutil.currentPod();\n    Assertions.assertNull(sup.get());\n    Assertions.assertFalse(util.isInsideKubernetes());\n  }\n  @Test void serviceAccountPathNotPresent(){\n    mockTokenPath(false);\n    mockHostname(HOST);\n    mockHostname(POD_HOSTNAME);\n    Fabric8PodUtils util\u003dnew Fabric8PodUtils(client);\n    Supplier\u003cPod\u003e sup\u003dutil.currentPod();\n    Assertions.assertNull(sup.get());\n    Assertions.assertFalse(util.isInsideKubernetes());\n  }\n  @Test void serviceAccountCertPathNotPresent(){\n    mockTokenPath(true);\n    mockCertPath(false);\n    mockHostname(HOST);\n    mockHostname(POD_HOSTNAME);\n    Fabric8PodUtils util\u003dnew Fabric8PodUtils(client);\n    Supplier\u003cPod\u003e sup\u003dutil.currentPod();\n    Assertions.assertNull(sup.get());\n    Assertions.assertFalse(util.isInsideKubernetes());\n  }\n  @Test void allPresent(){\n    mockTokenPath(true);\n    mockCertPath(true);\n    mockHost(HOST);\n    mockHostname(POD_HOSTNAME);\n    mockPodResult();\n    Fabric8PodUtils util\u003dnew Fabric8PodUtils(client);\n    Supplier\u003cPod\u003e sup\u003dutil.currentPod();\n    Assertions.assertNotNull(sup.get());\n    Assertions.assertTrue(util.isInsideKubernetes());\n  }\n  private void mockHost(  String host){\n    envReader.when(() -\u003e EnvReader.getEnv(KUBERNETES_SERVICE_HOST)).thenReturn(host);\n  }\n  private void mockHostname(  String name){\n    envReader.when(() -\u003e EnvReader.getEnv(HOSTNAME)).thenReturn(name);\n  }\n  private void mockTokenPath(  boolean result){\n    Mockito.when(tokenPath.toFile()).thenReturn(tokenFile);\n    Mockito.when(tokenFile.exists()).thenReturn(result);\n    paths.when(() -\u003e Paths.get(SERVICE_ACCOUNT_TOKEN_PATH)).thenReturn(tokenPath);\n  }\n  private void mockCertPath(  boolean result){\n    Mockito.when(certPath.toFile()).thenReturn(certFile);\n    Mockito.when(certFile.exists()).thenReturn(result);\n    paths.when(() -\u003e Paths.get(SERVICE_ACCOUNT_CERT_PATH)).thenReturn(certPath);\n  }\n  private void mockPodResult(){\n    Mockito.when(client.pods()).thenReturn(mixed);\n    Mockito.when(mixed.withName(POD_HOSTNAME)).thenReturn(podResource);\n    Mockito.when(podResource.get()).thenReturn(pod);\n  }\n}\n",
        "abstract": "@SuppressWarnings(\"unchecked\") class Fabric8PodUtilsTest {\n  private static final String KUBERNETES_SERVICE_HOST\u003dFabric8PodUtils.KUBERNETES_SERVICE_HOST;\n  private static final String HOSTNAME\u003dFabric8PodUtils.HOSTNAME;\n  private static final String SERVICE_ACCOUNT_TOKEN_PATH\u003dConfig.KUBERNETES_SERVICE_ACCOUNT_TOKEN_PATH;\n  private static final String SERVICE_ACCOUNT_CERT_PATH\u003dConfig.KUBERNETES_SERVICE_ACCOUNT_CA_CRT_PATH;\n  private static final String POD_HOSTNAME\u003d\"pod-hostname\";\n  private static final String HOST\u003d\"10.1.1.1\";\n  private final KubernetesClient client\u003dMockito.mock(KubernetesClient.class);\n  private final Path tokenPath\u003dMockito.mock(Path.class);\n  private final File tokenFile\u003dMockito.mock(File.class);\n  private final Path certPath\u003dMockito.mock(Path.class);\n  private final File certFile\u003dMockito.mock(File.class);\n  private final MixedOperation\u003cPod,PodList,PodResource\u003e mixed\u003dMockito.mock(MixedOperation.class);\n  private final Pod pod\u003dMockito.mock(Pod.class);\n  private final PodResource podResource\u003dMockito.mock(PodResource.class);\n  private MockedStatic\u003cEnvReader\u003e envReader;\n  private MockedStatic\u003cPaths\u003e paths;\n  @BeforeEach void before();\n  @AfterEach void after();\n  @Test void constructorThrowsIllegalArgumentExceptionWhenKubeClientNull();\n  @Test void serviceHostNotPresent();\n  @Test void hostnameNotPresent();\n  @Test void serviceAccountPathNotPresent();\n  @Test void serviceAccountCertPathNotPresent();\n  @Test void allPresent();\n  private void mockHost(  String host);\n  private void mockHostname(  String name);\n  private void mockTokenPath(  boolean result);\n  private void mockCertPath(  boolean result);\n  private void mockPodResult();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/example/App.java",
        "name": "App",
        "modifiers": "@SpringBootApplication public",
        "qualified_name": "org.springframework.cloud.kubernetes.example.App",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication public class App {\n}\n",
        "abstract": "@SpringBootApplication public class App {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/Fabric8AutoConfigurationTests.java",
        "name": "Fabric8AutoConfigurationTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.password\u003dmypassword\",\"spring.cloud.kubernetes.client.proxy-password\u003dmyproxypassword\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.Fabric8AutoConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.password\u003dmypassword\",\"spring.cloud.kubernetes.client.proxy-password\u003dmyproxypassword\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8AutoConfigurationTests {\n  private static KubernetesClient mockClient;\n  @Autowired ConfigurableApplicationContext context;\n  @BeforeAll static void setUpBeforeClass(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterAll static void afterClass(){\n    System.clearProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY);\n    System.clearProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY);\n    System.clearProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY);\n    System.clearProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY);\n    System.clearProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY);\n    System.clearProperty(Config.KUBERNETES_HTTP2_DISABLE);\n  }\n  @Test void beansAreCreated(){\n    assertThat(context.getBeanNamesForType(Config.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(KubernetesClient.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(Fabric8PodUtils.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(Fabric8HealthIndicator.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(Fabric8InfoContributor.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(KubernetesClientProperties.class)).hasSize(1);\n    Config config\u003dcontext.getBean(Config.class);\n    assertThat(config.getPassword()).isEqualTo(\"mypassword\");\n    assertThat(config.getProxyPassword()).isEqualTo(\"myproxypassword\");\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.password\u003dmypassword\",\"spring.cloud.kubernetes.client.proxy-password\u003dmyproxypassword\"}) @EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8AutoConfigurationTests {\n  private static KubernetesClient mockClient;\n  @Autowired ConfigurableApplicationContext context;\n  @BeforeAll static void setUpBeforeClass();\n  @AfterAll static void afterClass();\n  @Test void beansAreCreated();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/fabric8/Fabric8UtilsTests.java",
        "name": "Fabric8UtilsTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.Fabric8UtilsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8UtilsTests {\n  private KubernetesClient client;\n  private final KubernetesNamespaceProvider provider\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  @Test void testGetApplicationNamespaceNotPresent(){\n    String result\u003dFabric8Utils.getApplicationNamespace(client,\"\",\"target\",null);\n    assertThat(result).isEqualTo(\"test\");\n  }\n  @Test void testGetApplicationNamespacePresent(){\n    String result\u003dFabric8Utils.getApplicationNamespace(client,\"namespace\",\"target\",null);\n    assertThat(result).isEqualTo(\"namespace\");\n  }\n  @Test void testNamespaceFromNormalizedSource(){\n    String result\u003dFabric8Utils.getApplicationNamespace(client,\"abc\",\"target\",null);\n    assertThat(result).isEqualTo(\"abc\");\n  }\n  @Test void testNamespaceFromProvider(){\n    Mockito.when(provider.getNamespace()).thenReturn(\"def\");\n    String result\u003dFabric8Utils.getApplicationNamespace(client,\"\",\"target\",provider);\n    assertThat(result).isEqualTo(\"def\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) class Fabric8UtilsTests {\n  private KubernetesClient client;\n  private final KubernetesNamespaceProvider provider\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  @Test void testGetApplicationNamespaceNotPresent();\n  @Test void testGetApplicationNamespacePresent();\n  @Test void testNamespaceFromNormalizedSource();\n  @Test void testNamespaceFromProvider();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/fabric8/Fabric8UserAgentPropertiesConfigurationTests.java",
        "name": "Fabric8UserAgentPropertiesConfigurationTests",
        "modifiers": "@SpringBootTest(classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.client.userAgent\u003dnon-default\",\"spring.main.cloud-platform\u003dKUBERNETES\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.Fabric8UserAgentPropertiesConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.client.userAgent\u003dnon-default\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class Fabric8UserAgentPropertiesConfigurationTests {\n  @Autowired private KubernetesClient client;\n  @Test void testUserAgent(){\n    String userAgent\u003dclient.getConfiguration().getUserAgent();\n    assertThat(userAgent).isEqualTo(\"non-default\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.client.userAgent\u003dnon-default\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class Fabric8UserAgentPropertiesConfigurationTests {\n  @Autowired private KubernetesClient client;\n  @Test void testUserAgent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/fabric8/Fabric8UserAgentDefaultConfigurationTests.java",
        "name": "Fabric8UserAgentDefaultConfigurationTests",
        "modifiers": "@SpringBootTest(classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\")",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.Fabric8UserAgentDefaultConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\") class Fabric8UserAgentDefaultConfigurationTests {\n  @Autowired private KubernetesClient client;\n  @Test void testUserAgent(){\n    String userAgent\u003dclient.getConfiguration().getUserAgent();\n    assertThat(userAgent).isEqualTo(\"fabric8-kubernetes-client/6.9.2\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\") class Fabric8UserAgentDefaultConfigurationTests {\n  @Autowired private KubernetesClient client;\n  @Test void testUserAgent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/fabric8/Fabric8UtilsMockTests.java",
        "name": "Fabric8UtilsMockTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.Fabric8UtilsMockTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass Fabric8UtilsMockTests {\n  private final KubernetesClient mockClient\u003dMockito.mock(KubernetesClient.class);\n  @Test void testNamespaceFromClient(){\n    Mockito.when(mockClient.getNamespace()).thenReturn(\"qwe\");\n    String result\u003dFabric8Utils.getApplicationNamespace(mockClient,\"\",\"target\",null);\n    assertThat(result).isEqualTo(\"qwe\");\n  }\n  @Test void testNamespaceResolutionFailed(){\n    assertThatThrownBy(() -\u003e Fabric8Utils.getApplicationNamespace(mockClient,\"\",\"target\",null)).isInstanceOf(NamespaceResolutionFailedException.class);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass Fabric8UtilsMockTests {\n  private final KubernetesClient mockClient\u003dMockito.mock(KubernetesClient.class);\n  @Test void testNamespaceFromClient();\n  @Test void testNamespaceResolutionFailed();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/fabric8/Fabric8ClientUserAgentEnvPropertyTests.java",
        "name": "Fabric8ClientUserAgentEnvPropertyTests",
        "modifiers": "@SpringBootTest(classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\") @DirtiesContext",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.Fabric8ClientUserAgentEnvPropertyTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57test \"User-Agent\" functionality via system properties\n */\n@SpringBootTest(classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\") @DirtiesContext class Fabric8ClientUserAgentEnvPropertyTests {\n  @Autowired private KubernetesClient client;\n  @BeforeAll static void beforeAll(){\n    System.setProperty(Config.KUBERNETES_USER_AGENT,\"spring-k8s\");\n  }\n  @AfterAll static void afterAll(){\n    System.clearProperty(Config.KUBERNETES_USER_AGENT);\n  }\n  @Test void testUserAgent(){\n    String userAgent\u003dclient.getConfiguration().getUserAgent();\n    assertThat(userAgent).isEqualTo(\"spring-k8s\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57test \"User-Agent\" functionality via system properties\n */\n@SpringBootTest(classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\") @DirtiesContext class Fabric8ClientUserAgentEnvPropertyTests {\n  @Autowired private KubernetesClient client;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void afterAll();\n  @Test void testUserAgent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-autoconfig/src/test/java/org/springframework/cloud/kubernetes/fabric8/profile/Fabric8ProfileEnvironmentPostProcessorTests.java",
        "name": "Fabric8ProfileEnvironmentPostProcessorTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.profile.Fabric8ProfileEnvironmentPostProcessorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Thomas Vitale\n */\nclass Fabric8ProfileEnvironmentPostProcessorTests {\n  @Test void whenKubernetesEnvironmentAndNoApiAccessThenProfileEnabled(){\n    ConfigurableApplicationContext context\u003dnew SpringApplicationBuilder(App.class).web(org.springframework.boot.WebApplicationType.NONE).properties(\"KUBERNETES_SERVICE_HOST\u003d10.0.0.1\",\"spring.main.cloud-platform\u003dKUBERNETES\").run();\n    assertThat(context.getEnvironment().getActiveProfiles()).contains(KUBERNETES_PROFILE);\n  }\n  @Test void whenNoKubernetesEnvironmentAndNoApiAccessThenNoProfileEnabled(){\n    ConfigurableApplicationContext context\u003dnew SpringApplicationBuilder(App.class).web(org.springframework.boot.WebApplicationType.NONE).run();\n    assertThat(context.getEnvironment().getActiveProfiles()).doesNotContain(KUBERNETES_PROFILE);\n  }\n}\n",
        "abstract": "/** \n * @author Thomas Vitale\n */\nclass Fabric8ProfileEnvironmentPostProcessorTests {\n  @Test void whenKubernetesEnvironmentAndNoApiAccessThenProfileEnabled();\n  @Test void whenNoKubernetesEnvironmentAndNoApiAccessThenNoProfileEnabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/main/java/org/springframework/cloud/kubernetes/client/KubernetesClientUtils.java",
        "name": "KubernetesClientUtils",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic final class KubernetesClientUtils {\n  private static final Log LOG\u003dLogFactory.getLog(KubernetesClientUtils.class);\n  private KubernetesClientUtils(){\n  }\n  public static ApiClient createApiClientForInformerClient(){\n    ApiClient apiClient\u003dkubernetesApiClient();\n    apiClient.setReadTimeout(0);\n    return apiClient;\n  }\n  public static ApiClient kubernetesApiClient(){\n    try {\n      ApiClient apiClient\u003dClientBuilder.cluster().build();\n      LOG.info(\"Created API client in the cluster.\");\n      return apiClient;\n    }\n catch (    Exception e) {\n      if (e instanceof IllegalStateException \u0026\u0026 illegalStateException.getCause() instanceof NumberFormatException) {\n        LOG.info(\"Could not create the Kubernetes ApiClient in a cluster environment, because connection port \" + \"was not provided.\");\n      }\n else {\n        LOG.info(\"Could not create the Kubernetes ApiClient in a cluster environment, because : \",e);\n      }\n      LOG.info(null);\n      try {\n        ApiClient apiClient\u003dClientBuilder.defaultClient();\n        LOG.info(\"Created standard API client. Unless $KUBECONFIG or $HOME/.kube/config is defined, \" + \"this client will try to connect to localhost:8080\");\n        return apiClient;\n      }\n catch (      Exception e1) {\n        LOG.warn(\"Could not create a Kubernetes ApiClient from either a cluster or standard environment. \" + \"Will return one that always connects to localhost:8080\",e1);\n        return new ClientBuilder().build();\n      }\n    }\n  }\n  /** \n * this method does the namespace resolution for both config map and secrets implementations. It tries these places to find the namespace: \u003cpre\u003e 1. from a normalized source (which can be null) 2. from a property \u0027spring.cloud.kubernetes.client.namespace\u0027, if such is present 3. from a String residing in a file denoted by `spring.cloud.kubernetes.client.serviceAccountNamespacePath` property, if such is present 4. from a String residing in `/var/run/secrets/kubernetes.io/serviceaccount/namespace` file, if such is present (kubernetes default path) \u003c/pre\u003e If any of the above fail, we throw a NamespaceResolutionFailedException.\n * @param namespace normalized namespace\n * @param configurationTarget Config Map/Secret\n * @param provider the provider which computes the namespace\n * @return application namespace\n * @throws NamespaceResolutionFailedException when namespace could not be resolved\n */\n  public static String getApplicationNamespace(  String namespace,  String configurationTarget,  KubernetesNamespaceProvider provider){\n    if (StringUtils.hasText(namespace)) {\n      LOG.debug(configurationTarget + \" namespace : \" + namespace);\n      return namespace;\n    }\n    if (provider !\u003d null) {\n      String providerNamespace\u003dprovider.getNamespace();\n      if (StringUtils.hasText(providerNamespace)) {\n        LOG.debug(configurationTarget + \" namespace from provider : \" + namespace);\n        return providerNamespace;\n      }\n    }\n    throw new NamespaceResolutionFailedException(\"unresolved namespace\");\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic final class KubernetesClientUtils {\n  private static final Log LOG\u003dLogFactory.getLog(KubernetesClientUtils.class);\n  private KubernetesClientUtils();\n  public static ApiClient createApiClientForInformerClient();\n  public static ApiClient kubernetesApiClient();\n  /** \n * this method does the namespace resolution for both config map and secrets implementations. It tries these places to find the namespace: \u003cpre\u003e 1. from a normalized source (which can be null) 2. from a property \u0027spring.cloud.kubernetes.client.namespace\u0027, if such is present 3. from a String residing in a file denoted by `spring.cloud.kubernetes.client.serviceAccountNamespacePath` property, if such is present 4. from a String residing in `/var/run/secrets/kubernetes.io/serviceaccount/namespace` file, if such is present (kubernetes default path) \u003c/pre\u003e If any of the above fail, we throw a NamespaceResolutionFailedException.\n * @param namespace normalized namespace\n * @param configurationTarget Config Map/Secret\n * @param provider the provider which computes the namespace\n * @return application namespace\n * @throws NamespaceResolutionFailedException when namespace could not be resolved\n */\n  public static String getApplicationNamespace(  String namespace,  String configurationTarget,  KubernetesNamespaceProvider provider);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/main/java/org/springframework/cloud/kubernetes/client/KubernetesClientActuatorConfiguration.java",
        "name": "KubernetesClientActuatorConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesHealthIndicatorEnabled public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientActuatorConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesHealthIndicatorEnabled public class KubernetesClientActuatorConfiguration {\n  @Bean @ConditionalOnEnabledHealthIndicator(\"kubernetes\") public KubernetesClientHealthIndicator kubernetesHealthIndicator(  PodUtils\u003cV1Pod\u003e podUtils){\n    return new KubernetesClientHealthIndicator(podUtils);\n  }\n  @Bean @ConditionalOnEnabledInfoContributor(\"kubernetes\") public KubernetesClientInfoContributor kubernetesInfoContributor(  PodUtils\u003cV1Pod\u003e podUtils){\n    return new KubernetesClientInfoContributor(podUtils);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesHealthIndicatorEnabled public class KubernetesClientActuatorConfiguration {\n  @Bean @ConditionalOnEnabledHealthIndicator(\"kubernetes\") public KubernetesClientHealthIndicator kubernetesHealthIndicator(  PodUtils\u003cV1Pod\u003e podUtils);\n  @Bean @ConditionalOnEnabledInfoContributor(\"kubernetes\") public KubernetesClientInfoContributor kubernetesInfoContributor(  PodUtils\u003cV1Pod\u003e podUtils);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/main/java/org/springframework/cloud/kubernetes/client/KubernetesClientInfoContributor.java",
        "name": "KubernetesClientInfoContributor",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientInfoContributor",
        "extend": "AbstractKubernetesInfoContributor",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientInfoContributor extends AbstractKubernetesInfoContributor {\n  private final PodUtils\u003cV1Pod\u003e utils;\n  public KubernetesClientInfoContributor(  PodUtils\u003cV1Pod\u003e utils){\n    this.utils\u003dutils;\n  }\n  @Override public Map\u003cString,Object\u003e getDetails(){\n    V1Pod current\u003dutils.currentPod().get();\n    if (current !\u003d null) {\n      Map\u003cString,Object\u003e details\u003dCollectionUtils.newHashMap(7);\n      details.put(INSIDE,true);\n      V1ObjectMeta meta\u003dcurrent.getMetadata();\n      details.put(NAMESPACE,meta.getNamespace());\n      details.put(POD_NAME,meta.getName());\n      V1PodSpec spec\u003dcurrent.getSpec();\n      details.put(SERVICE_ACCOUNT,spec.getServiceAccountName());\n      details.put(NODE_NAME,spec.getNodeName());\n      V1PodStatus status\u003dcurrent.getStatus();\n      details.put(POD_IP,status.getPodIP());\n      details.put(HOST_IP,status.getHostIP());\n      return details;\n    }\n    return Collections.singletonMap(INSIDE,false);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientInfoContributor extends AbstractKubernetesInfoContributor {\n  private final PodUtils\u003cV1Pod\u003e utils;\n  public KubernetesClientInfoContributor(  PodUtils\u003cV1Pod\u003e utils);\n  @Override public Map\u003cString,Object\u003e getDetails();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/main/java/org/springframework/cloud/kubernetes/client/KubernetesClientHealthIndicator.java",
        "name": "KubernetesClientHealthIndicator",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientHealthIndicator",
        "extend": "AbstractKubernetesHealthIndicator",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientHealthIndicator extends AbstractKubernetesHealthIndicator {\n  private final PodUtils\u003cV1Pod\u003e utils;\n  public KubernetesClientHealthIndicator(  PodUtils\u003cV1Pod\u003e utils){\n    this.utils\u003dutils;\n  }\n  @Override protected Map\u003cString,Object\u003e getDetails(){\n    V1Pod current\u003dutils.currentPod().get();\n    if (current !\u003d null) {\n      Map\u003cString,Object\u003e details\u003dCollectionUtils.newHashMap(8);\n      details.put(INSIDE,true);\n      V1ObjectMeta meta\u003dcurrent.getMetadata();\n      details.put(NAMESPACE,meta.getNamespace());\n      details.put(POD_NAME,meta.getName());\n      details.put(LABELS,meta.getLabels());\n      V1PodStatus status\u003dcurrent.getStatus();\n      details.put(POD_IP,status.getPodIP());\n      details.put(HOST_IP,status.getHostIP());\n      V1PodSpec spec\u003dcurrent.getSpec();\n      details.put(SERVICE_ACCOUNT,spec.getServiceAccountName());\n      details.put(NODE_NAME,spec.getNodeName());\n      return details;\n    }\n else {\n      return Collections.singletonMap(INSIDE,false);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientHealthIndicator extends AbstractKubernetesHealthIndicator {\n  private final PodUtils\u003cV1Pod\u003e utils;\n  public KubernetesClientHealthIndicator(  PodUtils\u003cV1Pod\u003e utils);\n  @Override protected Map\u003cString,Object\u003e getDetails();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/main/java/org/springframework/cloud/kubernetes/client/KubernetesClientAutoConfiguration.java",
        "name": "KubernetesClientAutoConfiguration",
        "modifiers": "@Configuration @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @AutoConfigureAfter(KubernetesCommonsAutoConfiguration.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Configuration @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @AutoConfigureAfter(KubernetesCommonsAutoConfiguration.class) public class KubernetesClientAutoConfiguration {\n  /** \n * this bean will be based on {@link org.springframework.cloud.kubernetes.commons.discovery.KubernetesDiscoveryProperties}in the next major release.\n */\n  @Deprecated(forRemoval\u003dtrue) @Bean @ConditionalOnMissingBean public ApiClient apiClient(  Environment environment){\n    ApiClient apiClient\u003dkubernetesApiClient();\n    apiClient.setUserAgent(environment.getProperty(\"spring.cloud.kubernetes.client.user-agent\",KubernetesClientProperties.DEFAULT_USER_AGENT));\n    return apiClient;\n  }\n  @Bean @ConditionalOnMissingBean public CoreV1Api coreApi(  ApiClient apiClient){\n    return new CoreV1Api(apiClient);\n  }\n  @Bean @ConditionalOnMissingBean public KubernetesNamespaceProvider kubernetesNamespaceProvider(  Environment environment){\n    return new KubernetesNamespaceProvider(environment);\n  }\n  @Bean @ConditionalOnMissingBean public KubernetesClientPodUtils kubernetesPodUtils(  CoreV1Api client,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    return new KubernetesClientPodUtils(client,kubernetesNamespaceProvider.getNamespace(),true);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Configuration @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @AutoConfigureAfter(KubernetesCommonsAutoConfiguration.class) public class KubernetesClientAutoConfiguration {\n  /** \n * this bean will be based on {@link org.springframework.cloud.kubernetes.commons.discovery.KubernetesDiscoveryProperties}in the next major release.\n */\n  @Deprecated(forRemoval\u003dtrue) @Bean @ConditionalOnMissingBean public ApiClient apiClient(  Environment environment);\n  @Bean @ConditionalOnMissingBean public CoreV1Api coreApi(  ApiClient apiClient);\n  @Bean @ConditionalOnMissingBean public KubernetesNamespaceProvider kubernetesNamespaceProvider(  Environment environment);\n  @Bean @ConditionalOnMissingBean public KubernetesClientPodUtils kubernetesPodUtils(  CoreV1Api client,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/main/java/org/springframework/cloud/kubernetes/client/KubernetesClientPodUtils.java",
        "name": "KubernetesClientPodUtils",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientPodUtils",
        "extend": "",
        "implements": "PodUtils\u003cV1Pod\u003e",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientPodUtils implements PodUtils\u003cV1Pod\u003e {\n  /** \n * Hostname environment variable name.\n */\n  public static final String HOSTNAME\u003d\"HOSTNAME\";\n  /** \n * KUBERNETES_SERVICE_HOST environment variable name.\n */\n  public static final String KUBERNETES_SERVICE_HOST\u003d\"KUBERNETES_SERVICE_HOST\";\n  private static final Log LOG\u003dLogFactory.getLog(KubernetesClientPodUtils.class);\n  private final CoreV1Api client;\n  private final String hostName;\n  private final Supplier\u003cV1Pod\u003e current;\n  private final String namespace;\n  private final String serviceHost;\n  private final boolean failFast;\n  @Deprecated(forRemoval\u003dtrue) public KubernetesClientPodUtils(  CoreV1Api client,  String namespace){\n    if (client \u003d\u003d null) {\n      throw new IllegalArgumentException(\"Must provide an instance of KubernetesClient\");\n    }\n    this.client\u003dclient;\n    this.hostName\u003dEnvReader.getEnv(HOSTNAME);\n    this.serviceHost\u003dEnvReader.getEnv(KUBERNETES_SERVICE_HOST);\n    this.current\u003dLazilyInstantiate.using(this::internalGetPod);\n    this.namespace\u003dnamespace;\n    this.failFast\u003dfalse;\n  }\n  public KubernetesClientPodUtils(  CoreV1Api client,  String namespace,  boolean failFast){\n    if (client \u003d\u003d null) {\n      throw new IllegalArgumentException(\"Must provide an instance of KubernetesClient\");\n    }\n    this.client\u003dclient;\n    this.hostName\u003dEnvReader.getEnv(HOSTNAME);\n    this.serviceHost\u003dEnvReader.getEnv(KUBERNETES_SERVICE_HOST);\n    this.current\u003dLazilyInstantiate.using(this::internalGetPod);\n    this.namespace\u003dnamespace;\n    this.failFast\u003dfailFast;\n  }\n  @Override public Supplier\u003cV1Pod\u003e currentPod(){\n    return current;\n  }\n  @Override public boolean isInsideKubernetes(){\n    return currentPod().get() !\u003d null;\n  }\n  private V1Pod internalGetPod(){\n    try {\n      if (isServiceHostEnvVarPresent() \u0026\u0026 isHostNameEnvVarPresent() \u0026\u0026 isServiceAccountFound()) {\n        LOG.debug(\"reading pod in namespace : \" + namespace);\n        return client.readNamespacedPod(hostName,namespace,null);\n      }\n    }\n catch (    Throwable t) {\n      if (failFast) {\n        if (t instanceof ApiException) {\n          LOG.error(\"error reading pod : \" + apiException.getResponseBody());\n        }\n        throw new RuntimeException(t);\n      }\n      if (t instanceof ApiException) {\n        LOG.warn(\"error reading pod, with error : \" + apiException.getResponseBody());\n      }\n      LOG.warn(\"Failed to get pod with name:[\" + hostName + \"]. You should look into this if things aren\u0027t\"+ \" working as you expect. Are you missing serviceaccount permissions?\",t);\n    }\n    return null;\n  }\n  private boolean isServiceHostEnvVarPresent(){\n    return StringUtils.hasLength(serviceHost);\n  }\n  private boolean isHostNameEnvVarPresent(){\n    return StringUtils.hasLength(hostName);\n  }\n  private boolean isServiceAccountFound(){\n    boolean serviceAccountPathPresent\u003dPaths.get(Config.SERVICEACCOUNT_TOKEN_PATH).toFile().exists();\n    if (!serviceAccountPathPresent) {\n      LOG.warn(\"serviceaccount path not present, did you disable it via \u0027automountServiceAccountToken : false\u0027?\" + \" Major functionalities will not work without that property being set\");\n    }\n    return serviceAccountPathPresent \u0026\u0026 Paths.get(Config.SERVICEACCOUNT_CA_PATH).toFile().exists();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientPodUtils implements PodUtils\u003cV1Pod\u003e {\n  /** \n * Hostname environment variable name.\n */\n  public static final String HOSTNAME\u003d\"HOSTNAME\";\n  /** \n * KUBERNETES_SERVICE_HOST environment variable name.\n */\n  public static final String KUBERNETES_SERVICE_HOST\u003d\"KUBERNETES_SERVICE_HOST\";\n  private static final Log LOG\u003dLogFactory.getLog(KubernetesClientPodUtils.class);\n  private final CoreV1Api client;\n  private final String hostName;\n  private final Supplier\u003cV1Pod\u003e current;\n  private final String namespace;\n  private final String serviceHost;\n  private final boolean failFast;\n  @Deprecated(forRemoval\u003dtrue) public KubernetesClientPodUtils(  CoreV1Api client,  String namespace);\n  public KubernetesClientPodUtils(  CoreV1Api client,  String namespace,  boolean failFast);\n  @Override public Supplier\u003cV1Pod\u003e currentPod();\n  @Override public boolean isInsideKubernetes();\n  private V1Pod internalGetPod();\n  private boolean isServiceHostEnvVarPresent();\n  private boolean isHostNameEnvVarPresent();\n  private boolean isServiceAccountFound();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/main/java/org/springframework/cloud/kubernetes/client/profile/KubernetesClientProfileEnvironmentPostProcessor.java",
        "name": "KubernetesClientProfileEnvironmentPostProcessor",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.profile.KubernetesClientProfileEnvironmentPostProcessor",
        "extend": "AbstractKubernetesProfileEnvironmentPostProcessor",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Thomas Vitale\n */\npublic class KubernetesClientProfileEnvironmentPostProcessor extends AbstractKubernetesProfileEnvironmentPostProcessor {\n  @Override protected boolean isInsideKubernetes(  Environment environment){\n    CoreV1Api api\u003dnew CoreV1Api();\n    KubernetesClientPodUtils utils\u003dnew KubernetesClientPodUtils(api,environment.getProperty(NAMESPACE_PROPERTY),false);\n    return environment.containsProperty(ENV_SERVICE_HOST) || utils.isInsideKubernetes();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Thomas Vitale\n */\npublic class KubernetesClientProfileEnvironmentPostProcessor extends AbstractKubernetesProfileEnvironmentPostProcessor {\n  @Override protected boolean isInsideKubernetes(  Environment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/KubernetesClientInfoContributorNotInsideTests.java",
        "name": "KubernetesClientInfoContributorNotInsideTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.info.kubernetes.enabled\u003dfalse\"}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientInfoContributorNotInsideTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.info.kubernetes.enabled\u003dfalse\"}) public class KubernetesClientInfoContributorNotInsideTests {\n  @Autowired private ApplicationContext context;\n  @Test public void test(){\n    assertThatThrownBy(() -\u003e context.getBean(KubernetesClientInfoContributor.class)).isInstanceOf(NoSuchBeanDefinitionException.class);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.info.kubernetes.enabled\u003dfalse\"}) public class KubernetesClientInfoContributorNotInsideTests {\n  @Autowired private ApplicationContext context;\n  @Test public void test();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/default_api/ApiClientUserAgentNonDefaultHeader.java",
        "name": "ApiClientUserAgentNonDefaultHeader",
        "modifiers": "@SpringBootTest(classes\u003dApp.class,properties\u003d{\"kubernetes.informer.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.userAgent\u003dnon-default\",\"spring.main.cloud-platform\u003dKUBERNETES\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.default_api.ApiClientUserAgentNonDefaultHeader",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Robert McNeesThis tests that the apiClient created in KubernetesClientAutoConfiguration will not set itself as the default apiClient. This is to avoid overwriting the user\u0027s defaultApiClient if they include this project. kubernetes informer is disabled because KubernetesClientInformerAutoConfiguration creates a defaultApiClient that will be autowired instead of the ApiClient created in KubernetesClientAutoConfiguration\n */\n@SpringBootTest(classes\u003dApp.class,properties\u003d{\"kubernetes.informer.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.userAgent\u003dnon-default\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ApiClientUserAgentNonDefaultHeader {\n  @Autowired private ApiClient apiClient;\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void testApiClientUserAgentDefaultHeader() throws MalformedURLException {\n    assertThat(apiClient).isNotNull();\n    Request.Builder builder\u003dnew Request.Builder();\n    apiClient.processHeaderParams(Collections.emptyMap(),builder);\n    assertThat(builder.url(new URL(\"http://example.com\")).build().headers().get(\"User-Agent\")).isEqualTo(\"non-default\");\n  }\n}\n",
        "abstract": "/** \n * @author Robert McNeesThis tests that the apiClient created in KubernetesClientAutoConfiguration will not set itself as the default apiClient. This is to avoid overwriting the user\u0027s defaultApiClient if they include this project. kubernetes informer is disabled because KubernetesClientInformerAutoConfiguration creates a defaultApiClient that will be autowired instead of the ApiClient created in KubernetesClientAutoConfiguration\n */\n@SpringBootTest(classes\u003dApp.class,properties\u003d{\"kubernetes.informer.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.userAgent\u003dnon-default\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ApiClientUserAgentNonDefaultHeader {\n  @Autowired private ApiClient apiClient;\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void testApiClientUserAgentDefaultHeader() throws MalformedURLException;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/default_api/App.java",
        "name": "App",
        "modifiers": "@SpringBootApplication",
        "qualified_name": "org.springframework.cloud.kubernetes.client.default_api.App",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication class App {\n}\n",
        "abstract": "@SpringBootApplication class App {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/default_api/ApiClientUserAgentDefaultHeader.java",
        "name": "ApiClientUserAgentDefaultHeader",
        "modifiers": "@SpringBootTest(classes\u003dApp.class,properties\u003d{\"kubernetes.informer.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.default_api.ApiClientUserAgentDefaultHeader",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Robert McNeesThis tests that the apiClient created in KubernetesClientAutoConfiguration will not set itself as the default apiClient. This is to avoid overwriting the user\u0027s defaultApiClient if they include this project. kubernetes informer is disabled because KubernetesClientInformerAutoConfiguration creates a defaultApiClient that will be autowired instead of the ApiClient created in KubernetesClientAutoConfiguration\n */\n@SpringBootTest(classes\u003dApp.class,properties\u003d{\"kubernetes.informer.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ApiClientUserAgentDefaultHeader {\n  @Autowired private ApiClient apiClient;\n  @Test void testApiClientUserAgentDefaultHeader() throws MalformedURLException {\n    assertThat(apiClient).isNotNull();\n    Request.Builder builder\u003dnew Request.Builder();\n    apiClient.processHeaderParams(Collections.emptyMap(),builder);\n    assertThat(builder.url(new URL(\"http://example.com\")).build().headers().get(\"User-Agent\")).isEqualTo(\"Spring-Cloud-Kubernetes-Application\");\n  }\n}\n",
        "abstract": "/** \n * @author Robert McNeesThis tests that the apiClient created in KubernetesClientAutoConfiguration will not set itself as the default apiClient. This is to avoid overwriting the user\u0027s defaultApiClient if they include this project. kubernetes informer is disabled because KubernetesClientInformerAutoConfiguration creates a defaultApiClient that will be autowired instead of the ApiClient created in KubernetesClientAutoConfiguration\n */\n@SpringBootTest(classes\u003dApp.class,properties\u003d{\"kubernetes.informer.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ApiClientUserAgentDefaultHeader {\n  @Autowired private ApiClient apiClient;\n  @Test void testApiClientUserAgentDefaultHeader() throws MalformedURLException;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/default_api/DefaultApiClientNotSameAsApiClient.java",
        "name": "DefaultApiClientNotSameAsApiClient",
        "modifiers": "@SpringBootTest(classes\u003dApp.class,properties\u003d{\"kubernetes.informer.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.default_api.DefaultApiClientNotSameAsApiClient",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Robert McNeesThis tests that the apiClient created in KubernetesClientAutoConfiguration will not set itself as the default apiClient. This is to avoid overwriting the user\u0027s defaultApiClient if they include this project. kubernetes informer is disabled because KubernetesClientInformerAutoConfiguration creates a defaultApiClient that will be autowired instead of the ApiClient created in KubernetesClientAutoConfiguration\n */\n@SpringBootTest(classes\u003dApp.class,properties\u003d{\"kubernetes.informer.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class DefaultApiClientNotSameAsApiClient {\n  @Autowired private ApiClient apiClient;\n  @Test void testCreatedApiClientIsNotDefault(){\n    assertThat(apiClient).isNotNull();\n    ApiClient defaultApiClient\u003dio.kubernetes.client.openapi.Configuration.getDefaultApiClient();\n    assertThat(defaultApiClient).isNotNull();\n    assertThat(defaultApiClient).isNotSameAs(apiClient);\n  }\n}\n",
        "abstract": "/** \n * @author Robert McNeesThis tests that the apiClient created in KubernetesClientAutoConfiguration will not set itself as the default apiClient. This is to avoid overwriting the user\u0027s defaultApiClient if they include this project. kubernetes informer is disabled because KubernetesClientInformerAutoConfiguration creates a defaultApiClient that will be autowired instead of the ApiClient created in KubernetesClientAutoConfiguration\n */\n@SpringBootTest(classes\u003dApp.class,properties\u003d{\"kubernetes.informer.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class DefaultApiClientNotSameAsApiClient {\n  @Autowired private ApiClient apiClient;\n  @Test void testCreatedApiClientIsNotDefault();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/KubernetesClientUtilsTests.java",
        "name": "KubernetesClientUtilsTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientUtilsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesClientUtilsTests {\n  private final KubernetesNamespaceProvider provider\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  @Test void testNamespaceFromNormalizedSource(){\n    String result\u003dKubernetesClientUtils.getApplicationNamespace(\"abc\",\"target\",null);\n    assertThat(result).isEqualTo(\"abc\");\n  }\n  @Test void testNamespaceFromProvider(){\n    Mockito.when(provider.getNamespace()).thenReturn(\"def\");\n    String result\u003dKubernetesClientUtils.getApplicationNamespace(\"\",\"target\",provider);\n    assertThat(result).isEqualTo(\"def\");\n  }\n  @Test void testNamespaceResolutionFailed(){\n    assertThatThrownBy(() -\u003e KubernetesClientUtils.getApplicationNamespace(\"\",\"target\",null)).isInstanceOf(NamespaceResolutionFailedException.class);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesClientUtilsTests {\n  private final KubernetesNamespaceProvider provider\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  @Test void testNamespaceFromNormalizedSource();\n  @Test void testNamespaceFromProvider();\n  @Test void testNamespaceResolutionFailed();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/KubernetesClientPodUtilsTests.java",
        "name": "KubernetesClientPodUtilsTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientPodUtilsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesClientPodUtilsTests {\n  private static final String KUBERNETES_SERVICE_HOST\u003dKubernetesClientPodUtils.KUBERNETES_SERVICE_HOST;\n  private static final String HOSTNAME\u003dKubernetesClientPodUtils.HOSTNAME;\n  private static final String SERVICE_ACCOUNT_TOKEN_PATH\u003dConfig.SERVICEACCOUNT_TOKEN_PATH;\n  private static final String SERVICE_ACCOUNT_CERT_PATH\u003dConfig.SERVICEACCOUNT_CA_PATH;\n  private static final String POD_HOSTNAME\u003d\"pod-hostname\";\n  private static final String HOST\u003d\"10.1.1.1\";\n  private static final V1Pod POD\u003dnew V1Pod();\n  private final CoreV1Api client\u003dMockito.mock(CoreV1Api.class);\n  private final Path tokenPath\u003dMockito.mock(Path.class);\n  private final File tokenFile\u003dMockito.mock(File.class);\n  private final Path certPath\u003dMockito.mock(Path.class);\n  private final File certFile\u003dMockito.mock(File.class);\n  private MockedStatic\u003cEnvReader\u003e envReader;\n  private MockedStatic\u003cPaths\u003e paths;\n  @BeforeEach void before(){\n    envReader\u003dMockito.mockStatic(EnvReader.class);\n    paths\u003dMockito.mockStatic(Paths.class);\n  }\n  @AfterEach void after(){\n    envReader.close();\n    paths.close();\n  }\n  @Test void constructorThrowsIllegalArgumentExceptionWhenKubeClientIsNull(){\n    assertThatThrownBy(() -\u003e new KubernetesClientPodUtils(null,\"namespace\",false)).isInstanceOf(IllegalArgumentException.class).hasMessage(\"Must provide an instance of KubernetesClient\");\n  }\n  @Test void serviceHostNotPresent(){\n    mockHost(null);\n    KubernetesClientPodUtils util\u003dnew KubernetesClientPodUtils(client,\"namespace\",false);\n    Supplier\u003cV1Pod\u003e sup\u003dutil.currentPod();\n    assertSupplierAndClient(sup,util);\n  }\n  @Test void hostNameNotPresent(){\n    mockHost(HOST);\n    mockHostname(null);\n    KubernetesClientPodUtils util\u003dnew KubernetesClientPodUtils(client,\"namespace\",false);\n    Supplier\u003cV1Pod\u003e sup\u003dutil.currentPod();\n    assertSupplierAndClient(sup,util);\n  }\n  @Test void serviceAccountPathNotPresent(){\n    mockTokenPath(false);\n    mockHostname(HOST);\n    KubernetesClientPodUtils util\u003dnew KubernetesClientPodUtils(client,\"namespace\",false);\n    Supplier\u003cV1Pod\u003e sup\u003dutil.currentPod();\n    assertSupplierAndClient(sup,util);\n  }\n  @Test void serviceAccountCertPathNotPresent(){\n    mockTokenPath(true);\n    mockCertPath(false);\n    mockHostname(HOST);\n    KubernetesClientPodUtils util\u003dnew KubernetesClientPodUtils(client,\"namespace\",false);\n    Supplier\u003cV1Pod\u003e sup\u003dutil.currentPod();\n    assertSupplierAndClient(sup,util);\n  }\n  @Test void allPresent() throws ApiException {\n    mockTokenPath(true);\n    mockCertPath(true);\n    mockHost(HOST);\n    mockHostname(POD_HOSTNAME);\n    mockPodResult();\n    KubernetesClientPodUtils util\u003dnew KubernetesClientPodUtils(client,\"namespace\",false);\n    Supplier\u003cV1Pod\u003e sup\u003dutil.currentPod();\n    assertThat(sup.get()).isNotNull();\n    assertThat(util.isInsideKubernetes()).isTrue();\n  }\n  private void assertSupplierAndClient(  Supplier\u003cV1Pod\u003e sup,  KubernetesClientPodUtils util){\n    assertThat(sup.get()).isNull();\n    assertThat(util.isInsideKubernetes()).isFalse();\n  }\n  private void mockHost(  String host){\n    envReader.when(() -\u003e EnvReader.getEnv(KUBERNETES_SERVICE_HOST)).thenReturn(host);\n  }\n  private void mockHostname(  String name){\n    envReader.when(() -\u003e EnvReader.getEnv(HOSTNAME)).thenReturn(name);\n  }\n  private void mockTokenPath(  boolean result){\n    Mockito.when(tokenPath.toFile()).thenReturn(tokenFile);\n    Mockito.when(tokenFile.exists()).thenReturn(result);\n    paths.when(() -\u003e Paths.get(SERVICE_ACCOUNT_TOKEN_PATH)).thenReturn(tokenPath);\n  }\n  private void mockCertPath(  boolean result){\n    Mockito.when(certPath.toFile()).thenReturn(certFile);\n    Mockito.when(certFile.exists()).thenReturn(result);\n    paths.when(() -\u003e Paths.get(SERVICE_ACCOUNT_CERT_PATH)).thenReturn(certPath);\n  }\n  private void mockPodResult() throws ApiException {\n    Mockito.when(client.readNamespacedPod(POD_HOSTNAME,\"namespace\",null)).thenReturn(POD);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesClientPodUtilsTests {\n  private static final String KUBERNETES_SERVICE_HOST\u003dKubernetesClientPodUtils.KUBERNETES_SERVICE_HOST;\n  private static final String HOSTNAME\u003dKubernetesClientPodUtils.HOSTNAME;\n  private static final String SERVICE_ACCOUNT_TOKEN_PATH\u003dConfig.SERVICEACCOUNT_TOKEN_PATH;\n  private static final String SERVICE_ACCOUNT_CERT_PATH\u003dConfig.SERVICEACCOUNT_CA_PATH;\n  private static final String POD_HOSTNAME\u003d\"pod-hostname\";\n  private static final String HOST\u003d\"10.1.1.1\";\n  private static final V1Pod POD\u003dnew V1Pod();\n  private final CoreV1Api client\u003dMockito.mock(CoreV1Api.class);\n  private final Path tokenPath\u003dMockito.mock(Path.class);\n  private final File tokenFile\u003dMockito.mock(File.class);\n  private final Path certPath\u003dMockito.mock(Path.class);\n  private final File certFile\u003dMockito.mock(File.class);\n  private MockedStatic\u003cEnvReader\u003e envReader;\n  private MockedStatic\u003cPaths\u003e paths;\n  @BeforeEach void before();\n  @AfterEach void after();\n  @Test void constructorThrowsIllegalArgumentExceptionWhenKubeClientIsNull();\n  @Test void serviceHostNotPresent();\n  @Test void hostNameNotPresent();\n  @Test void serviceAccountPathNotPresent();\n  @Test void serviceAccountCertPathNotPresent();\n  @Test void allPresent() throws ApiException;\n  private void assertSupplierAndClient(  Supplier\u003cV1Pod\u003e sup,  KubernetesClientPodUtils util);\n  private void mockHost(  String host);\n  private void mockHostname(  String name);\n  private void mockTokenPath(  boolean result);\n  private void mockCertPath(  boolean result);\n  private void mockPodResult() throws ApiException;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/KubernetesClientHealthIndicatorInsideTests.java",
        "name": "KubernetesClientHealthIndicatorInsideTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientHealthIndicatorInsideTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\") public class KubernetesClientHealthIndicatorInsideTests {\n  @Autowired private ApplicationContext context;\n  @Test public void test(){\n    assertThat(context.getBean(KubernetesClientHealthIndicator.class)).isNotNull();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\") public class KubernetesClientHealthIndicatorInsideTests {\n  @Autowired private ApplicationContext context;\n  @Test public void test();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/ActuatorDisabledHealthTest.java",
        "name": "ActuatorDisabledHealthTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dfalse\",\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003dhealth\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.ActuatorDisabledHealthTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dfalse\",\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003dhealth\"}) class ActuatorDisabledHealthTest {\n  @Autowired private ReactiveHealthContributorRegistry registry;\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  @Test void healthEndpointShouldNotContainKubernetes(){\n    this.webClient.get().uri(\"http://localhost:{port}/actuator/health\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"components.kubernetes\").doesNotExist();\n    Assertions.assertNull(registry.getContributor(\"kubernetes\"),\"reactive kubernetes contributor must NOT be present when \u0027management.health.kubernetes.enabled\u003dfalse\u0027\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dfalse\",\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003dhealth\"}) class ActuatorDisabledHealthTest {\n  @Autowired private ReactiveHealthContributorRegistry registry;\n  @Autowired private WebTestClient webClient;\n  @LocalManagementPort private int port;\n  @Test void healthEndpointShouldNotContainKubernetes();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/ActuatorEnabledFailFastExceptionTest.java",
        "name": "ActuatorEnabledFailFastExceptionTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{App.class,ActuatorEnabledFailFastExceptionTest.ActuatorConfig.class},properties\u003d{\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.main.cloud-platform\u003dKUBERNETES\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.ActuatorEnabledFailFastExceptionTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{App.class,ActuatorEnabledFailFastExceptionTest.ActuatorConfig.class},properties\u003d{\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ActuatorEnabledFailFastExceptionTest {\n  private static final boolean FAIL_FAST\u003dtrue;\n  private static MockedStatic\u003cEnvReader\u003e envReaderMockedStatic;\n  private static MockedStatic\u003cPaths\u003e pathsMockedStatic;\n  private static final CoreV1Api coreV1Api\u003dMockito.mock(CoreV1Api.class);\n  @Autowired private KubernetesClientHealthIndicator healthIndicator;\n  @AfterEach void afterEach(){\n    envReaderMockedStatic.close();\n    pathsMockedStatic.close();\n  }\n  @Test void test() throws ApiException {\n    Health health\u003dhealthIndicator.getHealth(true);\n    Assertions.assertEquals(health.getStatus(),Status.DOWN);\n    Mockito.verify(coreV1Api).readNamespacedPod(\"host\",\"my-namespace\",null);\n  }\n  private static void mocks(){\n    envReaderMockedStatic\u003dMockito.mockStatic(EnvReader.class);\n    pathsMockedStatic\u003dMockito.mockStatic(Paths.class);\n    envReaderMockedStatic.when(() -\u003e EnvReader.getEnv(KubernetesClientPodUtils.KUBERNETES_SERVICE_HOST)).thenReturn(\"k8s-host\");\n    envReaderMockedStatic.when(() -\u003e EnvReader.getEnv(KubernetesClientPodUtils.HOSTNAME)).thenReturn(\"host\");\n    Path serviceAccountTokenPath\u003dMockito.mock(Path.class);\n    File serviceAccountTokenFile\u003dMockito.mock(File.class);\n    Mockito.when(serviceAccountTokenPath.toFile()).thenReturn(serviceAccountTokenFile);\n    Mockito.when(serviceAccountTokenFile.exists()).thenReturn(true);\n    pathsMockedStatic.when(() -\u003e Paths.get(Config.SERVICEACCOUNT_TOKEN_PATH)).thenReturn(serviceAccountTokenPath);\n    Path serviceAccountCAPath\u003dMockito.mock(Path.class);\n    File serviceAccountCAFile\u003dMockito.mock(File.class);\n    Mockito.when(serviceAccountCAPath.toFile()).thenReturn(serviceAccountCAFile);\n    Mockito.when(serviceAccountCAFile.exists()).thenReturn(true);\n    pathsMockedStatic.when(() -\u003e Paths.get(Config.SERVICEACCOUNT_CA_PATH)).thenReturn(serviceAccountCAPath);\n  }\n@TestConfiguration static class ActuatorConfig {\n    @Bean KubernetesClientPodUtils kubernetesPodUtils() throws ApiException {\n      mocks();\n      Mockito.when(coreV1Api.readNamespacedPod(\"host\",\"my-namespace\",null)).thenThrow(new RuntimeException(\"just because\"));\n      return new KubernetesClientPodUtils(coreV1Api,\"my-namespace\",FAIL_FAST);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{App.class,ActuatorEnabledFailFastExceptionTest.ActuatorConfig.class},properties\u003d{\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ActuatorEnabledFailFastExceptionTest {\n  private static final boolean FAIL_FAST\u003dtrue;\n  private static MockedStatic\u003cEnvReader\u003e envReaderMockedStatic;\n  private static MockedStatic\u003cPaths\u003e pathsMockedStatic;\n  private static final CoreV1Api coreV1Api\u003dMockito.mock(CoreV1Api.class);\n  @Autowired private KubernetesClientHealthIndicator healthIndicator;\n  @AfterEach void afterEach();\n  @Test void test() throws ApiException;\n  private static void mocks();\n@TestConfiguration static class ActuatorConfig {\n    @Bean KubernetesClientPodUtils kubernetesPodUtils() throws ApiException;\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/example/App.java",
        "name": "App",
        "modifiers": "@SpringBootApplication public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.example.App",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication public class App {\n  @Bean public ApiClient apiClient(){\n    ApiClient apiClient\u003dmock(ApiClient.class);\n    when(apiClient.getHttpClient()).thenReturn(new OkHttpClient.Builder().build());\n    return apiClient;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication public class App {\n  @Bean public ApiClient apiClient();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/StubProvider.java",
        "name": "StubProvider",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.StubProvider",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class StubProvider {\n  static final String STUB_POD_IP\u003d\"127.0.0.1\";\n  static final String STUB_HOST_IP\u003d\"123.456.789.1\";\n  static final String STUB_NODE_NAME\u003d\"nodeName\";\n  static final String STUB_SERVICE_ACCOUNT\u003d\"serviceAccount\";\n  static final String STUB_POD_NAME\u003d\"mypod\";\n  static final String STUB_NAMESPACE\u003d\"default\";\n  static final Map\u003cString,String\u003e STUB_LABELS\u003dCollections.singletonMap(\"spring\",\"cloud\");\n  private StubProvider(){\n  }\n  static V1Pod stubPod(){\n    V1ObjectMeta metaData\u003dnew V1ObjectMeta().labels(STUB_LABELS).name(STUB_POD_NAME).namespace(STUB_NAMESPACE);\n    V1PodStatus status\u003dnew V1PodStatus().podIP(STUB_POD_IP).hostIP(STUB_HOST_IP);\n    V1PodSpec spec\u003dnew V1PodSpec().nodeName(STUB_NODE_NAME).serviceAccountName(STUB_SERVICE_ACCOUNT);\n    return new V1Pod().metadata(metaData).status(status).spec(spec);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class StubProvider {\n  static final String STUB_POD_IP\u003d\"127.0.0.1\";\n  static final String STUB_HOST_IP\u003d\"123.456.789.1\";\n  static final String STUB_NODE_NAME\u003d\"nodeName\";\n  static final String STUB_SERVICE_ACCOUNT\u003d\"serviceAccount\";\n  static final String STUB_POD_NAME\u003d\"mypod\";\n  static final String STUB_NAMESPACE\u003d\"default\";\n  static final Map\u003cString,String\u003e STUB_LABELS\u003dCollections.singletonMap(\"spring\",\"cloud\");\n  private StubProvider();\n  static V1Pod stubPod();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/KubernetesClientInfoContributorTests.java",
        "name": "KubernetesClientInfoContributorTests",
        "modifiers": "@ExtendWith(MockitoExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientInfoContributorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@ExtendWith(MockitoExtension.class) class KubernetesClientInfoContributorTests {\n  @Mock private PodUtils\u003cV1Pod\u003e utils;\n  @Test void getDetailsIsNotInside(){\n    when(utils.currentPod()).thenReturn(() -\u003e null);\n    KubernetesClientInfoContributor infoContributor\u003dnew KubernetesClientInfoContributor(utils);\n    Map\u003cString,Object\u003e details\u003dinfoContributor.getDetails();\n    assertThat(details.size()).isEqualTo(1);\n    assertThat(details.get(INSIDE)).isEqualTo(false);\n  }\n  @Test void getDetailsInside(){\n    when(utils.currentPod()).thenReturn(StubProvider::stubPod);\n    KubernetesClientInfoContributor infoContributor\u003dnew KubernetesClientInfoContributor(utils);\n    Map\u003cString,Object\u003e details\u003dinfoContributor.getDetails();\n    assertThat(details.size()).isEqualTo(7);\n    assertThat(details.get(INSIDE)).isEqualTo(true);\n    assertThat(details.get(HOST_IP)).isEqualTo(STUB_HOST_IP);\n    assertThat(details.get(POD_IP)).isEqualTo(STUB_POD_IP);\n    assertThat(details.get(NODE_NAME)).isEqualTo(STUB_NODE_NAME);\n    assertThat(details.get(SERVICE_ACCOUNT)).isEqualTo(STUB_SERVICE_ACCOUNT);\n    assertThat(details.get(POD_NAME)).isEqualTo(STUB_POD_NAME);\n    assertThat(details.get(NAMESPACE)).isEqualTo(STUB_NAMESPACE);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@ExtendWith(MockitoExtension.class) class KubernetesClientInfoContributorTests {\n  @Mock private PodUtils\u003cV1Pod\u003e utils;\n  @Test void getDetailsIsNotInside();\n  @Test void getDetailsInside();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/KubernetesClientInfoContributorInsideTests.java",
        "name": "KubernetesClientInfoContributorInsideTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientInfoContributorInsideTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\") public class KubernetesClientInfoContributorInsideTests {\n  @Autowired private ApplicationContext context;\n  @Test public void test(){\n    assertThat(context.getBean(KubernetesClientInfoContributor.class)).isNotNull();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\") public class KubernetesClientInfoContributorInsideTests {\n  @Autowired private ApplicationContext context;\n  @Test public void test();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/ActuatorEnabledNoFailFastExceptionTest.java",
        "name": "ActuatorEnabledNoFailFastExceptionTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{App.class,ActuatorEnabledNoFailFastExceptionTest.ActuatorConfig.class},properties\u003d{\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.main.cloud-platform\u003dKUBERNETES\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.ActuatorEnabledNoFailFastExceptionTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{App.class,ActuatorEnabledNoFailFastExceptionTest.ActuatorConfig.class},properties\u003d{\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ActuatorEnabledNoFailFastExceptionTest {\n  private static final boolean FAIL_FAST\u003dfalse;\n  private static MockedStatic\u003cEnvReader\u003e envReaderMockedStatic;\n  private static MockedStatic\u003cPaths\u003e pathsMockedStatic;\n  private static final CoreV1Api coreV1Api\u003dMockito.mock(CoreV1Api.class);\n  @Autowired private KubernetesClientHealthIndicator healthIndicator;\n  @AfterEach void afterEach(){\n    envReaderMockedStatic.close();\n    pathsMockedStatic.close();\n  }\n  @Test void test() throws ApiException {\n    Health health\u003dhealthIndicator.getHealth(true);\n    Assertions.assertEquals(health.getStatus(),Status.UP);\n    Mockito.verify(coreV1Api).readNamespacedPod(\"host\",\"my-namespace\",null);\n  }\n  private static void mocks(){\n    envReaderMockedStatic\u003dMockito.mockStatic(EnvReader.class);\n    pathsMockedStatic\u003dMockito.mockStatic(Paths.class);\n    envReaderMockedStatic.when(() -\u003e EnvReader.getEnv(KubernetesClientPodUtils.KUBERNETES_SERVICE_HOST)).thenReturn(\"k8s-host\");\n    envReaderMockedStatic.when(() -\u003e EnvReader.getEnv(KubernetesClientPodUtils.HOSTNAME)).thenReturn(\"host\");\n    Path serviceAccountTokenPath\u003dMockito.mock(Path.class);\n    File serviceAccountTokenFile\u003dMockito.mock(File.class);\n    Mockito.when(serviceAccountTokenPath.toFile()).thenReturn(serviceAccountTokenFile);\n    Mockito.when(serviceAccountTokenFile.exists()).thenReturn(true);\n    pathsMockedStatic.when(() -\u003e Paths.get(Config.SERVICEACCOUNT_TOKEN_PATH)).thenReturn(serviceAccountTokenPath);\n    Path serviceAccountCAPath\u003dMockito.mock(Path.class);\n    File serviceAccountCAFile\u003dMockito.mock(File.class);\n    Mockito.when(serviceAccountCAPath.toFile()).thenReturn(serviceAccountCAFile);\n    Mockito.when(serviceAccountCAFile.exists()).thenReturn(true);\n    pathsMockedStatic.when(() -\u003e Paths.get(Config.SERVICEACCOUNT_CA_PATH)).thenReturn(serviceAccountCAPath);\n  }\n@TestConfiguration static class ActuatorConfig {\n    @Bean KubernetesClientPodUtils kubernetesPodUtils() throws ApiException {\n      mocks();\n      Mockito.when(coreV1Api.readNamespacedPod(\"host\",\"my-namespace\",null)).thenThrow(new RuntimeException(\"just because\"));\n      return new KubernetesClientPodUtils(coreV1Api,\"my-namespace\",FAIL_FAST);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{App.class,ActuatorEnabledNoFailFastExceptionTest.ActuatorConfig.class},properties\u003d{\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ActuatorEnabledNoFailFastExceptionTest {\n  private static final boolean FAIL_FAST\u003dfalse;\n  private static MockedStatic\u003cEnvReader\u003e envReaderMockedStatic;\n  private static MockedStatic\u003cPaths\u003e pathsMockedStatic;\n  private static final CoreV1Api coreV1Api\u003dMockito.mock(CoreV1Api.class);\n  @Autowired private KubernetesClientHealthIndicator healthIndicator;\n  @AfterEach void afterEach();\n  @Test void test() throws ApiException;\n  private static void mocks();\n@TestConfiguration static class ActuatorConfig {\n    @Bean KubernetesClientPodUtils kubernetesPodUtils() throws ApiException;\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/KubernetesClientHealthIndicatorTests.java",
        "name": "KubernetesClientHealthIndicatorTests",
        "modifiers": "@ExtendWith(MockitoExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientHealthIndicatorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@ExtendWith(MockitoExtension.class) class KubernetesClientHealthIndicatorTests {\n  @Mock private PodUtils\u003cV1Pod\u003e utils;\n  @Test void getDetailsNotInsideTest(){\n    when(utils.currentPod()).thenReturn(() -\u003e null);\n    KubernetesClientHealthIndicator healthIndicator\u003dnew KubernetesClientHealthIndicator(utils);\n    Map\u003cString,Object\u003e details\u003dhealthIndicator.getDetails();\n    assertThat(details.size()).isEqualTo(1);\n    assertThat(details.get(INSIDE)).isEqualTo(false);\n  }\n  @Test void getDetailsInsideTest(){\n    when(utils.currentPod()).thenReturn(StubProvider::stubPod);\n    KubernetesClientHealthIndicator healthIndicator\u003dnew KubernetesClientHealthIndicator(utils);\n    Map\u003cString,Object\u003e details\u003dhealthIndicator.getDetails();\n    assertThat(details.size()).isEqualTo(8);\n    assertThat(details.get(INSIDE)).isEqualTo(true);\n    assertThat(details.get(HOST_IP)).isEqualTo(STUB_HOST_IP);\n    assertThat(details.get(POD_IP)).isEqualTo(STUB_POD_IP);\n    assertThat(details.get(NODE_NAME)).isEqualTo(STUB_NODE_NAME);\n    assertThat(details.get(SERVICE_ACCOUNT)).isEqualTo(STUB_SERVICE_ACCOUNT);\n    assertThat(details.get(POD_NAME)).isEqualTo(STUB_POD_NAME);\n    assertThat(details.get(NAMESPACE)).isEqualTo(STUB_NAMESPACE);\n    assertThat(details.get(LABELS)).isEqualTo(STUB_LABELS);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@ExtendWith(MockitoExtension.class) class KubernetesClientHealthIndicatorTests {\n  @Mock private PodUtils\u003cV1Pod\u003e utils;\n  @Test void getDetailsNotInsideTest();\n  @Test void getDetailsInsideTest();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/KubernetesClientHealthIndicatorNotInsideTests.java",
        "name": "KubernetesClientHealthIndicatorNotInsideTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dfalse\"}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.KubernetesClientHealthIndicatorNotInsideTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dfalse\"}) public class KubernetesClientHealthIndicatorNotInsideTests {\n  @Autowired private ApplicationContext context;\n  @Test public void test(){\n    assertThatThrownBy(() -\u003e context.getBean(KubernetesClientHealthIndicator.class)).isInstanceOf(NoSuchBeanDefinitionException.class);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dfalse\"}) public class KubernetesClientHealthIndicatorNotInsideTests {\n  @Autowired private ApplicationContext context;\n  @Test public void test();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/ActuatorEnabledHealthTest.java",
        "name": "ActuatorEnabledHealthTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dtrue\",\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.main.cloud-platform\u003dKUBERNETES\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.ActuatorEnabledHealthTest",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dtrue\",\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ActuatorEnabledHealthTest {\n  @Autowired private WebTestClient webClient;\n  @Autowired private ReactiveHealthContributorRegistry registry;\n  @LocalManagementPort private int port;\n  @Test void healthEndpointShouldContainKubernetes(){\n    this.webClient.get().uri(\"http://localhost:{port}/actuator/health\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"components.kubernetes\").exists();\n    Assertions.assertNotNull(registry.getContributor(\"kubernetes\"),\"reactive kubernetes contributor must be present when \u0027management.health.kubernetes.enabled\u003dtrue\u0027\");\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"management.health.kubernetes.enabled\u003dtrue\",\"management.endpoint.health.show-details\u003dalways\",\"management.endpoint.health.show-components\u003dalways\",\"management.endpoints.web.exposure.include\u003dhealth\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class ActuatorEnabledHealthTest {\n  @Autowired private WebTestClient webClient;\n  @Autowired private ReactiveHealthContributorRegistry registry;\n  @LocalManagementPort private int port;\n  @Test void healthEndpointShouldContainKubernetes();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/profile/KubernetesClientProfileEnvironmentPostProcessorNoProfileTests.java",
        "name": "KubernetesClientProfileEnvironmentPostProcessorNoProfileTests",
        "modifiers": "@SpringBootTest(classes\u003d{App.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.profile.KubernetesClientProfileEnvironmentPostProcessorNoProfileTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(classes\u003d{App.class}) class KubernetesClientProfileEnvironmentPostProcessorNoProfileTests {\n  @Autowired private Environment environment;\n  @Test void whenNoKubernetesEnvironmentAndNoApiAccessThenNoProfileEnabled(){\n    assertThat(environment.getActiveProfiles()).doesNotContain(KUBERNETES_PROFILE);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(classes\u003d{App.class}) class KubernetesClientProfileEnvironmentPostProcessorNoProfileTests {\n  @Autowired private Environment environment;\n  @Test void whenNoKubernetesEnvironmentAndNoApiAccessThenNoProfileEnabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-autoconfig/src/test/java/org/springframework/cloud/kubernetes/client/profile/KubernetesClientProfileEnvironmentPostProcessorTests.java",
        "name": "KubernetesClientProfileEnvironmentPostProcessorTests",
        "modifiers": "@SpringBootTest(properties\u003d{ENV_SERVICE_HOST + \"\u003d10.0.0.1\",ENV_SERVICE_PORT + \"\u003d80\",\"spring.main.cloud-platform\u003dKUBERNETES\"},classes\u003d{App.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.profile.KubernetesClientProfileEnvironmentPostProcessorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Thomas Vitale\n */\n@SpringBootTest(properties\u003d{ENV_SERVICE_HOST + \"\u003d10.0.0.1\",ENV_SERVICE_PORT + \"\u003d80\",\"spring.main.cloud-platform\u003dKUBERNETES\"},classes\u003d{App.class}) class KubernetesClientProfileEnvironmentPostProcessorTests {\n  @Autowired private Environment environment;\n  @Test void whenKubernetesEnvironmentAndNoApiAccessThenProfileEnabled(){\n    assertThat(environment.getActiveProfiles()).contains(KUBERNETES_PROFILE);\n  }\n}\n",
        "abstract": "/** \n * @author Thomas Vitale\n */\n@SpringBootTest(properties\u003d{ENV_SERVICE_HOST + \"\u003d10.0.0.1\",ENV_SERVICE_PORT + \"\u003d80\",\"spring.main.cloud-platform\u003dKUBERNETES\"},classes\u003d{App.class}) class KubernetesClientProfileEnvironmentPostProcessorTests {\n  @Autowired private Environment environment;\n  @Test void whenKubernetesEnvironmentAndNoApiAccessThenProfileEnabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesInformerDiscoveryClientAutoConfiguration.java",
        "name": "KubernetesInformerDiscoveryClientAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesBlockingDiscovery @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class,KubernetesClientInformerAutoConfiguration.class,KubernetesClientInformerSelectiveNamespacesAutoConfiguration.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesInformerDiscoveryClientAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesBlockingDiscovery @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class,KubernetesClientInformerAutoConfiguration.class,KubernetesClientInformerSelectiveNamespacesAutoConfiguration.class}) public class KubernetesInformerDiscoveryClientAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesInformerDiscoveryClientAutoConfiguration.class));\n  @Deprecated(forRemoval\u003dtrue) public KubernetesInformerDiscoveryClient kubernetesInformerDiscoveryClient(  KubernetesNamespaceProvider kubernetesNamespaceProvider,  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties){\n    return new KubernetesInformerDiscoveryClient(kubernetesNamespaceProvider.getNamespace(),sharedInformerFactory,serviceLister,endpointsLister,serviceInformer,endpointsInformer,properties);\n  }\n  /** \n * Creation of this bean triggers publishing an InstanceRegisteredEvent. In turn, there is the CommonsClientAutoConfiguration::DiscoveryClientHealthIndicator, that implements \u0027ApplicationListener\u0027 that will catch this event. It also registers a bean of type DiscoveryClientHealthIndicator via ObjectProvider.\n */\n  @Bean @ConditionalOnSpringCloudKubernetesBlockingDiscoveryHealthInitializer public KubernetesDiscoveryClientHealthIndicatorInitializer indicatorInitializer(  ApplicationEventPublisher applicationEventPublisher,  PodUtils\u003c?\u003e podUtils){\n    LOG.debug(() -\u003e \"Will publish InstanceRegisteredEvent from blocking implementation\");\n    return new KubernetesDiscoveryClientHealthIndicatorInitializer(podUtils,applicationEventPublisher);\n  }\n  @Bean @ConditionalOnMissingBean @Conditional(ConditionalOnSelectiveNamespacesMissing.class) KubernetesInformerDiscoveryClient kubernetesClientInformerDiscoveryClient(  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties){\n    return new KubernetesInformerDiscoveryClient(sharedInformerFactory,serviceLister,endpointsLister,serviceInformer,endpointsInformer,properties);\n  }\n  @Bean @ConditionalOnMissingBean @Conditional(ConditionalOnSelectiveNamespacesPresent.class) KubernetesInformerDiscoveryClient selectiveNamespacesKubernetesInformerDiscoveryClient(  List\u003cSharedInformerFactory\u003e sharedInformerFactories,  List\u003cLister\u003cV1Service\u003e\u003e serviceListers,  List\u003cLister\u003cV1Endpoints\u003e\u003e endpointsListers,  List\u003cSharedInformer\u003cV1Service\u003e\u003e serviceInformers,  List\u003cSharedInformer\u003cV1Endpoints\u003e\u003e endpointsInformers,  KubernetesDiscoveryProperties properties){\n    return new KubernetesInformerDiscoveryClient(sharedInformerFactories,serviceListers,endpointsListers,serviceInformers,endpointsInformers,properties);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesBlockingDiscovery @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class,KubernetesClientInformerAutoConfiguration.class,KubernetesClientInformerSelectiveNamespacesAutoConfiguration.class}) public class KubernetesInformerDiscoveryClientAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesInformerDiscoveryClientAutoConfiguration.class));\n  @Deprecated(forRemoval\u003dtrue) public KubernetesInformerDiscoveryClient kubernetesInformerDiscoveryClient(  KubernetesNamespaceProvider kubernetesNamespaceProvider,  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties);\n  /** \n * Creation of this bean triggers publishing an InstanceRegisteredEvent. In turn, there is the CommonsClientAutoConfiguration::DiscoveryClientHealthIndicator, that implements \u0027ApplicationListener\u0027 that will catch this event. It also registers a bean of type DiscoveryClientHealthIndicator via ObjectProvider.\n */\n  @Bean @ConditionalOnSpringCloudKubernetesBlockingDiscoveryHealthInitializer public KubernetesDiscoveryClientHealthIndicatorInitializer indicatorInitializer(  ApplicationEventPublisher applicationEventPublisher,  PodUtils\u003c?\u003e podUtils);\n  @Bean @ConditionalOnMissingBean @Conditional(ConditionalOnSelectiveNamespacesMissing.class) KubernetesInformerDiscoveryClient kubernetesClientInformerDiscoveryClient(  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties);\n  @Bean @ConditionalOnMissingBean @Conditional(ConditionalOnSelectiveNamespacesPresent.class) KubernetesInformerDiscoveryClient selectiveNamespacesKubernetesInformerDiscoveryClient(  List\u003cSharedInformerFactory\u003e sharedInformerFactories,  List\u003cLister\u003cV1Service\u003e\u003e serviceListers,  List\u003cLister\u003cV1Endpoints\u003e\u003e endpointsListers,  List\u003cSharedInformer\u003cV1Service\u003e\u003e serviceInformers,  List\u003cSharedInformer\u003cV1Endpoints\u003e\u003e endpointsInformers,  KubernetesDiscoveryProperties properties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/K8sPodLabelsAndAnnotationsSupplier.java",
        "name": "K8sPodLabelsAndAnnotationsSupplier",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.K8sPodLabelsAndAnnotationsSupplier",
        "extend": "",
        "implements": "Function\u003cString,PodLabelsAndAnnotations\u003e",
        "raw": "/** \n * @author wind57\n */\nfinal class K8sPodLabelsAndAnnotationsSupplier implements Function\u003cString,PodLabelsAndAnnotations\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(K8sPodLabelsAndAnnotationsSupplier.class));\n  private final CoreV1Api coreV1Api;\n  private final String namespace;\n  private K8sPodLabelsAndAnnotationsSupplier(  CoreV1Api coreV1Api,  String namespace){\n    this.coreV1Api\u003dcoreV1Api;\n    this.namespace\u003dnamespace;\n  }\n  /** \n * to be used when .spec.type of the Service is !\u003d \u0027ExternalName\u0027.\n */\n  static K8sPodLabelsAndAnnotationsSupplier nonExternalName(  CoreV1Api coreV1Api,  String namespace){\n    return new K8sPodLabelsAndAnnotationsSupplier(coreV1Api,namespace);\n  }\n  /** \n * to be used when .spec.type of the Service is \u003d\u003d \u0027ExternalName\u0027.\n */\n  static K8sPodLabelsAndAnnotationsSupplier externalName(){\n    return new K8sPodLabelsAndAnnotationsSupplier(null,null);\n  }\n  @Override public PodLabelsAndAnnotations apply(  String podName){\n    V1ObjectMeta objectMeta;\n    try {\n      objectMeta\u003dOptional.ofNullable(coreV1Api.readNamespacedPod(podName,namespace,null).getMetadata()).orElse(new V1ObjectMetaBuilder().withLabels(Map.of()).withAnnotations(Map.of()).build());\n    }\n catch (    ApiException e) {\n      LOG.warn(e,\"Could not get pod metadata\");\n      objectMeta\u003dnew V1ObjectMetaBuilder().withLabels(Map.of()).withAnnotations(Map.of()).build();\n    }\n    return new PodLabelsAndAnnotations(Optional.ofNullable(objectMeta.getLabels()).orElse(Map.of()),Optional.ofNullable(objectMeta.getAnnotations()).orElse(Map.of()));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class K8sPodLabelsAndAnnotationsSupplier implements Function\u003cString,PodLabelsAndAnnotations\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(K8sPodLabelsAndAnnotationsSupplier.class));\n  private final CoreV1Api coreV1Api;\n  private final String namespace;\n  private K8sPodLabelsAndAnnotationsSupplier(  CoreV1Api coreV1Api,  String namespace);\n  /** \n * to be used when .spec.type of the Service is !\u003d \u0027ExternalName\u0027.\n */\n  static K8sPodLabelsAndAnnotationsSupplier nonExternalName(  CoreV1Api coreV1Api,  String namespace);\n  /** \n * to be used when .spec.type of the Service is \u003d\u003d \u0027ExternalName\u0027.\n */\n  static K8sPodLabelsAndAnnotationsSupplier externalName();\n  @Override public PodLabelsAndAnnotations apply(  String podName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/catalog/KubernetesCatalogWatch.java",
        "name": "KubernetesCatalogWatch",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.catalog.KubernetesCatalogWatch",
        "extend": "",
        "implements": "ApplicationEventPublisherAware",
        "raw": "/** \n * Catalog watch implementation for kubernetes native client.\n * @author wind57\n */\nclass KubernetesCatalogWatch implements ApplicationEventPublisherAware {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesCatalogWatch.class));\n  private final KubernetesCatalogWatchContext context;\n  private Function\u003cKubernetesCatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e stateGenerator;\n  private volatile List\u003cEndpointNameAndNamespace\u003e catalogEndpointsState\u003dnull;\n  private ApplicationEventPublisher publisher;\n  KubernetesCatalogWatch(  CoreV1Api coreV1Api,  ApiClient apiClient,  KubernetesDiscoveryProperties properties,  KubernetesNamespaceProvider namespaceProvider){\n    context\u003dnew KubernetesCatalogWatchContext(coreV1Api,apiClient,properties,namespaceProvider);\n  }\n  @Override public void setApplicationEventPublisher(  ApplicationEventPublisher publisher){\n    this.publisher\u003dpublisher;\n  }\n  @Scheduled(fixedDelayString\u003d\"${\" + CATALOG_WATCH_PROPERTY_WITH_DEFAULT_VALUE + \"}\") void catalogServicesWatch(){\n    try {\n      List\u003cEndpointNameAndNamespace\u003e currentState\u003dstateGenerator.apply(context);\n      if (!currentState.equals(catalogEndpointsState)) {\n        LOG.debug(() -\u003e \"Received endpoints update from kubernetesClient: \" + currentState);\n        publisher.publishEvent(new HeartbeatEvent(this,currentState));\n      }\n      catalogEndpointsState\u003dcurrentState;\n    }\n catch (    Exception e) {\n      LOG.error(e,() -\u003e \"Error watching Kubernetes Services\");\n    }\n  }\n  @PostConstruct void postConstruct(){\n    stateGenerator\u003dstateGenerator();\n  }\n  Function\u003cKubernetesCatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e stateGenerator(){\n    Function\u003cKubernetesCatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e localStateGenerator;\n    if (context.properties().useEndpointSlices()) {\n      ApiClient apiClient\u003dcontext.apiClient();\n      CustomObjectsApi customObjectsApi\u003dnew CustomObjectsApi(apiClient);\n      try {\n        List\u003cV1APIResource\u003e resources\u003dcustomObjectsApi.getAPIResources(DISCOVERY_GROUP,DISCOVERY_VERSION).getResources();\n        boolean found\u003dresources.stream().map(V1APIResource::getKind).anyMatch(ENDPOINT_SLICE::equals);\n        if (!found) {\n          throw new IllegalArgumentException(\"EndpointSlices are not supported on the cluster\");\n        }\n else {\n          localStateGenerator\u003dnew KubernetesEndpointSlicesCatalogWatch();\n        }\n      }\n catch (      ApiException e) {\n        throw new RuntimeException(e);\n      }\n    }\n else {\n      localStateGenerator\u003dnew KubernetesEndpointsCatalogWatch();\n    }\n    LOG.debug(() -\u003e \"stateGenerator is of type: \" + localStateGenerator.getClass().getSimpleName());\n    return localStateGenerator;\n  }\n}\n",
        "abstract": "/** \n * Catalog watch implementation for kubernetes native client.\n * @author wind57\n */\nclass KubernetesCatalogWatch implements ApplicationEventPublisherAware {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesCatalogWatch.class));\n  private final KubernetesCatalogWatchContext context;\n  private Function\u003cKubernetesCatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e stateGenerator;\n  private volatile List\u003cEndpointNameAndNamespace\u003e catalogEndpointsState\u003dnull;\n  private ApplicationEventPublisher publisher;\n  KubernetesCatalogWatch(  CoreV1Api coreV1Api,  ApiClient apiClient,  KubernetesDiscoveryProperties properties,  KubernetesNamespaceProvider namespaceProvider);\n  @Override public void setApplicationEventPublisher(  ApplicationEventPublisher publisher);\n  @Scheduled(fixedDelayString\u003d\"${\" + CATALOG_WATCH_PROPERTY_WITH_DEFAULT_VALUE + \"}\") void catalogServicesWatch();\n  @PostConstruct void postConstruct();\n  Function\u003cKubernetesCatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e stateGenerator();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/catalog/KubernetesEndpointsCatalogWatch.java",
        "name": "KubernetesEndpointsCatalogWatch",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.catalog.KubernetesEndpointsCatalogWatch",
        "extend": "",
        "implements": "Function\u003cKubernetesCatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e",
        "raw": "/** \n * Implementation that is based on V1Endpoints.\n * @author wind57\n */\nfinal class KubernetesEndpointsCatalogWatch implements Function\u003cKubernetesCatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesEndpointsCatalogWatch.class));\n  @Override public List\u003cEndpointNameAndNamespace\u003e apply(  KubernetesCatalogWatchContext context){\n    List\u003cV1Endpoints\u003e endpoints;\n    CoreV1Api coreV1Api\u003dcontext.coreV1Api();\n    if (context.properties().allNamespaces()) {\n      LOG.debug(() -\u003e \"discovering endpoints in all namespaces\");\n      endpoints\u003dendpoints(coreV1Api,context.properties().serviceLabels());\n    }\n else     if (!context.properties().namespaces().isEmpty()) {\n      LOG.debug(() -\u003e \"discovering endpoints in \" + context.properties().namespaces());\n      List\u003cV1Endpoints\u003e inner\u003dnew ArrayList\u003c\u003e(context.properties().namespaces().size());\n      context.properties().namespaces().forEach(namespace -\u003e inner.addAll(namespacedEndpoints(coreV1Api,namespace,context.properties().serviceLabels())));\n      endpoints\u003dinner;\n    }\n else {\n      String namespace\u003dKubernetesClientUtils.getApplicationNamespace(null,\"catalog-watch\",context.namespaceProvider());\n      LOG.debug(() -\u003e \"discovering endpoints in namespace : \" + namespace);\n      endpoints\u003dnamespacedEndpoints(coreV1Api,namespace,context.properties().serviceLabels());\n    }\n    Stream\u003cV1ObjectReference\u003e references\u003dendpoints.stream().map(V1Endpoints::getSubsets).filter(Objects::nonNull).flatMap(List::stream).map(V1EndpointSubset::getAddresses).filter(Objects::nonNull).flatMap(List::stream).map(V1EndpointAddress::getTargetRef);\n    return KubernetesCatalogWatchContext.state(references);\n  }\n  private List\u003cV1Endpoints\u003e endpoints(  CoreV1Api client,  Map\u003cString,String\u003e labels){\n    try {\n      return client.listEndpointsForAllNamespaces(null,null,null,labelSelector(labels),null,null,null,null,null,null,null).getItems();\n    }\n catch (    ApiException e) {\n      LOG.warn(e,() -\u003e \"can not list endpoints in all namespaces\");\n      return Collections.emptyList();\n    }\n  }\n  private List\u003cV1Endpoints\u003e namespacedEndpoints(  CoreV1Api client,  String namespace,  Map\u003cString,String\u003e labels){\n    try {\n      return client.listNamespacedEndpoints(namespace,null,null,null,null,labelSelector(labels),null,null,null,null,null,null).getItems();\n    }\n catch (    ApiException e) {\n      LOG.warn(e,() -\u003e \"can not list endpoints in namespace \" + namespace);\n      return Collections.emptyList();\n    }\n  }\n}\n",
        "abstract": "/** \n * Implementation that is based on V1Endpoints.\n * @author wind57\n */\nfinal class KubernetesEndpointsCatalogWatch implements Function\u003cKubernetesCatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesEndpointsCatalogWatch.class));\n  @Override public List\u003cEndpointNameAndNamespace\u003e apply(  KubernetesCatalogWatchContext context);\n  private List\u003cV1Endpoints\u003e endpoints(  CoreV1Api client,  Map\u003cString,String\u003e labels);\n  private List\u003cV1Endpoints\u003e namespacedEndpoints(  CoreV1Api client,  String namespace,  Map\u003cString,String\u003e labels);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/catalog/KubernetesCatalogWatchAutoConfiguration.java",
        "name": "KubernetesCatalogWatchAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesCatalogWatcherEnabled @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.catalog.KubernetesCatalogWatchAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Auto configuration for catalog watcher.\n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesCatalogWatcherEnabled @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) class KubernetesCatalogWatchAutoConfiguration {\n  @Bean @ConditionalOnMissingBean KubernetesCatalogWatch kubernetesCatalogWatch(  CoreV1Api coreV1Api,  ApiClient apiClient,  KubernetesDiscoveryProperties properties,  Environment environment){\n    return new KubernetesCatalogWatch(coreV1Api,apiClient,properties,new KubernetesNamespaceProvider(environment));\n  }\n}\n",
        "abstract": "/** \n * Auto configuration for catalog watcher.\n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesCatalogWatcherEnabled @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) class KubernetesCatalogWatchAutoConfiguration {\n  @Bean @ConditionalOnMissingBean KubernetesCatalogWatch kubernetesCatalogWatch(  CoreV1Api coreV1Api,  ApiClient apiClient,  KubernetesDiscoveryProperties properties,  Environment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/catalog/KubernetesEndpointSlicesCatalogWatch.java",
        "name": "KubernetesEndpointSlicesCatalogWatch",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.catalog.KubernetesEndpointSlicesCatalogWatch",
        "extend": "",
        "implements": "Function\u003cKubernetesCatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e",
        "raw": "/** \n * Implementation that is based on EndpointSlice V1.\n * @author wind57\n */\nfinal class KubernetesEndpointSlicesCatalogWatch implements Function\u003cKubernetesCatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesEndpointSlicesCatalogWatch.class));\n  @Override public List\u003cEndpointNameAndNamespace\u003e apply(  KubernetesCatalogWatchContext context){\n    List\u003cV1EndpointSlice\u003e endpointSlices;\n    DiscoveryV1Api api\u003dnew DiscoveryV1Api(context.apiClient());\n    if (context.properties().allNamespaces()) {\n      LOG.debug(() -\u003e \"discovering endpoint slices in all namespaces\");\n      endpointSlices\u003dendpointSlices(api,context.properties().serviceLabels());\n    }\n else     if (!context.properties().namespaces().isEmpty()) {\n      LOG.debug(() -\u003e \"discovering endpoint slices in \" + context.properties().namespaces());\n      List\u003cV1EndpointSlice\u003e inner\u003dnew ArrayList\u003c\u003e(context.properties().namespaces().size());\n      context.properties().namespaces().forEach(namespace -\u003e inner.addAll(namespacedEndpointSlices(api,namespace,context.properties().serviceLabels())));\n      endpointSlices\u003dinner;\n    }\n else {\n      String namespace\u003dKubernetesClientUtils.getApplicationNamespace(null,\"catalog-watch\",context.namespaceProvider());\n      LOG.debug(() -\u003e \"discovering endpoint slices in namespace : \" + namespace);\n      endpointSlices\u003dnamespacedEndpointSlices(api,namespace,context.properties().serviceLabels());\n    }\n    Stream\u003cV1ObjectReference\u003e references\u003dendpointSlices.stream().map(V1EndpointSlice::getEndpoints).flatMap(List::stream).map(V1Endpoint::getTargetRef);\n    return KubernetesCatalogWatchContext.state(references);\n  }\n  private List\u003cV1EndpointSlice\u003e endpointSlices(  DiscoveryV1Api api,  Map\u003cString,String\u003e labels){\n    try {\n      return api.listEndpointSliceForAllNamespaces(null,null,null,labelSelector(labels),null,null,null,null,null,null,null).getItems();\n    }\n catch (    ApiException e) {\n      LOG.warn(e,() -\u003e \"can not list endpoint slices in all namespaces\");\n      return Collections.emptyList();\n    }\n  }\n  private List\u003cV1EndpointSlice\u003e namespacedEndpointSlices(  DiscoveryV1Api api,  String namespace,  Map\u003cString,String\u003e labels){\n    try {\n      return api.listNamespacedEndpointSlice(namespace,null,null,null,null,labelSelector(labels),null,null,null,null,null,null).getItems();\n    }\n catch (    ApiException e) {\n      LOG.warn(e,() -\u003e \"can not list endpoint slices in namespace \" + namespace);\n      return Collections.emptyList();\n    }\n  }\n}\n",
        "abstract": "/** \n * Implementation that is based on EndpointSlice V1.\n * @author wind57\n */\nfinal class KubernetesEndpointSlicesCatalogWatch implements Function\u003cKubernetesCatalogWatchContext,List\u003cEndpointNameAndNamespace\u003e\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesEndpointSlicesCatalogWatch.class));\n  @Override public List\u003cEndpointNameAndNamespace\u003e apply(  KubernetesCatalogWatchContext context);\n  private List\u003cV1EndpointSlice\u003e endpointSlices(  DiscoveryV1Api api,  Map\u003cString,String\u003e labels);\n  private List\u003cV1EndpointSlice\u003e namespacedEndpointSlices(  DiscoveryV1Api api,  String namespace,  Map\u003cString,String\u003e labels);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/K8sInstanceIdHostPodNameSupplier.java",
        "name": "K8sInstanceIdHostPodNameSupplier",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.K8sInstanceIdHostPodNameSupplier",
        "extend": "",
        "implements": "Supplier\u003cInstanceIdHostPodName\u003e",
        "raw": "/** \n * @author wind57\n */\nfinal class K8sInstanceIdHostPodNameSupplier implements Supplier\u003cInstanceIdHostPodName\u003e {\n  private final V1EndpointAddress endpointAddress;\n  private final V1Service service;\n  private K8sInstanceIdHostPodNameSupplier(  V1EndpointAddress endpointAddress,  V1Service service){\n    this.endpointAddress\u003dendpointAddress;\n    this.service\u003dservice;\n  }\n  @Override public InstanceIdHostPodName get(){\n    return new InstanceIdHostPodName(instanceId(),host(),podName());\n  }\n  /** \n * to be used when .spec.type of the Service is !\u003d \u0027ExternalName\u0027.\n */\n  static K8sInstanceIdHostPodNameSupplier nonExternalName(  V1EndpointAddress endpointAddress,  V1Service service){\n    return new K8sInstanceIdHostPodNameSupplier(endpointAddress,service);\n  }\n  /** \n * to be used when .spec.type of the Service is \u003d\u003d \u0027ExternalName\u0027.\n */\n  static K8sInstanceIdHostPodNameSupplier externalName(  V1Service service){\n    return new K8sInstanceIdHostPodNameSupplier(null,service);\n  }\n  private String instanceId(){\n    return Optional.ofNullable(endpointAddress).map(V1EndpointAddress::getTargetRef).map(V1ObjectReference::getUid).orElseGet(() -\u003e service.getMetadata().getUid());\n  }\n  private String host(){\n    return Optional.ofNullable(endpointAddress).map(V1EndpointAddress::getIp).orElseGet(() -\u003e service.getSpec().getExternalName());\n  }\n  private String podName(){\n    return Optional.ofNullable(endpointAddress).map(V1EndpointAddress::getTargetRef).filter(objectReference -\u003e \"Pod\".equals(objectReference.getKind())).map(V1ObjectReference::getName).orElse(null);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class K8sInstanceIdHostPodNameSupplier implements Supplier\u003cInstanceIdHostPodName\u003e {\n  private final V1EndpointAddress endpointAddress;\n  private final V1Service service;\n  private K8sInstanceIdHostPodNameSupplier(  V1EndpointAddress endpointAddress,  V1Service service);\n  @Override public InstanceIdHostPodName get();\n  /** \n * to be used when .spec.type of the Service is !\u003d \u0027ExternalName\u0027.\n */\n  static K8sInstanceIdHostPodNameSupplier nonExternalName(  V1EndpointAddress endpointAddress,  V1Service service);\n  /** \n * to be used when .spec.type of the Service is \u003d\u003d \u0027ExternalName\u0027.\n */\n  static K8sInstanceIdHostPodNameSupplier externalName(  V1Service service);\n  private String instanceId();\n  private String host();\n  private String podName();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesClientInformerSelectiveNamespacesAutoConfiguration.java",
        "name": "KubernetesClientInformerSelectiveNamespacesAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingOrReactiveDiscoveryEnabled @Conditional(ConditionalOnSelectiveNamespacesPresent.class) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesClientInformerSelectiveNamespacesAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Auto-configuration to be used when \"spring.cloud.kubernetes.discovery.namespaces\" is defined.\n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingOrReactiveDiscoveryEnabled @Conditional(ConditionalOnSelectiveNamespacesPresent.class) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public class KubernetesClientInformerSelectiveNamespacesAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientInformerSelectiveNamespacesAutoConfiguration.class));\n  @Bean public List\u003cString\u003e selectiveNamespaces(  KubernetesDiscoveryProperties properties){\n    List\u003cString\u003e selectiveNamespaces\u003dproperties.namespaces().stream().sorted().toList();\n    LOG.debug(() -\u003e \"using selective namespaces : \" + selectiveNamespaces);\n    return selectiveNamespaces;\n  }\n  @Bean @ConditionalOnMissingBean(value\u003dSharedInformerFactory.class,parameterizedContainer\u003dList.class) public List\u003cSharedInformerFactory\u003e sharedInformerFactories(  ApiClient apiClient,  List\u003cString\u003e selectiveNamespaces){\n    int howManyNamespaces\u003dselectiveNamespaces.size();\n    List\u003cSharedInformerFactory\u003e sharedInformerFactories\u003dnew ArrayList\u003c\u003e(howManyNamespaces);\n    for (int i\u003d0; i \u003c howManyNamespaces; ++i) {\n      sharedInformerFactories.add(new SharedInformerFactory(apiClient));\n    }\n    return sharedInformerFactories;\n  }\n  @Bean @ConditionalOnMissingBean(value\u003dV1Service.class,parameterizedContainer\u003d{List.class,SharedIndexInformer.class}) public List\u003cSharedIndexInformer\u003cV1Service\u003e\u003e serviceSharedIndexInformers(  List\u003cSharedInformerFactory\u003e sharedInformerFactories,  List\u003cString\u003e selectiveNamespaces,  ApiClient apiClient){\n    int howManyNamespaces\u003dselectiveNamespaces.size();\n    List\u003cSharedIndexInformer\u003cV1Service\u003e\u003e serviceSharedIndexedInformers\u003dnew ArrayList\u003c\u003e(howManyNamespaces);\n    for (int i\u003d0; i \u003c howManyNamespaces; ++i) {\n      GenericKubernetesApi\u003cV1Service,V1ServiceList\u003e servicesApi\u003dnew GenericKubernetesApi\u003c\u003e(V1Service.class,V1ServiceList.class,\"\",\"v1\",\"services\",apiClient);\n      SharedIndexInformer\u003cV1Service\u003e sharedIndexInformer\u003dsharedInformerFactories.get(i).sharedIndexInformerFor(servicesApi,V1Service.class,0L,selectiveNamespaces.get(i));\n      serviceSharedIndexedInformers.add(sharedIndexInformer);\n    }\n    return serviceSharedIndexedInformers;\n  }\n  @Bean @ConditionalOnMissingBean(value\u003dV1Service.class,parameterizedContainer\u003d{List.class,Lister.class}) public List\u003cLister\u003cV1Service\u003e\u003e serviceListers(  List\u003cString\u003e selectiveNamespaces,  List\u003cSharedIndexInformer\u003cV1Service\u003e\u003e serviceSharedIndexInformers){\n    int howManyNamespaces\u003dselectiveNamespaces.size();\n    List\u003cLister\u003cV1Service\u003e\u003e serviceListers\u003dnew ArrayList\u003c\u003e(howManyNamespaces);\n    for (int i\u003d0; i \u003c howManyNamespaces; ++i) {\n      String namespace\u003dselectiveNamespaces.get(i);\n      Lister\u003cV1Service\u003e lister\u003dnew Lister\u003c\u003e(serviceSharedIndexInformers.get(i).getIndexer(),namespace);\n      LOG.debug(() -\u003e \"registering lister (for services) in namespace : \" + namespace);\n      serviceListers.add(lister);\n    }\n    return serviceListers;\n  }\n  @Bean @ConditionalOnMissingBean(value\u003dV1Endpoints.class,parameterizedContainer\u003d{List.class,SharedIndexInformer.class}) public List\u003cSharedIndexInformer\u003cV1Endpoints\u003e\u003e endpointsSharedIndexInformers(  List\u003cSharedInformerFactory\u003e sharedInformerFactories,  List\u003cString\u003e selectiveNamespaces,  ApiClient apiClient){\n    int howManyNamespaces\u003dselectiveNamespaces.size();\n    List\u003cSharedIndexInformer\u003cV1Endpoints\u003e\u003e endpointsSharedIndexedInformers\u003dnew ArrayList\u003c\u003e(howManyNamespaces);\n    for (int i\u003d0; i \u003c howManyNamespaces; ++i) {\n      GenericKubernetesApi\u003cV1Endpoints,V1EndpointsList\u003e endpointsApi\u003dnew GenericKubernetesApi\u003c\u003e(V1Endpoints.class,V1EndpointsList.class,\"\",\"v1\",\"endpoints\",apiClient);\n      SharedIndexInformer\u003cV1Endpoints\u003e sharedIndexInformer\u003dsharedInformerFactories.get(i).sharedIndexInformerFor(endpointsApi,V1Endpoints.class,0L,selectiveNamespaces.get(i));\n      endpointsSharedIndexedInformers.add(sharedIndexInformer);\n    }\n    return endpointsSharedIndexedInformers;\n  }\n  @Bean @ConditionalOnMissingBean(value\u003dV1Endpoints.class,parameterizedContainer\u003d{List.class,Lister.class}) public List\u003cLister\u003cV1Endpoints\u003e\u003e endpointsListers(  List\u003cString\u003e selectiveNamespaces,  List\u003cSharedIndexInformer\u003cV1Endpoints\u003e\u003e serviceSharedIndexInformers){\n    int howManyNamespaces\u003dselectiveNamespaces.size();\n    List\u003cLister\u003cV1Endpoints\u003e\u003e endpointsListers\u003dnew ArrayList\u003c\u003e(howManyNamespaces);\n    for (int i\u003d0; i \u003c howManyNamespaces; ++i) {\n      String namespace\u003dselectiveNamespaces.get(i);\n      Lister\u003cV1Endpoints\u003e lister\u003dnew Lister\u003c\u003e(serviceSharedIndexInformers.get(i).getIndexer());\n      LOG.debug(() -\u003e \"registering lister (for endpoints) in namespace : \" + namespace);\n      endpointsListers.add(lister);\n    }\n    return endpointsListers;\n  }\n}\n",
        "abstract": "/** \n * Auto-configuration to be used when \"spring.cloud.kubernetes.discovery.namespaces\" is defined.\n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingOrReactiveDiscoveryEnabled @Conditional(ConditionalOnSelectiveNamespacesPresent.class) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public class KubernetesClientInformerSelectiveNamespacesAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientInformerSelectiveNamespacesAutoConfiguration.class));\n  @Bean public List\u003cString\u003e selectiveNamespaces(  KubernetesDiscoveryProperties properties);\n  @Bean @ConditionalOnMissingBean(value\u003dSharedInformerFactory.class,parameterizedContainer\u003dList.class) public List\u003cSharedInformerFactory\u003e sharedInformerFactories(  ApiClient apiClient,  List\u003cString\u003e selectiveNamespaces);\n  @Bean @ConditionalOnMissingBean(value\u003dV1Service.class,parameterizedContainer\u003d{List.class,SharedIndexInformer.class}) public List\u003cSharedIndexInformer\u003cV1Service\u003e\u003e serviceSharedIndexInformers(  List\u003cSharedInformerFactory\u003e sharedInformerFactories,  List\u003cString\u003e selectiveNamespaces,  ApiClient apiClient);\n  @Bean @ConditionalOnMissingBean(value\u003dV1Service.class,parameterizedContainer\u003d{List.class,Lister.class}) public List\u003cLister\u003cV1Service\u003e\u003e serviceListers(  List\u003cString\u003e selectiveNamespaces,  List\u003cSharedIndexInformer\u003cV1Service\u003e\u003e serviceSharedIndexInformers);\n  @Bean @ConditionalOnMissingBean(value\u003dV1Endpoints.class,parameterizedContainer\u003d{List.class,SharedIndexInformer.class}) public List\u003cSharedIndexInformer\u003cV1Endpoints\u003e\u003e endpointsSharedIndexInformers(  List\u003cSharedInformerFactory\u003e sharedInformerFactories,  List\u003cString\u003e selectiveNamespaces,  ApiClient apiClient);\n  @Bean @ConditionalOnMissingBean(value\u003dV1Endpoints.class,parameterizedContainer\u003d{List.class,Lister.class}) public List\u003cLister\u003cV1Endpoints\u003e\u003e endpointsListers(  List\u003cString\u003e selectiveNamespaces,  List\u003cSharedIndexInformer\u003cV1Endpoints\u003e\u003e serviceSharedIndexInformers);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesDiscoveryClientUtils.java",
        "name": "KubernetesDiscoveryClientUtils",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesDiscoveryClientUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class KubernetesDiscoveryClientUtils {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesDiscoveryClientUtils.class));\n  private static final SpelExpressionParser PARSER\u003dnew SpelExpressionParser();\n  private static final SimpleEvaluationContext EVALUATION_CONTEXT\u003dSimpleEvaluationContext.forReadOnlyDataBinding().withInstanceMethods().build();\n  private KubernetesDiscoveryClientUtils(){\n  }\n  static boolean matchesServiceLabels(  V1Service service,  KubernetesDiscoveryProperties properties){\n    Map\u003cString,String\u003e propertiesServiceLabels\u003dproperties.serviceLabels();\n    Map\u003cString,String\u003e serviceLabels\u003dOptional.ofNullable(service.getMetadata()).map(V1ObjectMeta::getLabels).orElse(Map.of());\n    if (propertiesServiceLabels.isEmpty()) {\n      LOG.debug(() -\u003e \"service labels from properties are empty, service with name : \u0027\" + service.getMetadata().getName() + \"\u0027 will match\");\n      return true;\n    }\n    if (serviceLabels.isEmpty()) {\n      LOG.debug(() -\u003e \"service with name : \u0027\" + service.getMetadata().getName() + \"\u0027 does not have labels\");\n      return false;\n    }\n    LOG.debug(() -\u003e \"Service labels from properties : \" + propertiesServiceLabels);\n    LOG.debug(() -\u003e \"Service labels from service : \" + serviceLabels);\n    return serviceLabels.entrySet().containsAll(propertiesServiceLabels.entrySet());\n  }\n  static Predicate\u003cV1Service\u003e filter(  KubernetesDiscoveryProperties properties){\n    String spelExpression\u003dproperties.filter();\n    Predicate\u003cV1Service\u003e predicate;\n    if (spelExpression \u003d\u003d null || spelExpression.isEmpty()) {\n      LOG.debug(() -\u003e \"filter not defined, returning always true predicate\");\n      predicate\u003dservice -\u003e true;\n    }\n else {\n      Expression filterExpr\u003dPARSER.parseExpression(spelExpression);\n      predicate\u003dservice -\u003e {\n        Boolean include\u003dfilterExpr.getValue(EVALUATION_CONTEXT,service,Boolean.class);\n        return Optional.ofNullable(include).orElse(false);\n      }\n;\n      LOG.debug(() -\u003e \"returning predicate based on filter expression: \" + spelExpression);\n    }\n    return predicate;\n  }\n  static void postConstruct(  List\u003cSharedInformerFactory\u003e sharedInformerFactories,  KubernetesDiscoveryProperties properties,  Supplier\u003cBoolean\u003e informersReadyFunc,  List\u003cLister\u003cV1Service\u003e\u003e serviceListers){\n    sharedInformerFactories.forEach(SharedInformerFactory::startAllRegisteredInformers);\n    if (!Wait.poll(Duration.ofSeconds(1),Duration.ofSeconds(properties.cacheLoadingTimeoutSeconds()),() -\u003e {\n      LOG.info(() -\u003e \"Waiting for the cache of informers to be fully loaded..\");\n      return informersReadyFunc.get();\n    }\n)) {\n      if (properties.waitCacheReady()) {\n        throw new IllegalStateException(\"Timeout waiting for informers cache to be ready, is the kubernetes service up?\");\n      }\n else {\n        LOG.warn(() -\u003e \"Timeout waiting for informers cache to be ready, \" + \"ignoring the failure because waitForInformerCacheReady property is false\");\n      }\n    }\n else {\n      LOG.info(() -\u003e \"Cache fully loaded (total \" + serviceListers.stream().mapToLong(x -\u003e x.list().size()).sum() + \" services), discovery client is now available\");\n    }\n  }\n  static ServiceMetadata serviceMetadata(  V1Service service){\n    V1ObjectMeta metadata\u003dservice.getMetadata();\n    V1ServiceSpec serviceSpec\u003dservice.getSpec();\n    return new ServiceMetadata(metadata.getName(),metadata.getNamespace(),serviceSpec.getType(),metadata.getLabels(),metadata.getAnnotations());\n  }\n  /** \n * a service is allowed to have a single port defined without a name.\n */\n  static Map\u003cString,Integer\u003e endpointSubsetsPortData(  List\u003cV1EndpointSubset\u003e endpointSubsets){\n    return endpointSubsets.stream().flatMap(endpointSubset -\u003e Optional.ofNullable(endpointSubset.getPorts()).orElse(List.of()).stream()).collect(Collectors.toMap(endpointPort -\u003e hasText(endpointPort.getName()) ? endpointPort.getName() : UNSET_PORT_NAME,CoreV1EndpointPort::getPort));\n  }\n  static List\u003cV1EndpointAddress\u003e addresses(  V1EndpointSubset endpointSubset,  KubernetesDiscoveryProperties properties){\n    List\u003cV1EndpointAddress\u003e addresses\u003dOptional.ofNullable(endpointSubset.getAddresses()).map(ArrayList::new).orElse(new ArrayList\u003c\u003e());\n    if (properties.includeNotReadyAddresses()) {\n      List\u003cV1EndpointAddress\u003e notReadyAddresses\u003dendpointSubset.getNotReadyAddresses();\n      if (CollectionUtils.isEmpty(notReadyAddresses)) {\n        return addresses;\n      }\n      addresses.addAll(notReadyAddresses);\n    }\n    return addresses;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class KubernetesDiscoveryClientUtils {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesDiscoveryClientUtils.class));\n  private static final SpelExpressionParser PARSER\u003dnew SpelExpressionParser();\n  private static final SimpleEvaluationContext EVALUATION_CONTEXT\u003dSimpleEvaluationContext.forReadOnlyDataBinding().withInstanceMethods().build();\n  private KubernetesDiscoveryClientUtils();\n  static boolean matchesServiceLabels(  V1Service service,  KubernetesDiscoveryProperties properties);\n  static Predicate\u003cV1Service\u003e filter(  KubernetesDiscoveryProperties properties);\n  static void postConstruct(  List\u003cSharedInformerFactory\u003e sharedInformerFactories,  KubernetesDiscoveryProperties properties,  Supplier\u003cBoolean\u003e informersReadyFunc,  List\u003cLister\u003cV1Service\u003e\u003e serviceListers);\n  static ServiceMetadata serviceMetadata(  V1Service service);\n  /** \n * a service is allowed to have a single port defined without a name.\n */\n  static Map\u003cString,Integer\u003e endpointSubsetsPortData(  List\u003cV1EndpointSubset\u003e endpointSubsets);\n  static List\u003cV1EndpointAddress\u003e addresses(  V1EndpointSubset endpointSubset,  KubernetesDiscoveryProperties properties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/ConditionalOnSelectiveNamespacesPresent.java",
        "name": "ConditionalOnSelectiveNamespacesPresent",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.ConditionalOnSelectiveNamespacesPresent",
        "extend": "",
        "implements": "ConfigurationCondition",
        "raw": "/** \n * Conditional that checks if our discovery is based on selective namespaces, i.e.: \u0027spring.cloud.kubernetes.discovery.namespaces\u0027 is set.\n * @author wind57\n */\npublic final class ConditionalOnSelectiveNamespacesPresent implements ConfigurationCondition {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(ConditionalOnSelectiveNamespacesPresent.class));\n  @Override public boolean matches(  ConditionContext context,  AnnotatedTypeMetadata metadata){\n    Set\u003cString\u003e selectiveNamespaces\u003dBinder.get(context.getEnvironment()).bind(\"spring.cloud.kubernetes.discovery.namespaces\",Bindable.setOf(String.class)).orElse(Set.of());\n    boolean selectiveNamespacesPresent\u003d!selectiveNamespaces.isEmpty();\n    if (selectiveNamespacesPresent) {\n      LOG.debug(() -\u003e \"found selective namespaces : \" + selectiveNamespaces.stream().sorted().toList());\n    }\n else {\n      LOG.debug(() -\u003e \"selective namespaces not present\");\n    }\n    return selectiveNamespacesPresent;\n  }\n  @Override public ConfigurationCondition.ConfigurationPhase getConfigurationPhase(){\n    return ConfigurationPhase.REGISTER_BEAN;\n  }\n}\n",
        "abstract": "/** \n * Conditional that checks if our discovery is based on selective namespaces, i.e.: \u0027spring.cloud.kubernetes.discovery.namespaces\u0027 is set.\n * @author wind57\n */\npublic final class ConditionalOnSelectiveNamespacesPresent implements ConfigurationCondition {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(ConditionalOnSelectiveNamespacesPresent.class));\n  @Override public boolean matches(  ConditionContext context,  AnnotatedTypeMetadata metadata);\n  @Override public ConfigurationCondition.ConfigurationPhase getConfigurationPhase();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/ConditionalOnSelectiveNamespacesMissing.java",
        "name": "ConditionalOnSelectiveNamespacesMissing",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.ConditionalOnSelectiveNamespacesMissing",
        "extend": "",
        "implements": "ConfigurationCondition",
        "raw": "/** \n * Conditional that checks if our discovery is _not_ based on selective namespaces, i.e.: \u0027spring.cloud.kubernetes.discovery.namespaces\u0027 is not set.\n * @author wind57\n */\npublic final class ConditionalOnSelectiveNamespacesMissing implements ConfigurationCondition {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(ConditionalOnSelectiveNamespacesMissing.class));\n  @Override public boolean matches(  ConditionContext context,  AnnotatedTypeMetadata metadata){\n    Set\u003cString\u003e selectiveNamespaces\u003dBinder.get(context.getEnvironment()).bind(\"spring.cloud.kubernetes.discovery.namespaces\",Bindable.setOf(String.class)).orElse(Set.of());\n    boolean selectiveNamespacesMissing\u003dselectiveNamespaces.isEmpty();\n    if (selectiveNamespacesMissing) {\n      LOG.debug(() -\u003e \"selective namespaces not present\");\n    }\n else {\n      LOG.debug(() -\u003e \"found selective namespaces : \" + selectiveNamespaces.stream().sorted().toList());\n    }\n    return selectiveNamespacesMissing;\n  }\n  @Override public ConfigurationPhase getConfigurationPhase(){\n    return ConfigurationPhase.REGISTER_BEAN;\n  }\n}\n",
        "abstract": "/** \n * Conditional that checks if our discovery is _not_ based on selective namespaces, i.e.: \u0027spring.cloud.kubernetes.discovery.namespaces\u0027 is not set.\n * @author wind57\n */\npublic final class ConditionalOnSelectiveNamespacesMissing implements ConfigurationCondition {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(ConditionalOnSelectiveNamespacesMissing.class));\n  @Override public boolean matches(  ConditionContext context,  AnnotatedTypeMetadata metadata);\n  @Override public ConfigurationPhase getConfigurationPhase();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/reactive/KubernetesInformerReactiveDiscoveryClient.java",
        "name": "KubernetesInformerReactiveDiscoveryClient",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.reactive.KubernetesInformerReactiveDiscoveryClient",
        "extend": "",
        "implements": "ReactiveDiscoveryClient",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesInformerReactiveDiscoveryClient implements ReactiveDiscoveryClient {\n  private final KubernetesInformerDiscoveryClient kubernetesDiscoveryClient;\n  @Deprecated(forRemoval\u003dtrue) public KubernetesInformerReactiveDiscoveryClient(  KubernetesNamespaceProvider kubernetesNamespaceProvider,  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties){\n    this.kubernetesDiscoveryClient\u003dnew KubernetesInformerDiscoveryClient(kubernetesNamespaceProvider.getNamespace(),sharedInformerFactory,serviceLister,endpointsLister,serviceInformer,endpointsInformer,properties);\n  }\n  KubernetesInformerReactiveDiscoveryClient(  KubernetesInformerDiscoveryClient kubernetesDiscoveryClient){\n    this.kubernetesDiscoveryClient\u003dkubernetesDiscoveryClient;\n  }\n  @Override public String description(){\n    return \"Kubernetes Reactive Discovery Client\";\n  }\n  @Override public Flux\u003cServiceInstance\u003e getInstances(  String serviceId){\n    Objects.requireNonNull(serviceId,\"serviceId must be provided\");\n    return Flux.defer(() -\u003e Flux.fromIterable(kubernetesDiscoveryClient.getInstances(serviceId))).subscribeOn(Schedulers.boundedElastic());\n  }\n  @Override public Flux\u003cString\u003e getServices(){\n    return Flux.defer(() -\u003e Flux.fromIterable(kubernetesDiscoveryClient.getServices())).subscribeOn(Schedulers.boundedElastic());\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesInformerReactiveDiscoveryClient implements ReactiveDiscoveryClient {\n  private final KubernetesInformerDiscoveryClient kubernetesDiscoveryClient;\n  @Deprecated(forRemoval\u003dtrue) public KubernetesInformerReactiveDiscoveryClient(  KubernetesNamespaceProvider kubernetesNamespaceProvider,  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties);\n  KubernetesInformerReactiveDiscoveryClient(  KubernetesInformerDiscoveryClient kubernetesDiscoveryClient);\n  @Override public String description();\n  @Override public Flux\u003cServiceInstance\u003e getInstances(  String serviceId);\n  @Override public Flux\u003cString\u003e getServices();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/reactive/KubernetesInformerReactiveDiscoveryClientAutoConfiguration.java",
        "name": "KubernetesInformerReactiveDiscoveryClientAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesReactiveDiscovery @AutoConfigureBefore({SimpleReactiveDiscoveryClientAutoConfiguration.class,ReactiveCommonsClientAutoConfiguration.class}) @AutoConfigureAfter({ReactiveCompositeDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class,KubernetesClientInformerAutoConfiguration.class,KubernetesClientInformerSelectiveNamespacesAutoConfiguration.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.reactive.KubernetesInformerReactiveDiscoveryClientAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesReactiveDiscovery @AutoConfigureBefore({SimpleReactiveDiscoveryClientAutoConfiguration.class,ReactiveCommonsClientAutoConfiguration.class}) @AutoConfigureAfter({ReactiveCompositeDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class,KubernetesClientInformerAutoConfiguration.class,KubernetesClientInformerSelectiveNamespacesAutoConfiguration.class}) public class KubernetesInformerReactiveDiscoveryClientAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesInformerReactiveDiscoveryClientAutoConfiguration.class));\n  @Deprecated(forRemoval\u003dtrue) public ReactiveDiscoveryClientHealthIndicator kubernetesReactiveDiscoveryClientHealthIndicator(  KubernetesInformerReactiveDiscoveryClient client,  DiscoveryClientHealthIndicatorProperties properties,  KubernetesClientPodUtils podUtils){\n    ReactiveDiscoveryClientHealthIndicator healthIndicator\u003dnew ReactiveDiscoveryClientHealthIndicator(client,properties);\n    InstanceRegisteredEvent\u003cRegisteredEventSource\u003e event\u003dnew InstanceRegisteredEvent\u003c\u003e(new RegisteredEventSource(\"kubernetes\",podUtils.isInsideKubernetes(),podUtils.currentPod().get()),null);\n    healthIndicator.onApplicationEvent(event);\n    return healthIndicator;\n  }\n  @Deprecated(forRemoval\u003dtrue) public KubernetesInformerReactiveDiscoveryClient kubernetesReactiveDiscoveryClient(  KubernetesNamespaceProvider kubernetesNamespaceProvider,  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties){\n    return new KubernetesInformerReactiveDiscoveryClient(kubernetesNamespaceProvider,sharedInformerFactory,serviceLister,endpointsLister,serviceInformer,endpointsInformer,properties);\n  }\n  /** \n * Post an event so that health indicator is initialized.\n */\n  @Bean @ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer KubernetesDiscoveryClientHealthIndicatorInitializer reactiveIndicatorInitializer(  ApplicationEventPublisher applicationEventPublisher,  PodUtils\u003c?\u003e podUtils){\n    LOG.debug(() -\u003e \"Will publish InstanceRegisteredEvent from reactive implementation\");\n    return new KubernetesDiscoveryClientHealthIndicatorInitializer(podUtils,applicationEventPublisher);\n  }\n  /** \n * unlike the blocking implementation, we need to register the health indicator.\n */\n  @Bean @ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer ReactiveDiscoveryClientHealthIndicator kubernetesReactiveDiscoveryClientHealthIndicator(  KubernetesInformerReactiveDiscoveryClient client,  DiscoveryClientHealthIndicatorProperties properties){\n    return new ReactiveDiscoveryClientHealthIndicator(client,properties);\n  }\n  @Bean @ConditionalOnMissingBean KubernetesInformerReactiveDiscoveryClient kubernetesClientReactiveDiscoveryClient(  KubernetesInformerDiscoveryClient kubernetesClientInformerDiscoveryClient){\n    return new KubernetesInformerReactiveDiscoveryClient(kubernetesClientInformerDiscoveryClient);\n  }\n  @Bean @ConditionalOnMissingBean @Conditional(ConditionalOnSelectiveNamespacesMissing.class) KubernetesInformerDiscoveryClient kubernetesClientInformerDiscoveryClient(  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties){\n    return new KubernetesInformerDiscoveryClient(sharedInformerFactory,serviceLister,endpointsLister,serviceInformer,endpointsInformer,properties);\n  }\n  @Bean @ConditionalOnMissingBean @Conditional(ConditionalOnSelectiveNamespacesPresent.class) KubernetesInformerDiscoveryClient selectiveNamespacesKubernetesClientInformerDiscoveryClient(  List\u003cSharedInformerFactory\u003e sharedInformerFactories,  List\u003cLister\u003cV1Service\u003e\u003e serviceListers,  List\u003cLister\u003cV1Endpoints\u003e\u003e endpointsListers,  List\u003cSharedInformer\u003cV1Service\u003e\u003e serviceInformers,  List\u003cSharedInformer\u003cV1Endpoints\u003e\u003e endpointsInformers,  KubernetesDiscoveryProperties properties){\n    return new KubernetesInformerDiscoveryClient(sharedInformerFactories,serviceListers,endpointsListers,serviceInformers,endpointsInformers,properties);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesReactiveDiscovery @AutoConfigureBefore({SimpleReactiveDiscoveryClientAutoConfiguration.class,ReactiveCommonsClientAutoConfiguration.class}) @AutoConfigureAfter({ReactiveCompositeDiscoveryClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class,KubernetesClientInformerAutoConfiguration.class,KubernetesClientInformerSelectiveNamespacesAutoConfiguration.class}) public class KubernetesInformerReactiveDiscoveryClientAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesInformerReactiveDiscoveryClientAutoConfiguration.class));\n  @Deprecated(forRemoval\u003dtrue) public ReactiveDiscoveryClientHealthIndicator kubernetesReactiveDiscoveryClientHealthIndicator(  KubernetesInformerReactiveDiscoveryClient client,  DiscoveryClientHealthIndicatorProperties properties,  KubernetesClientPodUtils podUtils);\n  @Deprecated(forRemoval\u003dtrue) public KubernetesInformerReactiveDiscoveryClient kubernetesReactiveDiscoveryClient(  KubernetesNamespaceProvider kubernetesNamespaceProvider,  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties);\n  /** \n * Post an event so that health indicator is initialized.\n */\n  @Bean @ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer KubernetesDiscoveryClientHealthIndicatorInitializer reactiveIndicatorInitializer(  ApplicationEventPublisher applicationEventPublisher,  PodUtils\u003c?\u003e podUtils);\n  /** \n * unlike the blocking implementation, we need to register the health indicator.\n */\n  @Bean @ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer ReactiveDiscoveryClientHealthIndicator kubernetesReactiveDiscoveryClientHealthIndicator(  KubernetesInformerReactiveDiscoveryClient client,  DiscoveryClientHealthIndicatorProperties properties);\n  @Bean @ConditionalOnMissingBean KubernetesInformerReactiveDiscoveryClient kubernetesClientReactiveDiscoveryClient(  KubernetesInformerDiscoveryClient kubernetesClientInformerDiscoveryClient);\n  @Bean @ConditionalOnMissingBean @Conditional(ConditionalOnSelectiveNamespacesMissing.class) KubernetesInformerDiscoveryClient kubernetesClientInformerDiscoveryClient(  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties);\n  @Bean @ConditionalOnMissingBean @Conditional(ConditionalOnSelectiveNamespacesPresent.class) KubernetesInformerDiscoveryClient selectiveNamespacesKubernetesClientInformerDiscoveryClient(  List\u003cSharedInformerFactory\u003e sharedInformerFactories,  List\u003cLister\u003cV1Service\u003e\u003e serviceListers,  List\u003cLister\u003cV1Endpoints\u003e\u003e endpointsListers,  List\u003cSharedInformer\u003cV1Service\u003e\u003e serviceInformers,  List\u003cSharedInformer\u003cV1Endpoints\u003e\u003e endpointsInformers,  KubernetesDiscoveryProperties properties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesDiscoveryClientConfigClientBootstrapConfiguration.java",
        "name": "KubernetesDiscoveryClientConfigClientBootstrapConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(\"spring.cloud.config.discovery.enabled\") @Import({KubernetesClientAutoConfiguration.class,KubernetesInformerDiscoveryClientAutoConfiguration.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesDiscoveryClientConfigClientBootstrapConfiguration",
        "extend": "",
        "implements": "",
        "raw": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(\"spring.cloud.config.discovery.enabled\") @Import({KubernetesClientAutoConfiguration.class,KubernetesInformerDiscoveryClientAutoConfiguration.class}) public class KubernetesDiscoveryClientConfigClientBootstrapConfiguration {\n}\n",
        "abstract": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(\"spring.cloud.config.discovery.enabled\") @Import({KubernetesClientAutoConfiguration.class,KubernetesInformerDiscoveryClientAutoConfiguration.class}) public class KubernetesDiscoveryClientConfigClientBootstrapConfiguration {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesInformerAutoConfiguration.java",
        "name": "KubernetesInformerAutoConfiguration",
        "modifiers": "@Deprecated(forRemoval\u003dtrue) @Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingOrReactiveDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @Conditional(ConditionalOnSelectiveNamespacesMissing.class) @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesInformerAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * This configuration is not used by us internally and will be removed in a future release. Use it at your own risk.\n * @author wind57\n */\n@Deprecated(forRemoval\u003dtrue) @Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingOrReactiveDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @Conditional(ConditionalOnSelectiveNamespacesMissing.class) @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public class KubernetesInformerAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesInformerAutoConfiguration.class));\n  @Bean @ConditionalOnMissingBean public SharedInformerFactory sharedInformerFactory(  ApiClient client){\n    return new SharedInformerFactory(client);\n  }\n  @Bean @ConditionalOnMissingBean(value\u003dV1Service.class,parameterizedContainer\u003dSharedIndexInformer.class) public SharedIndexInformer\u003cV1Service\u003e servicesSharedIndexInformer(  SharedInformerFactory sharedInformerFactory,  ApiClient apiClient,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  KubernetesDiscoveryProperties discoveryProperties){\n    GenericKubernetesApi\u003cV1Service,V1ServiceList\u003e servicesApi\u003dnew GenericKubernetesApi\u003c\u003e(V1Service.class,V1ServiceList.class,\"\",\"v1\",\"services\",apiClient);\n    return sharedInformerFactory.sharedIndexInformerFor(servicesApi,V1Service.class,0L,namespace(discoveryProperties,kubernetesNamespaceProvider));\n  }\n  @Bean @ConditionalOnMissingBean(value\u003dV1Endpoints.class,parameterizedContainer\u003dSharedIndexInformer.class) public SharedIndexInformer\u003cV1Endpoints\u003e endpointsSharedIndexInformer(  SharedInformerFactory sharedInformerFactory,  ApiClient apiClient,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  KubernetesDiscoveryProperties discoveryProperties){\n    GenericKubernetesApi\u003cV1Endpoints,V1EndpointsList\u003e servicesApi\u003dnew GenericKubernetesApi\u003c\u003e(V1Endpoints.class,V1EndpointsList.class,\"\",\"v1\",\"endpoints\",apiClient);\n    return sharedInformerFactory.sharedIndexInformerFor(servicesApi,V1Endpoints.class,0L,namespace(discoveryProperties,kubernetesNamespaceProvider));\n  }\n  @Bean @ConditionalOnMissingBean(value\u003dV1Service.class,parameterizedContainer\u003dLister.class) public Lister\u003cV1Service\u003e servicesLister(  SharedIndexInformer\u003cV1Service\u003e servicesSharedIndexInformer){\n    return new Lister\u003c\u003e(servicesSharedIndexInformer.getIndexer());\n  }\n  @Bean @ConditionalOnMissingBean(value\u003dV1Endpoints.class,parameterizedContainer\u003dLister.class) public Lister\u003cV1Endpoints\u003e endpointsLister(  SharedIndexInformer\u003cV1Endpoints\u003e endpointsSharedIndexInformer){\n    return new Lister\u003c\u003e(endpointsSharedIndexInformer.getIndexer());\n  }\n  private String namespace(  KubernetesDiscoveryProperties discoveryProperties,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    String namespace;\n    if (discoveryProperties.allNamespaces()) {\n      namespace\u003dNAMESPACE_ALL;\n    }\n else     if (kubernetesNamespaceProvider.getNamespace() \u003d\u003d null) {\n      namespace\u003dNAMESPACE_DEFAULT;\n    }\n else {\n      namespace\u003dkubernetesNamespaceProvider.getNamespace();\n    }\n    LOG.debug(() -\u003e \"serviceSharedInformer will use namespace : \" + namespace);\n    return namespace;\n  }\n}\n",
        "abstract": "/** \n * This configuration is not used by us internally and will be removed in a future release. Use it at your own risk.\n * @author wind57\n */\n@Deprecated(forRemoval\u003dtrue) @Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingOrReactiveDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @Conditional(ConditionalOnSelectiveNamespacesMissing.class) @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public class KubernetesInformerAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesInformerAutoConfiguration.class));\n  @Bean @ConditionalOnMissingBean public SharedInformerFactory sharedInformerFactory(  ApiClient client);\n  @Bean @ConditionalOnMissingBean(value\u003dV1Service.class,parameterizedContainer\u003dSharedIndexInformer.class) public SharedIndexInformer\u003cV1Service\u003e servicesSharedIndexInformer(  SharedInformerFactory sharedInformerFactory,  ApiClient apiClient,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  KubernetesDiscoveryProperties discoveryProperties);\n  @Bean @ConditionalOnMissingBean(value\u003dV1Endpoints.class,parameterizedContainer\u003dSharedIndexInformer.class) public SharedIndexInformer\u003cV1Endpoints\u003e endpointsSharedIndexInformer(  SharedInformerFactory sharedInformerFactory,  ApiClient apiClient,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  KubernetesDiscoveryProperties discoveryProperties);\n  @Bean @ConditionalOnMissingBean(value\u003dV1Service.class,parameterizedContainer\u003dLister.class) public Lister\u003cV1Service\u003e servicesLister(  SharedIndexInformer\u003cV1Service\u003e servicesSharedIndexInformer);\n  @Bean @ConditionalOnMissingBean(value\u003dV1Endpoints.class,parameterizedContainer\u003dLister.class) public Lister\u003cV1Endpoints\u003e endpointsLister(  SharedIndexInformer\u003cV1Endpoints\u003e endpointsSharedIndexInformer);\n  private String namespace(  KubernetesDiscoveryProperties discoveryProperties,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesInformerDiscoveryClient.java",
        "name": "KubernetesInformerDiscoveryClient",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesInformerDiscoveryClient",
        "extend": "",
        "implements": "DiscoveryClient",
        "raw": "/** \n * @author Min Kim\n * @author Ryan Baxter\n * @author Tim Yysewyn\n */\npublic class KubernetesInformerDiscoveryClient implements DiscoveryClient {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesInformerDiscoveryClient.class));\n  private final List\u003cSharedInformerFactory\u003e sharedInformerFactories;\n  private final List\u003cLister\u003cV1Service\u003e\u003e serviceListers;\n  private final List\u003cLister\u003cV1Endpoints\u003e\u003e endpointsListers;\n  private final Supplier\u003cBoolean\u003e informersReadyFunc;\n  private final KubernetesDiscoveryProperties properties;\n  private final Predicate\u003cV1Service\u003e filter;\n  private final ServicePortSecureResolver servicePortSecureResolver;\n  @Autowired CoreV1Api coreV1Api;\n  @Deprecated(forRemoval\u003dtrue) public KubernetesInformerDiscoveryClient(  String namespace,  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties){\n    this.sharedInformerFactories\u003dList.of(sharedInformerFactory);\n    this.serviceListers\u003dList.of(serviceLister);\n    this.endpointsListers\u003dList.of(endpointsLister);\n    this.informersReadyFunc\u003d() -\u003e serviceInformer.hasSynced() \u0026\u0026 endpointsInformer.hasSynced();\n    this.properties\u003dproperties;\n    filter\u003dfilter(properties);\n    servicePortSecureResolver\u003dnew ServicePortSecureResolver(properties);\n  }\n  public KubernetesInformerDiscoveryClient(  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties){\n    this.sharedInformerFactories\u003dList.of(sharedInformerFactory);\n    this.serviceListers\u003dList.of(serviceLister);\n    this.endpointsListers\u003dList.of(endpointsLister);\n    this.informersReadyFunc\u003d() -\u003e serviceInformer.hasSynced() \u0026\u0026 endpointsInformer.hasSynced();\n    this.properties\u003dproperties;\n    filter\u003dfilter(properties);\n    servicePortSecureResolver\u003dnew ServicePortSecureResolver(properties);\n  }\n  public KubernetesInformerDiscoveryClient(  List\u003cSharedInformerFactory\u003e sharedInformerFactories,  List\u003cLister\u003cV1Service\u003e\u003e serviceListers,  List\u003cLister\u003cV1Endpoints\u003e\u003e endpointsListers,  List\u003cSharedInformer\u003cV1Service\u003e\u003e serviceInformers,  List\u003cSharedInformer\u003cV1Endpoints\u003e\u003e endpointsInformers,  KubernetesDiscoveryProperties properties){\n    this.sharedInformerFactories\u003dsharedInformerFactories;\n    this.serviceListers\u003dserviceListers;\n    this.endpointsListers\u003dendpointsListers;\n    this.informersReadyFunc\u003d() -\u003e {\n      boolean serviceInformersReady\u003dserviceInformers.isEmpty() || serviceInformers.stream().map(SharedInformer::hasSynced).reduce(Boolean::logicalAnd).orElse(false);\n      boolean endpointsInformersReady\u003dendpointsInformers.isEmpty() || endpointsInformers.stream().map(SharedInformer::hasSynced).reduce(Boolean::logicalAnd).orElse(false);\n      return serviceInformersReady \u0026\u0026 endpointsInformersReady;\n    }\n;\n    this.properties\u003dproperties;\n    filter\u003dfilter(properties);\n    servicePortSecureResolver\u003dnew ServicePortSecureResolver(properties);\n  }\n  @Override public String description(){\n    return \"Kubernetes Client Discovery\";\n  }\n  @Override public List\u003cServiceInstance\u003e getInstances(  String serviceId){\n    Objects.requireNonNull(serviceId,\"serviceId must be provided\");\n    List\u003cV1Service\u003e allServices\u003dserviceListers.stream().flatMap(x -\u003e x.list().stream()).filter(scv -\u003e scv.getMetadata() !\u003d null).filter(svc -\u003e serviceId.equals(svc.getMetadata().getName())).filter(scv -\u003e matchesServiceLabels(scv,properties)).toList();\n    List\u003cServiceInstance\u003e serviceInstances\u003dallServices.stream().filter(filter).flatMap(service -\u003e serviceInstances(service,serviceId).stream()).collect(Collectors.toCollection(ArrayList::new));\n    if (properties.includeExternalNameServices()) {\n      LOG.debug(() -\u003e \"Searching for \u0027ExternalName\u0027 type of services with serviceId : \" + serviceId);\n      List\u003cV1Service\u003e externalNameServices\u003dallServices.stream().filter(s -\u003e s.getSpec() !\u003d null).filter(s -\u003e EXTERNAL_NAME.equals(s.getSpec().getType())).toList();\n      for (      V1Service service : externalNameServices) {\n        ServiceMetadata serviceMetadata\u003dserviceMetadata(service);\n        Map\u003cString,String\u003e serviceInstanceMetadata\u003dserviceInstanceMetadata(Map.of(),serviceMetadata,properties);\n        K8sInstanceIdHostPodNameSupplier supplierOne\u003dexternalName(service);\n        K8sPodLabelsAndAnnotationsSupplier supplierTwo\u003dexternalName();\n        ServiceInstance externalNameServiceInstance\u003dserviceInstance(null,serviceMetadata,supplierOne,supplierTwo,new ServicePortNameAndNumber(-1,null),serviceInstanceMetadata,properties);\n        serviceInstances.add(externalNameServiceInstance);\n      }\n    }\n    return serviceInstances;\n  }\n  private List\u003cServiceInstance\u003e serviceInstances(  V1Service service,  String serviceId){\n    List\u003cServiceInstance\u003e instances\u003dnew ArrayList\u003c\u003e();\n    List\u003cV1Endpoints\u003e allEndpoints\u003dendpointsListers.stream().map(endpointsLister -\u003e endpointsLister.namespace(service.getMetadata().getNamespace()).get(serviceId)).filter(Objects::nonNull).toList();\n    for (    V1Endpoints endpoints : allEndpoints) {\n      List\u003cV1EndpointSubset\u003e subsets\u003dendpoints.getSubsets();\n      if (subsets \u003d\u003d null || subsets.isEmpty()) {\n        LOG.debug(() -\u003e \"serviceId : \" + serviceId + \" does not have any subsets\");\n      }\n else {\n        ServiceMetadata serviceMetadata\u003dserviceMetadata(service);\n        Map\u003cString,Integer\u003e portsData\u003dendpointSubsetsPortData(subsets);\n        Map\u003cString,String\u003e serviceInstanceMetadata\u003dserviceInstanceMetadata(portsData,serviceMetadata,properties);\n        for (        V1EndpointSubset endpointSubset : subsets) {\n          Map\u003cString,Integer\u003e endpointsPortData\u003dendpointSubsetsPortData(List.of(endpointSubset));\n          ServicePortNameAndNumber portData\u003dendpointsPort(endpointsPortData,serviceMetadata,properties);\n          List\u003cV1EndpointAddress\u003e addresses\u003daddresses(endpointSubset,properties);\n          for (          V1EndpointAddress endpointAddress : addresses) {\n            K8sInstanceIdHostPodNameSupplier supplierOne\u003dnonExternalName(endpointAddress,service);\n            K8sPodLabelsAndAnnotationsSupplier supplierTwo\u003dnonExternalName(coreV1Api,service.getMetadata().getNamespace());\n            ServiceInstance serviceInstance\u003dserviceInstance(servicePortSecureResolver,serviceMetadata,supplierOne,supplierTwo,portData,serviceInstanceMetadata,properties);\n            instances.add(serviceInstance);\n          }\n        }\n      }\n    }\n    return instances;\n  }\n  @Override public List\u003cString\u003e getServices(){\n    List\u003cString\u003e services\u003dserviceListers.stream().flatMap(serviceLister -\u003e serviceLister.list().stream()).filter(service -\u003e matchesServiceLabels(service,properties)).filter(filter).map(s -\u003e s.getMetadata().getName()).distinct().toList();\n    LOG.debug(() -\u003e \"will return services : \" + services);\n    return services;\n  }\n  @PostConstruct public void afterPropertiesSet(){\n    postConstruct(sharedInformerFactories,properties,informersReadyFunc,serviceListers);\n  }\n  @Override public int getOrder(){\n    return properties.order();\n  }\n}\n",
        "abstract": "/** \n * @author Min Kim\n * @author Ryan Baxter\n * @author Tim Yysewyn\n */\npublic class KubernetesInformerDiscoveryClient implements DiscoveryClient {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesInformerDiscoveryClient.class));\n  private final List\u003cSharedInformerFactory\u003e sharedInformerFactories;\n  private final List\u003cLister\u003cV1Service\u003e\u003e serviceListers;\n  private final List\u003cLister\u003cV1Endpoints\u003e\u003e endpointsListers;\n  private final Supplier\u003cBoolean\u003e informersReadyFunc;\n  private final KubernetesDiscoveryProperties properties;\n  private final Predicate\u003cV1Service\u003e filter;\n  private final ServicePortSecureResolver servicePortSecureResolver;\n  @Autowired CoreV1Api coreV1Api;\n  @Deprecated(forRemoval\u003dtrue) public KubernetesInformerDiscoveryClient(  String namespace,  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties);\n  public KubernetesInformerDiscoveryClient(  SharedInformerFactory sharedInformerFactory,  Lister\u003cV1Service\u003e serviceLister,  Lister\u003cV1Endpoints\u003e endpointsLister,  SharedInformer\u003cV1Service\u003e serviceInformer,  SharedInformer\u003cV1Endpoints\u003e endpointsInformer,  KubernetesDiscoveryProperties properties);\n  public KubernetesInformerDiscoveryClient(  List\u003cSharedInformerFactory\u003e sharedInformerFactories,  List\u003cLister\u003cV1Service\u003e\u003e serviceListers,  List\u003cLister\u003cV1Endpoints\u003e\u003e endpointsListers,  List\u003cSharedInformer\u003cV1Service\u003e\u003e serviceInformers,  List\u003cSharedInformer\u003cV1Endpoints\u003e\u003e endpointsInformers,  KubernetesDiscoveryProperties properties);\n  @Override public String description();\n  @Override public List\u003cServiceInstance\u003e getInstances(  String serviceId);\n  private List\u003cServiceInstance\u003e serviceInstances(  V1Service service,  String serviceId);\n  @Override public List\u003cString\u003e getServices();\n  @PostConstruct public void afterPropertiesSet();\n  @Override public int getOrder();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesClientInformerAutoConfiguration.java",
        "name": "KubernetesClientInformerAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingOrReactiveDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @Conditional(ConditionalOnSelectiveNamespacesMissing.class) @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesClientInformerAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingOrReactiveDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @Conditional(ConditionalOnSelectiveNamespacesMissing.class) @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public class KubernetesClientInformerAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientInformerAutoConfiguration.class));\n  @Bean @ConditionalOnMissingBean public SharedInformerFactory sharedInformerFactory(  ApiClient client){\n    LOG.debug(() -\u003e \"registering sharedInformerFactory for non-selective namespaces\");\n    return new SharedInformerFactory(client);\n  }\n  @Bean public String kubernetesClientNamespace(  KubernetesDiscoveryProperties properties,  KubernetesNamespaceProvider provider){\n    String namespace;\n    if (properties.allNamespaces()) {\n      namespace\u003dNAMESPACE_ALL;\n      LOG.debug(() -\u003e \"serviceSharedInformer will use all-namespaces\");\n    }\n else {\n      try {\n        namespace\u003dgetApplicationNamespace(null,\"kubernetes client discovery\",provider);\n      }\n catch (      NamespaceResolutionFailedException ex) {\n        LOG.warn(() -\u003e \"failed to resolve namespace, defaulting to :\" + NAMESPACE_DEFAULT + \". This will fail in a future release.\");\n        namespace\u003dNAMESPACE_DEFAULT;\n      }\n      LOG.debug(\"serviceSharedInformer will use namespace : \" + namespace);\n    }\n    return namespace;\n  }\n  @Bean @ConditionalOnMissingBean(value\u003dV1Service.class,parameterizedContainer\u003dSharedIndexInformer.class) public SharedIndexInformer\u003cV1Service\u003e servicesSharedIndexInformer(  SharedInformerFactory sharedInformerFactory,  ApiClient apiClient,  String kubernetesClientNamespace){\n    GenericKubernetesApi\u003cV1Service,V1ServiceList\u003e servicesApi\u003dnew GenericKubernetesApi\u003c\u003e(V1Service.class,V1ServiceList.class,\"\",\"v1\",\"services\",apiClient);\n    return sharedInformerFactory.sharedIndexInformerFor(servicesApi,V1Service.class,0L,kubernetesClientNamespace);\n  }\n  @Bean @ConditionalOnMissingBean(value\u003dV1Endpoints.class,parameterizedContainer\u003dSharedIndexInformer.class) public SharedIndexInformer\u003cV1Endpoints\u003e endpointsSharedIndexInformer(  SharedInformerFactory sharedInformerFactory,  ApiClient apiClient,  String kubernetesClientNamespace){\n    GenericKubernetesApi\u003cV1Endpoints,V1EndpointsList\u003e servicesApi\u003dnew GenericKubernetesApi\u003c\u003e(V1Endpoints.class,V1EndpointsList.class,\"\",\"v1\",\"endpoints\",apiClient);\n    return sharedInformerFactory.sharedIndexInformerFor(servicesApi,V1Endpoints.class,0L,kubernetesClientNamespace);\n  }\n  @Bean @ConditionalOnMissingBean(value\u003dV1Service.class,parameterizedContainer\u003dLister.class) public Lister\u003cV1Service\u003e servicesLister(  SharedIndexInformer\u003cV1Service\u003e servicesSharedIndexInformer,  String kubernetesClientNamespace){\n    return new Lister\u003c\u003e(servicesSharedIndexInformer.getIndexer(),kubernetesClientNamespace);\n  }\n  @Bean @ConditionalOnMissingBean(value\u003dV1Endpoints.class,parameterizedContainer\u003dLister.class) public Lister\u003cV1Endpoints\u003e endpointsLister(  SharedIndexInformer\u003cV1Endpoints\u003e endpointsSharedIndexInformer,  String kubernetesClientNamespace){\n    return new Lister\u003c\u003e(endpointsSharedIndexInformer.getIndexer(),kubernetesClientNamespace);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingOrReactiveDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @Conditional(ConditionalOnSelectiveNamespacesMissing.class) @AutoConfigureBefore({SimpleDiscoveryClientAutoConfiguration.class,CommonsClientAutoConfiguration.class}) @AutoConfigureAfter({KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class}) public class KubernetesClientInformerAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientInformerAutoConfiguration.class));\n  @Bean @ConditionalOnMissingBean public SharedInformerFactory sharedInformerFactory(  ApiClient client);\n  @Bean public String kubernetesClientNamespace(  KubernetesDiscoveryProperties properties,  KubernetesNamespaceProvider provider);\n  @Bean @ConditionalOnMissingBean(value\u003dV1Service.class,parameterizedContainer\u003dSharedIndexInformer.class) public SharedIndexInformer\u003cV1Service\u003e servicesSharedIndexInformer(  SharedInformerFactory sharedInformerFactory,  ApiClient apiClient,  String kubernetesClientNamespace);\n  @Bean @ConditionalOnMissingBean(value\u003dV1Endpoints.class,parameterizedContainer\u003dSharedIndexInformer.class) public SharedIndexInformer\u003cV1Endpoints\u003e endpointsSharedIndexInformer(  SharedInformerFactory sharedInformerFactory,  ApiClient apiClient,  String kubernetesClientNamespace);\n  @Bean @ConditionalOnMissingBean(value\u003dV1Service.class,parameterizedContainer\u003dLister.class) public Lister\u003cV1Service\u003e servicesLister(  SharedIndexInformer\u003cV1Service\u003e servicesSharedIndexInformer,  String kubernetesClientNamespace);\n  @Bean @ConditionalOnMissingBean(value\u003dV1Endpoints.class,parameterizedContainer\u003dLister.class) public Lister\u003cV1Endpoints\u003e endpointsLister(  SharedIndexInformer\u003cV1Endpoints\u003e endpointsSharedIndexInformer,  String kubernetesClientNamespace);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/ConditionalOnBlockingOrReactiveEnabled.java",
        "name": "ConditionalOnBlockingOrReactiveEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnBlockingOrReactiveEnabled.OnBlockingOrReactiveEnabled.class) @Deprecated(forRemoval\u003dtrue) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.ConditionalOnBlockingOrReactiveEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Conditional that is resolved to active when either {@link ConditionalOnBlockingDiscoveryEnabled} or{@link ConditionalOnReactiveDiscoveryEnabled} matches.\n * @deprecated in favor of {@link ConditionalOnBlockingOrReactiveDiscoveryEnabled}\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnBlockingOrReactiveEnabled.OnBlockingOrReactiveEnabled.class) @Deprecated(forRemoval\u003dtrue) public @interface ConditionalOnBlockingOrReactiveEnabled {class OnBlockingOrReactiveEnabled extends AnyNestedCondition {\n  OnBlockingOrReactiveEnabled(){\n    super(ConfigurationPhase.REGISTER_BEAN);\n  }\n@ConditionalOnBlockingDiscoveryEnabled static class OnBlockingEnabled {\n  }\n@ConditionalOnReactiveDiscoveryEnabled static class OnReactiveEnabled {\n  }\n}\n}\n",
        "abstract": "/** \n * Conditional that is resolved to active when either {@link ConditionalOnBlockingDiscoveryEnabled} or{@link ConditionalOnReactiveDiscoveryEnabled} matches.\n * @deprecated in favor of {@link ConditionalOnBlockingOrReactiveDiscoveryEnabled}\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnBlockingOrReactiveEnabled.OnBlockingOrReactiveEnabled.class) @Deprecated(forRemoval\u003dtrue) public @interface ConditionalOnBlockingOrReactiveEnabled {class OnBlockingOrReactiveEnabled extends AnyNestedCondition {\n  OnBlockingOrReactiveEnabled(){\n    super(ConfigurationPhase.REGISTER_BEAN);\n  }\n@ConditionalOnBlockingDiscoveryEnabled static class OnBlockingEnabled {\n  }\n@ConditionalOnReactiveDiscoveryEnabled static class OnReactiveEnabled {\n  }\n}\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/main/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesClientConfigServerBootstrapper.java",
        "name": "KubernetesClientConfigServerBootstrapper",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesClientConfigServerBootstrapper",
        "extend": "KubernetesConfigServerBootstrapper",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass KubernetesClientConfigServerBootstrapper extends KubernetesConfigServerBootstrapper {\n  private static final Log LOG\u003dLogFactory.getLog(KubernetesClientConfigServerBootstrapper.class);\n  @Override public void initialize(  BootstrapRegistry registry){\n    if (hasConfigServerInstanceProvider()) {\n      return;\n    }\n    registry.registerIfAbsent(KubernetesDiscoveryProperties.class,context -\u003e {\n      if (!getDiscoveryEnabled(context)) {\n        return null;\n      }\n      return createKubernetesDiscoveryProperties(context);\n    }\n);\n    registry.registerIfAbsent(KubernetesClientProperties.class,context -\u003e {\n      if (!getDiscoveryEnabled(context)) {\n        return null;\n      }\n      return createKubernetesClientProperties(context);\n    }\n);\n    registry.registerIfAbsent(ConfigServerInstanceProvider.Function.class,context -\u003e {\n      if (!getDiscoveryEnabled(context)) {\n        return (id) -\u003e Collections.emptyList();\n      }\n      if (context.isRegistered(KubernetesInformerDiscoveryClient.class)) {\n        KubernetesInformerDiscoveryClient client\u003dcontext.get(KubernetesInformerDiscoveryClient.class);\n        return client::getInstances;\n      }\n else {\n        PropertyResolver propertyResolver\u003dgetPropertyResolver(context);\n        ApiClient defaultApiClient\u003dkubernetesApiClient();\n        defaultApiClient.setUserAgent(propertyResolver.get(\"spring.cloud.kubernetes.client.user-agent\",String.class,KubernetesClientProperties.DEFAULT_USER_AGENT));\n        KubernetesClientAutoConfiguration clientAutoConfiguration\u003dnew KubernetesClientAutoConfiguration();\n        ApiClient apiClient\u003dcontext.getOrElseSupply(ApiClient.class,() -\u003e defaultApiClient);\n        KubernetesNamespaceProvider kubernetesNamespaceProvider\u003dclientAutoConfiguration.kubernetesNamespaceProvider(getNamespaceEnvironment(propertyResolver));\n        KubernetesDiscoveryProperties discoveryProperties\u003dcontext.get(KubernetesDiscoveryProperties.class);\n        String namespace\u003dgetInformerNamespace(kubernetesNamespaceProvider,discoveryProperties);\n        SharedInformerFactory sharedInformerFactory\u003dnew SharedInformerFactory(apiClient);\n        GenericKubernetesApi\u003cV1Service,V1ServiceList\u003e servicesApi\u003dnew GenericKubernetesApi\u003c\u003e(V1Service.class,V1ServiceList.class,\"\",\"v1\",\"services\",apiClient);\n        SharedIndexInformer\u003cV1Service\u003e serviceSharedIndexInformer\u003dsharedInformerFactory.sharedIndexInformerFor(servicesApi,V1Service.class,0L,namespace);\n        Lister\u003cV1Service\u003e serviceLister\u003dnew Lister\u003c\u003e(serviceSharedIndexInformer.getIndexer());\n        GenericKubernetesApi\u003cV1Endpoints,V1EndpointsList\u003e endpointsApi\u003dnew GenericKubernetesApi\u003c\u003e(V1Endpoints.class,V1EndpointsList.class,\"\",\"v1\",\"endpoints\",apiClient);\n        SharedIndexInformer\u003cV1Endpoints\u003e endpointsSharedIndexInformer\u003dsharedInformerFactory.sharedIndexInformerFor(endpointsApi,V1Endpoints.class,0L,namespace);\n        Lister\u003cV1Endpoints\u003e endpointsLister\u003dnew Lister\u003c\u003e(endpointsSharedIndexInformer.getIndexer());\n        KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(sharedInformerFactory,serviceLister,endpointsLister,serviceSharedIndexInformer,endpointsSharedIndexInformer,discoveryProperties);\n        try {\n          discoveryClient.afterPropertiesSet();\n          return discoveryClient::getInstances;\n        }\n catch (        Exception e) {\n          LOG.warn(\"Error initiating informer discovery client\",e);\n          return (serviceId) -\u003e Collections.emptyList();\n        }\n finally {\n          sharedInformerFactory.stopAllRegisteredInformers();\n        }\n      }\n    }\n);\n  }\n  private String getInformerNamespace(  KubernetesNamespaceProvider kubernetesNamespaceProvider,  KubernetesDiscoveryProperties discoveryProperties){\n    return discoveryProperties.allNamespaces() ? Namespaces.NAMESPACE_ALL : kubernetesNamespaceProvider.getNamespace() \u003d\u003d null ? Namespaces.NAMESPACE_DEFAULT : kubernetesNamespaceProvider.getNamespace();\n  }\n  private Environment getNamespaceEnvironment(  ConfigServerConfigDataLocationResolver.PropertyResolver propertyResolver){\n    return new AbstractEnvironment(){\n      @Override public String getProperty(      String key){\n        return propertyResolver.get(key,String.class,super.getProperty(key));\n      }\n    }\n;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass KubernetesClientConfigServerBootstrapper extends KubernetesConfigServerBootstrapper {\n  private static final Log LOG\u003dLogFactory.getLog(KubernetesClientConfigServerBootstrapper.class);\n  @Override public void initialize(  BootstrapRegistry registry);\n  private String getInformerNamespace(  KubernetesNamespaceProvider kubernetesNamespaceProvider,  KubernetesDiscoveryProperties discoveryProperties);\n  private Environment getNamespaceEnvironment(  ConfigServerConfigDataLocationResolver.PropertyResolver propertyResolver);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/SharedInformerFactoryStub.java",
        "name": "SharedInformerFactoryStub",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.SharedInformerFactoryStub",
        "extend": "SharedInformerFactory",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class SharedInformerFactoryStub extends SharedInformerFactory {\n  @Override public void startAllRegisteredInformers(){\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class SharedInformerFactoryStub extends SharedInformerFactory {\n  @Override public void startAllRegisteredInformers();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/catalog/KubernetesCatalogWatchEndpointsTests.java",
        "name": "KubernetesCatalogWatchEndpointsTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.catalog.KubernetesCatalogWatchEndpointsTests",
        "extend": "KubernetesEndpointsAndEndpointSlicesTests",
        "implements": "",
        "raw": "/** \n * Test cases for the Endpoints support\n * @author wind57\n */\nclass KubernetesCatalogWatchEndpointsTests extends KubernetesEndpointsAndEndpointSlicesTests {\n  private static final Boolean USE_ENDPOINT_SLICES\u003dfalse;\n  private static CoreV1Api coreV1Api;\n  public static WireMockServer wireMockServer;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    coreV1Api\u003dnew CoreV1Api(new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build());\n  }\n  @AfterAll public static void after(){\n    wireMockServer.stop();\n  }\n  @AfterEach public void afterEach(){\n    WireMock.reset();\n    Mockito.reset(APPLICATION_EVENT_PUBLISHER);\n  }\n  @Test @Override void testInAllNamespacesEmptyServiceLabels(){\n    stubFor(get(\"/api/v1/endpoints?labelSelector\u003d\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpoints(\"a\",\"default\")))));\n    KubernetesCatalogWatch watch\u003dcreateWatcherInAllNamespacesWithLabels(Map.of(),Set.of(),coreV1Api,null,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"default\")));\n  }\n  @Test @Override void testInAllNamespacesWithSingleLabel(){\n    stubFor(get(\"/api/v1/endpoints?labelSelector\u003da%3Db\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpoints(\"a\",\"default\")))));\n    KubernetesCatalogWatch watch\u003dcreateWatcherInAllNamespacesWithLabels(Map.of(\"a\",\"b\"),Set.of(),coreV1Api,null,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"default\")));\n  }\n  @Test @Override void testInAllNamespacesWithDoubleLabel(){\n    stubFor(get(\"/api/v1/endpoints?labelSelector\u003da%3Db%26c%3Dd\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpoints(\"a\",\"default\")))));\n    LinkedHashMap\u003cString,String\u003e map\u003dnew LinkedHashMap\u003c\u003e();\n    map.put(\"a\",\"b\");\n    map.put(\"c\",\"d\");\n    KubernetesCatalogWatch watch\u003dcreateWatcherInAllNamespacesWithLabels(map,Set.of(),coreV1Api,null,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"default\")));\n  }\n  @Test @Override void testInSpecificNamespacesEmptyServiceLabels(){\n    stubFor(get(\"/api/v1/namespaces/b/endpoints?labelSelector\u003d\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpoints(\"a\",\"b\")))));\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespacesWithLabels(Set.of(\"b\"),Map.of(),coreV1Api,null,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"b\")));\n  }\n  @Test @Override void testInSpecificNamespacesWithSingleLabel(){\n    stubFor(get(\"/api/v1/namespaces/one/endpoints?labelSelector\u003da%3Db\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpoints(\"aa\",\"a\")))));\n    stubFor(get(\"/api/v1/namespaces/two/endpoints?labelSelector\u003da%3Db\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpoints(\"bb\",\"b\")))));\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespacesWithLabels(Set.of(\"one\",\"two\"),Map.of(\"a\",\"b\"),coreV1Api,null,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"aa\",\"a\"),new EndpointNameAndNamespace(\"bb\",\"b\")));\n  }\n  @Test @Override void testInSpecificNamespacesWithDoubleLabel(){\n    stubFor(get(\"/api/v1/namespaces/one/endpoints?labelSelector\u003da%3Db%26c%3Dd\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpoints(\"aa\",\"a\")))));\n    stubFor(get(\"/api/v1/namespaces/two/endpoints?labelSelector\u003da%3Db%26c%3Dd\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpoints(\"bb\",\"b\")))));\n    LinkedHashMap\u003cString,String\u003e map\u003dnew LinkedHashMap\u003c\u003e();\n    map.put(\"a\",\"b\");\n    map.put(\"c\",\"d\");\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespacesWithLabels(Set.of(\"one\",\"two\"),map,coreV1Api,null,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"aa\",\"a\"),new EndpointNameAndNamespace(\"bb\",\"b\")));\n  }\n  @Test @Override void testInOneNamespaceEmptyServiceLabels(){\n    stubFor(get(\"/api/v1/namespaces/b/endpoints?labelSelector\u003d\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpoints(\"a\",\"b\")))));\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespaceWithLabels(\"b\",Map.of(),coreV1Api,null,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"b\")));\n  }\n  @Test @Override void testInOneNamespaceWithSingleLabel(){\n    stubFor(get(\"/api/v1/namespaces/b/endpoints?labelSelector\u003dkey%3Dvalue\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpoints(\"a\",\"b\")))));\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespaceWithLabels(\"b\",Map.of(\"key\",\"value\"),coreV1Api,null,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"b\")));\n  }\n  @Test @Override void testInOneNamespaceWithDoubleLabel(){\n    stubFor(get(\"/api/v1/namespaces/b/endpoints?labelSelector\u003dkey%3Dvalue%26key1%3Dvalue1\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpoints(\"a\",\"b\")))));\n    LinkedHashMap\u003cString,String\u003e map\u003dnew LinkedHashMap\u003c\u003e();\n    map.put(\"key\",\"value\");\n    map.put(\"key1\",\"value1\");\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespaceWithLabels(\"b\",map,coreV1Api,null,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"b\")));\n  }\n}\n",
        "abstract": "/** \n * Test cases for the Endpoints support\n * @author wind57\n */\nclass KubernetesCatalogWatchEndpointsTests extends KubernetesEndpointsAndEndpointSlicesTests {\n  private static final Boolean USE_ENDPOINT_SLICES\u003dfalse;\n  private static CoreV1Api coreV1Api;\n  public static WireMockServer wireMockServer;\n  @BeforeAll static void beforeAll();\n  @AfterAll public static void after();\n  @AfterEach public void afterEach();\n  @Test @Override void testInAllNamespacesEmptyServiceLabels();\n  @Test @Override void testInAllNamespacesWithSingleLabel();\n  @Test @Override void testInAllNamespacesWithDoubleLabel();\n  @Test @Override void testInSpecificNamespacesEmptyServiceLabels();\n  @Test @Override void testInSpecificNamespacesWithSingleLabel();\n  @Test @Override void testInSpecificNamespacesWithDoubleLabel();\n  @Test @Override void testInOneNamespaceEmptyServiceLabels();\n  @Test @Override void testInOneNamespaceWithSingleLabel();\n  @Test @Override void testInOneNamespaceWithDoubleLabel();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/catalog/KubernetesCatalogWatchAutoConfigurationApplicationContextTests.java",
        "name": "KubernetesCatalogWatchAutoConfigurationApplicationContextTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.catalog.KubernetesCatalogWatchAutoConfigurationApplicationContextTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Test various conditionals for  {@link KubernetesCatalogWatch}\n * @author wind57\n */\nclass KubernetesCatalogWatchAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  @Test void discoveryEnabledDefault(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(KubernetesCatalogWatch.class));\n  }\n  @Test void discoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(KubernetesCatalogWatch.class));\n  }\n  @Test void discoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e assertThat(context).doesNotHaveBean(KubernetesCatalogWatch.class));\n  }\n  @Test void kubernetesDiscoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(KubernetesCatalogWatch.class));\n  }\n  @Test void kubernetesDiscoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e assertThat(context).doesNotHaveBean(KubernetesCatalogWatch.class));\n  }\n  /** \n * both blocking and reactive configs are disabled, catalog watcher is disabled also.\n */\n  @Test void disableBlockingAndReactive(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesCatalogWatch.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(SharedInformerFactory.class);\n      assertThat(context).doesNotHaveBean(SharedIndexInformer.class);\n      assertThat(context).doesNotHaveBean(Lister.class);\n    }\n);\n  }\n  /** \n * blocking is disabled, reactive is enabled, catalog watcher is enabled.\n */\n  @Test void disableBlockingEnableReactive(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesCatalogWatch.class);\n    }\n);\n  }\n  /** \n * blocking is enabled, reactive is disabled, catalog watcher is enabled.\n */\n  @Test void enableBlockingDisableReactive(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dtrue\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesCatalogWatch.class);\n    }\n);\n  }\n  /** \n * spring.cloud.kubernetes.discovery.enabled is false, catalog watcher is disabled also.\n */\n  @Test void disableKubernetesDiscovery(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesCatalogWatch.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n    }\n);\n  }\n  private void setup(  String... properties){\n    applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesCatalogWatchAutoConfiguration.class,KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class,KubernetesCommonsAutoConfiguration.class)).withPropertyValues(properties);\n  }\n}\n",
        "abstract": "/** \n * Test various conditionals for  {@link KubernetesCatalogWatch}\n * @author wind57\n */\nclass KubernetesCatalogWatchAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  @Test void discoveryEnabledDefault();\n  @Test void discoveryEnabled();\n  @Test void discoveryDisabled();\n  @Test void kubernetesDiscoveryEnabled();\n  @Test void kubernetesDiscoveryDisabled();\n  /** \n * both blocking and reactive configs are disabled, catalog watcher is disabled also.\n */\n  @Test void disableBlockingAndReactive();\n  /** \n * blocking is disabled, reactive is enabled, catalog watcher is enabled.\n */\n  @Test void disableBlockingEnableReactive();\n  /** \n * blocking is enabled, reactive is disabled, catalog watcher is enabled.\n */\n  @Test void enableBlockingDisableReactive();\n  /** \n * spring.cloud.kubernetes.discovery.enabled is false, catalog watcher is disabled also.\n */\n  @Test void disableKubernetesDiscovery();\n  private void setup(  String... properties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/catalog/KubernetesEndpointsAndEndpointSlicesTests.java",
        "name": "KubernetesEndpointsAndEndpointSlicesTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.catalog.KubernetesEndpointsAndEndpointSlicesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * make sure that all the tests for endpoints are also handled by endpoint slices\n * @author wind57\n */\nabstract class KubernetesEndpointsAndEndpointSlicesTests {\n  static final KubernetesNamespaceProvider NAMESPACE_PROVIDER\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  static final ArgumentCaptor\u003cHeartbeatEvent\u003e HEARTBEAT_EVENT_ARGUMENT_CAPTOR\u003dArgumentCaptor.forClass(HeartbeatEvent.class);\n  static final ApplicationEventPublisher APPLICATION_EVENT_PUBLISHER\u003dMockito.mock(ApplicationEventPublisher.class);\n  /** \n * test in all namespaces with service labels being empty\n */\n  abstract void testInAllNamespacesEmptyServiceLabels();\n  /** \n * test in all namespaces with service labels having a single label present\n */\n  abstract void testInAllNamespacesWithSingleLabel();\n  /** \n * test in all namespaces with service labels having two labels\n */\n  abstract void testInAllNamespacesWithDoubleLabel();\n  /** \n * test in some specific namespaces with service labels being empty\n */\n  abstract void testInSpecificNamespacesEmptyServiceLabels();\n  /** \n * test in some specific namespaces with service labels having a single label present\n */\n  abstract void testInSpecificNamespacesWithSingleLabel();\n  /** \n * test in some specific namespaces with service labels having two labels\n */\n  abstract void testInSpecificNamespacesWithDoubleLabel();\n  /** \n * test in one namespace with service labels being empty\n */\n  abstract void testInOneNamespaceEmptyServiceLabels();\n  /** \n * test in one namespace with service labels having a single label present\n */\n  abstract void testInOneNamespaceWithSingleLabel();\n  /** \n * test in one namespace with service labels having two labels\n */\n  abstract void testInOneNamespaceWithDoubleLabel();\n  KubernetesCatalogWatch createWatcherInAllNamespacesWithLabels(  Map\u003cString,String\u003e labels,  Set\u003cString\u003e namespaces,  CoreV1Api coreV1Api,  ApiClient apiClient,  boolean endpointSlices){\n    boolean allNamespaces\u003dtrue;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60,false,\"\",Set.of(),labels,\"\",null,0,endpointSlices);\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(coreV1Api,apiClient,properties,NAMESPACE_PROVIDER);\n    if (endpointSlices) {\n      watch\u003dMockito.spy(watch);\n      Mockito.doReturn(new KubernetesEndpointSlicesCatalogWatch()).when(watch).stateGenerator();\n    }\n    watch.postConstruct();\n    watch.setApplicationEventPublisher(APPLICATION_EVENT_PUBLISHER);\n    return watch;\n  }\n  KubernetesCatalogWatch createWatcherInSpecificNamespacesWithLabels(  Set\u003cString\u003e namespaces,  Map\u003cString,String\u003e labels,  CoreV1Api coreV1Api,  ApiClient apiClient,  boolean endpointSlices){\n    boolean allNamespaces\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,namespaces,true,60,false,\"\",Set.of(),labels,\"\",null,0,false);\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(coreV1Api,apiClient,properties,NAMESPACE_PROVIDER);\n    if (endpointSlices) {\n      watch\u003dMockito.spy(watch);\n      Mockito.doReturn(new KubernetesEndpointSlicesCatalogWatch()).when(watch).stateGenerator();\n    }\n    watch.setApplicationEventPublisher(APPLICATION_EVENT_PUBLISHER);\n    watch.postConstruct();\n    return watch;\n  }\n  KubernetesCatalogWatch createWatcherInSpecificNamespaceWithLabels(  String namespace,  Map\u003cString,String\u003e labels,  CoreV1Api coreV1Api,  ApiClient apiClient,  boolean endpointSlices){\n    when(NAMESPACE_PROVIDER.getNamespace()).thenReturn(namespace);\n    boolean allNamespaces\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(),true,60,false,\"\",Set.of(),labels,\"\",null,0,endpointSlices);\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(coreV1Api,apiClient,properties,NAMESPACE_PROVIDER);\n    if (endpointSlices) {\n      watch\u003dMockito.spy(watch);\n      Mockito.doReturn(new KubernetesEndpointSlicesCatalogWatch()).when(watch).stateGenerator();\n    }\n    watch.postConstruct();\n    watch.setApplicationEventPublisher(APPLICATION_EVENT_PUBLISHER);\n    return watch;\n  }\n  V1EndpointsList endpoints(  String name,  String namespace){\n    return new V1EndpointsListBuilder().addToItems(new V1EndpointsBuilder().addToSubsets(new V1EndpointSubsetBuilder().addToAddresses(new V1EndpointAddressBuilder().withTargetRef(new V1ObjectReferenceBuilder().withName(name).withNamespace(namespace).build()).build()).build()).build()).build();\n  }\n  V1EndpointSliceList endpointSlices(  String name,  String namespace){\n    return new V1EndpointSliceListBuilder().addToItems(new V1EndpointSliceBuilder().addToEndpoints(new V1EndpointBuilder().withTargetRef(new V1ObjectReferenceBuilder().withName(name).withNamespace(namespace).build()).build()).build()).build();\n  }\n  static void invokeAndAssert(  KubernetesCatalogWatch watch,  List\u003cEndpointNameAndNamespace\u003e state){\n    watch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(HEARTBEAT_EVENT_ARGUMENT_CAPTOR.capture());\n    HeartbeatEvent event\u003dHEARTBEAT_EVENT_ARGUMENT_CAPTOR.getValue();\n    assertThat(event.getValue()).isInstanceOf(List.class);\n    assertThat(event.getValue()).isEqualTo(state);\n  }\n}\n",
        "abstract": "/** \n * make sure that all the tests for endpoints are also handled by endpoint slices\n * @author wind57\n */\nabstract class KubernetesEndpointsAndEndpointSlicesTests {\n  static final KubernetesNamespaceProvider NAMESPACE_PROVIDER\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  static final ArgumentCaptor\u003cHeartbeatEvent\u003e HEARTBEAT_EVENT_ARGUMENT_CAPTOR\u003dArgumentCaptor.forClass(HeartbeatEvent.class);\n  static final ApplicationEventPublisher APPLICATION_EVENT_PUBLISHER\u003dMockito.mock(ApplicationEventPublisher.class);\n  /** \n * test in all namespaces with service labels being empty\n */\n  abstract void testInAllNamespacesEmptyServiceLabels();\n  /** \n * test in all namespaces with service labels having a single label present\n */\n  abstract void testInAllNamespacesWithSingleLabel();\n  /** \n * test in all namespaces with service labels having two labels\n */\n  abstract void testInAllNamespacesWithDoubleLabel();\n  /** \n * test in some specific namespaces with service labels being empty\n */\n  abstract void testInSpecificNamespacesEmptyServiceLabels();\n  /** \n * test in some specific namespaces with service labels having a single label present\n */\n  abstract void testInSpecificNamespacesWithSingleLabel();\n  /** \n * test in some specific namespaces with service labels having two labels\n */\n  abstract void testInSpecificNamespacesWithDoubleLabel();\n  /** \n * test in one namespace with service labels being empty\n */\n  abstract void testInOneNamespaceEmptyServiceLabels();\n  /** \n * test in one namespace with service labels having a single label present\n */\n  abstract void testInOneNamespaceWithSingleLabel();\n  /** \n * test in one namespace with service labels having two labels\n */\n  abstract void testInOneNamespaceWithDoubleLabel();\n  KubernetesCatalogWatch createWatcherInAllNamespacesWithLabels(  Map\u003cString,String\u003e labels,  Set\u003cString\u003e namespaces,  CoreV1Api coreV1Api,  ApiClient apiClient,  boolean endpointSlices);\n  KubernetesCatalogWatch createWatcherInSpecificNamespacesWithLabels(  Set\u003cString\u003e namespaces,  Map\u003cString,String\u003e labels,  CoreV1Api coreV1Api,  ApiClient apiClient,  boolean endpointSlices);\n  KubernetesCatalogWatch createWatcherInSpecificNamespaceWithLabels(  String namespace,  Map\u003cString,String\u003e labels,  CoreV1Api coreV1Api,  ApiClient apiClient,  boolean endpointSlices);\n  V1EndpointsList endpoints(  String name,  String namespace);\n  V1EndpointSliceList endpointSlices(  String name,  String namespace);\n  static void invokeAndAssert(  KubernetesCatalogWatch watch,  List\u003cEndpointNameAndNamespace\u003e state);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/catalog/KubernetesCatalogWatchEndpointSlicesTests.java",
        "name": "KubernetesCatalogWatchEndpointSlicesTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.catalog.KubernetesCatalogWatchEndpointSlicesTests",
        "extend": "KubernetesEndpointsAndEndpointSlicesTests",
        "implements": "",
        "raw": "/** \n * Test cases for the Endpoint Slices support\n * @author wind57\n */\nclass KubernetesCatalogWatchEndpointSlicesTests extends KubernetesEndpointsAndEndpointSlicesTests {\n  private static final Boolean USE_ENDPOINT_SLICES\u003dtrue;\n  private static ApiClient apiClient;\n  public static WireMockServer wireMockServer;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    apiClient\u003dnew ClientBuilder().setBasePath(wireMockServer.baseUrl()).build();\n  }\n  @AfterAll public static void after(){\n    wireMockServer.stop();\n  }\n  @AfterEach public void afterEach(){\n    WireMock.reset();\n    Mockito.reset(APPLICATION_EVENT_PUBLISHER);\n  }\n  @Test @Override void testInAllNamespacesEmptyServiceLabels(){\n    stubFor(get(\"/apis/discovery.k8s.io/v1/endpointslices?labelSelector\u003d\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpointSlices(\"a\",\"default\")))));\n    KubernetesCatalogWatch watch\u003dcreateWatcherInAllNamespacesWithLabels(Map.of(),Set.of(),null,apiClient,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"default\")));\n  }\n  @Test @Override void testInAllNamespacesWithSingleLabel(){\n    stubFor(get(\"/apis/discovery.k8s.io/v1/endpointslices?labelSelector\u003da%3Db\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpointSlices(\"a\",\"default\")))));\n    KubernetesCatalogWatch watch\u003dcreateWatcherInAllNamespacesWithLabels(Map.of(\"a\",\"b\"),Set.of(),null,apiClient,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"default\")));\n  }\n  @Test @Override void testInAllNamespacesWithDoubleLabel(){\n    stubFor(get(\"/apis/discovery.k8s.io/v1/endpointslices?labelSelector\u003da%3Db%26c%3Dd\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpointSlices(\"a\",\"default\")))));\n    LinkedHashMap\u003cString,String\u003e map\u003dnew LinkedHashMap\u003c\u003e();\n    map.put(\"a\",\"b\");\n    map.put(\"c\",\"d\");\n    KubernetesCatalogWatch watch\u003dcreateWatcherInAllNamespacesWithLabels(map,Set.of(),null,apiClient,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"default\")));\n  }\n  @Test @Override void testInSpecificNamespacesEmptyServiceLabels(){\n    stubFor(get(\"/apis/discovery.k8s.io/v1/namespaces/b/endpointslices?labelSelector\u003d\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpointSlices(\"a\",\"b\")))));\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespacesWithLabels(Set.of(\"b\"),Map.of(),null,apiClient,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"b\")));\n  }\n  @Test @Override void testInSpecificNamespacesWithSingleLabel(){\n    stubFor(get(\"/apis/discovery.k8s.io/v1/namespaces/one/endpointslices?labelSelector\u003da%3Db\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpointSlices(\"aa\",\"a\")))));\n    stubFor(get(\"/apis/discovery.k8s.io/v1/namespaces/two/endpointslices?labelSelector\u003da%3Db\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpointSlices(\"bb\",\"b\")))));\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespacesWithLabels(Set.of(\"one\",\"two\"),Map.of(\"a\",\"b\"),null,apiClient,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"aa\",\"a\"),new EndpointNameAndNamespace(\"bb\",\"b\")));\n  }\n  @Test @Override void testInSpecificNamespacesWithDoubleLabel(){\n    stubFor(get(\"/apis/discovery.k8s.io/v1/namespaces/one/endpointslices?labelSelector\u003da%3Db%26c%3Dd\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpointSlices(\"aa\",\"a\")))));\n    stubFor(get(\"/apis/discovery.k8s.io/v1/namespaces/two/endpointslices?labelSelector\u003da%3Db%26c%3Dd\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpointSlices(\"bb\",\"b\")))));\n    LinkedHashMap\u003cString,String\u003e map\u003dnew LinkedHashMap\u003c\u003e();\n    map.put(\"a\",\"b\");\n    map.put(\"c\",\"d\");\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespacesWithLabels(Set.of(\"one\",\"two\"),map,null,apiClient,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"aa\",\"a\"),new EndpointNameAndNamespace(\"bb\",\"b\")));\n  }\n  @Test @Override void testInOneNamespaceEmptyServiceLabels(){\n    stubFor(get(\"/apis/discovery.k8s.io/v1/namespaces/b/endpointslices?labelSelector\u003d\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpointSlices(\"a\",\"b\")))));\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespaceWithLabels(\"b\",Map.of(),null,apiClient,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"b\")));\n  }\n  @Test @Override void testInOneNamespaceWithSingleLabel(){\n    stubFor(get(\"/apis/discovery.k8s.io/v1/namespaces/b/endpointslices?labelSelector\u003dkey%3Dvalue\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpointSlices(\"a\",\"b\")))));\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespaceWithLabels(\"b\",Map.of(\"key\",\"value\"),null,apiClient,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"b\")));\n  }\n  @Test @Override void testInOneNamespaceWithDoubleLabel(){\n    stubFor(get(\"/apis/discovery.k8s.io/v1/namespaces/b/endpointslices?labelSelector\u003dkey%3Dvalue%26key1%3Dvalue1\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(endpointSlices(\"a\",\"b\")))));\n    LinkedHashMap\u003cString,String\u003e map\u003dnew LinkedHashMap\u003c\u003e();\n    map.put(\"key\",\"value\");\n    map.put(\"key1\",\"value1\");\n    KubernetesCatalogWatch watch\u003dcreateWatcherInSpecificNamespaceWithLabels(\"b\",map,null,apiClient,USE_ENDPOINT_SLICES);\n    invokeAndAssert(watch,List.of(new EndpointNameAndNamespace(\"a\",\"b\")));\n  }\n}\n",
        "abstract": "/** \n * Test cases for the Endpoint Slices support\n * @author wind57\n */\nclass KubernetesCatalogWatchEndpointSlicesTests extends KubernetesEndpointsAndEndpointSlicesTests {\n  private static final Boolean USE_ENDPOINT_SLICES\u003dtrue;\n  private static ApiClient apiClient;\n  public static WireMockServer wireMockServer;\n  @BeforeAll static void beforeAll();\n  @AfterAll public static void after();\n  @AfterEach public void afterEach();\n  @Test @Override void testInAllNamespacesEmptyServiceLabels();\n  @Test @Override void testInAllNamespacesWithSingleLabel();\n  @Test @Override void testInAllNamespacesWithDoubleLabel();\n  @Test @Override void testInSpecificNamespacesEmptyServiceLabels();\n  @Test @Override void testInSpecificNamespacesWithSingleLabel();\n  @Test @Override void testInSpecificNamespacesWithDoubleLabel();\n  @Test @Override void testInOneNamespaceEmptyServiceLabels();\n  @Test @Override void testInOneNamespaceWithSingleLabel();\n  @Test @Override void testInOneNamespaceWithDoubleLabel();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/catalog/KubernetesCatalogWatchContextTests.java",
        "name": "KubernetesCatalogWatchContextTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.catalog.KubernetesCatalogWatchContextTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesCatalogWatchContextTests {\n  @Test void emptyLabels(){\n    String result\u003dKubernetesCatalogWatchContext.labelSelector(Map.of());\n    Assertions.assertEquals(\"\",result);\n  }\n  @Test void singleLabel(){\n    String result\u003dKubernetesCatalogWatchContext.labelSelector(Map.of(\"a\",\"b\"));\n    Assertions.assertEquals(\"a\u003db\",result);\n  }\n  @Test void multipleLabelsLabel(){\n    String result\u003dKubernetesCatalogWatchContext.labelSelector(Map.of(\"a\",\"b\",\"c\",\"d\"));\n    Assertions.assertTrue(result.contains(\"c\u003dd\"));\n    Assertions.assertTrue(result.contains(\"\u0026\"));\n    Assertions.assertTrue(result.contains(\"a\u003db\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesCatalogWatchContextTests {\n  @Test void emptyLabels();\n  @Test void singleLabel();\n  @Test void multipleLabelsLabel();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/catalog/KubernetesClientCatalogWatchEndpointSlicesSupportTests.java",
        "name": "KubernetesClientCatalogWatchEndpointSlicesSupportTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.catalog.KubernetesClientCatalogWatchEndpointSlicesSupportTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Tests that only assert the needed support for EndpointSlices in the cluster.\n * @author wind57\n */\nclass KubernetesClientCatalogWatchEndpointSlicesSupportTests {\n  public static WireMockServer wireMockServer;\n  private static final KubernetesNamespaceProvider NAMESPACE_PROVIDER\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  private static ApiClient apiClient;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    apiClient\u003dnew ClientBuilder().setBasePath(wireMockServer.baseUrl()).build();\n  }\n  @AfterAll public static void after(){\n    wireMockServer.stop();\n  }\n  @AfterEach public void afterEach(){\n    WireMock.reset();\n  }\n  /** \n * \u003cpre\u003e - endpoint slices are enabled, but are not supported by the cluster, as such we will fail with an IllegalArgumentException - V1APIResource is empty \u003c/pre\u003e\n */\n  @Test void testEndpointSlicesEnabledButNotSupported(){\n    boolean useEndpointSlices\u003dtrue;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,\"\",Set.of(),Map.of(),\"\",null,0,useEndpointSlices);\n    V1APIResourceList list\u003dnew V1APIResourceListBuilder().addToResources(new V1APIResource()).build();\n    stubFor(get(\"/apis/discovery.k8s.io/v1\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(list))));\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(null,apiClient,properties,NAMESPACE_PROVIDER);\n    IllegalArgumentException ex\u003dAssertions.assertThrows(IllegalArgumentException.class,watch::postConstruct);\n    Assertions.assertEquals(\"EndpointSlices are not supported on the cluster\",ex.getMessage());\n  }\n  /** \n * \u003cpre\u003e - endpoint slices are enabled, but are not supported by the cluster, as such we will fail with an IllegalArgumentException - V1APIResource does not contain EndpointSlice \u003c/pre\u003e\n */\n  @Test void testEndpointSlicesEnabledButNotSupportedViaApiVersions(){\n    boolean useEndpointSlices\u003dtrue;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,\"\",Set.of(),Map.of(),\"\",null,0,useEndpointSlices);\n    V1APIResourceList list\u003dnew V1APIResourceListBuilder().addToResources(new V1APIResourceBuilder().withName(\"not-the-one\").build()).build();\n    stubFor(get(\"/apis/discovery.k8s.io/v1\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(list))));\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(null,apiClient,properties,NAMESPACE_PROVIDER);\n    IllegalArgumentException ex\u003dAssertions.assertThrows(IllegalArgumentException.class,watch::postConstruct);\n    Assertions.assertEquals(\"EndpointSlices are not supported on the cluster\",ex.getMessage());\n  }\n  /** \n * endpoint slices are disabled via properties, as such we will use a catalog watch based on Endpoints\n */\n  @Test void testEndpointsSupport(){\n    boolean useEndpointSlices\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,\"\",Set.of(),Map.of(),\"\",null,0,useEndpointSlices);\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(null,apiClient,properties,NAMESPACE_PROVIDER);\n    Assertions.assertEquals(KubernetesEndpointsCatalogWatch.class,watch.stateGenerator().getClass());\n  }\n  /** \n * endpoint slices are enabled via properties and supported by the cluster, as such we will use a catalog watch based on Endpoint Slices\n */\n  @Test void testEndpointSlicesSupport(){\n    boolean useEndpointSlices\u003dtrue;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,\"\",Set.of(),Map.of(),\"\",null,0,useEndpointSlices);\n    V1APIResourceList list\u003dnew V1APIResourceListBuilder().addToResources(new V1APIResourceBuilder().withName(\"endpointslices\").withKind(ENDPOINT_SLICE).build()).build();\n    stubFor(get(\"/apis/discovery.k8s.io/v1\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(list))));\n    KubernetesCatalogWatch watch\u003dnew KubernetesCatalogWatch(null,apiClient,properties,NAMESPACE_PROVIDER);\n    Assertions.assertEquals(KubernetesEndpointSlicesCatalogWatch.class,watch.stateGenerator().getClass());\n  }\n}\n",
        "abstract": "/** \n * Tests that only assert the needed support for EndpointSlices in the cluster.\n * @author wind57\n */\nclass KubernetesClientCatalogWatchEndpointSlicesSupportTests {\n  public static WireMockServer wireMockServer;\n  private static final KubernetesNamespaceProvider NAMESPACE_PROVIDER\u003dMockito.mock(KubernetesNamespaceProvider.class);\n  private static ApiClient apiClient;\n  @BeforeAll static void beforeAll();\n  @AfterAll public static void after();\n  @AfterEach public void afterEach();\n  /** \n * \u003cpre\u003e - endpoint slices are enabled, but are not supported by the cluster, as such we will fail with an IllegalArgumentException - V1APIResource is empty \u003c/pre\u003e\n */\n  @Test void testEndpointSlicesEnabledButNotSupported();\n  /** \n * \u003cpre\u003e - endpoint slices are enabled, but are not supported by the cluster, as such we will fail with an IllegalArgumentException - V1APIResource does not contain EndpointSlice \u003c/pre\u003e\n */\n  @Test void testEndpointSlicesEnabledButNotSupportedViaApiVersions();\n  /** \n * endpoint slices are disabled via properties, as such we will use a catalog watch based on Endpoints\n */\n  @Test void testEndpointsSupport();\n  /** \n * endpoint slices are enabled via properties and supported by the cluster, as such we will use a catalog watch based on Endpoint Slices\n */\n  @Test void testEndpointSlicesSupport();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesDiscoveryClientTests.java",
        "name": "KubernetesDiscoveryClientTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesDiscoveryClientTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryClientTests {\n  private static final SharedInformerFactoryStub STUB\u003dnew SharedInformerFactoryStub();\n  private static final SharedInformerStub\u003cV1Service\u003e SERVICE_SHARED_INFORMER_STUB\u003dnew SharedInformerStub\u003c\u003e();\n  private static final SharedInformerStub\u003cV1Endpoints\u003e ENDPOINTS_SHARED_INFORMER_STUB\u003dnew SharedInformerStub\u003c\u003e();\n  private Cache\u003cV1Service\u003e servicesCache;\n  private Lister\u003cV1Service\u003e servicesLister;\n  private Cache\u003cV1Endpoints\u003e endpointsCache;\n  private Lister\u003cV1Endpoints\u003e endpointsLister;\n  @BeforeEach void beforeEach(){\n    servicesCache\u003dnew Cache\u003c\u003e();\n    servicesLister\u003dnew Lister\u003c\u003e(servicesCache);\n    endpointsCache\u003dnew Cache\u003c\u003e();\n    endpointsLister\u003dnew Lister\u003c\u003e(endpointsCache);\n  }\n  @Test void getInstancesShouldBeAbleToHandleEndpointsSingleAddress(){\n    Map\u003cString,String\u003e labels\u003dMap.of(\"l\",\"v\");\n    String serviceId\u003d\"id\";\n    String serviceType\u003d\"ExternalName\";\n    String namespace\u003d\"test\";\n    List\u003cString\u003e ips\u003dList.of(\"ip1\");\n    List\u003cString\u003e uuids\u003dList.of(\"10\");\n    List\u003cString\u003e names\u003dList.of(\"http\");\n    List\u003cString\u003e protocols\u003dList.of(\"TCP\");\n    List\u003cInteger\u003e ports\u003dList.of(80);\n    List\u003cString\u003e appProtocols\u003dList.of(\"appTCP\");\n    setup(serviceId,serviceType,namespace,labels,ips,uuids,names,protocols,ports,appProtocols);\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,null,false,null,false,null);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"id\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 !s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"10\")).hasSize(1);\n  }\n  @Test void getInstancesShouldBeAbleToHandleEndpointsSingleAddressAndMultiplePorts(){\n    Map\u003cString,String\u003e labels\u003dMap.of(\"l2\",\"v2\");\n    String serviceId\u003d\"endpoint\";\n    String serviceType\u003d\"ExternalName\";\n    String namespace\u003d\"test\";\n    List\u003cString\u003e ips\u003dList.of(\"ip1\");\n    List\u003cString\u003e uuids\u003dList.of(\"20\");\n    List\u003cString\u003e names\u003dList.of(\"http\",\"mgmt\");\n    List\u003cString\u003e protocols\u003dList.of(\"TCP\",\"TCP\");\n    List\u003cInteger\u003e ports\u003dList.of(80,900);\n    List\u003cString\u003e appProtocols\u003dList.of(\"http_tcp\",\"mgmt_tcp\");\n    setup(serviceId,serviceType,namespace,labels,ips,uuids,names,protocols,ports,appProtocols);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),labels,\"http_tcp\",KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 !s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"20\")).hasSize(1).filteredOn(s -\u003e 80 \u003d\u003d s.getPort()).hasSize(1);\n  }\n  @Test void getInstancesShouldBeAbleToHandleEndpointsMultipleAddresses(){\n    Map\u003cString,String\u003e labels\u003dMap.of(\"l1\",\"v1\");\n    String serviceId\u003d\"endpoint\";\n    String serviceType\u003d\"ExternalName\";\n    String namespace\u003d\"test\";\n    List\u003cString\u003e ips\u003dList.of(\"ip1\",\"ip2\");\n    List\u003cString\u003e uuids\u003dList.of(\"40\",\"50\");\n    List\u003cString\u003e names\u003dList.of(\"https\");\n    List\u003cString\u003e protocols\u003dList.of(\"TCP\");\n    List\u003cInteger\u003e ports\u003dList.of(443);\n    List\u003cString\u003e appProtocols\u003dList.of(\"https_tcp\");\n    setup(serviceId,serviceType,namespace,labels,ips,uuids,names,protocols,ports,appProtocols);\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,null,false,null,true,\"port.\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(443,8443),labels,null,metadata,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint\");\n    assertThat(instances).hasSize(2).filteredOn(ServiceInstance::isSecure).extracting(ServiceInstance::getHost).containsOnly(\"ip1\",\"ip2\");\n  }\n  @Test void getInstancesShouldBeAbleToHandleEndpointsFromMultipleNamespaces(){\n    Map\u003cString,String\u003e labels\u003dMap.of(\"l\",\"v\");\n    String serviceId\u003d\"endpoint\";\n    String serviceType\u003d\"ExternalName\";\n    String namespace\u003d\"test\";\n    List\u003cString\u003e ips\u003dList.of(\"ip1\");\n    List\u003cString\u003e uuids\u003dList.of(\"60\");\n    List\u003cString\u003e names\u003dList.of(\"http\");\n    List\u003cString\u003e protocols\u003dList.of(\"TCP\");\n    List\u003cInteger\u003e ports\u003dList.of(80);\n    List\u003cString\u003e appProtocols\u003dList.of(\"https_tcp\");\n    setup(serviceId,serviceType,namespace,labels,ips,uuids,names,protocols,ports,appProtocols);\n    ips\u003dList.of(\"ip2\");\n    uuids\u003dList.of(\"70\");\n    namespace\u003d\"test2\";\n    setup(serviceId,serviceType,namespace,labels,ips,uuids,names,protocols,ports,appProtocols);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint\");\n    assertThat(instances).hasSize(2);\n    assertThat(instances).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 !s.isSecure()).hasSize(1);\n    assertThat(instances).filteredOn(s -\u003e s.getHost().equals(\"ip2\") \u0026\u0026 !s.isSecure()).hasSize(1);\n    assertThat(instances).filteredOn(s -\u003e s.getServiceId().contains(\"endpoint\") \u0026\u0026 ((KubernetesServiceInstance)s).getNamespace().equals(\"test\")).hasSize(1);\n    assertThat(instances).filteredOn(s -\u003e s.getServiceId().contains(\"endpoint\") \u0026\u0026 ((KubernetesServiceInstance)s).getNamespace().equals(\"test2\")).hasSize(1);\n    assertThat(instances).filteredOn(s -\u003e s.getInstanceId().equals(\"60\")).hasSize(1);\n    assertThat(instances).filteredOn(s -\u003e s.getInstanceId().equals(\"70\")).hasSize(1);\n  }\n  @Test void instanceWithoutSubsetsShouldBeSkipped(){\n    V1Endpoints endpoints\u003dnew V1EndpointsBuilder().withNewMetadata().withName(\"endpoint1\").withNamespace(\"test\").withLabels(Collections.emptyMap()).endMetadata().build();\n    endpointsCache.add(endpoints);\n    V1Service service\u003dnew V1ServiceBuilder().withNewMetadata().withName(\"endpoint1\").withNamespace(\"test\").and().build();\n    servicesCache.add(service);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint1\");\n    assertThat(instances).isEmpty();\n  }\n  @Test void getInstancesShouldBeAbleToHandleEndpointsSingleAddressAndMultiplePortsUsingPrimaryPortNameLabel(){\n    Map\u003cString,String\u003e labels\u003dMap.of(\"primary-port-name\",\"https\");\n    String serviceId\u003d\"endpoint2\";\n    String serviceType\u003d\"ExternalName\";\n    String namespace\u003d\"test\";\n    List\u003cString\u003e ips\u003dList.of(\"ip1\");\n    List\u003cString\u003e uuids\u003dList.of(\"80\");\n    List\u003cString\u003e names\u003dList.of(\"http\",\"https\");\n    List\u003cString\u003e protocols\u003dList.of(\"TCP\",\"TCP\");\n    List\u003cInteger\u003e ports\u003dList.of(80,443);\n    List\u003cString\u003e appProtocols\u003dList.of(\"http\",\"https\");\n    setup(serviceId,serviceType,namespace,labels,ips,uuids,names,protocols,ports,appProtocols);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint2\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"80\")).hasSize(1).filteredOn(s -\u003e 443 \u003d\u003d s.getPort()).hasSize(1);\n  }\n  @Test void instanceWithMultiplePortsAndMisconfiguredPrimaryPortNameInLabelWithoutFallbackShouldLogWarning(){\n    Map\u003cString,String\u003e labels\u003dMap.of(\"primary-port-name\",\"oops\");\n    String serviceId\u003d\"endpoint3\";\n    String serviceType\u003d\"ExternalName\";\n    String namespace\u003d\"test\";\n    List\u003cString\u003e ips\u003dList.of(\"ip1\");\n    List\u003cString\u003e uuids\u003dList.of(\"90\");\n    List\u003cString\u003e names\u003dList.of(\"httpA\",\"httpB\",\"httpC\",\"httpD\");\n    List\u003cString\u003e protocols\u003dList.of(\"TCP\",\"TCP\",\"TCP\",\"TCP\");\n    List\u003cInteger\u003e ports\u003dList.of(8443,443,80,8080);\n    List\u003cString\u003e appProtocols\u003dList.of(\"https1\",\"https2\",\"http1\",\"http2\");\n    setup(serviceId,serviceType,namespace,labels,ips,uuids,names,protocols,ports,appProtocols);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint3\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"90\")).hasSize(1).hasSize(1);\n  }\n  @Test void instanceWithMultiplePortsAndMisconfiguredGenericPrimaryPortNameWithoutFallbackShouldLogWarning(){\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    String serviceId\u003d\"endpoint4\";\n    String serviceType\u003d\"ExternalName\";\n    String namespace\u003d\"test\";\n    List\u003cString\u003e ips\u003dList.of(\"ip1\");\n    List\u003cString\u003e uuids\u003dList.of(\"100\");\n    List\u003cString\u003e names\u003dList.of(\"httpA\",\"httpB\",\"httpC\",\"httpD\");\n    List\u003cString\u003e protocols\u003dList.of(\"TCP\",\"TCP\",\"TCP\",\"TCP\");\n    List\u003cInteger\u003e ports\u003dList.of(8443,443,80,8080);\n    List\u003cString\u003e appProtocols\u003dList.of(\"https1\",\"https2\",\"http1\",\"http2\");\n    setup(serviceId,serviceType,namespace,labels,ips,uuids,names,protocols,ports,appProtocols);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),\"oops\",KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint4\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"100\")).hasSize(1).hasSize(1);\n  }\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedShouldFallBackToHttps(){\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    String serviceId\u003d\"endpoint5\";\n    String serviceType\u003d\"ExternalName\";\n    String namespace\u003d\"test\";\n    List\u003cString\u003e ips\u003dList.of(\"ip1\");\n    List\u003cString\u003e uuids\u003dList.of(\"110\");\n    List\u003cString\u003e names\u003dList.of(\"httpA\",\"httpB\");\n    List\u003cString\u003e protocols\u003dList.of(\"TCP\",\"TCP\");\n    List\u003cInteger\u003e ports\u003dList.of(443,80);\n    List\u003cString\u003e appProtocols\u003dList.of(\"http\",\"https\");\n    setup(serviceId,serviceType,namespace,labels,ips,uuids,names,protocols,ports,appProtocols);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint5\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"110\")).hasSize(1).filteredOn(s -\u003e 443 \u003d\u003d s.getPort()).hasSize(1);\n  }\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedOrHttpsPortShouldFallBackToHttp(){\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    String serviceId\u003d\"endpoint5\";\n    String serviceType\u003d\"ExternalName\";\n    String namespace\u003d\"test\";\n    List\u003cString\u003e ips\u003dList.of(\"ip1\");\n    List\u003cString\u003e uuids\u003dList.of(\"120\");\n    List\u003cString\u003e names\u003dList.of(\"httpA\",\"httpB\",\"httpC\");\n    List\u003cString\u003e protocols\u003dList.of(\"http\",\"http\",\"http\");\n    List\u003cInteger\u003e ports\u003dList.of(80,8443,80);\n    List\u003cString\u003e appProtocols\u003dList.of(\"TCP\",\"TCP\",\"TCP\");\n    setup(serviceId,serviceType,namespace,labels,ips,uuids,names,protocols,ports,appProtocols);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,KubernetesDiscoveryProperties.DEFAULT);\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint5\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 !s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"120\")).hasSize(1).filteredOn(s -\u003e 80 \u003d\u003d s.getPort()).hasSize(1);\n  }\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedShouldLogWarning(){\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    String serviceId\u003d\"endpoint5\";\n    String serviceType\u003d\"ExternalName\";\n    String namespace\u003d\"test\";\n    List\u003cString\u003e ips\u003dList.of(\"ip1\");\n    List\u003cString\u003e uuids\u003dList.of(\"130\");\n    List\u003cString\u003e names\u003dList.of(\"http\",\"https\");\n    List\u003cString\u003e protocols\u003dList.of(\"http\",\"https\");\n    List\u003cInteger\u003e ports\u003dList.of(80,443);\n    List\u003cString\u003e appProtocols\u003dList.of(\"TCP\",\"TCP\");\n    setup(serviceId,serviceType,namespace,labels,ips,uuids,names,protocols,ports,appProtocols);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,true,null,Set.of(443,8443),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint5\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getInstanceId().equals(\"130\")).hasSize(1).filteredOn(s -\u003e 443 \u003d\u003d s.getPort()).hasSize(1);\n  }\n  @Test public void instanceWithoutPorts(){\n    Map\u003cString,String\u003e labels\u003dMap.of();\n    String serviceId\u003d\"endpoint5\";\n    String serviceType\u003d\"ExternalName\";\n    String namespace\u003d\"test\";\n    List\u003cString\u003e ips\u003dList.of(\"ip1\");\n    List\u003cString\u003e uuids\u003dList.of(\"130\");\n    List\u003cString\u003e names\u003dList.of();\n    List\u003cString\u003e protocols\u003dList.of();\n    List\u003cInteger\u003e ports\u003dList.of();\n    List\u003cString\u003e appProtocols\u003dList.of();\n    setup(serviceId,serviceType,namespace,labels,ips,uuids,names,protocols,ports,appProtocols);\n    KubernetesDiscoveryProperties properties\u003dKubernetesDiscoveryProperties.DEFAULT;\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(\"endpoint5\");\n    assertThat(instances).hasSize(1).filteredOn(s -\u003e s.getHost().equals(\"ip1\") \u0026\u0026 !s.isSecure()).hasSize(1).filteredOn(s -\u003e s.getUri().toASCIIString().equals(\"http://ip1\")).filteredOn(s -\u003e s.getInstanceId().equals(\"130\")).hasSize(1).filteredOn(s -\u003e 0 \u003d\u003d s.getPort()).hasSize(1);\n  }\n  private void setup(  String serviceId,  String serviceType,  String namespace,  Map\u003cString,String\u003e labels,  List\u003cString\u003e ips,  List\u003cString\u003e uuids,  List\u003cString\u003e names,  List\u003cString\u003e protocols,  List\u003cInteger\u003e ports,  List\u003cString\u003e appProtocols){\n    V1Service service\u003dnew V1ServiceBuilder().withSpec(new V1ServiceSpecBuilder().withType(serviceType).build()).withNewMetadata().withName(serviceId).withNamespace(namespace).withLabels(labels).endMetadata().build();\n    servicesCache.add(service);\n    V1ObjectMeta objectMeta\u003dnew V1ObjectMeta();\n    objectMeta.setNamespace(namespace);\n    objectMeta.setName(serviceId);\n    V1Endpoints endpoints\u003dnew V1EndpointsBuilder().withNewMetadata().withName(serviceId).withNamespace(namespace).withLabels(labels).endMetadata().build();\n    List\u003cV1EndpointAddress\u003e addresses\u003dnew ArrayList\u003c\u003e();\n    for (int i\u003d0; i \u003c ips.size(); ++i) {\n      V1EndpointAddress address\u003dnew V1EndpointAddressBuilder().withIp(ips.get(i)).withNewTargetRef().withUid(uuids.get(i)).endTargetRef().build();\n      addresses.add(address);\n    }\n    V1EndpointSubset subset\u003dnew V1EndpointSubset();\n    subset.setAddresses(addresses);\n    List\u003cCoreV1EndpointPort\u003e corePorts\u003dnew ArrayList\u003c\u003e();\n    for (int i\u003d0; i \u003c names.size(); ++i) {\n      CoreV1EndpointPort port\u003dnew CoreV1EndpointPortBuilder().withName(names.get(i)).withProtocol(protocols.get(i)).withPort(ports.get(i)).withAppProtocol(appProtocols.get(i)).build();\n      corePorts.add(port);\n    }\n    subset.setPorts(corePorts);\n    endpoints.setSubsets(List.of(subset));\n    endpointsCache.add(endpoints);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryClientTests {\n  private static final SharedInformerFactoryStub STUB\u003dnew SharedInformerFactoryStub();\n  private static final SharedInformerStub\u003cV1Service\u003e SERVICE_SHARED_INFORMER_STUB\u003dnew SharedInformerStub\u003c\u003e();\n  private static final SharedInformerStub\u003cV1Endpoints\u003e ENDPOINTS_SHARED_INFORMER_STUB\u003dnew SharedInformerStub\u003c\u003e();\n  private Cache\u003cV1Service\u003e servicesCache;\n  private Lister\u003cV1Service\u003e servicesLister;\n  private Cache\u003cV1Endpoints\u003e endpointsCache;\n  private Lister\u003cV1Endpoints\u003e endpointsLister;\n  @BeforeEach void beforeEach();\n  @Test void getInstancesShouldBeAbleToHandleEndpointsSingleAddress();\n  @Test void getInstancesShouldBeAbleToHandleEndpointsSingleAddressAndMultiplePorts();\n  @Test void getInstancesShouldBeAbleToHandleEndpointsMultipleAddresses();\n  @Test void getInstancesShouldBeAbleToHandleEndpointsFromMultipleNamespaces();\n  @Test void instanceWithoutSubsetsShouldBeSkipped();\n  @Test void getInstancesShouldBeAbleToHandleEndpointsSingleAddressAndMultiplePortsUsingPrimaryPortNameLabel();\n  @Test void instanceWithMultiplePortsAndMisconfiguredPrimaryPortNameInLabelWithoutFallbackShouldLogWarning();\n  @Test void instanceWithMultiplePortsAndMisconfiguredGenericPrimaryPortNameWithoutFallbackShouldLogWarning();\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedShouldFallBackToHttps();\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedOrHttpsPortShouldFallBackToHttp();\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedShouldLogWarning();\n  @Test public void instanceWithoutPorts();\n  private void setup(  String serviceId,  String serviceType,  String namespace,  Map\u003cString,String\u003e labels,  List\u003cString\u003e ips,  List\u003cString\u003e uuids,  List\u003cString\u003e names,  List\u003cString\u003e protocols,  List\u003cInteger\u003e ports,  List\u003cString\u003e appProtocols);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesDiscoveryClientUtilsTests.java",
        "name": "KubernetesDiscoveryClientUtilsTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesDiscoveryClientUtilsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesDiscoveryClientUtilsTests {\n  /** \n * properties service labels are empty\n */\n  @Test void testEmptyServiceLabelsFromProperties(  CapturedOutput output){\n    KubernetesDiscoveryProperties properties\u003dKubernetesDiscoveryProperties.DEFAULT;\n    V1Service service\u003dnew V1ServiceBuilder().withMetadata(new V1ObjectMeta().name(\"my-service\")).build();\n    boolean result\u003dmatchesServiceLabels(service,properties);\n    Assertions.assertTrue(result);\n    Assertions.assertTrue(output.getOut().contains(\"service labels from properties are empty, service with name : \u0027my-service\u0027 will match\"));\n  }\n  /** \n * labels from service are empty\n */\n  @Test void testEmptyServiceLabelsFromService(  CapturedOutput output){\n    Map\u003cString,String\u003e propertiesLabels\u003dMap.of(\"key\",\"value\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),propertiesLabels,\"\",null,0,false);\n    V1Service service\u003dnew V1ServiceBuilder().withMetadata(new V1ObjectMeta().name(\"my-service\")).build();\n    boolean result\u003dmatchesServiceLabels(service,properties);\n    Assertions.assertFalse(result);\n    Assertions.assertTrue(output.getOut().contains(\"service with name : \u0027my-service\u0027 does not have labels\"));\n  }\n  /** \n * \u003cpre\u003e properties \u003d [a\u003db] service    \u003d [a\u003db] This means the service is picked-up. \u003c/pre\u003e\n */\n  @Test void testOne(  CapturedOutput output){\n    Map\u003cString,String\u003e propertiesLabels\u003dMap.of(\"a\",\"b\");\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"a\",\"b\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),propertiesLabels,\"\",null,0,false);\n    V1Service service\u003dnew V1ServiceBuilder().withMetadata(new V1ObjectMeta().labels(serviceLabels).name(\"my-service\")).build();\n    boolean result\u003dmatchesServiceLabels(service,properties);\n    Assertions.assertTrue(result);\n    Assertions.assertTrue(output.getOut().contains(\"Service labels from properties : {a\u003db}\"));\n    Assertions.assertTrue(output.getOut().contains(\"Service labels from service : {a\u003db}\"));\n  }\n  /** \n * \u003cpre\u003e properties \u003d [a\u003db, c\u003dd] service    \u003d [a\u003db] This means the service is not picked-up. \u003c/pre\u003e\n */\n  @Test void testTwo(  CapturedOutput output){\n    Map\u003cString,String\u003e propertiesLabels\u003dordered(Map.of(\"a\",\"b\",\"c\",\"d\"));\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"a\",\"b\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),propertiesLabels,\"\",null,0,false);\n    V1Service service\u003dnew V1ServiceBuilder().withMetadata(new V1ObjectMeta().labels(serviceLabels).name(\"my-service\")).build();\n    boolean result\u003dmatchesServiceLabels(service,properties);\n    Assertions.assertFalse(result);\n    Assertions.assertTrue(output.getOut().contains(\"Service labels from properties : {a\u003db, c\u003dd}\"));\n    Assertions.assertTrue(output.getOut().contains(\"Service labels from service : {a\u003db}\"));\n  }\n  /** \n * \u003cpre\u003e properties \u003d [a\u003db, c\u003dd] service    \u003d [a\u003db, c\u003dd] This means the service is picked-up. \u003c/pre\u003e\n */\n  @Test void testThree(  CapturedOutput output){\n    Map\u003cString,String\u003e propertiesLabels\u003dordered(Map.of(\"a\",\"b\",\"c\",\"d\"));\n    Map\u003cString,String\u003e serviceLabels\u003dordered(Map.of(\"a\",\"b\",\"c\",\"d\"));\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),propertiesLabels,\"\",null,0,false);\n    V1Service service\u003dnew V1ServiceBuilder().withMetadata(new V1ObjectMeta().labels(serviceLabels).name(\"my-service\")).build();\n    boolean result\u003dmatchesServiceLabels(service,properties);\n    Assertions.assertTrue(result);\n    Assertions.assertTrue(output.getOut().contains(\"Service labels from properties : {a\u003db, c\u003dd}\"));\n    Assertions.assertTrue(output.getOut().contains(\"Service labels from service : {a\u003db, c\u003dd}\"));\n  }\n  /** \n * \u003cpre\u003e properties \u003d [a\u003db] service    \u003d [a\u003db, c\u003dd] This means the service is picked-up. \u003c/pre\u003e\n */\n  @Test void testFour(  CapturedOutput output){\n    Map\u003cString,String\u003e propertiesLabels\u003dMap.of(\"a\",\"b\");\n    Map\u003cString,String\u003e serviceLabels\u003dordered(Map.of(\"a\",\"b\",\"c\",\"d\"));\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),propertiesLabels,\"\",null,0,false);\n    V1Service service\u003dnew V1ServiceBuilder().withMetadata(new V1ObjectMeta().labels(serviceLabels).name(\"my-service\")).build();\n    boolean result\u003dmatchesServiceLabels(service,properties);\n    Assertions.assertTrue(result);\n    Assertions.assertTrue(output.getOut().contains(\"Service labels from properties : {a\u003db}\"));\n    Assertions.assertTrue(output.getOut().contains(\"Service labels from service : {a\u003db, c\u003dd}\"));\n  }\n  @Test void testPortsDataOne(){\n    List\u003cV1EndpointSubset\u003e endpointSubsets\u003dList.of(new V1EndpointSubsetBuilder().withPorts(new CoreV1EndpointPortBuilder().withPort(8081).withName(\"\").build()).build(),new V1EndpointSubsetBuilder().withPorts(new CoreV1EndpointPortBuilder().withPort(8080).withName(\"https\").build()).build());\n    Map\u003cString,Integer\u003e portsData\u003dendpointSubsetsPortData(endpointSubsets);\n    Assertions.assertEquals(portsData.size(),2);\n    Assertions.assertEquals(portsData.get(\"https\"),8080);\n    Assertions.assertEquals(portsData.get(\"\u003cunset\u003e\"),8081);\n  }\n  @Test void testPortsDataTwo(){\n    List\u003cV1EndpointSubset\u003e endpointSubsets\u003dList.of(new V1EndpointSubsetBuilder().withPorts(new CoreV1EndpointPortBuilder().withPort(8081).withName(\"http\").build()).build(),new V1EndpointSubsetBuilder().withPorts(new CoreV1EndpointPortBuilder().withPort(8080).withName(\"https\").build()).build());\n    Map\u003cString,Integer\u003e portsData\u003dendpointSubsetsPortData(endpointSubsets);\n    Assertions.assertEquals(portsData.size(),2);\n    Assertions.assertEquals(portsData.get(\"https\"),8080);\n    Assertions.assertEquals(portsData.get(\"http\"),8081);\n  }\n  @Test void endpointSubsetPortsDataWithoutPorts(){\n    V1EndpointSubset endpointSubset\u003dnew V1EndpointSubsetBuilder().build();\n    Map\u003cString,Integer\u003e result\u003dendpointSubsetsPortData(List.of(endpointSubset));\n    Assertions.assertEquals(result.size(),0);\n  }\n  @Test void endpointSubsetPortsDataSinglePort(){\n    V1EndpointSubset endpointSubset\u003dnew V1EndpointSubsetBuilder().withPorts(new CoreV1EndpointPortBuilder().withName(\"name\").withPort(80).build()).build();\n    Map\u003cString,Integer\u003e result\u003dendpointSubsetsPortData(List.of(endpointSubset));\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(\"name\"),80);\n  }\n  @Test void endpointSubsetPortsDataSinglePortNoName(){\n    V1EndpointSubset endpointSubset\u003dnew V1EndpointSubsetBuilder().withPorts(new CoreV1EndpointPortBuilder().withPort(80).build()).build();\n    Map\u003cString,Integer\u003e result\u003dendpointSubsetsPortData(List.of(endpointSubset));\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(\"\u003cunset\u003e\"),80);\n  }\n  /** \n * \u003cpre\u003e - ready addresses are empty - not ready addresses are not included \u003c/pre\u003e\n */\n  @Test void testEmptyAddresses(){\n    boolean includeNotReadyAddresses\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,includeNotReadyAddresses,\"\",Set.of(),Map.of(),\"\",null,0,false,false);\n    V1EndpointSubset endpointSubset\u003dnew V1EndpointSubsetBuilder().build();\n    List\u003cV1EndpointAddress\u003e addresses\u003dKubernetesDiscoveryClientUtils.addresses(endpointSubset,properties);\n    Assertions.assertEquals(addresses.size(),0);\n  }\n  /** \n * \u003cpre\u003e - ready addresses has two entries - not ready addresses are not included \u003c/pre\u003e\n */\n  @Test void testReadyAddressesOnly(){\n    boolean includeNotReadyAddresses\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,includeNotReadyAddresses,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    V1EndpointSubset endpointSubset\u003dnew V1EndpointSubsetBuilder().withAddresses(new V1EndpointAddressBuilder().withHostname(\"one\").build(),new V1EndpointAddressBuilder().withHostname(\"two\").build()).build();\n    List\u003cV1EndpointAddress\u003e addresses\u003dKubernetesDiscoveryClientUtils.addresses(endpointSubset,properties);\n    Assertions.assertEquals(addresses.size(),2);\n  }\n  /** \n * \u003cpre\u003e - ready addresses has two entries - not ready addresses has a single entry, but we do not take it \u003c/pre\u003e\n */\n  @Test void testReadyAddressesTakenNotReadyAddressesNotTaken(){\n    boolean includeNotReadyAddresses\u003dfalse;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,includeNotReadyAddresses,\"\",Set.of(),Map.of(),\"\",null,0,false,false);\n    V1EndpointSubset endpointSubset\u003dnew V1EndpointSubsetBuilder().withAddresses(new V1EndpointAddressBuilder().withHostname(\"one\").build(),new V1EndpointAddressBuilder().withHostname(\"two\").build()).withNotReadyAddresses(new V1EndpointAddressBuilder().withHostname(\"three\").build()).build();\n    List\u003cV1EndpointAddress\u003e addresses\u003dKubernetesDiscoveryClientUtils.addresses(endpointSubset,properties);\n    Assertions.assertEquals(addresses.size(),2);\n    List\u003cString\u003e hostNames\u003daddresses.stream().map(V1EndpointAddress::getHostname).sorted().toList();\n    Assertions.assertEquals(hostNames,List.of(\"one\",\"two\"));\n  }\n  /** \n * \u003cpre\u003e - ready addresses has two entries - not ready addresses has a single entry, but we do not take it \u003c/pre\u003e\n */\n  @Test void testBothAddressesTaken(){\n    boolean includeNotReadyAddresses\u003dtrue;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,includeNotReadyAddresses,\"\",Set.of(),Map.of(),\"\",null,0,false);\n    V1EndpointSubset endpointSubset\u003dnew V1EndpointSubsetBuilder().withAddresses(new V1EndpointAddressBuilder().withHostname(\"one\").build(),new V1EndpointAddressBuilder().withHostname(\"two\").build()).withNotReadyAddresses(new V1EndpointAddressBuilder().withHostname(\"three\").build()).build();\n    List\u003cV1EndpointAddress\u003e addresses\u003dKubernetesDiscoveryClientUtils.addresses(endpointSubset,properties);\n    Assertions.assertEquals(addresses.size(),3);\n    List\u003cString\u003e hostNames\u003daddresses.stream().map(V1EndpointAddress::getHostname).sorted().toList();\n    Assertions.assertEquals(hostNames,List.of(\"one\",\"three\",\"two\"));\n  }\n  private Map\u003cString,String\u003e ordered(  Map\u003cString,String\u003e input){\n    return input.entrySet().stream().sorted(Map.Entry.comparingByKey()).collect(Collectors.toMap(Map.Entry::getKey,Map.Entry::getValue,(left,right) -\u003e left,LinkedHashMap::new));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesDiscoveryClientUtilsTests {\n  /** \n * properties service labels are empty\n */\n  @Test void testEmptyServiceLabelsFromProperties(  CapturedOutput output);\n  /** \n * labels from service are empty\n */\n  @Test void testEmptyServiceLabelsFromService(  CapturedOutput output);\n  /** \n * \u003cpre\u003e properties \u003d [a\u003db] service    \u003d [a\u003db] This means the service is picked-up. \u003c/pre\u003e\n */\n  @Test void testOne(  CapturedOutput output);\n  /** \n * \u003cpre\u003e properties \u003d [a\u003db, c\u003dd] service    \u003d [a\u003db] This means the service is not picked-up. \u003c/pre\u003e\n */\n  @Test void testTwo(  CapturedOutput output);\n  /** \n * \u003cpre\u003e properties \u003d [a\u003db, c\u003dd] service    \u003d [a\u003db, c\u003dd] This means the service is picked-up. \u003c/pre\u003e\n */\n  @Test void testThree(  CapturedOutput output);\n  /** \n * \u003cpre\u003e properties \u003d [a\u003db] service    \u003d [a\u003db, c\u003dd] This means the service is picked-up. \u003c/pre\u003e\n */\n  @Test void testFour(  CapturedOutput output);\n  @Test void testPortsDataOne();\n  @Test void testPortsDataTwo();\n  @Test void endpointSubsetPortsDataWithoutPorts();\n  @Test void endpointSubsetPortsDataSinglePort();\n  @Test void endpointSubsetPortsDataSinglePortNoName();\n  /** \n * \u003cpre\u003e - ready addresses are empty - not ready addresses are not included \u003c/pre\u003e\n */\n  @Test void testEmptyAddresses();\n  /** \n * \u003cpre\u003e - ready addresses has two entries - not ready addresses are not included \u003c/pre\u003e\n */\n  @Test void testReadyAddressesOnly();\n  /** \n * \u003cpre\u003e - ready addresses has two entries - not ready addresses has a single entry, but we do not take it \u003c/pre\u003e\n */\n  @Test void testReadyAddressesTakenNotReadyAddressesNotTaken();\n  /** \n * \u003cpre\u003e - ready addresses has two entries - not ready addresses has a single entry, but we do not take it \u003c/pre\u003e\n */\n  @Test void testBothAddressesTaken();\n  private Map\u003cString,String\u003e ordered(  Map\u003cString,String\u003e input);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesDiscoveryClientConfigClientBootstrapConfigurationTests.java",
        "name": "KubernetesDiscoveryClientConfigClientBootstrapConfigurationTests",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesDiscoveryClientConfigClientBootstrapConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "public class KubernetesDiscoveryClientConfigClientBootstrapConfigurationTests {\n  private AnnotationConfigApplicationContext context;\n  @AfterEach void close(){\n    if (this.context !\u003d null) {\n      if (this.context.getParent() !\u003d null) {\n        ((AnnotationConfigApplicationContext)this.context.getParent()).close();\n      }\n      this.context.close();\n    }\n  }\n  @Test void onWhenRequested(){\n    setup(\"server.port\u003d7000\",\"spring.cloud.config.discovery.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.enabled:true\",\"spring.application.name:test\",\"spring.cloud.config.discovery.service-id:configserver\");\n    Assertions.assertEquals(1,this.context.getParent().getBeanNamesForType(DiscoveryClient.class).length);\n    DiscoveryClient client\u003dthis.context.getParent().getBean(DiscoveryClient.class);\n    verify(client,atLeast(2)).getInstances(\"configserver\");\n    ConfigClientProperties locator\u003dthis.context.getBean(ConfigClientProperties.class);\n    Assertions.assertEquals(\"http://fake:8888/\",locator.getUri()[0]);\n  }\n  private void setup(  String... env){\n    AnnotationConfigApplicationContext parent\u003dnew AnnotationConfigApplicationContext();\n    TestPropertyValues.of(env).applyTo(parent);\n    parent.register(UtilAutoConfiguration.class,PropertyPlaceholderAutoConfiguration.class,EnvironmentKnobbler.class,KubernetesCommonsAutoConfiguration.class,KubernetesClientAutoConfiguration.class,KubernetesInformerDiscoveryClientAutoConfiguration.class,DiscoveryClientConfigServiceBootstrapConfiguration.class,ConfigClientProperties.class);\n    parent.refresh();\n    this.context\u003dnew AnnotationConfigApplicationContext();\n    this.context.setParent(parent);\n    this.context.register(PropertyPlaceholderAutoConfiguration.class,KubernetesCommonsAutoConfiguration.class,KubernetesInformerDiscoveryClientAutoConfiguration.class);\n    this.context.refresh();\n  }\n@Configuration(proxyBeanMethods\u003dfalse) protected static class EnvironmentKnobbler {\n    @Bean CoreV1Api coreV1Api(    ApiClient apiClient){\n      return new CoreV1Api(apiClient);\n    }\n    @Bean ApiClient apiClient(){\n      ApiClient apiClient\u003dmock(ApiClient.class);\n      when(apiClient.getJSON()).thenReturn(new JSON());\n      when(apiClient.getHttpClient()).thenReturn(new OkHttpClient.Builder().build());\n      return apiClient;\n    }\n    @Bean KubernetesNamespaceProvider kubernetesNamespaceProvider(){\n      KubernetesNamespaceProvider provider\u003dmock(KubernetesNamespaceProvider.class);\n      when(provider.getNamespace()).thenReturn(\"test\");\n      return provider;\n    }\n    @Bean KubernetesInformerDiscoveryClient kubernetesInformerDiscoveryClient(){\n      KubernetesInformerDiscoveryClient client\u003dmock(KubernetesInformerDiscoveryClient.class);\n      ServiceInstance instance\u003dnew DefaultServiceInstance(\"configserver1\",\"configserver\",\"fake\",8888,false);\n      given(client.getInstances(\"configserver\")).willReturn(Collections.singletonList(instance));\n      return client;\n    }\n  }\n}\n",
        "abstract": "public class KubernetesDiscoveryClientConfigClientBootstrapConfigurationTests {\n  private AnnotationConfigApplicationContext context;\n  @AfterEach void close();\n  @Test void onWhenRequested();\n  private void setup(  String... env);\n@Configuration(proxyBeanMethods\u003dfalse) protected static class EnvironmentKnobbler {\n    @Bean CoreV1Api coreV1Api(    ApiClient apiClient);\n    @Bean ApiClient apiClient();\n    @Bean KubernetesNamespaceProvider kubernetesNamespaceProvider();\n    @Bean KubernetesInformerDiscoveryClient kubernetesInformerDiscoveryClient();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesClientInformerSelectiveNamespacesAutoConfigurationTests.java",
        "name": "KubernetesClientInformerSelectiveNamespacesAutoConfigurationTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesClientInformerSelectiveNamespacesAutoConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesClientInformerSelectiveNamespacesAutoConfigurationTests {\n  private static final String NAMESPACE_A\u003d\"a\";\n  private static final String NAMESPACE_B\u003d\"b\";\n  private static final String NAMESPACE_C\u003d\"c\";\n  private static final String NAMESPACE_D\u003d\"d\";\n  @Test void testBeansCreates(  CapturedOutput output){\n    new ApplicationContextRunner().withPropertyValues(\"spring.cloud.discovery.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.namespaces[0]\u003d\" + NAMESPACE_A,\"spring.cloud.kubernetes.discovery.namespaces[1]\u003d\" + NAMESPACE_B,\"spring.main.cloud-platform\u003dkubernetes\").withConfiguration(AutoConfigurations.of(KubernetesClientInformerSelectiveNamespacesAutoConfiguration.class)).withUserConfiguration(Config.class).run(context -\u003e {\n      assertThat(context.getBean(\"selectiveNamespaces\")).isNotNull();\n      @SuppressWarnings(\"unchecked\") Set\u003cString\u003e selectiveNamespaces\u003dcontext.getBean(\"selectiveNamespaces\",Set.class);\n      Assertions.assertEquals(selectiveNamespaces,Set.of(\"a\",\"b\"));\n      @SuppressWarnings(\"unchecked\") Set\u003cString\u003e namespaces\u003dcontext.getBean(\"namespaces\",Set.class);\n      Assertions.assertEquals(namespaces,Set.of(\"c\",\"d\"));\n    }\n);\n    assertThat(output.getOut().contains(\"registering lister (for services) in namespace : \" + NAMESPACE_A)).isTrue();\n    assertThat(output.getOut().contains(\"registering lister (for services) in namespace : \" + NAMESPACE_B)).isTrue();\n    assertThat(output.getOut().contains(\"registering lister (for services) in namespace : \" + NAMESPACE_C)).isFalse();\n    assertThat(output.getOut().contains(\"registering lister (for services) in namespace : \" + NAMESPACE_D)).isFalse();\n    assertThat(output.getOut().contains(\"registering lister (for endpoints) in namespace : \" + NAMESPACE_A)).isTrue();\n    assertThat(output.getOut().contains(\"registering lister (for endpoints) in namespace : \" + NAMESPACE_B)).isTrue();\n    assertThat(output.getOut().contains(\"registering lister (for endpoints) in namespace : \" + NAMESPACE_C)).isFalse();\n    assertThat(output.getOut().contains(\"registering lister (for endpoints) in namespace : \" + NAMESPACE_D)).isFalse();\n  }\n@Configuration @EnableConfigurationProperties(KubernetesDiscoveryProperties.class) static class Config {\n    @Bean ApiClient apiClient(){\n      return Mockito.mock(ApiClient.class);\n    }\n    @Bean List\u003cString\u003e namespaces(){\n      return List.of(NAMESPACE_C,NAMESPACE_D);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesClientInformerSelectiveNamespacesAutoConfigurationTests {\n  private static final String NAMESPACE_A\u003d\"a\";\n  private static final String NAMESPACE_B\u003d\"b\";\n  private static final String NAMESPACE_C\u003d\"c\";\n  private static final String NAMESPACE_D\u003d\"d\";\n  @Test void testBeansCreates(  CapturedOutput output);\n@Configuration @EnableConfigurationProperties(KubernetesDiscoveryProperties.class) static class Config {\n    @Bean ApiClient apiClient();\n    @Bean List\u003cString\u003e namespaces();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesDiscoveryClientFilterTests.java",
        "name": "KubernetesDiscoveryClientFilterTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesDiscoveryClientFilterTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesDiscoveryClientFilterTests {\n  @Test void testEmptyExpression(  CapturedOutput output){\n    String spelFilter\u003dnull;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,false,Set.of(),true,60L,false,spelFilter,Set.of(),Map.of(),null,null,0,false);\n    Predicate\u003cV1Service\u003e predicate\u003dKubernetesDiscoveryClientUtils.filter(properties);\n    Assertions.assertNotNull(predicate);\n    Assertions.assertTrue(output.getOut().contains(\"filter not defined, returning always true predicate\"));\n  }\n  @Test void testExpressionPresent(  CapturedOutput output){\n    String spelFilter\u003d\"some\";\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,false,Set.of(),true,60L,false,spelFilter,Set.of(),Map.of(),null,null,0,false);\n    Predicate\u003cV1Service\u003e predicate\u003dKubernetesDiscoveryClientUtils.filter(properties);\n    Assertions.assertNotNull(predicate);\n    Assertions.assertTrue(output.getOut().contains(\"returning predicate based on filter expression: some\"));\n  }\n  @Test void testTwoServicesBothMatch(){\n    String spelFilter\u003dnull;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,false,Set.of(),true,60L,false,spelFilter,Set.of(),Map.of(),null,null,0,false);\n    V1Service a\u003dnew V1ServiceBuilder().withNewMetadata().withNamespace(\"namespace-A\").withName(\"a\").and().build();\n    V1Service b\u003dnew V1ServiceBuilder().withNewMetadata().withNamespace(\"namespace-A\").withName(\"a\").and().build();\n    List\u003cV1Service\u003e unfiltered\u003dList.of(a,b);\n    Predicate\u003cV1Service\u003e predicate\u003dKubernetesDiscoveryClientUtils.filter(properties);\n    List\u003cV1Service\u003e filtered\u003dunfiltered.stream().filter(predicate).sorted(Comparator.comparing(service -\u003e service.getMetadata().getName())).toList();\n    Assertions.assertEquals(filtered.get(0).getMetadata().getName(),\"a\");\n    Assertions.assertEquals(filtered.get(1).getMetadata().getName(),\"a\");\n  }\n  @Test void testTwoServicesNoneMatch(){\n    String spelFilter\u003dnull;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,false,Set.of(),true,60L,false,spelFilter,Set.of(),Map.of(),null,null,0,false);\n    V1Service a\u003dnew V1ServiceBuilder().withNewMetadata().withNamespace(\"namespace-B\").withName(\"a\").and().build();\n    V1Service b\u003dnew V1ServiceBuilder().withNewMetadata().withNamespace(\"namespace-B\").withName(\"a\").and().build();\n    List\u003cV1Service\u003e unfiltered\u003dList.of(a,b);\n    Predicate\u003cV1Service\u003e predicate\u003dKubernetesDiscoveryClientUtils.filter(properties);\n    List\u003cV1Service\u003e filtered\u003dunfiltered.stream().filter(predicate).sorted(Comparator.comparing(service -\u003e service.getMetadata().getName())).toList();\n    Assertions.assertEquals(filtered.size(),0);\n  }\n  @Test void testTwoServicesOneMatch(){\n    String spelFilter\u003dnull;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,false,Set.of(),true,60L,false,spelFilter,Set.of(),Map.of(),null,null,0,false);\n    V1Service a\u003dnew V1ServiceBuilder().withNewMetadata().withNamespace(\"namespace-B\").withName(\"a\").and().build();\n    V1Service b\u003dnew V1ServiceBuilder().withNewMetadata().withNamespace(\"namespace-B\").withName(\"a\").and().build();\n    List\u003cV1Service\u003e unfiltered\u003dList.of(a,b);\n    Predicate\u003cV1Service\u003e predicate\u003dKubernetesDiscoveryClientUtils.filter(properties);\n    List\u003cV1Service\u003e filtered\u003dunfiltered.stream().filter(predicate).sorted(Comparator.comparing(service -\u003e service.getMetadata().getName())).toList();\n    Assertions.assertEquals(filtered.size(),0);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesDiscoveryClientFilterTests {\n  @Test void testEmptyExpression(  CapturedOutput output);\n  @Test void testExpressionPresent(  CapturedOutput output);\n  @Test void testTwoServicesBothMatch();\n  @Test void testTwoServicesNoneMatch();\n  @Test void testTwoServicesOneMatch();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/TestUtils.java",
        "name": "TestUtils",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.TestUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Some common class that test code delegates to.\n * @author wind57\n */\npublic final class TestUtils {\n  private TestUtils(){\n  }\n  public static void assertSelectiveNamespacesBeansMissing(  AssertableApplicationContext context){\n    String[] sharedInformerFactoriesBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cList\u003cSharedInformerFactory\u003e\u003e(){\n    }\n));\n    assertThat(sharedInformerFactoriesBeanName).isEmpty();\n    String[] serviceSharedIndexInformersBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cList\u003cSharedIndexInformer\u003cV1Service\u003e\u003e\u003e(){\n    }\n));\n    assertThat(serviceSharedIndexInformersBeanName).isEmpty();\n    String[] endpointsSharedIndexInformersBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cList\u003cSharedIndexInformer\u003cV1Endpoints\u003e\u003e\u003e(){\n    }\n));\n    assertThat(endpointsSharedIndexInformersBeanName).isEmpty();\n    String[] serviceListersBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cList\u003cLister\u003cV1Service\u003e\u003e\u003e(){\n    }\n));\n    assertThat(serviceListersBeanName).isEmpty();\n    String[] endpointsListersBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cList\u003cLister\u003cV1Endpoints\u003e\u003e\u003e(){\n    }\n));\n    assertThat(endpointsListersBeanName).isEmpty();\n  }\n  @SuppressWarnings(\"unchecked\") public static void assertSelectiveNamespacesBeansPresent(  AssertableApplicationContext context,  int times){\n    String sharedInformerFactoriesBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cList\u003cSharedInformerFactory\u003e\u003e(){\n    }\n))[0];\n    List\u003cSharedInformerFactory\u003e sharedInformerFactories\u003d(List\u003cSharedInformerFactory\u003e)context.getBean(sharedInformerFactoriesBeanName);\n    assertThat(sharedInformerFactories.size()).isEqualTo(times);\n    String serviceSharedIndexInformersBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cList\u003cSharedIndexInformer\u003cV1Service\u003e\u003e\u003e(){\n    }\n))[0];\n    List\u003cSharedIndexInformer\u003cV1Service\u003e\u003e serviceSharedIndexInformers\u003d(List\u003cSharedIndexInformer\u003cV1Service\u003e\u003e)context.getBean(serviceSharedIndexInformersBeanName);\n    assertThat(serviceSharedIndexInformers.size()).isEqualTo(times);\n    String endpointsSharedIndexInformersBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cList\u003cSharedIndexInformer\u003cV1Endpoints\u003e\u003e\u003e(){\n    }\n))[0];\n    List\u003cSharedIndexInformer\u003cV1Endpoints\u003e\u003e endpointsSharedIndexInformers\u003d(List\u003cSharedIndexInformer\u003cV1Endpoints\u003e\u003e)context.getBean(endpointsSharedIndexInformersBeanName);\n    assertThat(endpointsSharedIndexInformers.size()).isEqualTo(times);\n    String serviceListersBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cList\u003cLister\u003cV1Service\u003e\u003e\u003e(){\n    }\n))[0];\n    List\u003cLister\u003cV1Service\u003e\u003e serviceListers\u003d(List\u003cLister\u003cV1Service\u003e\u003e)context.getBean(serviceListersBeanName);\n    assertThat(serviceListers.size()).isEqualTo(times);\n    String endpointsListersBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cList\u003cLister\u003cV1Endpoints\u003e\u003e\u003e(){\n    }\n))[0];\n    List\u003cLister\u003cV1Endpoints\u003e\u003e endpointsListers\u003d(List\u003cLister\u003cV1Endpoints\u003e\u003e)context.getBean(endpointsListersBeanName);\n    assertThat(endpointsListers.size()).isEqualTo(times);\n  }\n  @SuppressWarnings(\"unchecked\") public static void assertNonSelectiveNamespacesBeansPresent(  AssertableApplicationContext context){\n    assertThat(context).hasSingleBean(SharedInformerFactory.class);\n    String serviceSharedIndexInformerBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cSharedIndexInformer\u003cV1Service\u003e\u003e(){\n    }\n))[0];\n    SharedIndexInformer\u003cV1Service\u003e serviceSharedIndexInformer\u003d(SharedIndexInformer\u003cV1Service\u003e)context.getBean(serviceSharedIndexInformerBeanName);\n    assertThat(serviceSharedIndexInformer).isNotNull();\n    String endpointSharedIndexInformerBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cSharedIndexInformer\u003cV1Endpoints\u003e\u003e(){\n    }\n))[0];\n    SharedIndexInformer\u003cV1Endpoints\u003e endpointsSharedIndexInformer\u003d(SharedIndexInformer\u003cV1Endpoints\u003e)context.getBean(endpointSharedIndexInformerBeanName);\n    assertThat(endpointsSharedIndexInformer).isNotNull();\n    String serviceListerBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cLister\u003cV1Service\u003e\u003e(){\n    }\n))[0];\n    Lister\u003cV1Service\u003e serviceLister\u003d(Lister\u003cV1Service\u003e)context.getBean(serviceListerBeanName);\n    assertThat(serviceLister).isNotNull();\n    String endpointsListerBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cLister\u003cV1Endpoints\u003e\u003e(){\n    }\n))[0];\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003d(Lister\u003cV1Endpoints\u003e)context.getBean(endpointsListerBeanName);\n    assertThat(endpointsLister).isNotNull();\n  }\n  public static void assertNonSelectiveNamespacesBeansMissing(  AssertableApplicationContext context){\n    String[] serviceSharedIndexInformerBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cSharedIndexInformer\u003cV1Service\u003e\u003e(){\n    }\n));\n    assertThat(serviceSharedIndexInformerBeanName).isEmpty();\n    String[] endpointSharedIndexInformerBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cSharedIndexInformer\u003cV1Endpoints\u003e\u003e(){\n    }\n));\n    assertThat(endpointSharedIndexInformerBeanName).isEmpty();\n    String[] serviceListerBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cLister\u003cV1Service\u003e\u003e(){\n    }\n));\n    assertThat(serviceListerBeanName).isEmpty();\n    String[] endpointsListerBeanName\u003dcontext.getBeanNamesForType(ResolvableType.forType(new ParameterizedTypeReference\u003cLister\u003cV1Endpoints\u003e\u003e(){\n    }\n));\n    assertThat(endpointsListerBeanName).isEmpty();\n  }\n}\n",
        "abstract": "/** \n * Some common class that test code delegates to.\n * @author wind57\n */\npublic final class TestUtils {\n  private TestUtils();\n  public static void assertSelectiveNamespacesBeansMissing(  AssertableApplicationContext context);\n  @SuppressWarnings(\"unchecked\") public static void assertSelectiveNamespacesBeansPresent(  AssertableApplicationContext context,  int times);\n  @SuppressWarnings(\"unchecked\") public static void assertNonSelectiveNamespacesBeansPresent(  AssertableApplicationContext context);\n  public static void assertNonSelectiveNamespacesBeansMissing(  AssertableApplicationContext context);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesInformerDiscoveryClientAutoConfigurationApplicationContextTests.java",
        "name": "KubernetesInformerDiscoveryClientAutoConfigurationApplicationContextTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesInformerDiscoveryClientAutoConfigurationApplicationContextTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Test various conditionals for {@link KubernetesInformerDiscoveryClientAutoConfiguration}\n * @author wind57\n */\nclass KubernetesInformerDiscoveryClientAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  private static K3sContainer container;\n  @AfterAll static void afterAll(){\n    container.stop();\n  }\n  @Test void discoveryEnabledDefault(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void discoveryEnabledDefaultWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b,c\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,3);\n    }\n);\n  }\n  @Test void discoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void discoveryEnabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,2);\n    }\n);\n  }\n  @Test void discoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void discoveryDisabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryEnabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b,c,d\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,4);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryDisabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b,c,d\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryBlockingEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryBlockingEnabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.namespaces\u003da\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,1);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryBlockingDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryBlockingDisabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,2);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryHealthIndicatorEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryHealthIndicatorEnabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.namespaces\u003db\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,1);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryHealthIndicatorDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryHealthIndicatorDisabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces\u003db\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,1);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryHealthIndicatorEnabledHealthIndicatorMissing(){\n    setupWithFilteredClassLoader(HealthIndicator.class,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryHealthIndicatorEnabledHealthIndicatorMissingWithSelectiveNamespaces(){\n    setupWithFilteredClassLoader(HealthIndicator.class,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b,c,d,e\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,5);\n    }\n);\n  }\n  /** \n * reactive is disabled and should not impact blocking in any way\n */\n  @Test void reactiveDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  /** \n * reactive is disabled and should not impact blocking in any way\n */\n  @Test void reactiveDisabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b,c,d,e\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,5);\n    }\n);\n  }\n  private void setup(  String... properties){\n    applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesInformerDiscoveryClientAutoConfiguration.class,KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class,KubernetesClientInformerAutoConfiguration.class,KubernetesClientInformerSelectiveNamespacesAutoConfiguration.class)).withUserConfiguration(ApiClientConfig.class).withPropertyValues(properties);\n  }\n  private void setupWithFilteredClassLoader(  Class\u003c?\u003e cls,  String... properties){\n    applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesInformerDiscoveryClientAutoConfiguration.class,KubernetesClientAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class,KubernetesClientInformerAutoConfiguration.class,KubernetesClientInformerSelectiveNamespacesAutoConfiguration.class)).withClassLoader(new FilteredClassLoader(cls)).withUserConfiguration(ApiClientConfig.class).withPropertyValues(properties);\n  }\n@Configuration static class ApiClientConfig {\n    @Bean @Primary ApiClient apiClient() throws Exception {\n      container\u003dCommons.container();\n      container.start();\n      return Config.fromConfig(new StringReader(container.getKubeConfigYaml()));\n    }\n  }\n}\n",
        "abstract": "/** \n * Test various conditionals for {@link KubernetesInformerDiscoveryClientAutoConfiguration}\n * @author wind57\n */\nclass KubernetesInformerDiscoveryClientAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  private static K3sContainer container;\n  @AfterAll static void afterAll();\n  @Test void discoveryEnabledDefault();\n  @Test void discoveryEnabledDefaultWithSelectiveNamespaces();\n  @Test void discoveryEnabled();\n  @Test void discoveryEnabledWithSelectiveNamespaces();\n  @Test void discoveryDisabled();\n  @Test void discoveryDisabledWithSelectiveNamespaces();\n  @Test void kubernetesDiscoveryEnabled();\n  @Test void kubernetesDiscoveryEnabledWithSelectiveNamespaces();\n  @Test void kubernetesDiscoveryDisabled();\n  @Test void kubernetesDiscoveryDisabledWithSelectiveNamespaces();\n  @Test void kubernetesDiscoveryBlockingEnabled();\n  @Test void kubernetesDiscoveryBlockingEnabledWithSelectiveNamespaces();\n  @Test void kubernetesDiscoveryBlockingDisabled();\n  @Test void kubernetesDiscoveryBlockingDisabledWithSelectiveNamespaces();\n  @Test void kubernetesDiscoveryHealthIndicatorEnabled();\n  @Test void kubernetesDiscoveryHealthIndicatorEnabledWithSelectiveNamespaces();\n  @Test void kubernetesDiscoveryHealthIndicatorDisabled();\n  @Test void kubernetesDiscoveryHealthIndicatorDisabledWithSelectiveNamespaces();\n  @Test void kubernetesDiscoveryHealthIndicatorEnabledHealthIndicatorMissing();\n  @Test void kubernetesDiscoveryHealthIndicatorEnabledHealthIndicatorMissingWithSelectiveNamespaces();\n  /** \n * reactive is disabled and should not impact blocking in any way\n */\n  @Test void reactiveDisabled();\n  /** \n * reactive is disabled and should not impact blocking in any way\n */\n  @Test void reactiveDisabledWithSelectiveNamespaces();\n  private void setup(  String... properties);\n  private void setupWithFilteredClassLoader(  Class\u003c?\u003e cls,  String... properties);\n@Configuration static class ApiClientConfig {\n    @Bean @Primary ApiClient apiClient() throws Exception;\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/K8sPodLabelsAndAnnotationsSupplierTests.java",
        "name": "K8sPodLabelsAndAnnotationsSupplierTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.K8sPodLabelsAndAnnotationsSupplierTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass K8sPodLabelsAndAnnotationsSupplierTests {\n  private static final String NAMESPACE\u003d\"spring-k8s\";\n  private static final String POD_NAME\u003d\"my-pod\";\n  private final CoreV1Api coreV1Api\u003dMockito.mock(CoreV1Api.class);\n  @AfterEach void afterEach(){\n    Mockito.reset(coreV1Api);\n  }\n  @Test void noObjetMeta() throws Exception {\n    Mockito.when(coreV1Api.readNamespacedPod(POD_NAME,NAMESPACE,null)).thenReturn(new V1PodBuilder().withMetadata(new V1ObjectMetaBuilder().withName(POD_NAME).build()).build());\n    PodLabelsAndAnnotations result\u003dK8sPodLabelsAndAnnotationsSupplier.nonExternalName(coreV1Api,NAMESPACE).apply(POD_NAME);\n    Assertions.assertNotNull(result);\n    Assertions.assertTrue(result.labels().isEmpty());\n    Assertions.assertTrue(result.annotations().isEmpty());\n  }\n  @Test void labelsAndAnnotationsPresent() throws Exception {\n    Mockito.when(coreV1Api.readNamespacedPod(POD_NAME,NAMESPACE,null)).thenReturn(new V1PodBuilder().withMetadata(new V1ObjectMetaBuilder().withName(POD_NAME).withLabels(Map.of(\"a\",\"b\")).withAnnotations(Map.of(\"c\",\"d\")).build()).build());\n    PodLabelsAndAnnotations result\u003dK8sPodLabelsAndAnnotationsSupplier.nonExternalName(coreV1Api,NAMESPACE).apply(POD_NAME);\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.labels(),Map.of(\"a\",\"b\"));\n    Assertions.assertEquals(result.annotations(),Map.of(\"c\",\"d\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass K8sPodLabelsAndAnnotationsSupplierTests {\n  private static final String NAMESPACE\u003d\"spring-k8s\";\n  private static final String POD_NAME\u003d\"my-pod\";\n  private final CoreV1Api coreV1Api\u003dMockito.mock(CoreV1Api.class);\n  @AfterEach void afterEach();\n  @Test void noObjetMeta() throws Exception;\n  @Test void labelsAndAnnotationsPresent() throws Exception;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesDiscoveryClientAutoConfigurationTests.java",
        "name": "KubernetesDiscoveryClientAutoConfigurationTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.cacheLoadingTimeoutSeconds\u003d5\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.waitCacheReady\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesDiscoveryClientAutoConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.cacheLoadingTimeoutSeconds\u003d5\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.waitCacheReady\u003dfalse\"}) class KubernetesDiscoveryClientAutoConfigurationTests {\n  @Autowired private DiscoveryClient discoveryClient;\n  private static WireMockServer wireMockServer;\n  @AfterAll static void after(){\n    wireMockServer.stop();\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n  }\n  @Test void kubernetesDiscoveryClientCreated(){\n    assertThat(this.discoveryClient).isNotNull().isInstanceOf(CompositeDiscoveryClient.class);\n    CompositeDiscoveryClient composite\u003d(CompositeDiscoveryClient)this.discoveryClient;\n    assertThat(composite.getDiscoveryClients().stream().anyMatch(dc -\u003e dc instanceof KubernetesInformerDiscoveryClient)).isTrue();\n  }\n@SpringBootApplication protected static class TestConfig {\n    @Bean KubernetesNamespaceProvider kubernetesNamespaceProvider(){\n      KubernetesNamespaceProvider provider\u003dmock(KubernetesNamespaceProvider.class);\n      when(provider.getNamespace()).thenReturn(\"test\");\n      return provider;\n    }\n    @Bean ApiClient apiClient(){\n      wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n      wireMockServer.start();\n      WireMock.configureFor(wireMockServer.port());\n      stubFor(get(\"/api/v1/namespaces/test/endpoints?resourceVersion\u003d0\u0026watch\u003dfalse\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1EndpointsListBuilder().withMetadata(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).build()))));\n      stubFor(get(\"/api/v1/namespaces/test/services?resourceVersion\u003d0\u0026watch\u003dfalse\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1ServiceListBuilder().withMetadata(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).build()))));\n      return new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build();\n    }\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.cacheLoadingTimeoutSeconds\u003d5\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.waitCacheReady\u003dfalse\"}) class KubernetesDiscoveryClientAutoConfigurationTests {\n  @Autowired private DiscoveryClient discoveryClient;\n  private static WireMockServer wireMockServer;\n  @AfterAll static void after();\n  @AfterEach void afterEach();\n  @Test void kubernetesDiscoveryClientCreated();\n@SpringBootApplication protected static class TestConfig {\n    @Bean KubernetesNamespaceProvider kubernetesNamespaceProvider();\n    @Bean ApiClient apiClient();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/reactive/KubernetesInformerReactiveDiscoveryClientAutoConfigurationTests.java",
        "name": "KubernetesInformerReactiveDiscoveryClientAutoConfigurationTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.cacheLoadingTimeoutSeconds\u003d5\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.waitCacheReady\u003dfalse\",\"spring.main.web-application-type\u003dreactive\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.reactive.KubernetesInformerReactiveDiscoveryClientAutoConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.cacheLoadingTimeoutSeconds\u003d5\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.waitCacheReady\u003dfalse\",\"spring.main.web-application-type\u003dreactive\"}) class KubernetesInformerReactiveDiscoveryClientAutoConfigurationTests {\n  @Autowired private ReactiveDiscoveryClient discoveryClient;\n  private static WireMockServer wireMockServer;\n  @AfterAll static void after(){\n    wireMockServer.stop();\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n  }\n  @Test void kubernetesDiscoveryClientCreated(){\n    assertThat(this.discoveryClient).isNotNull().isInstanceOf(ReactiveCompositeDiscoveryClient.class);\n    ReactiveCompositeDiscoveryClient composite\u003d(ReactiveCompositeDiscoveryClient)this.discoveryClient;\n    assertThat(composite.getDiscoveryClients().stream().anyMatch(dc -\u003e dc instanceof KubernetesInformerReactiveDiscoveryClient)).isTrue();\n  }\n@SpringBootApplication protected static class TestConfig {\n    @Bean ApiClient apiClient(){\n      wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n      wireMockServer.start();\n      WireMock.configureFor(wireMockServer.port());\n      stubFor(get(\"/api/v1/namespaces/test/endpoints?resourceVersion\u003d0\u0026watch\u003dfalse\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1EndpointsListBuilder().withMetadata(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).build()))));\n      stubFor(get(\"/api/v1/namespaces/test/services?resourceVersion\u003d0\u0026watch\u003dfalse\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1ServiceListBuilder().withMetadata(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).build()))));\n      return new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build();\n    }\n    @Bean KubernetesNamespaceProvider kubernetesNamespaceProvider(){\n      KubernetesNamespaceProvider provider\u003dmock(KubernetesNamespaceProvider.class);\n      when(provider.getNamespace()).thenReturn(\"test\");\n      return provider;\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.cacheLoadingTimeoutSeconds\u003d5\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.waitCacheReady\u003dfalse\",\"spring.main.web-application-type\u003dreactive\"}) class KubernetesInformerReactiveDiscoveryClientAutoConfigurationTests {\n  @Autowired private ReactiveDiscoveryClient discoveryClient;\n  private static WireMockServer wireMockServer;\n  @AfterAll static void after();\n  @AfterEach void afterEach();\n  @Test void kubernetesDiscoveryClientCreated();\n@SpringBootApplication protected static class TestConfig {\n    @Bean ApiClient apiClient();\n    @Bean KubernetesNamespaceProvider kubernetesNamespaceProvider();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/reactive/KubernetesInformerReactiveDiscoveryClientTests.java",
        "name": "KubernetesInformerReactiveDiscoveryClientTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.reactive.KubernetesInformerReactiveDiscoveryClientTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass KubernetesInformerReactiveDiscoveryClientTests {\n  private Cache\u003cV1Service\u003e serviceCache\u003dnew Cache\u003c\u003e();\n  private Cache\u003cV1Endpoints\u003e endpointsCache\u003dnew Cache\u003c\u003e();\n  private static final String NAMESPACE_1\u003d\"namespace1\";\n  private static final String NAMESPACE_2\u003d\"namespace2\";\n  private final SharedInformerFactory sharedInformerFactory\u003dMockito.mock(SharedInformerFactory.class);\n  private static final V1Service TEST_SERVICE_1\u003dnew V1Service().spec(new V1ServiceSpec().type(\"ClusterIP\")).metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(NAMESPACE_1));\n  private static final V1Service TEST_SERVICE_2\u003dnew V1Service().spec(new V1ServiceSpec().type(\"ClusterIP\")).metadata(new V1ObjectMeta().name(\"test-svc-2\").namespace(NAMESPACE_2));\n  private static final V1Service TEST_SERVICE_3\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"test-svc-2\").namespace(NAMESPACE_2));\n  private static final V1Endpoints TEST_ENDPOINTS_1\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(NAMESPACE_1)).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080)).addAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\")));\n  @AfterEach void afterEach(){\n    serviceCache\u003dnew Cache\u003c\u003e();\n    endpointsCache\u003dnew Cache\u003c\u003e();\n  }\n  @Test void testDiscoveryGetServicesAllNamespaceShouldWork(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(NAMESPACE_ALL,TEST_SERVICE_1,TEST_SERVICE_2,TEST_SERVICE_3);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(\"\");\n    KubernetesDiscoveryProperties kubernetesDiscoveryProperties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,null,0,false);\n    KubernetesInformerReactiveDiscoveryClient discoveryClient\u003dnew KubernetesInformerReactiveDiscoveryClient(new KubernetesInformerDiscoveryClient(sharedInformerFactory,serviceLister,endpointsLister,null,null,kubernetesDiscoveryProperties));\n    StepVerifier.create(discoveryClient.getServices()).expectNext(TEST_SERVICE_1.getMetadata().getName(),TEST_SERVICE_2.getMetadata().getName()).expectComplete().verify();\n  }\n  @Test void testDiscoveryGetServicesOneNamespaceShouldWork(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(NAMESPACE_1,TEST_SERVICE_1,TEST_SERVICE_2);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(\"\");\n    KubernetesInformerReactiveDiscoveryClient discoveryClient\u003dnew KubernetesInformerReactiveDiscoveryClient(new KubernetesInformerDiscoveryClient(sharedInformerFactory,serviceLister,endpointsLister,null,null,KubernetesDiscoveryProperties.DEFAULT));\n    StepVerifier.create(discoveryClient.getServices()).expectNext(TEST_SERVICE_1.getMetadata().getName()).expectComplete().verify();\n  }\n  @Test void testDiscoveryGetInstanceAllNamespaceShouldWork(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(NAMESPACE_ALL,TEST_SERVICE_1,TEST_SERVICE_2);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(NAMESPACE_1,TEST_ENDPOINTS_1);\n    KubernetesDiscoveryProperties kubernetesDiscoveryProperties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    KubernetesInformerReactiveDiscoveryClient discoveryClient\u003dnew KubernetesInformerReactiveDiscoveryClient(new KubernetesInformerDiscoveryClient(sharedInformerFactory,serviceLister,endpointsLister,null,null,kubernetesDiscoveryProperties));\n    StepVerifier.create(discoveryClient.getInstances(\"test-svc-1\")).expectNext(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"2.2.2.2\",8080,Map.of(\"type\",\"ClusterIP\",\"port.\u003cunset\u003e\",\"8080\",\"k8s_namespace\",\"namespace1\"),false,\"namespace1\",null)).expectComplete().verify();\n  }\n  @Test void testDiscoveryGetInstanceOneNamespaceShouldWork(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(NAMESPACE_1,TEST_SERVICE_1,TEST_SERVICE_2);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(NAMESPACE_1,TEST_ENDPOINTS_1);\n    KubernetesDiscoveryProperties kubernetesDiscoveryProperties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    KubernetesInformerReactiveDiscoveryClient discoveryClient\u003dnew KubernetesInformerReactiveDiscoveryClient(new KubernetesInformerDiscoveryClient(sharedInformerFactory,serviceLister,endpointsLister,null,null,kubernetesDiscoveryProperties));\n    StepVerifier.create(discoveryClient.getInstances(\"test-svc-1\")).expectNext(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"2.2.2.2\",8080,Map.of(\"type\",\"ClusterIP\",\"port.\u003cunset\u003e\",\"8080\",\"k8s_namespace\",\"namespace1\"),false,\"namespace1\",null)).expectComplete().verify();\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - service-a in namespace-a exists - service-b in namespace-b exists As such, both services are found. \u003c/pre\u003e\n */\n  @Test void testAllNamespacesTwoServicesPresent(){\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(\"\");\n    boolean allNamespaces\u003dtrue;\n    V1Service serviceA\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"service-a\").namespace(\"namespace-a\"));\n    V1Service serviceB\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"service-b\").namespace(\"namespace-b\"));\n    serviceCache.add(serviceA);\n    serviceCache.add(serviceB);\n    Lister\u003cV1Service\u003e serviceLister\u003dnew Lister\u003c\u003e(serviceCache).namespace(NAMESPACE_ALL);\n    KubernetesDiscoveryProperties kubernetesDiscoveryProperties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(),true,60,false,null,Set.of(),Map.of(),null,null,0,false);\n    KubernetesInformerReactiveDiscoveryClient discoveryClient\u003dnew KubernetesInformerReactiveDiscoveryClient(new KubernetesInformerDiscoveryClient(sharedInformerFactory,serviceLister,endpointsLister,null,null,kubernetesDiscoveryProperties));\n    List\u003cString\u003e result\u003ddiscoveryClient.getServices().collectList().block();\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertTrue(result.contains(\"service-a\"));\n    Assertions.assertTrue(result.contains(\"service-b\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - service-a in namespace-a exists - service-b in namespace-b exists - service lister exists in namespace-a As such, one service is found. \u003c/pre\u003e\n */\n  @Test void testSingleNamespaceTwoServicesPresent(){\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(\"\");\n    boolean allNamespaces\u003dfalse;\n    V1Service serviceA\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"service-a\").namespace(\"namespace-a\"));\n    V1Service serviceB\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"service-b\").namespace(\"namespace-b\"));\n    serviceCache.add(serviceA);\n    serviceCache.add(serviceB);\n    Lister\u003cV1Service\u003e serviceLister\u003dnew Lister\u003c\u003e(serviceCache).namespace(\"namespace-a\");\n    KubernetesDiscoveryProperties kubernetesDiscoveryProperties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(),true,60,false,null,Set.of(),Map.of(),null,null,0,false);\n    KubernetesInformerReactiveDiscoveryClient discoveryClient\u003dnew KubernetesInformerReactiveDiscoveryClient(new KubernetesInformerDiscoveryClient(sharedInformerFactory,serviceLister,endpointsLister,null,null,kubernetesDiscoveryProperties));\n    List\u003cString\u003e result\u003ddiscoveryClient.getServices().collectList().block();\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertTrue(result.contains(\"service-a\"));\n    Assertions.assertFalse(result.contains(\"service-b\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - endpoints-X in namespace-a exists - endpoints-X in namespace-b exists As such, both endpoints are found. \u003c/pre\u003e\n */\n  @Test void testAllNamespacesTwoEndpointsPresent(){\n    boolean allNamespaces\u003dtrue;\n    V1Service serviceXNamespaceA\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"endpoints-x\").namespace(\"namespace-a\")).spec(new V1ServiceSpecBuilder().withType(\"ClusterIP\").build());\n    V1Service serviceXNamespaceB\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"endpoints-x\").namespace(\"namespace-b\")).spec(new V1ServiceSpecBuilder().withType(\"ClusterIP\").build());\n    serviceCache.add(serviceXNamespaceA);\n    serviceCache.add(serviceXNamespaceB);\n    V1Endpoints endpointsXNamespaceA\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"endpoints-x\").namespace(\"namespace-a\")).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080)).addAddressesItem(new V1EndpointAddress().ip(\"1.1.1.1\")));\n    V1Endpoints endpointsXNamespaceB\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"endpoints-x\").namespace(\"namespace-b\")).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080)).addAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\")));\n    endpointsCache.add(endpointsXNamespaceA);\n    endpointsCache.add(endpointsXNamespaceB);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dnew Lister\u003c\u003e(endpointsCache,NAMESPACE_ALL);\n    Lister\u003cV1Service\u003e serviceLister\u003dnew Lister\u003c\u003e(serviceCache,NAMESPACE_ALL);\n    KubernetesDiscoveryProperties kubernetesDiscoveryProperties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    KubernetesInformerReactiveDiscoveryClient discoveryClient\u003dnew KubernetesInformerReactiveDiscoveryClient(new KubernetesInformerDiscoveryClient(sharedInformerFactory,serviceLister,endpointsLister,null,null,kubernetesDiscoveryProperties));\n    List\u003cServiceInstance\u003e result\u003ddiscoveryClient.getInstances(\"endpoints-x\").collectList().block();\n    Assertions.assertEquals(result.size(),2);\n    List\u003cString\u003e byIp\u003dresult.stream().map(ServiceInstance::getHost).sorted().toList();\n    Assertions.assertTrue(byIp.contains(\"1.1.1.1\"));\n    Assertions.assertTrue(byIp.contains(\"2.2.2.2\"));\n  }\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - endpoints-X in namespace-a exists - endpoints-X in namespace-b exists We search in namespace-a, only. As such, single endpoints is found. \u003c/pre\u003e\n */\n  @Test void testAllSingleTwoEndpointsPresent(){\n    boolean allNamespaces\u003dtrue;\n    V1Service serviceXNamespaceA\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"endpoints-x\").namespace(\"namespace-a\")).spec(new V1ServiceSpecBuilder().withType(\"ClusterIP\").build());\n    V1Service serviceXNamespaceB\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"endpoints-x\").namespace(\"namespace-b\")).spec(new V1ServiceSpecBuilder().withType(\"ClusterIP\").build());\n    serviceCache.add(serviceXNamespaceA);\n    serviceCache.add(serviceXNamespaceB);\n    V1Endpoints endpointsXNamespaceA\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"endpoints-x\").namespace(\"namespace-a\")).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080)).addAddressesItem(new V1EndpointAddress().ip(\"1.1.1.1\")));\n    V1Endpoints endpointsXNamespaceB\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"endpoints-x\").namespace(\"namespace-b\")).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080)).addAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\")));\n    endpointsCache.add(endpointsXNamespaceA);\n    endpointsCache.add(endpointsXNamespaceB);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dnew Lister\u003c\u003e(endpointsCache).namespace(\"namespace-a\");\n    Lister\u003cV1Service\u003e serviceLister\u003dnew Lister\u003c\u003e(serviceCache).namespace(\"namespace-a\");\n    KubernetesDiscoveryProperties kubernetesDiscoveryProperties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    KubernetesInformerReactiveDiscoveryClient discoveryClient\u003dnew KubernetesInformerReactiveDiscoveryClient(new KubernetesInformerDiscoveryClient(sharedInformerFactory,serviceLister,endpointsLister,null,null,kubernetesDiscoveryProperties));\n    List\u003cServiceInstance\u003e result\u003ddiscoveryClient.getInstances(\"endpoints-x\").collectList().block();\n    Assertions.assertEquals(result.size(),1);\n    List\u003cString\u003e byIp\u003dresult.stream().map(ServiceInstance::getHost).sorted().toList();\n    Assertions.assertTrue(byIp.contains(\"1.1.1.1\"));\n  }\n  private Lister\u003cV1Service\u003e setupServiceLister(  String namespace,  V1Service... services){\n    Lister\u003cV1Service\u003e serviceLister\u003dnew Lister\u003c\u003e(serviceCache,namespace);\n    for (    V1Service svc : services) {\n      serviceCache.add(svc);\n    }\n    return serviceLister;\n  }\n  private Lister\u003cV1Endpoints\u003e setupEndpointsLister(  String namespace,  V1Endpoints... endpoints){\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dnew Lister\u003c\u003e(endpointsCache);\n    for (    V1Endpoints ep : endpoints) {\n      endpointsCache.add(ep);\n    }\n    return endpointsLister;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass KubernetesInformerReactiveDiscoveryClientTests {\n  private Cache\u003cV1Service\u003e serviceCache\u003dnew Cache\u003c\u003e();\n  private Cache\u003cV1Endpoints\u003e endpointsCache\u003dnew Cache\u003c\u003e();\n  private static final String NAMESPACE_1\u003d\"namespace1\";\n  private static final String NAMESPACE_2\u003d\"namespace2\";\n  private final SharedInformerFactory sharedInformerFactory\u003dMockito.mock(SharedInformerFactory.class);\n  private static final V1Service TEST_SERVICE_1\u003dnew V1Service().spec(new V1ServiceSpec().type(\"ClusterIP\")).metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(NAMESPACE_1));\n  private static final V1Service TEST_SERVICE_2\u003dnew V1Service().spec(new V1ServiceSpec().type(\"ClusterIP\")).metadata(new V1ObjectMeta().name(\"test-svc-2\").namespace(NAMESPACE_2));\n  private static final V1Service TEST_SERVICE_3\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"test-svc-2\").namespace(NAMESPACE_2));\n  private static final V1Endpoints TEST_ENDPOINTS_1\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(NAMESPACE_1)).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080)).addAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\")));\n  @AfterEach void afterEach();\n  @Test void testDiscoveryGetServicesAllNamespaceShouldWork();\n  @Test void testDiscoveryGetServicesOneNamespaceShouldWork();\n  @Test void testDiscoveryGetInstanceAllNamespaceShouldWork();\n  @Test void testDiscoveryGetInstanceOneNamespaceShouldWork();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - service-a in namespace-a exists - service-b in namespace-b exists As such, both services are found. \u003c/pre\u003e\n */\n  @Test void testAllNamespacesTwoServicesPresent();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d false - service-a in namespace-a exists - service-b in namespace-b exists - service lister exists in namespace-a As such, one service is found. \u003c/pre\u003e\n */\n  @Test void testSingleNamespaceTwoServicesPresent();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - endpoints-X in namespace-a exists - endpoints-X in namespace-b exists As such, both endpoints are found. \u003c/pre\u003e\n */\n  @Test void testAllNamespacesTwoEndpointsPresent();\n  /** \n * \u003cpre\u003e - all-namespaces \u003d true - endpoints-X in namespace-a exists - endpoints-X in namespace-b exists We search in namespace-a, only. As such, single endpoints is found. \u003c/pre\u003e\n */\n  @Test void testAllSingleTwoEndpointsPresent();\n  private Lister\u003cV1Service\u003e setupServiceLister(  String namespace,  V1Service... services);\n  private Lister\u003cV1Endpoints\u003e setupEndpointsLister(  String namespace,  V1Endpoints... endpoints);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/reactive/KubernetesInformerReactiveDiscoveryClientAutoConfigurationApplicationContextTests.java",
        "name": "KubernetesInformerReactiveDiscoveryClientAutoConfigurationApplicationContextTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.reactive.KubernetesInformerReactiveDiscoveryClientAutoConfigurationApplicationContextTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Test various conditionals for {@link KubernetesInformerReactiveDiscoveryClientAutoConfiguration}\n * @author wind57\n */\nclass KubernetesInformerReactiveDiscoveryClientAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  private static K3sContainer container;\n  @AfterAll static void afterAll(){\n    container.stop();\n  }\n  @Test void discoveryEnabledDefault(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"kubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).getBeans(ReactiveDiscoveryClientHealthIndicator.class).size().isEqualTo(2);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).hasBean(\"reactiveIndicatorInitializer\");\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void discoveryEnabledDefaultWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b,c\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"selectiveNamespacesKubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).getBeans(ReactiveDiscoveryClientHealthIndicator.class).size().isEqualTo(2);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).hasBean(\"reactiveIndicatorInitializer\");\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,3);\n    }\n);\n  }\n  @Test void discoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"kubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).getBeans(ReactiveDiscoveryClientHealthIndicator.class).size().isEqualTo(2);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).hasBean(\"reactiveIndicatorInitializer\");\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void discoveryEnabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b,c\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"selectiveNamespacesKubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).getBeans(ReactiveDiscoveryClientHealthIndicator.class).size().isEqualTo(2);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).hasBean(\"reactiveIndicatorInitializer\");\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,3);\n    }\n);\n  }\n  @Test void discoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void discoveryDisabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b,c\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"kubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).getBeans(ReactiveDiscoveryClientHealthIndicator.class).size().isEqualTo(2);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).hasBean(\"reactiveIndicatorInitializer\");\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryEnabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"selectiveNamespacesKubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).getBeans(ReactiveDiscoveryClientHealthIndicator.class).size().isEqualTo(2);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).hasBean(\"reactiveIndicatorInitializer\");\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,2);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).hasSingleBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesDiscoveryDisabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).hasSingleBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesReactiveDiscoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"kubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).getBeans(ReactiveDiscoveryClientHealthIndicator.class).size().isEqualTo(2);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).hasBean(\"reactiveIndicatorInitializer\");\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesReactiveDiscoveryEnabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"selectiveNamespacesKubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).getBeans(ReactiveDiscoveryClientHealthIndicator.class).size().isEqualTo(2);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).hasBean(\"reactiveIndicatorInitializer\");\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,2);\n    }\n);\n  }\n  @Test void kubernetesReactiveDiscoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void kubernetesReactiveDiscoveryDisabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,2);\n    }\n);\n  }\n  /** \n * blocking is disabled, and it should not impact reactive in any way.\n */\n  @Test void blockingDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"kubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).getBeans(ReactiveDiscoveryClientHealthIndicator.class).size().isEqualTo(2);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).hasBean(\"reactiveIndicatorInitializer\");\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  /** \n * blocking is disabled, and it should not impact reactive in any way.\n */\n  @Test void blockingDisabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"selectiveNamespacesKubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).getBeans(ReactiveDiscoveryClientHealthIndicator.class).size().isEqualTo(2);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertThat(context).hasBean(\"reactiveIndicatorInitializer\");\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,2);\n    }\n);\n  }\n  @Test void healthDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"kubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void healthDisabledWithSelectiveNamespaces(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"selectiveNamespacesKubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,2);\n    }\n);\n  }\n  @Test void healthEnabledClassNotPresent(){\n    setupWithFilteredClassLoader(\"org.springframework.boot.actuate.health.ReactiveHealthIndicator\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"kubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertNonSelectiveNamespacesBeansPresent(context);\n      assertSelectiveNamespacesBeansMissing(context);\n    }\n);\n  }\n  @Test void healthEnabledClassNotPresentWithSelectiveNamespaces(){\n    setupWithFilteredClassLoader(\"org.springframework.boot.actuate.health.ReactiveHealthIndicator\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces\u003da,b\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesInformerDiscoveryClient.class);\n      assertThat(context).hasBean(\"selectiveNamespacesKubernetesClientInformerDiscoveryClient\");\n      assertThat(context).hasSingleBean(KubernetesInformerReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClientHealthIndicatorInitializer.class);\n      assertNonSelectiveNamespacesBeansMissing(context);\n      assertSelectiveNamespacesBeansPresent(context,2);\n    }\n);\n  }\n  private void setup(  String... properties){\n    applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesInformerReactiveDiscoveryClientAutoConfiguration.class,KubernetesClientAutoConfiguration.class,SimpleReactiveDiscoveryClientAutoConfiguration.class,UtilAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class,KubernetesClientInformerSelectiveNamespacesAutoConfiguration.class,KubernetesCommonsAutoConfiguration.class,KubernetesClientInformerAutoConfiguration.class)).withUserConfiguration(ApiClientConfig.class).withPropertyValues(properties);\n  }\n  private void setupWithFilteredClassLoader(  String name,  String... properties){\n    applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesInformerReactiveDiscoveryClientAutoConfiguration.class,KubernetesClientAutoConfiguration.class,SimpleReactiveDiscoveryClientAutoConfiguration.class,UtilAutoConfiguration.class,KubernetesDiscoveryPropertiesAutoConfiguration.class,KubernetesClientInformerSelectiveNamespacesAutoConfiguration.class,KubernetesCommonsAutoConfiguration.class,KubernetesClientInformerAutoConfiguration.class)).withUserConfiguration(ApiClientConfig.class).withClassLoader(new FilteredClassLoader(name)).withPropertyValues(properties);\n  }\n@Configuration static class ApiClientConfig {\n    @Bean @Primary ApiClient apiClient() throws Exception {\n      container\u003dCommons.container();\n      container.start();\n      return Config.fromConfig(new StringReader(container.getKubeConfigYaml()));\n    }\n  }\n}\n",
        "abstract": "/** \n * Test various conditionals for {@link KubernetesInformerReactiveDiscoveryClientAutoConfiguration}\n * @author wind57\n */\nclass KubernetesInformerReactiveDiscoveryClientAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  private static K3sContainer container;\n  @AfterAll static void afterAll();\n  @Test void discoveryEnabledDefault();\n  @Test void discoveryEnabledDefaultWithSelectiveNamespaces();\n  @Test void discoveryEnabled();\n  @Test void discoveryEnabledWithSelectiveNamespaces();\n  @Test void discoveryDisabled();\n  @Test void discoveryDisabledWithSelectiveNamespaces();\n  @Test void kubernetesDiscoveryEnabled();\n  @Test void kubernetesDiscoveryEnabledWithSelectiveNamespaces();\n  @Test void kubernetesDiscoveryDisabled();\n  @Test void kubernetesDiscoveryDisabledWithSelectiveNamespaces();\n  @Test void kubernetesReactiveDiscoveryEnabled();\n  @Test void kubernetesReactiveDiscoveryEnabledWithSelectiveNamespaces();\n  @Test void kubernetesReactiveDiscoveryDisabled();\n  @Test void kubernetesReactiveDiscoveryDisabledWithSelectiveNamespaces();\n  /** \n * blocking is disabled, and it should not impact reactive in any way.\n */\n  @Test void blockingDisabled();\n  /** \n * blocking is disabled, and it should not impact reactive in any way.\n */\n  @Test void blockingDisabledWithSelectiveNamespaces();\n  @Test void healthDisabled();\n  @Test void healthDisabledWithSelectiveNamespaces();\n  @Test void healthEnabledClassNotPresent();\n  @Test void healthEnabledClassNotPresentWithSelectiveNamespaces();\n  private void setup(  String... properties);\n  private void setupWithFilteredClassLoader(  String name,  String... properties);\n@Configuration static class ApiClientConfig {\n    @Bean @Primary ApiClient apiClient() throws Exception;\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesInformerDiscoveryClientTests.java",
        "name": "KubernetesInformerDiscoveryClientTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesInformerDiscoveryClientTests",
        "extend": "",
        "implements": "",
        "raw": "class KubernetesInformerDiscoveryClientTests {\n  private static final V1Service SERVICE_1\u003dservice(\"test-svc-1\",\"namespace1\",Map.of());\n  private static final V1Service SERVICE_2\u003dservice(\"test-svc-1\",\"namespace2\",Map.of());\n  private static final V1Service SERVICE_3\u003dservice(\"test-svc-3\",\"namespace1\",Map.of(\"spring\",\"true\",\"k8s\",\"true\"));\n  private static final V1Service SERVICE_4\u003dservice(\"test-svc-1\",\"namespace1\",Map.of(\"secured\",\"true\"));\n  private static final V1Service SERVICE_5\u003dservice(\"test-svc-1\",\"namespace1\",Map.of(\"primary-port-name\",\"oops\"));\n  private static final V1Service SERVICE_6\u003dservice(\"test-svc-1\",\"namespace1\",Map.of(\"primary-port-name\",\"https\"));\n  private static final SharedInformerFactory SHARED_INFORMER_FACTORY\u003dMockito.mock(SharedInformerFactory.class);\n  private static final V1Endpoints ENDPOINTS_1\u003dendpointsReadyAddress(\"test-svc-1\",\"namespace1\");\n  private static final V1Endpoints ENDPOINTS_2\u003dendpointsReadyAddress(\"test-svc-1\",\"namespace2\");\n  private static final V1Endpoints ENDPOINTS_3\u003dendpointsReadyAddress(\"test-svc-3\",\"namespace1\");\n  private static final V1Endpoints ENDPOINTS_NOT_READY_ADDRESS\u003dendpointsNotReadyAddress();\n  private static final V1Endpoints ENDPOINTS_NO_PORTS\u003dendpointsNoPorts();\n  private static final V1Endpoints ENDPOINTS_NO_UNSET_PORT_NAME\u003dendpointsNoUnsetPortName();\n  private static final V1Endpoints ENDPOINTS_WITH\u003dendpointsWithMultiplePorts();\n  private static final V1Endpoints ENDPOINTS_WITH_MULTIPLE_PORTS_NO_HTTPS\u003dendpointsWithMultiplePortsNoHttps();\n  private static final V1Endpoints ENDPOINTS_MULTIPLE_PORTS_WITHOUT_SUPPORTED_PORT_NAMES\u003dendpointsMultiplePortsWithoutSupportedPortNames();\n  private static final KubernetesDiscoveryProperties ALL_NAMESPACES\u003dproperties(true,Map.of());\n  private static final KubernetesDiscoveryProperties NOT_ALL_NAMESPACES\u003dproperties(false,Map.of());\n  @Test void testServiceWithUnsetPortNames(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_NO_UNSET_PORT_NAME);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,ALL_NAMESPACES);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\").toArray()).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"1.1.1.1\",80,Map.of(\"port.\u003cunset\u003e\",\"80\",\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),false,\"namespace1\",null));\n  }\n  @Test void testDiscoveryGetServicesAllNamespaceShouldWork(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1,SERVICE_2);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_NO_UNSET_PORT_NAME);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,KubernetesDiscoveryProperties.DEFAULT);\n    assertThat(discoveryClient.getServices().toArray()).containsOnly(SERVICE_1.getMetadata().getName(),SERVICE_2.getMetadata().getName());\n  }\n  @Test void testDiscoveryWithServiceLabels(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1,SERVICE_2,SERVICE_3);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_NO_UNSET_PORT_NAME);\n    Map\u003cString,String\u003e labels\u003dMap.of(\"k8s\",\"true\",\"spring\",\"true\");\n    KubernetesDiscoveryProperties kubernetesDiscoveryProperties\u003dproperties(true,labels);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,kubernetesDiscoveryProperties);\n    assertThat(discoveryClient.getServices().toArray()).containsOnly(SERVICE_3.getMetadata().getName());\n  }\n  @Test void testDiscoveryInstancesWithServiceLabels(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1,SERVICE_2,SERVICE_3);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_1,ENDPOINTS_3);\n    Map\u003cString,String\u003e labels\u003dMap.of(\"k8s\",\"true\",\"spring\",\"true\");\n    KubernetesDiscoveryProperties kubernetesDiscoveryProperties\u003dproperties(true,labels);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,kubernetesDiscoveryProperties);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\").toArray()).isEmpty();\n    assertThat(discoveryClient.getInstances(\"test-svc-3\").toArray()).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-3\",\"2.2.2.2\",8080,Map.of(\"spring\",\"true\",\"port.\u003cunset\u003e\",\"8080\",\"k8s\",\"true\",\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),false,\"namespace1\",null));\n  }\n  @Test void testDiscoveryInstancesWithSecuredServiceByAnnotations(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_4);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_1);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,ALL_NAMESPACES);\n    assertThat(discoveryClient.getServices().toArray()).containsOnly(SERVICE_4.getMetadata().getName());\n    ServiceInstance serviceInstance\u003ddiscoveryClient.getInstances(SERVICE_4.getMetadata().getName()).get(0);\n    assertThat(serviceInstance.isSecure()).isTrue();\n  }\n  @Test void testDiscoveryInstancesWithSecuredServiceByLabels(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_4);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_1);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,ALL_NAMESPACES);\n    assertThat(discoveryClient.getServices().toArray()).containsOnly(SERVICE_4.getMetadata().getName());\n    ServiceInstance serviceInstance\u003ddiscoveryClient.getInstances(SERVICE_4.getMetadata().getName()).get(0);\n    assertThat(serviceInstance.isSecure()).isTrue();\n  }\n  @Test void testDiscoveryGetServicesOneNamespaceShouldWork(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1,SERVICE_2);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_NO_UNSET_PORT_NAME);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,KubernetesDiscoveryProperties.DEFAULT);\n    assertThat(discoveryClient.getServices().toArray()).containsOnly(SERVICE_1.getMetadata().getName());\n  }\n  @Test void testDiscoveryGetInstanceAllNamespaceShouldWork(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1,SERVICE_2);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_1);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,ALL_NAMESPACES);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"2.2.2.2\",8080,Map.of(\"port.\u003cunset\u003e\",\"8080\",\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),false,\"namespace1\",null));\n  }\n  @Test void testDiscoveryGetInstanceOneNamespaceShouldWork(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1,SERVICE_2);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_1);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,NOT_ALL_NAMESPACES);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"2.2.2.2\",8080,Map.of(\"port.\u003cunset\u003e\",\"8080\",\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),false,\"namespace1\",null));\n  }\n  @Test void testDiscoveryGetInstanceWithoutReadyAddressesShouldWork(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_NOT_READY_ADDRESS);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,KubernetesDiscoveryProperties.DEFAULT);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).isEmpty();\n  }\n  @Test void testDiscoveryGetInstanceWithNotReadyAddressesIncludedShouldWork(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_NOT_READY_ADDRESS);\n    KubernetesDiscoveryProperties kubernetesDiscoveryProperties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,true,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,kubernetesDiscoveryProperties);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"2.2.2.2\",8080,Map.of(\"port.\u003cunset\u003e\",\"8080\",\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),false,\"namespace1\",null));\n  }\n  @Test void instanceWithoutEndpointsShouldBeSkipped(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister();\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,KubernetesDiscoveryProperties.DEFAULT);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).isEmpty();\n  }\n  @Test void instanceWithoutPortsWillNotBeSkipped(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_NO_PORTS);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,KubernetesDiscoveryProperties.DEFAULT);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"1.1.1.1\",0,Map.of(\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),false,\"namespace1\",null));\n  }\n  @Test void instanceWithMultiplePortsAndPrimaryPortNameConfiguredWithLabelShouldWork(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_6);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_WITH);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,NOT_ALL_NAMESPACES);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"1.1.1.1\",443,Map.of(\"port.http\",\"80\",\"primary-port-name\",\"https\",\"port.https\",\"443\",\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),true,\"namespace1\",null));\n  }\n  @Test void instanceWithMultiplePortsAndMisconfiguredPrimaryPortNameInLabelShouldReturnFirstPortAndLogWarning(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_5);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_MULTIPLE_PORTS_WITHOUT_SUPPORTED_PORT_NAMES);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,NOT_ALL_NAMESPACES);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"1.1.1.1\",80,Map.of(\"port.tcp1\",\"80\",\"primary-port-name\",\"oops\",\"port.tcp2\",\"443\",\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),false,\"namespace1\",null));\n  }\n  @Test void instanceWithMultiplePortsAndGenericPrimaryPortNameConfiguredShouldWork(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_WITH);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,NOT_ALL_NAMESPACES);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"1.1.1.1\",443,Map.of(\"port.http\",\"80\",\"port.https\",\"443\",\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),true,\"namespace1\",null));\n  }\n  @Test void instanceWithMultiplePortsAndMisconfiguredGenericPrimaryPortNameShouldReturnFirstPortAndLogWarning(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_MULTIPLE_PORTS_WITHOUT_SUPPORTED_PORT_NAMES);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,NOT_ALL_NAMESPACES);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"1.1.1.1\",80,Map.of(\"port.tcp1\",\"80\",\"port.tcp2\",\"443\",\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),false,\"namespace1\",null));\n  }\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedShouldFallBackToHttpsPort(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_WITH);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,NOT_ALL_NAMESPACES);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"1.1.1.1\",443,Map.of(\"port.http\",\"80\",\"port.https\",\"443\",\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),true,\"namespace1\",null));\n  }\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedOrHttpsPortShouldFallBackToHttpPort(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_WITH_MULTIPLE_PORTS_NO_HTTPS);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,NOT_ALL_NAMESPACES);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"1.1.1.1\",80,Map.of(\"port.http\",\"80\",\"port.tcp\",\"443\",\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),false,\"namespace1\",null));\n  }\n  @Test void instanceWithMultiplePortsAndWithoutAnyConfigurationShouldPickTheFirstPort(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_MULTIPLE_PORTS_WITHOUT_SUPPORTED_PORT_NAMES);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,NOT_ALL_NAMESPACES);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"1.1.1.1\",80,Map.of(\"port.tcp1\",\"80\",\"port.tcp2\",\"443\",\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),false,\"namespace1\",null));\n  }\n  @Test void getInstancesShouldReturnInstancesWithTheSameServiceIdFromNamespaces(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1,SERVICE_2);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_1,ENDPOINTS_2);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,ALL_NAMESPACES);\n    assertThat(discoveryClient.getInstances(\"test-svc-1\")).containsOnly(new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"2.2.2.2\",8080,Map.of(\"port.\u003cunset\u003e\",\"8080\",\"k8s_namespace\",\"namespace1\",\"type\",\"ClusterIP\"),false,\"namespace1\",null),new DefaultKubernetesServiceInstance(null,\"test-svc-1\",\"2.2.2.2\",8080,Map.of(\"port.\u003cunset\u003e\",\"8080\",\"k8s_namespace\",\"namespace2\",\"type\",\"ClusterIP\"),false,\"namespace2\",null));\n  }\n  @Test void testBothServicesMatchesFilter(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1,SERVICE_3);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_1,ENDPOINTS_3);\n    String spelFilter\u003dnull;\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,false,Set.of(),true,60L,false,spelFilter,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,properties);\n    assertThat(discoveryClient.getServices()).contains(\"test-svc-1\",\"test-svc-3\");\n    List\u003cServiceInstance\u003e one\u003ddiscoveryClient.getInstances(\"test-svc-1\");\n    assertThat(one.get(0).getMetadata().get(\"k8s_namespace\")).isEqualTo(\"namespace1\");\n    List\u003cServiceInstance\u003e two\u003ddiscoveryClient.getInstances(\"test-svc-3\");\n    assertThat(two.get(0).getMetadata().get(\"k8s_namespace\")).isEqualTo(\"namespace1\");\n  }\n  @Test void testOneServiceMatchesFilter(){\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(SERVICE_1,SERVICE_2);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(ENDPOINTS_1,ENDPOINTS_2);\n    String spelFilter\u003d\"\";\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,false,Set.of(),true,60L,false,spelFilter,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,properties);\n    assertThat(discoveryClient.getServices()).contains(\"test-svc-1\");\n    List\u003cServiceInstance\u003e result\u003ddiscoveryClient.getInstances(\"test-svc-1\").stream().sorted(Comparator.comparing(res -\u003e res.getMetadata().get(\"k8s_namespace\"))).toList();\n    assertThat(result.get(0).getMetadata().get(\"k8s_namespace\")).isEqualTo(\"namespace1\");\n    assertThat(result.get(1).getMetadata().get(\"k8s_namespace\")).isEqualTo(\"namespace2\");\n    spelFilter\u003dnull;\n    properties\u003dnew KubernetesDiscoveryProperties(false,false,Set.of(),true,60L,false,spelFilter,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,properties);\n    assertThat(discoveryClient.getServices()).contains(\"test-svc-1\");\n    result\u003ddiscoveryClient.getInstances(\"test-svc-1\").stream().sorted(Comparator.comparing(res -\u003e res.getMetadata().get(\"k8s_namespace\"))).toList();\n    assertThat(result.size()).isEqualTo(1);\n    assertThat(result.get(0).getMetadata().get(\"k8s_namespace\")).isEqualTo(\"namespace1\");\n  }\n  @Test void testServicesWithDifferentMetadataLabels(){\n    V1Service serviceA\u003dservice(\"serviceX\",\"namespaceA\",Map.of(\"shape\",\"round\"));\n    V1Service serviceB\u003dservice(\"serviceX\",\"namespaceB\",Map.of(\"shape\",\"triangle\"));\n    V1Endpoints endpointsA\u003dendpointsReadyAddress(\"serviceX\",\"namespaceA\");\n    V1Endpoints endpointsB\u003dendpointsReadyAddress(\"serviceX\",\"namespaceB\");\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(serviceA,serviceB);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(endpointsA,endpointsB);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,true,Set.of(),true,60L,false,null,Set.of(),Map.of(\"shape\",\"round\"),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,properties);\n    List\u003cServiceInstance\u003e serviceInstances\u003ddiscoveryClient.getInstances(\"serviceX\");\n    assertThat(serviceInstances.size()).isEqualTo(1);\n    assertThat(serviceInstances.get(0).getMetadata().get(\"k8s_namespace\")).isEqualTo(\"namespaceA\");\n  }\n  @Test void testServicesWithSameMetadataLabels(){\n    V1Service serviceA\u003dservice(\"serviceX\",\"namespaceA\",Map.of(\"shape\",\"round\"));\n    V1Service serviceB\u003dservice(\"serviceX\",\"namespaceB\",Map.of(\"shape\",\"round\"));\n    V1Endpoints endpointsA\u003dendpointsReadyAddress(\"serviceX\",\"namespaceA\");\n    V1Endpoints endpointsB\u003dendpointsReadyAddress(\"serviceX\",\"namespaceB\");\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(serviceA,serviceB);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(endpointsA,endpointsB);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(false,true,Set.of(),true,60L,false,null,Set.of(),Map.of(\"shape\",\"round\"),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,properties);\n    List\u003cServiceInstance\u003e serviceInstances\u003ddiscoveryClient.getInstances(\"serviceX\").stream().sorted(Comparator.comparing(x -\u003e x.getMetadata().get(\"k8s_namespace\"))).toList();\n    assertThat(serviceInstances.size()).isEqualTo(2);\n    assertThat(serviceInstances.get(0).getMetadata().get(\"k8s_namespace\")).isEqualTo(\"namespaceA\");\n    assertThat(serviceInstances.get(1).getMetadata().get(\"k8s_namespace\")).isEqualTo(\"namespaceB\");\n  }\n  @Test void testExternalNameService(){\n    V1Service externalNameService\u003dnew V1ServiceBuilder().withSpec(new V1ServiceSpecBuilder().withType(\"ExternalName\").withExternalName(\"k8s-spring-b\").build()).withNewMetadata().withLabels(Map.of(\"label-key\",\"label-value\")).withAnnotations(Map.of(\"abc\",\"def\")).withName(\"blue-service\").withNamespace(\"b\").endMetadata().build();\n    V1Endpoints endpoints\u003dnew V1EndpointsBuilder().withMetadata(new V1ObjectMeta().namespace(\"irrelevant\")).build();\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(externalNameService);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(endpoints);\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(true,\"labels-prefix-\",true,\"annotations-prefix-\",true,\"ports-prefix\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(\"a\",\"b\"),true,60L,false,\"\",Set.of(),Map.of(),\"\",metadata,0,false,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,properties);\n    List\u003cServiceInstance\u003e result\u003ddiscoveryClient.getInstances(\"blue-service\");\n    Assertions.assertEquals(result.size(),1);\n    DefaultKubernetesServiceInstance externalNameServiceInstance\u003d(DefaultKubernetesServiceInstance)result.get(0);\n    Assertions.assertEquals(externalNameServiceInstance.getServiceId(),\"blue-service\");\n    Assertions.assertEquals(externalNameServiceInstance.getHost(),\"k8s-spring-b\");\n    Assertions.assertEquals(externalNameServiceInstance.getPort(),-1);\n    Assertions.assertFalse(externalNameServiceInstance.isSecure());\n    Assertions.assertEquals(externalNameServiceInstance.getUri().toASCIIString(),\"k8s-spring-b\");\n    Assertions.assertEquals(externalNameServiceInstance.getMetadata(),Map.of(\"k8s_namespace\",\"b\",\"labels-prefix-label-key\",\"label-value\",\"annotations-prefix-abc\",\"def\",\"type\",\"ExternalName\"));\n  }\n  @Test void testPodMetadata(){\n    V1Service nonExternalNameService\u003dnew V1ServiceBuilder().withSpec(new V1ServiceSpecBuilder().withType(\"ClusterIP\").build()).withNewMetadata().withName(\"blue-service\").withNamespace(\"a\").endMetadata().build();\n    V1Endpoints endpoints\u003dnew V1EndpointsBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"blue-service\").withNamespace(\"a\").build()).withSubsets(new V1EndpointSubsetBuilder().withPorts(new CoreV1EndpointPortBuilder().withPort(8080).build()).withAddresses(new V1EndpointAddressBuilder().withIp(\"127.0.0.1\").withTargetRef(new V1ObjectReferenceBuilder().withKind(\"Pod\").withName(\"my-pod\").build()).build()).build()).build();\n    Lister\u003cV1Service\u003e serviceLister\u003dsetupServiceLister(nonExternalNameService);\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dsetupEndpointsLister(endpoints);\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + server.port()).build();\n    V1Pod pod\u003dnew V1PodBuilder().withNewMetadata().withName(\"my-pod\").withLabels(Map.of(\"a\",\"b\")).withAnnotations(Map.of(\"c\",\"d\")).endMetadata().build();\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/a/pods/my-pod\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(pod))));\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(true,\"labels-prefix-\",true,\"annotations-prefix-\",true,\"ports-prefix\",true,true);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(\"a\",\"b\"),true,60L,false,\"\",Set.of(),Map.of(),\"\",metadata,0,false,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,properties);\n    discoveryClient.coreV1Api\u003dnew CoreV1Api(apiClient);\n    List\u003cServiceInstance\u003e result\u003ddiscoveryClient.getInstances(\"blue-service\");\n    Assertions.assertEquals(result.size(),1);\n    DefaultKubernetesServiceInstance serviceInstance\u003d(DefaultKubernetesServiceInstance)result.get(0);\n    Assertions.assertEquals(serviceInstance.getServiceId(),\"blue-service\");\n    Assertions.assertEquals(serviceInstance.getHost(),\"127.0.0.1\");\n    Assertions.assertEquals(serviceInstance.getPort(),8080);\n    Assertions.assertFalse(serviceInstance.isSecure());\n    Assertions.assertEquals(serviceInstance.getUri().toASCIIString(),\"http://127.0.0.1:8080\");\n    Assertions.assertEquals(serviceInstance.getMetadata(),Map.of(\"k8s_namespace\",\"a\",\"type\",\"ClusterIP\",\"ports-prefix\u003cunset\u003e\",\"8080\"));\n    Assertions.assertEquals(serviceInstance.podMetadata().get(\"labels\"),Map.of(\"a\",\"b\"));\n    Assertions.assertEquals(serviceInstance.podMetadata().get(\"annotations\"),Map.of(\"c\",\"d\"));\n    server.shutdown();\n  }\n  private Lister\u003cV1Service\u003e setupServiceLister(  V1Service... services){\n    Cache\u003cV1Service\u003e serviceCache\u003dnew Cache\u003c\u003e();\n    Lister\u003cV1Service\u003e serviceLister\u003dnew Lister\u003c\u003e(serviceCache);\n    for (    V1Service svc : services) {\n      serviceCache.add(svc);\n    }\n    return serviceLister;\n  }\n  private Lister\u003cV1Endpoints\u003e setupEndpointsLister(  V1Endpoints... endpoints){\n    Cache\u003cV1Endpoints\u003e endpointsCache\u003dnew Cache\u003c\u003e();\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dnew Lister\u003c\u003e(endpointsCache);\n    for (    V1Endpoints ep : endpoints) {\n      endpointsCache.add(ep);\n    }\n    return endpointsLister;\n  }\n  private static V1Service service(  String name,  String namespace,  Map\u003cString,String\u003e labels){\n    return new V1Service().metadata(new V1ObjectMeta().name(name).namespace(namespace).labels(labels)).spec(new V1ServiceSpec().type(\"ClusterIP\"));\n  }\n  private static V1Endpoints endpointsReadyAddress(  String name,  String namespace){\n    return new V1Endpoints().metadata(new V1ObjectMeta().name(name).namespace(namespace)).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080)).addAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\")));\n  }\n  private static V1Endpoints endpointsNotReadyAddress(){\n    return new V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(\"namespace1\")).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080)).addNotReadyAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\")));\n  }\n  private static V1Endpoints endpointsNoPorts(){\n    return new V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(\"namespace1\")).addSubsetsItem(new V1EndpointSubset().addAddressesItem(new V1EndpointAddress().ip(\"1.1.1.1\")));\n  }\n  private static V1Endpoints endpointsNoUnsetPortName(){\n    return new V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(\"namespace1\")).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(80)).addAddressesItem(new V1EndpointAddress().ip(\"1.1.1.1\")));\n  }\n  private static V1Endpoints endpointsWithMultiplePorts(){\n    return new V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(\"namespace1\")).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().name(\"http\").port(80)).addPortsItem(new CoreV1EndpointPort().name(\"https\").port(443)).addAddressesItem(new V1EndpointAddress().ip(\"1.1.1.1\")));\n  }\n  private static V1Endpoints endpointsWithMultiplePortsNoHttps(){\n    return new V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(\"namespace1\")).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().name(\"http\").port(80)).addPortsItem(new CoreV1EndpointPort().name(\"tcp\").port(443)).addAddressesItem(new V1EndpointAddress().ip(\"1.1.1.1\")));\n  }\n  private static V1Endpoints endpointsMultiplePortsWithoutSupportedPortNames(){\n    return new V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(\"namespace1\")).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().name(\"tcp1\").port(80)).addPortsItem(new CoreV1EndpointPort().name(\"tcp2\").port(443)).addAddressesItem(new V1EndpointAddress().ip(\"1.1.1.1\")));\n  }\n  private static KubernetesDiscoveryProperties properties(  boolean allNamespaces,  Map\u003cString,String\u003e labels){\n    return new KubernetesDiscoveryProperties(false,allNamespaces,Set.of(),true,60,false,null,Set.of(),labels,null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n  }\n}\n",
        "abstract": "class KubernetesInformerDiscoveryClientTests {\n  private static final V1Service SERVICE_1\u003dservice(\"test-svc-1\",\"namespace1\",Map.of());\n  private static final V1Service SERVICE_2\u003dservice(\"test-svc-1\",\"namespace2\",Map.of());\n  private static final V1Service SERVICE_3\u003dservice(\"test-svc-3\",\"namespace1\",Map.of(\"spring\",\"true\",\"k8s\",\"true\"));\n  private static final V1Service SERVICE_4\u003dservice(\"test-svc-1\",\"namespace1\",Map.of(\"secured\",\"true\"));\n  private static final V1Service SERVICE_5\u003dservice(\"test-svc-1\",\"namespace1\",Map.of(\"primary-port-name\",\"oops\"));\n  private static final V1Service SERVICE_6\u003dservice(\"test-svc-1\",\"namespace1\",Map.of(\"primary-port-name\",\"https\"));\n  private static final SharedInformerFactory SHARED_INFORMER_FACTORY\u003dMockito.mock(SharedInformerFactory.class);\n  private static final V1Endpoints ENDPOINTS_1\u003dendpointsReadyAddress(\"test-svc-1\",\"namespace1\");\n  private static final V1Endpoints ENDPOINTS_2\u003dendpointsReadyAddress(\"test-svc-1\",\"namespace2\");\n  private static final V1Endpoints ENDPOINTS_3\u003dendpointsReadyAddress(\"test-svc-3\",\"namespace1\");\n  private static final V1Endpoints ENDPOINTS_NOT_READY_ADDRESS\u003dendpointsNotReadyAddress();\n  private static final V1Endpoints ENDPOINTS_NO_PORTS\u003dendpointsNoPorts();\n  private static final V1Endpoints ENDPOINTS_NO_UNSET_PORT_NAME\u003dendpointsNoUnsetPortName();\n  private static final V1Endpoints ENDPOINTS_WITH\u003dendpointsWithMultiplePorts();\n  private static final V1Endpoints ENDPOINTS_WITH_MULTIPLE_PORTS_NO_HTTPS\u003dendpointsWithMultiplePortsNoHttps();\n  private static final V1Endpoints ENDPOINTS_MULTIPLE_PORTS_WITHOUT_SUPPORTED_PORT_NAMES\u003dendpointsMultiplePortsWithoutSupportedPortNames();\n  private static final KubernetesDiscoveryProperties ALL_NAMESPACES\u003dproperties(true,Map.of());\n  private static final KubernetesDiscoveryProperties NOT_ALL_NAMESPACES\u003dproperties(false,Map.of());\n  @Test void testServiceWithUnsetPortNames();\n  @Test void testDiscoveryGetServicesAllNamespaceShouldWork();\n  @Test void testDiscoveryWithServiceLabels();\n  @Test void testDiscoveryInstancesWithServiceLabels();\n  @Test void testDiscoveryInstancesWithSecuredServiceByAnnotations();\n  @Test void testDiscoveryInstancesWithSecuredServiceByLabels();\n  @Test void testDiscoveryGetServicesOneNamespaceShouldWork();\n  @Test void testDiscoveryGetInstanceAllNamespaceShouldWork();\n  @Test void testDiscoveryGetInstanceOneNamespaceShouldWork();\n  @Test void testDiscoveryGetInstanceWithoutReadyAddressesShouldWork();\n  @Test void testDiscoveryGetInstanceWithNotReadyAddressesIncludedShouldWork();\n  @Test void instanceWithoutEndpointsShouldBeSkipped();\n  @Test void instanceWithoutPortsWillNotBeSkipped();\n  @Test void instanceWithMultiplePortsAndPrimaryPortNameConfiguredWithLabelShouldWork();\n  @Test void instanceWithMultiplePortsAndMisconfiguredPrimaryPortNameInLabelShouldReturnFirstPortAndLogWarning();\n  @Test void instanceWithMultiplePortsAndGenericPrimaryPortNameConfiguredShouldWork();\n  @Test void instanceWithMultiplePortsAndMisconfiguredGenericPrimaryPortNameShouldReturnFirstPortAndLogWarning();\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedShouldFallBackToHttpsPort();\n  @Test void instanceWithMultiplePortsAndWithoutPrimaryPortNameSpecifiedOrHttpsPortShouldFallBackToHttpPort();\n  @Test void instanceWithMultiplePortsAndWithoutAnyConfigurationShouldPickTheFirstPort();\n  @Test void getInstancesShouldReturnInstancesWithTheSameServiceIdFromNamespaces();\n  @Test void testBothServicesMatchesFilter();\n  @Test void testOneServiceMatchesFilter();\n  @Test void testServicesWithDifferentMetadataLabels();\n  @Test void testServicesWithSameMetadataLabels();\n  @Test void testExternalNameService();\n  @Test void testPodMetadata();\n  private Lister\u003cV1Service\u003e setupServiceLister(  V1Service... services);\n  private Lister\u003cV1Endpoints\u003e setupEndpointsLister(  V1Endpoints... endpoints);\n  private static V1Service service(  String name,  String namespace,  Map\u003cString,String\u003e labels);\n  private static V1Endpoints endpointsReadyAddress(  String name,  String namespace);\n  private static V1Endpoints endpointsNotReadyAddress();\n  private static V1Endpoints endpointsNoPorts();\n  private static V1Endpoints endpointsNoUnsetPortName();\n  private static V1Endpoints endpointsWithMultiplePorts();\n  private static V1Endpoints endpointsWithMultiplePortsNoHttps();\n  private static V1Endpoints endpointsMultiplePortsWithoutSupportedPortNames();\n  private static KubernetesDiscoveryProperties properties(  boolean allNamespaces,  Map\u003cString,String\u003e labels);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/SharedInformerStub.java",
        "name": "SharedInformerStub",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.SharedInformerStub",
        "extend": "",
        "implements": "SharedInformer\u003cT\u003e",
        "raw": "/** \n * @author wind57\n */\nfinal class SharedInformerStub\u003cT extends KubernetesObject\u003e implements SharedInformer\u003cT\u003e {\n  @Override public void addEventHandler(  ResourceEventHandler\u003cT\u003e handler){\n  }\n  @Override public void addEventHandlerWithResyncPeriod(  ResourceEventHandler\u003cT\u003e handler,  long resyncPeriod){\n  }\n  @Override public void run(){\n  }\n  @Override public void stop(){\n  }\n  @Override public boolean hasSynced(){\n    return true;\n  }\n  @Override public String lastSyncResourceVersion(){\n    return null;\n  }\n  @Override public void setTransform(  TransformFunc transformFunc){\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class SharedInformerStub\u003cT extends KubernetesObject\u003e implements SharedInformer\u003cT\u003e {\n  @Override public void addEventHandler(  ResourceEventHandler\u003cT\u003e handler);\n  @Override public void addEventHandlerWithResyncPeriod(  ResourceEventHandler\u003cT\u003e handler,  long resyncPeriod);\n  @Override public void run();\n  @Override public void stop();\n  @Override public boolean hasSynced();\n  @Override public String lastSyncResourceVersion();\n  @Override public void setTransform(  TransformFunc transformFunc);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/K8sInstanceIdHostPodNameSupplierTests.java",
        "name": "K8sInstanceIdHostPodNameSupplierTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.K8sInstanceIdHostPodNameSupplierTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass K8sInstanceIdHostPodNameSupplierTests {\n  @Test void instanceIdNoEndpointAddress(){\n    V1Service service\u003dnew V1ServiceBuilder().withSpec(new V1ServiceSpecBuilder().build()).withMetadata(new V1ObjectMetaBuilder().withUid(\"123\").build()).build();\n    K8sInstanceIdHostPodNameSupplier supplier\u003dK8sInstanceIdHostPodNameSupplier.externalName(service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.instanceId(),\"123\");\n  }\n  @Test void instanceIdWithEndpointAddress(){\n    V1EndpointAddress endpointAddress\u003dnew V1EndpointAddressBuilder().withTargetRef(new V1ObjectReferenceBuilder().withUid(\"456\").build()).build();\n    V1Service service\u003dnew V1ServiceBuilder().withSpec(new V1ServiceSpecBuilder().build()).withMetadata(new V1ObjectMetaBuilder().withUid(\"123\").build()).build();\n    K8sInstanceIdHostPodNameSupplier supplier\u003dK8sInstanceIdHostPodNameSupplier.nonExternalName(endpointAddress,service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.instanceId(),\"456\");\n  }\n  @Test void hostNoEndpointAddress(){\n    V1Service service\u003dnew V1ServiceBuilder().withSpec(new V1ServiceSpecBuilder().withExternalName(\"external-name\").build()).withMetadata(new V1ObjectMeta()).build();\n    K8sInstanceIdHostPodNameSupplier supplier\u003dK8sInstanceIdHostPodNameSupplier.externalName(service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.host(),\"external-name\");\n  }\n  @Test void hostWithEndpointAddress(){\n    V1EndpointAddress endpointAddress\u003dnew V1EndpointAddressBuilder().withIp(\"127.0.0.1\").build();\n    V1Service service\u003dnew V1ServiceBuilder().withSpec(new V1ServiceSpecBuilder().withExternalName(\"external-name\").build()).withMetadata(new V1ObjectMeta()).build();\n    K8sInstanceIdHostPodNameSupplier supplier\u003dK8sInstanceIdHostPodNameSupplier.nonExternalName(endpointAddress,service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.host(),\"127.0.0.1\");\n  }\n  @Test void testPodNameIsNull(){\n    V1Service service\u003dnew V1ServiceBuilder().withMetadata(new V1ObjectMetaBuilder().withUid(\"123\").build()).withSpec(new V1ServiceSpecBuilder().withExternalName(\"external-name\").build()).build();\n    K8sInstanceIdHostPodNameSupplier supplier\u003dK8sInstanceIdHostPodNameSupplier.externalName(service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertNull(result.podName());\n  }\n  @Test void podNameKindNotPod(){\n    V1EndpointAddress endpointAddress\u003dnew V1EndpointAddressBuilder().withTargetRef(new V1ObjectReferenceBuilder().withKind(\"Service\").build()).build();\n    V1Service service\u003dnew V1ServiceBuilder().withSpec(new V1ServiceSpecBuilder().withExternalName(\"external-name\").build()).withMetadata(new V1ObjectMeta()).build();\n    K8sInstanceIdHostPodNameSupplier supplier\u003dK8sInstanceIdHostPodNameSupplier.nonExternalName(endpointAddress,service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertNull(result.podName());\n  }\n  @Test void podNameKindIsPod(){\n    V1EndpointAddress endpointAddress\u003dnew V1EndpointAddressBuilder().withTargetRef(new V1ObjectReferenceBuilder().withKind(\"Pod\").withName(\"my-pod\").build()).build();\n    V1Service service\u003dnew V1ServiceBuilder().withSpec(new V1ServiceSpecBuilder().withExternalName(\"external-name\").build()).withMetadata(new V1ObjectMeta()).build();\n    K8sInstanceIdHostPodNameSupplier supplier\u003dK8sInstanceIdHostPodNameSupplier.nonExternalName(endpointAddress,service);\n    InstanceIdHostPodName result\u003dsupplier.get();\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.podName(),\"my-pod\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass K8sInstanceIdHostPodNameSupplierTests {\n  @Test void instanceIdNoEndpointAddress();\n  @Test void instanceIdWithEndpointAddress();\n  @Test void hostNoEndpointAddress();\n  @Test void hostWithEndpointAddress();\n  @Test void testPodNameIsNull();\n  @Test void podNameKindNotPod();\n  @Test void podNameKindIsPod();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/ConditionalOnSelectiveNamespacesEnabledTests.java",
        "name": "ConditionalOnSelectiveNamespacesEnabledTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.ConditionalOnSelectiveNamespacesEnabledTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass ConditionalOnSelectiveNamespacesEnabledTests {\n  private static final ConditionalOnSelectiveNamespacesPresent TO_TEST\u003dnew ConditionalOnSelectiveNamespacesPresent();\n  private static final ConditionContext CONDITION_CONTEXT\u003dMockito.mock(ConditionContext.class);\n  @Test void testSelectiveNamespacesNotPresent(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    Mockito.when(CONDITION_CONTEXT.getEnvironment()).thenReturn(environment);\n    boolean result\u003dTO_TEST.matches(CONDITION_CONTEXT,null);\n    Assertions.assertFalse(result);\n  }\n  @Test void testSelectiveNamespacesPresentEmpty(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.discovery.namespaces\",\"\");\n    Mockito.when(CONDITION_CONTEXT.getEnvironment()).thenReturn(environment);\n    boolean result\u003dTO_TEST.matches(CONDITION_CONTEXT,null);\n    Assertions.assertFalse(result);\n  }\n  @Test void testSelectiveNamespacesPresentNonEmpty(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.discovery.namespaces\",\"default\");\n    Mockito.when(CONDITION_CONTEXT.getEnvironment()).thenReturn(environment);\n    boolean result\u003dTO_TEST.matches(CONDITION_CONTEXT,null);\n    Assertions.assertTrue(result);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass ConditionalOnSelectiveNamespacesEnabledTests {\n  private static final ConditionalOnSelectiveNamespacesPresent TO_TEST\u003dnew ConditionalOnSelectiveNamespacesPresent();\n  private static final ConditionContext CONDITION_CONTEXT\u003dMockito.mock(ConditionContext.class);\n  @Test void testSelectiveNamespacesNotPresent();\n  @Test void testSelectiveNamespacesPresentEmpty();\n  @Test void testSelectiveNamespacesPresentNonEmpty();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesDiscoveryClientFilterMetadataTest.java",
        "name": "KubernetesDiscoveryClientFilterMetadataTest",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesDiscoveryClientFilterMetadataTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryClientFilterMetadataTest {\n  private static final SharedInformerFactoryStub STUB\u003dnew SharedInformerFactoryStub();\n  private static final SharedInformerStub\u003cV1Service\u003e SERVICE_SHARED_INFORMER_STUB\u003dnew SharedInformerStub\u003c\u003e();\n  private static final SharedInformerStub\u003cV1Endpoints\u003e ENDPOINTS_SHARED_INFORMER_STUB\u003dnew SharedInformerStub\u003c\u003e();\n  private Cache\u003cV1Service\u003e servicesCache;\n  private Lister\u003cV1Service\u003e servicesLister;\n  private Cache\u003cV1Endpoints\u003e endpointsCache;\n  private Lister\u003cV1Endpoints\u003e endpointsLister;\n  @BeforeEach void beforeEach(){\n    servicesCache\u003dnew Cache\u003c\u003e();\n    servicesLister\u003dnew Lister\u003c\u003e(servicesCache);\n    endpointsCache\u003dnew Cache\u003c\u003e();\n    endpointsLister\u003dnew Lister\u003c\u003e(endpointsCache);\n  }\n  @Test void testAllExtraMetadataDisabled(){\n    String serviceId\u003d\"s\";\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,null,false,null,false,null);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    setup(serviceId,\"ns\",Map.of(\"l1\",\"lab\"),Map.of(\"l1\",\"lab\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).isEqualTo(Map.of(\"k8s_namespace\",\"ns\",\"type\",\"ClusterIP\"));\n  }\n  @Test void testLabelsEnabled(){\n    String serviceId\u003d\"s\";\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(true,null,false,null,false,null);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    setup(serviceId,\"ns\",Map.of(\"l1\",\"v1\",\"l2\",\"v2\"),Map.of(\"l1\",\"lab\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"l1\",\"v1\"),entry(\"l2\",\"v2\"),entry(\"k8s_namespace\",\"ns\"),entry(\"type\",\"ClusterIP\"));\n  }\n  @Test void testLabelsEnabledWithPrefix(){\n    String serviceId\u003d\"s\";\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(true,\"l_\",false,null,false,null);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    setup(serviceId,\"ns\",Map.of(\"l1\",\"v1\",\"l2\",\"v2\"),Map.of(\"l1\",\"lab\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"l_l1\",\"v1\"),entry(\"l_l2\",\"v2\"),entry(\"k8s_namespace\",\"ns\"),entry(\"type\",\"ClusterIP\"));\n  }\n  @Test void testAnnotationsEnabled(){\n    String serviceId\u003d\"s\";\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,null,true,null,false,null);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    setup(serviceId,\"ns\",Map.of(\"l1\",\"v1\"),Map.of(\"a1\",\"v1\",\"a2\",\"v2\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"a1\",\"v1\"),entry(\"a2\",\"v2\"),entry(\"k8s_namespace\",\"ns\"),entry(\"type\",\"ClusterIP\"));\n  }\n  @Test void testAnnotationsEnabledWithPrefix(){\n    String serviceId\u003d\"s\";\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,null,true,\"a_\",false,null);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    setup(serviceId,\"ns\",Map.of(\"l1\",\"v1\"),Map.of(\"a1\",\"v1\",\"a2\",\"v2\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"a_a1\",\"v1\"),entry(\"a_a2\",\"v2\"),entry(\"k8s_namespace\",\"ns\"),entry(\"type\",\"ClusterIP\"));\n  }\n  @Test void testPortsEnabled(){\n    String serviceId\u003d\"s\";\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,null,false,null,true,null);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    setup(serviceId,\"test\",Map.of(\"l1\",\"v1\"),Map.of(\"a1\",\"v1\",\"a2\",\"v2\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"http\",\"80\"),entry(\"k8s_namespace\",\"test\"),entry(\"\u003cunset\u003e\",\"5555\"),entry(\"type\",\"ClusterIP\"));\n  }\n  @Test void testPortsEnabledWithPrefix(){\n    String serviceId\u003d\"s\";\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,null,false,null,true,\"p_\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    setup(serviceId,\"ns\",Map.of(\"l1\",\"v1\"),Map.of(\"a1\",\"v1\",\"a2\",\"v2\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"p_http\",\"80\"),entry(\"k8s_namespace\",\"ns\"),entry(\"p_\u003cunset\u003e\",\"5555\"),entry(\"type\",\"ClusterIP\"));\n  }\n  @Test void testLabelsAndAnnotationsAndPortsEnabledWithPrefix(){\n    String serviceId\u003d\"s\";\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(true,\"l_\",true,\"a_\",true,\"p_\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,metadata,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    setup(serviceId,\"ns\",Map.of(\"l1\",\"la1\"),Map.of(\"a1\",\"an1\",\"a2\",\"an2\"),Map.of(80,\"http\",5555,\"\"));\n    List\u003cServiceInstance\u003e instances\u003ddiscoveryClient.getInstances(serviceId);\n    assertThat(instances).hasSize(1);\n    assertThat(instances.get(0).getMetadata()).containsOnly(entry(\"a_a1\",\"an1\"),entry(\"a_a2\",\"an2\"),entry(\"l_l1\",\"la1\"),entry(\"p_http\",\"80\"),entry(\"k8s_namespace\",\"ns\"),entry(\"type\",\"ClusterIP\"),entry(\"p_\u003cunset\u003e\",\"5555\"));\n  }\n  private void setup(  String serviceId,  String namespace,  Map\u003cString,String\u003e labels,  Map\u003cString,String\u003e annotations,  Map\u003cInteger,String\u003e ports){\n    V1Service service\u003dnew V1ServiceBuilder().withSpec(new V1ServiceSpecBuilder().withType(\"ClusterIP\").withPorts(getServicePorts(ports)).build()).withNewMetadata().withName(serviceId).withNamespace(namespace).withLabels(labels).withAnnotations(annotations).endMetadata().build();\n    servicesCache.add(service);\n    V1ObjectMeta objectMeta\u003dnew V1ObjectMeta();\n    objectMeta.setNamespace(namespace);\n    objectMeta.setName(serviceId);\n    V1Endpoints endpoints\u003dnew V1EndpointsBuilder().withMetadata(objectMeta).addNewSubset().addAllToPorts(getEndpointPorts(ports)).addNewAddress().endAddress().endSubset().build();\n    endpointsCache.add(endpoints);\n  }\n  private List\u003cV1ServicePort\u003e getServicePorts(  Map\u003cInteger,String\u003e ports){\n    return ports.entrySet().stream().map(e -\u003e {\n      V1ServicePortBuilder servicePortBuilder\u003dnew V1ServicePortBuilder();\n      servicePortBuilder.withPort(e.getKey());\n      if (!Strings.isNullOrEmpty(e.getValue())) {\n        servicePortBuilder.withName(e.getValue());\n      }\n      return servicePortBuilder.build();\n    }\n).collect(toList());\n  }\n  private List\u003cCoreV1EndpointPort\u003e getEndpointPorts(  Map\u003cInteger,String\u003e ports){\n    return ports.entrySet().stream().map(e -\u003e {\n      CoreV1EndpointPortBuilder endpointPortBuilder\u003dnew CoreV1EndpointPortBuilder();\n      endpointPortBuilder.withPort(e.getKey());\n      if (!Strings.isNullOrEmpty(e.getValue())) {\n        endpointPortBuilder.withName(e.getValue());\n      }\n      return endpointPortBuilder.build();\n    }\n).collect(toList());\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryClientFilterMetadataTest {\n  private static final SharedInformerFactoryStub STUB\u003dnew SharedInformerFactoryStub();\n  private static final SharedInformerStub\u003cV1Service\u003e SERVICE_SHARED_INFORMER_STUB\u003dnew SharedInformerStub\u003c\u003e();\n  private static final SharedInformerStub\u003cV1Endpoints\u003e ENDPOINTS_SHARED_INFORMER_STUB\u003dnew SharedInformerStub\u003c\u003e();\n  private Cache\u003cV1Service\u003e servicesCache;\n  private Lister\u003cV1Service\u003e servicesLister;\n  private Cache\u003cV1Endpoints\u003e endpointsCache;\n  private Lister\u003cV1Endpoints\u003e endpointsLister;\n  @BeforeEach void beforeEach();\n  @Test void testAllExtraMetadataDisabled();\n  @Test void testLabelsEnabled();\n  @Test void testLabelsEnabledWithPrefix();\n  @Test void testAnnotationsEnabled();\n  @Test void testAnnotationsEnabledWithPrefix();\n  @Test void testPortsEnabled();\n  @Test void testPortsEnabledWithPrefix();\n  @Test void testLabelsAndAnnotationsAndPortsEnabledWithPrefix();\n  private void setup(  String serviceId,  String namespace,  Map\u003cString,String\u003e labels,  Map\u003cString,String\u003e annotations,  Map\u003cInteger,String\u003e ports);\n  private List\u003cV1ServicePort\u003e getServicePorts(  Map\u003cInteger,String\u003e ports);\n  private List\u003cCoreV1EndpointPort\u003e getEndpointPorts(  Map\u003cInteger,String\u003e ports);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesClientConfigServerBootstrapperTests.java",
        "name": "KubernetesClientConfigServerBootstrapperTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesClientConfigServerBootstrapperTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass KubernetesClientConfigServerBootstrapperTests {\n  private static WireMockServer wireMockServer;\n  private ConfigurableApplicationContext context;\n  @BeforeEach public void before() throws JsonProcessingException {\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    V1ServiceList SERVICE_LIST\u003dnew V1ServiceListBuilder().withMetadata(new V1ListMetaBuilder().withResourceVersion(\"1\").build()).addToItems(new V1ServiceBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"spring-cloud-kubernetes-configserver\").withNamespace(\"default\").withResourceVersion(\"0\").addToLabels(\"beta\",\"true\").addToAnnotations(\"org.springframework.cloud\",\"true\").withUid(\"0\").build()).withSpec(new V1ServiceSpecBuilder().withClusterIP(\"localhost\").withSessionAffinity(\"None\").withType(\"ClusterIP\").addToPorts(new V1ServicePortBuilder().withPort(wireMockServer.port()).withName(\"http\").withProtocol(\"TCP\").withNewTargetPort(wireMockServer.port()).build()).build()).build()).build();\n    V1EndpointsList ENDPOINTS_LIST\u003dnew V1EndpointsListBuilder().withMetadata(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).addToItems(new V1Endpoints().metadata(new V1ObjectMeta().name(\"spring-cloud-kubernetes-configserver\").namespace(\"default\")).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(wireMockServer.port()).name(\"http\")).addAddressesItem(new V1EndpointAddress().hostname(\"localhost\").ip(\"localhost\").targetRef(new V1ObjectReferenceBuilder().withUid(\"uid1\").build())))).build();\n    Environment environment\u003dnew Environment(\"test\",\"default\");\n    Map\u003cString,Object\u003e properties\u003dnew HashMap\u003c\u003e();\n    properties.put(\"hello\",\"world\");\n    org.springframework.cloud.config.environment.PropertySource p\u003dnew PropertySource(\"p1\",properties);\n    environment.add(p);\n    ObjectMapper objectMapper\u003dnew ObjectMapper();\n    stubFor(get(\"/application/default\").willReturn(aResponse().withStatus(200).withBody(objectMapper.writeValueAsString(environment)).withHeader(\"content-type\",\"application/json\")));\n    stubFor(get(\"/api/v1/namespaces/default/endpoints?resourceVersion\u003d0\u0026watch\u003dfalse\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(ENDPOINTS_LIST)).withHeader(\"content-type\",\"application/json\")));\n    stubFor(get(\"/api/v1/namespaces/default/services?resourceVersion\u003d0\u0026watch\u003dfalse\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(SERVICE_LIST)).withHeader(\"content-type\",\"application/json\")));\n    stubFor(get(urlMatching(\"/api/v1/namespaces/default/services.*.watch\u003dtrue\")).willReturn(aResponse().withStatus(200)));\n    stubFor(get(urlMatching(\"/api/v1/namespaces/default/endpoints.*.watch\u003dtrue\")).willReturn(aResponse().withStatus(200)));\n  }\n  @AfterEach public void after(){\n    wireMockServer.stop();\n    context.close();\n  }\n  @Test void testBootstrapper(){\n    this.context\u003dsetup().run();\n    verify(getRequestedFor(urlEqualTo(\"/application/default\")));\n    assertThat(this.context.getEnvironment().getProperty(\"hello\")).isEqualTo(\"world\");\n  }\n  SpringApplicationBuilder setup(  String... env){\n    SpringApplicationBuilder builder\u003dnew SpringApplicationBuilder(TestConfig.class).properties(addDefaultEnv(env));\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).setReadTimeout(Duration.ZERO).build();\n    builder.addBootstrapRegistryInitializer(registry -\u003e registry.register(ApiClient.class,(context) -\u003e apiClient));\n    builder.addBootstrapRegistryInitializer(new KubernetesClientConfigServerBootstrapper());\n    return builder;\n  }\n  private String[] addDefaultEnv(  String[] env){\n    Set\u003cString\u003e set\u003dnew LinkedHashSet\u003c\u003e();\n    if (env !\u003d null \u0026\u0026 env.length \u003e 0) {\n      set.addAll(Arrays.asList(env));\n    }\n    set.add(\"server.port\u003d0\");\n    set.add(\"spring.cloud.config.discovery.enabled\u003dtrue\");\n    set.add(\"spring.config.import\u003doptional:configserver:\");\n    set.add(\"spring.cloud.config.discovery.service-id\u003dspring-cloud-kubernetes-configserver\");\n    set.add(\"spring.cloud.kubernetes.client.namespace\u003ddefault\");\n    return set.toArray(new String[0]);\n  }\n@SpringBootConfiguration @EnableAutoConfiguration static class TestConfig {\n    @Bean public ApiClient apiClient(){\n      return new ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass KubernetesClientConfigServerBootstrapperTests {\n  private static WireMockServer wireMockServer;\n  private ConfigurableApplicationContext context;\n  @BeforeEach public void before() throws JsonProcessingException;\n  @AfterEach public void after();\n  @Test void testBootstrapper();\n  SpringApplicationBuilder setup(  String... env);\n  private String[] addDefaultEnv(  String[] env);\n@SpringBootConfiguration @EnableAutoConfiguration static class TestConfig {\n    @Bean public ApiClient apiClient();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/ConditionalOnSelectiveNamespacesDisabledTests.java",
        "name": "ConditionalOnSelectiveNamespacesDisabledTests",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.ConditionalOnSelectiveNamespacesDisabledTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic class ConditionalOnSelectiveNamespacesDisabledTests {\n  private static final ConditionalOnSelectiveNamespacesMissing TO_TEST\u003dnew ConditionalOnSelectiveNamespacesMissing();\n  private static final ConditionContext CONDITION_CONTEXT\u003dMockito.mock(ConditionContext.class);\n  @Test void testSelectiveNamespacesNotPresent(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    Mockito.when(CONDITION_CONTEXT.getEnvironment()).thenReturn(environment);\n    boolean result\u003dTO_TEST.matches(CONDITION_CONTEXT,null);\n    Assertions.assertTrue(result);\n  }\n  @Test void testSelectiveNamespacesPresentEmpty(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.discovery.namespaces\",\"\");\n    Mockito.when(CONDITION_CONTEXT.getEnvironment()).thenReturn(environment);\n    boolean result\u003dTO_TEST.matches(CONDITION_CONTEXT,null);\n    Assertions.assertTrue(result);\n  }\n  @Test void testSelectiveNamespacesPresentNonEmpty(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.discovery.namespaces\",\"default\");\n    Mockito.when(CONDITION_CONTEXT.getEnvironment()).thenReturn(environment);\n    boolean result\u003dTO_TEST.matches(CONDITION_CONTEXT,null);\n    Assertions.assertFalse(result);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic class ConditionalOnSelectiveNamespacesDisabledTests {\n  private static final ConditionalOnSelectiveNamespacesMissing TO_TEST\u003dnew ConditionalOnSelectiveNamespacesMissing();\n  private static final ConditionContext CONDITION_CONTEXT\u003dMockito.mock(ConditionContext.class);\n  @Test void testSelectiveNamespacesNotPresent();\n  @Test void testSelectiveNamespacesPresentEmpty();\n  @Test void testSelectiveNamespacesPresentNonEmpty();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-discovery/src/test/java/org/springframework/cloud/kubernetes/client/discovery/KubernetesDiscoveryClientServiceWithoutPortNameTests.java",
        "name": "KubernetesDiscoveryClientServiceWithoutPortNameTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.KubernetesDiscoveryClientServiceWithoutPortNameTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryClientServiceWithoutPortNameTests {\n  private static final String NAMESPACE\u003d\"spring-k8s\";\n  private static final SharedInformerFactoryStub STUB\u003dnew SharedInformerFactoryStub();\n  private static final SharedInformerStub\u003cV1Service\u003e SERVICE_SHARED_INFORMER_STUB\u003dnew SharedInformerStub\u003c\u003e();\n  private static final SharedInformerStub\u003cV1Endpoints\u003e ENDPOINTS_SHARED_INFORMER_STUB\u003dnew SharedInformerStub\u003c\u003e();\n  private Cache\u003cV1Service\u003e servicesCache;\n  private Lister\u003cV1Service\u003e servicesLister;\n  private Cache\u003cV1Endpoints\u003e endpointsCache;\n  private Lister\u003cV1Endpoints\u003e endpointsLister;\n  @BeforeEach void beforeEach(){\n    servicesCache\u003dnew Cache\u003c\u003e();\n    servicesLister\u003dnew Lister\u003c\u003e(servicesCache);\n    endpointsCache\u003dnew Cache\u003c\u003e();\n    endpointsLister\u003dnew Lister\u003c\u003e(endpointsCache);\n  }\n  @Test void testDiscoveryWithoutAServicePortName(){\n    V1Endpoints endpoints\u003dnew V1EndpointsBuilder().withSubsets(new V1EndpointSubsetBuilder().withPorts(new CoreV1EndpointPortBuilder().withPort(8080).build()).withAddresses(new V1EndpointAddressBuilder().withIp(\"127.0.0.1\").build()).build()).withMetadata(new V1ObjectMetaBuilder().withName(\"no-port-name-service\").withNamespace(NAMESPACE).build()).build();\n    endpointsCache.add(endpoints);\n    V1Service service\u003dnew V1ServiceBuilder().withSpec(new V1ServiceSpecBuilder().withPorts(new V1ServicePortBuilder().withPort(8080).build()).build()).withMetadata(new V1ObjectMetaBuilder().withName(\"no-port-name-service\").withNamespace(NAMESPACE).build()).withSpec(new V1ServiceSpecBuilder().withType(\"ClusterIP\").build()).build();\n    servicesCache.add(service);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(NAMESPACE),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesInformerDiscoveryClient discoveryClient\u003dnew KubernetesInformerDiscoveryClient(STUB,servicesLister,endpointsLister,SERVICE_SHARED_INFORMER_STUB,ENDPOINTS_SHARED_INFORMER_STUB,properties);\n    List\u003cServiceInstance\u003e serviceInstances\u003ddiscoveryClient.getInstances(\"no-port-name-service\");\n    Assertions.assertEquals(serviceInstances.size(),1);\n    Assertions.assertEquals(serviceInstances.get(0).getMetadata(),Map.of(\"port.\u003cunset\u003e\",\"8080\",\"k8s_namespace\",\"spring-k8s\",\"type\",\"ClusterIP\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryClientServiceWithoutPortNameTests {\n  private static final String NAMESPACE\u003d\"spring-k8s\";\n  private static final SharedInformerFactoryStub STUB\u003dnew SharedInformerFactoryStub();\n  private static final SharedInformerStub\u003cV1Service\u003e SERVICE_SHARED_INFORMER_STUB\u003dnew SharedInformerStub\u003c\u003e();\n  private static final SharedInformerStub\u003cV1Endpoints\u003e ENDPOINTS_SHARED_INFORMER_STUB\u003dnew SharedInformerStub\u003c\u003e();\n  private Cache\u003cV1Service\u003e servicesCache;\n  private Lister\u003cV1Service\u003e servicesLister;\n  private Cache\u003cV1Endpoints\u003e endpointsCache;\n  private Lister\u003cV1Endpoints\u003e endpointsLister;\n  @BeforeEach void beforeEach();\n  @Test void testDiscoveryWithoutAServicePortName();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-istio/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/istio/IstioAutoConfiguration.java",
        "name": "IstioAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(value\u003d\"spring.cloud.istio.enabled\",matchIfMissing\u003dtrue) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.istio.IstioAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Auto configuration for Istio.\n * @author Mauricio Salatino\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(value\u003d\"spring.cloud.istio.enabled\",matchIfMissing\u003dtrue) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public class IstioAutoConfiguration {\n  @Bean @ConditionalOnMissingBean public IstioClient istioClient(  Config config){\n    return new DefaultIstioClient(config);\n  }\n}\n",
        "abstract": "/** \n * Auto configuration for Istio.\n * @author Mauricio Salatino\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(value\u003d\"spring.cloud.istio.enabled\",matchIfMissing\u003dtrue) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public class IstioAutoConfiguration {\n  @Bean @ConditionalOnMissingBean public IstioClient istioClient(  Config config);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-istio/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/istio/utils/MeshUtils.java",
        "name": "MeshUtils",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.istio.utils.MeshUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Utility class to work with meshes.\n * @author Mauricio Salatino\n */\npublic class MeshUtils {\n  private static final Log LOG\u003dLogFactory.getLog(MeshUtils.class);\n  private final IstioClientProperties istioClientProperties;\n  private final RestTemplate restTemplate\u003dnew RestTemplateBuilder().build();\n  public MeshUtils(  IstioClientProperties istioClientProperties){\n    this.istioClientProperties\u003distioClientProperties;\n  }\n  public Boolean isIstioEnabled(){\n    return checkIstioServices();\n  }\n  private synchronized boolean checkIstioServices(){\n    try {\n      String resource\u003d\"http://localhost:\" + this.istioClientProperties.getEnvoyPort();\n      ResponseEntity\u003cString\u003e response\u003dthis.restTemplate.getForEntity(resource + \"/\" + this.istioClientProperties.getTestPath(),String.class);\n      if (response.getStatusCode().is2xxSuccessful()) {\n        LOG.info(\"Istio Resources Found.\");\n        return true;\n      }\n      LOG.warn(\"Although Envoy proxy did respond at port\" + this.istioClientProperties.getEnvoyPort() + \", it did not respond with HTTP 200 to path: \"+ this.istioClientProperties.getTestPath()+ \". You may need to tweak the test path in order to get proper Istio support\");\n      return false;\n    }\n catch (    Throwable t) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Envoy proxy could not be located at port: \" + this.istioClientProperties.getEnvoyPort() + \". Assuming that the application is not running inside the Istio Service Mesh\");\n      }\n      return false;\n    }\n  }\n}\n",
        "abstract": "/** \n * Utility class to work with meshes.\n * @author Mauricio Salatino\n */\npublic class MeshUtils {\n  private static final Log LOG\u003dLogFactory.getLog(MeshUtils.class);\n  private final IstioClientProperties istioClientProperties;\n  private final RestTemplate restTemplate\u003dnew RestTemplateBuilder().build();\n  public MeshUtils(  IstioClientProperties istioClientProperties);\n  public Boolean isIstioEnabled();\n  private synchronized boolean checkIstioServices();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-istio/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/istio/IstioClientProperties.java",
        "name": "IstioClientProperties",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConfigurationProperties(\"spring.cloud.istio.client\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.istio.IstioClientProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Istio client properties.\n * @author Mauricio Salatino\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConfigurationProperties(\"spring.cloud.istio.client\") public class IstioClientProperties {\n  private Integer envoyPort\u003d15090;\n  private String testPath\u003d\"stats/prometheus\";\n  public Integer getEnvoyPort(){\n    return this.envoyPort;\n  }\n  public void setEnvoyPort(  Integer envoyPort){\n    this.envoyPort\u003denvoyPort;\n  }\n  public String getTestPath(){\n    return this.testPath;\n  }\n  public void setTestPath(  String testPath){\n    this.testPath\u003dtestPath;\n  }\n}\n",
        "abstract": "/** \n * Istio client properties.\n * @author Mauricio Salatino\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConfigurationProperties(\"spring.cloud.istio.client\") public class IstioClientProperties {\n  private Integer envoyPort\u003d15090;\n  private String testPath\u003d\"stats/prometheus\";\n  public Integer getEnvoyPort();\n  public void setEnvoyPort(  Integer envoyPort);\n  public String getTestPath();\n  public void setTestPath(  String testPath);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-istio/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/istio/IstioBootstrapConfiguration.java",
        "name": "IstioBootstrapConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(value\u003d\"spring.cloud.istio.enabled\",matchIfMissing\u003dtrue) @EnableConfigurationProperties(IstioClientProperties.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.istio.IstioBootstrapConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Auto configuration for Istio bootstrap.\n * @author Mauricio Salatino\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(value\u003d\"spring.cloud.istio.enabled\",matchIfMissing\u003dtrue) @EnableConfigurationProperties(IstioClientProperties.class) public class IstioBootstrapConfiguration {\n  private static final Log LOG\u003dLogFactory.getLog(IstioBootstrapConfiguration.class);\n  private static final String ISTIO_PROFILE\u003d\"istio\";\n  @Bean @ConditionalOnMissingBean public MeshUtils istioMeshUtils(  IstioClientProperties istioClientProperties){\n    return new MeshUtils(istioClientProperties);\n  }\n@EnableConfigurationProperties(IstioClientProperties.class) protected static class IstioDetectionConfiguration {\n    private final MeshUtils utils;\n    private final ConfigurableEnvironment environment;\n    public IstioDetectionConfiguration(    MeshUtils utils,    ConfigurableEnvironment environment){\n      this.utils\u003dutils;\n      this.environment\u003denvironment;\n    }\n    @PostConstruct public void detectIstio(){\n      addIstioProfile(this.environment);\n    }\n    void addIstioProfile(    ConfigurableEnvironment environment){\n      if (utils.isIstioEnabled()) {\n        if (hasIstioProfile(environment)) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"\u0027istio\u0027 already in list of active profiles\");\n          }\n        }\n else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Adding \u0027istio\u0027 to list of active profiles\");\n          }\n          environment.addActiveProfile(ISTIO_PROFILE);\n        }\n      }\n else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Not running inside kubernetes with istio enabled. Skipping \u0027istio\u0027 profile activation.\");\n        }\n      }\n    }\n    private boolean hasIstioProfile(    Environment environment){\n      return Arrays.stream(environment.getActiveProfiles()).anyMatch(ISTIO_PROFILE::equalsIgnoreCase);\n    }\n  }\n}\n",
        "abstract": "/** \n * Auto configuration for Istio bootstrap.\n * @author Mauricio Salatino\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(value\u003d\"spring.cloud.istio.enabled\",matchIfMissing\u003dtrue) @EnableConfigurationProperties(IstioClientProperties.class) public class IstioBootstrapConfiguration {\n  private static final Log LOG\u003dLogFactory.getLog(IstioBootstrapConfiguration.class);\n  private static final String ISTIO_PROFILE\u003d\"istio\";\n  @Bean @ConditionalOnMissingBean public MeshUtils istioMeshUtils(  IstioClientProperties istioClientProperties);\n@EnableConfigurationProperties(IstioClientProperties.class) protected static class IstioDetectionConfiguration {\n    private final MeshUtils utils;\n    private final ConfigurableEnvironment environment;\n    public IstioDetectionConfiguration(    MeshUtils utils,    ConfigurableEnvironment environment);\n    @PostConstruct public void detectIstio();\n    void addIstioProfile(    ConfigurableEnvironment environment);\n    private boolean hasIstioProfile(    Environment environment);\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-istio/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/istio/IstioAutoConfigurationClientPresentWhenIstioEnabledTest.java",
        "name": "IstioAutoConfigurationClientPresentWhenIstioEnabledTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.cloud.istio.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.istio.IstioAutoConfigurationClientPresentWhenIstioEnabledTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.cloud.istio.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class IstioAutoConfigurationClientPresentWhenIstioEnabledTest {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void istioClientIsPresent(){\n    assertThat(context.getBeanNamesForType(IstioClient.class)).hasSize(1);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.cloud.istio.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class IstioAutoConfigurationClientPresentWhenIstioEnabledTest {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void istioClientIsPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-istio/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/istio/App.java",
        "name": "App",
        "modifiers": "@SpringBootApplication public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.istio.App",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication public class App {\n}\n",
        "abstract": "@SpringBootApplication public class App {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-istio/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/istio/IstioAutoConfigurationClientNotPresentWhenIstioDisabledTest.java",
        "name": "IstioAutoConfigurationClientNotPresentWhenIstioDisabledTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.cloud.istio.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.istio.IstioAutoConfigurationClientNotPresentWhenIstioDisabledTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.cloud.istio.enabled\u003dfalse\"}) class IstioAutoConfigurationClientNotPresentWhenIstioDisabledTest {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void istioClientNotPresent(){\n    assertThat(context.getBeanNamesForType(IstioClient.class)).hasSize(0);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d{\"spring.cloud.istio.enabled\u003dfalse\"}) class IstioAutoConfigurationClientNotPresentWhenIstioDisabledTest {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void istioClientNotPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-istio/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/istio/IstioAutoConfigurationClientPresentByDefaultTest.java",
        "name": "IstioAutoConfigurationClientPresentByDefaultTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\")",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.istio.IstioAutoConfigurationClientPresentByDefaultTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\") class IstioAutoConfigurationClientPresentByDefaultTest {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void istioClientIsPresent(){\n    assertThat(context.getBeanNamesForType(IstioClient.class)).hasSize(1);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class,properties\u003d\"spring.main.cloud-platform\u003dKUBERNETES\") class IstioAutoConfigurationClientPresentByDefaultTest {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void istioClientIsPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-istio/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/istio/IstioAutoConfigurationClientNotPresentWhenKubernetesDisabledTest.java",
        "name": "IstioAutoConfigurationClientNotPresentWhenKubernetesDisabledTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.istio.IstioAutoConfigurationClientNotPresentWhenKubernetesDisabledTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class) class IstioAutoConfigurationClientNotPresentWhenKubernetesDisabledTest {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void istioClientNotPresent(){\n    assertThat(context.getBeanNamesForType(IstioClient.class)).hasSize(0);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApp.class) class IstioAutoConfigurationClientNotPresentWhenKubernetesDisabledTest {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void istioClientNotPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-examples/kubernetes-leader-election-example/src/main/java/org/springframework/cloud/kubernetes/examples/LeaderController.java",
        "name": "LeaderController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.examples.LeaderController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class LeaderController {\n  private final String host;\n  @Value(\"${spring.cloud.kubernetes.leader.role}\") private String role;\n  private Context context;\n  public LeaderController() throws UnknownHostException {\n    this.host\u003dInetAddress.getLocalHost().getHostName();\n  }\n  /** \n * Return a message whether this instance is a leader or not.\n * @return info\n */\n  @GetMapping(\"/\") public String getInfo(){\n    if (this.context \u003d\u003d null) {\n      return String.format(\"I am \u0027%s\u0027 but I am not a leader of the \u0027%s\u0027\",this.host,this.role);\n    }\n    return String.format(\"I am \u0027%s\u0027 and I am the leader of the \u0027%s\u0027\",this.host,this.role);\n  }\n  /** \n * PUT request to try and revoke a leadership of this instance. If the instance is not a leader, leadership cannot be revoked. Thus \"HTTP Bad Request\" response. If the instance is a leader, it must have a leadership context instance which can be used to give up the leadership.\n * @return info about leadership\n */\n  @PutMapping(\"/\") public ResponseEntity\u003cString\u003e revokeLeadership(){\n    if (this.context \u003d\u003d null) {\n      String message\u003dString.format(\"Cannot revoke leadership because \u0027%s\u0027 is not a leader\",this.host);\n      return ResponseEntity.badRequest().body(message);\n    }\n    this.context.yield();\n    String message\u003dString.format(\"Leadership revoked for \u0027%s\u0027\",this.host);\n    return ResponseEntity.ok(message);\n  }\n  /** \n * Handle a notification that this instance has become a leader.\n * @param event on granted event\n */\n  @EventListener public void handleEvent(  OnGrantedEvent event){\n    System.out.println(String.format(\"\u0027%s\u0027 leadership granted\",event.getRole()));\n    this.context\u003devent.getContext();\n  }\n  /** \n * Handle a notification that this instance\u0027s leadership has been revoked.\n * @param event on revoked event\n */\n  @EventListener public void handleEvent(  OnRevokedEvent event){\n    System.out.println(String.format(\"\u0027%s\u0027 leadership revoked\",event.getRole()));\n    this.context\u003dnull;\n  }\n}\n",
        "abstract": "@RestController public class LeaderController {\n  private final String host;\n  @Value(\"${spring.cloud.kubernetes.leader.role}\") private String role;\n  private Context context;\n  public LeaderController() throws UnknownHostException;\n  /** \n * Return a message whether this instance is a leader or not.\n * @return info\n */\n  @GetMapping(\"/\") public String getInfo();\n  /** \n * PUT request to try and revoke a leadership of this instance. If the instance is not a leader, leadership cannot be revoked. Thus \"HTTP Bad Request\" response. If the instance is a leader, it must have a leadership context instance which can be used to give up the leadership.\n * @return info about leadership\n */\n  @PutMapping(\"/\") public ResponseEntity\u003cString\u003e revokeLeadership();\n  /** \n * Handle a notification that this instance has become a leader.\n * @param event on granted event\n */\n  @EventListener public void handleEvent(  OnGrantedEvent event);\n  /** \n * Handle a notification that this instance\u0027s leadership has been revoked.\n * @param event on revoked event\n */\n  @EventListener public void handleEvent(  OnRevokedEvent event);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-examples/kubernetes-leader-election-example/src/main/java/org/springframework/cloud/kubernetes/examples/App.java",
        "name": "App",
        "modifiers": "@SpringBootApplication public",
        "qualified_name": "org.springframework.cloud.kubernetes.examples.App",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication public class App {\n  public static void main(  String[] args){\n    SpringApplication.run(App.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication public class App {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-examples/kubernetes-leader-election-example/src/test/java/org/springframework/cloud/kubernetes/examples/LeaderControllerTest.java",
        "name": "LeaderControllerTest",
        "modifiers": "@ExtendWith(MockitoExtension.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.examples.LeaderControllerTest",
        "extend": "",
        "implements": "",
        "raw": "@ExtendWith(MockitoExtension.class) public class LeaderControllerTest {\n  @Mock private OnGrantedEvent mockOnGrantedEvent;\n  @Mock private OnRevokedEvent mockOnRevokedEvent;\n  @Mock private Context mockContext;\n  private String host;\n  private LeaderController leaderController;\n  @BeforeEach public void before() throws UnknownHostException {\n    this.host\u003dInetAddress.getLocalHost().getHostName();\n    this.leaderController\u003dnew LeaderController();\n  }\n  @Test public void shouldGetNonLeaderInfo(){\n    String message\u003dString.format(\"I am \u0027%s\u0027 but I am not a leader of the \u0027null\u0027\",this.host);\n    assertThat(this.leaderController.getInfo()).isEqualTo(message);\n  }\n  @Test public void shouldHandleGrantedEvent(){\n    given(this.mockOnGrantedEvent.getContext()).willReturn(this.mockContext);\n    this.leaderController.handleEvent(this.mockOnGrantedEvent);\n    String message\u003dString.format(\"I am \u0027%s\u0027 and I am the leader of the \u0027null\u0027\",this.host);\n    assertThat(this.leaderController.getInfo()).isEqualTo(message);\n  }\n  @Test public void shouldHandleRevokedEvent(){\n    given(this.mockOnGrantedEvent.getContext()).willReturn(this.mockContext);\n    this.leaderController.handleEvent(this.mockOnGrantedEvent);\n    this.leaderController.handleEvent(this.mockOnRevokedEvent);\n    String message\u003dString.format(\"I am \u0027%s\u0027 but I am not a leader of the \u0027null\u0027\",this.host);\n    assertThat(this.leaderController.getInfo()).isEqualTo(message);\n  }\n  @Test public void shouldRevokeLeadership(){\n    given(this.mockOnGrantedEvent.getContext()).willReturn(this.mockContext);\n    this.leaderController.handleEvent(this.mockOnGrantedEvent);\n    ResponseEntity\u003cString\u003e responseEntity\u003dthis.leaderController.revokeLeadership();\n    String message\u003dString.format(\"Leadership revoked for \u0027%s\u0027\",this.host);\n    assertThat(responseEntity.getBody()).isEqualTo(message);\n    assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);\n    verify(this.mockContext).yield();\n  }\n  @Test public void shouldNotRevokeLeadershipIfNotLeader(){\n    ResponseEntity\u003cString\u003e responseEntity\u003dthis.leaderController.revokeLeadership();\n    String message\u003dString.format(\"Cannot revoke leadership because \u0027%s\u0027 is not a leader\",this.host);\n    assertThat(responseEntity.getBody()).isEqualTo(message);\n    assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);\n    verify(this.mockContext,times(0)).yield();\n  }\n}\n",
        "abstract": "@ExtendWith(MockitoExtension.class) public class LeaderControllerTest {\n  @Mock private OnGrantedEvent mockOnGrantedEvent;\n  @Mock private OnRevokedEvent mockOnRevokedEvent;\n  @Mock private Context mockContext;\n  private String host;\n  private LeaderController leaderController;\n  @BeforeEach public void before() throws UnknownHostException;\n  @Test public void shouldGetNonLeaderInfo();\n  @Test public void shouldHandleGrantedEvent();\n  @Test public void shouldHandleRevokedEvent();\n  @Test public void shouldRevokeLeadership();\n  @Test public void shouldNotRevokeLeadershipIfNotLeader();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-test-support/src/main/java/org/springframework/cloud/kubernetes/tests/commons/junit_extension/DisabledTestsCondition.java",
        "name": "DisabledTestsCondition",
        "modifiers": "@Deprecated public",
        "qualified_name": "org.springframework.cloud.kubernetes.tests.commons.junit_extension.DisabledTestsCondition",
        "extend": "",
        "implements": "ExecutionCondition",
        "raw": "/** \n * This is mainly needed for our pipeline, to get the test classes names. Its purpose is to act like a \u0027dry-run\u0027: show all the tests fully qualified names without actually running them. The way to use it: \"mvn clean test -Dspring.cloud.k8s.skip.tests\u003dtrue\". This way all tests will be skipped, but also will be printed to the standard output as a fully qualified name, i.e.: \u003cpre\u003e spring.cloud.k8s.test.to.run -\u003e org.springframework.cloud.kubernetes.Fabric8InsideHealthIndicatorTest \u003c/pre\u003e\n * @author wind57\n */\n@Deprecated public class DisabledTestsCondition implements ExecutionCondition {\n  private static final boolean SKIP_RUNNING_TESTS\u003d\"true\".equals(System.getProperty(\"spring.cloud.k8s.skip.tests\"));\n  @Override public ConditionEvaluationResult evaluateExecutionCondition(  ExtensionContext extensionContext){\n    if (SKIP_RUNNING_TESTS) {\n      System.out.println(\"\\nspring.cloud.k8s.test.to.run -\u003e \" + extensionContext.getRequiredTestClass().getName() + \" \\n\");\n      return ConditionEvaluationResult.disabled(\"\");\n    }\n else {\n      return ConditionEvaluationResult.enabled(\"\");\n    }\n  }\n}\n",
        "abstract": "/** \n * This is mainly needed for our pipeline, to get the test classes names. Its purpose is to act like a \u0027dry-run\u0027: show all the tests fully qualified names without actually running them. The way to use it: \"mvn clean test -Dspring.cloud.k8s.skip.tests\u003dtrue\". This way all tests will be skipped, but also will be printed to the standard output as a fully qualified name, i.e.: \u003cpre\u003e spring.cloud.k8s.test.to.run -\u003e org.springframework.cloud.kubernetes.Fabric8InsideHealthIndicatorTest \u003c/pre\u003e\n * @author wind57\n */\n@Deprecated public class DisabledTestsCondition implements ExecutionCondition {\n  private static final boolean SKIP_RUNNING_TESTS\u003d\"true\".equals(System.getProperty(\"spring.cloud.k8s.skip.tests\"));\n  @Override public ConditionEvaluationResult evaluateExecutionCondition(  ExtensionContext extensionContext);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-test-support/src/main/java/org/springframework/cloud/kubernetes/tests/discovery/TestsDiscovery.java",
        "name": "TestsDiscovery",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.tests.discovery.TestsDiscovery",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic class TestsDiscovery {\n  public static void main(  String[] args) throws Exception {\n    List\u003cString\u003e classpathEntries\u003dentireClasspath();\n    List\u003cString\u003e targetClasses\u003dclasspathEntries.stream().filter(x -\u003e x.contains(\"target/classes\")).toList();\n    List\u003cString\u003e targetTestClasses\u003dtargetClasses.stream().map(x -\u003e x.replace(\"classes\",\"test-classes\")).toList();\n    List\u003cString\u003e jars\u003dclasspathEntries.stream().filter(x -\u003e x.contains(\".jar\")).toList();\n    List\u003cURL\u003e urls\u003dStream.of(targetClasses,targetTestClasses,jars).flatMap(List::stream).map(x -\u003e toURL(new File(x).toPath().toUri())).toList();\n    Set\u003cPath\u003e paths\u003dStream.of(targetClasses,targetTestClasses,jars).flatMap(List::stream).map(Paths::get).collect(Collectors.toSet());\n    replaceClassloader(urls);\n    LauncherDiscoveryRequest request\u003dLauncherDiscoveryRequestBuilder.request().selectors(DiscoverySelectors.selectClasspathRoots(paths)).build();\n    try (LauncherSession session\u003dLauncherFactory.openSession()){\n      Launcher launcher\u003dsession.getLauncher();\n      TestPlan testPlan\u003dlauncher.discover(request);\n      testPlan.getRoots().stream().flatMap(x -\u003e testPlan.getChildren(x).stream()).map(TestIdentifier::getLegacyReportingName).sorted().forEach(test -\u003e System.out.println(\"spring.cloud.k8s.test.to.run -\u003e \" + test));\n    }\n   }\n  private static void replaceClassloader(  List\u003cURL\u003e classpathURLs){\n    ClassLoader parentClassLoader\u003dThread.currentThread().getContextClassLoader();\n    URLClassLoader classLoader\u003dURLClassLoader.newInstance(classpathURLs.toArray(new URL[0]),parentClassLoader);\n    Thread.currentThread().setContextClassLoader(classLoader);\n  }\n  private static List\u003cString\u003e entireClasspath() throws Exception {\n    try (Stream\u003cString\u003e lines\u003dFiles.lines(Paths.get(\"/tmp/deps.txt\"))){\n      return lines.distinct().collect(Collectors.toList());\n    }\n   }\n  private static URL toURL(  URI uri){\n    try {\n      return uri.toURL();\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic class TestsDiscovery {\n  public static void main(  String[] args) throws Exception;\n  private static void replaceClassloader(  List\u003cURL\u003e classpathURLs);\n  private static List\u003cString\u003e entireClasspath() throws Exception;\n  private static URL toURL(  URI uri);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-test-support/src/main/java/org/springframework/cloud/kubernetes/integration/tests/commons/fabric8_client/Util.java",
        "name": "Util",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.integration.tests.commons.fabric8_client.Util",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic final class Util {\n  private static final Log LOG\u003dLogFactory.getLog(Util.class);\n  /** \n * Image we get  {@code istioctl} from in order to install Istio. \n */\n  public static final String ISTIO_ISTIOCTL\u003d\"istio/istioctl\";\n  private final K3sContainer container;\n  private final KubernetesClient client;\n  public Util(  K3sContainer container){\n    this.container\u003dcontainer;\n    this.client\u003dnew KubernetesClientBuilder().withConfig(Config.fromKubeconfig(container.getKubeConfigYaml())).build();\n  }\n  /** \n * This is the preferred method to use when creating a deployment alongside with a service. It creates the given resources as-well as waits for them to be created. The delay check is intentionally not taken as an argument, so that it stays as tight as possible, providing reasonable defaults.\n */\n  public void createAndWait(  String namespace,  String name,  @Nullable Deployment deployment,  @Nullable Service service,  @Nullable Ingress ingress,  boolean changeVersion){\n    try {\n      if (deployment !\u003d null) {\n        String imageFromDeployment\u003ddeployment.getSpec().getTemplate().getSpec().getContainers().get(0).getImage();\n        if (changeVersion) {\n          deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setImage(imageFromDeployment + \":\" + pomVersion());\n        }\n else {\n          String[] image\u003dimageFromDeployment.split(\":\",2);\n          pullImage(image[0],image[1],container);\n          loadImage(image[0],image[1],name,container);\n        }\n        client.apps().deployments().inNamespace(namespace).resource(deployment).create();\n        waitForDeployment(namespace,deployment);\n      }\n      if (service !\u003d null) {\n        client.services().inNamespace(namespace).resource(service).create();\n      }\n      if (ingress !\u003d null) {\n        client.network().v1().ingresses().inNamespace(namespace).resource(ingress).create();\n        waitForIngress(namespace,ingress);\n      }\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public void busybox(  String namespace,  Phase phase){\n    InputStream deploymentStream\u003dinputStream(\"busybox/deployment.yaml\");\n    InputStream serviceStream\u003dinputStream(\"busybox/service.yaml\");\n    Deployment deployment\u003dclient.apps().deployments().load(deploymentStream).item();\n    String busyboxVersion\u003dImages.busyboxVersion();\n    String imageWithoutVersion\u003ddeployment.getSpec().getTemplate().getSpec().getContainers().get(0).getImage();\n    String imageWithVersion\u003dimageWithoutVersion + \":\" + busyboxVersion;\n    deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setImage(imageWithVersion);\n    Service service\u003dclient.services().load(serviceStream).item();\n    if (phase.equals(Phase.CREATE)) {\n      createAndWait(namespace,\"busybox\",deployment,service,null,false);\n    }\n else     if (phase.equals(Phase.DELETE)) {\n      deleteAndWait(namespace,deployment,service,null);\n    }\n  }\n  public void deleteAndWait(  String namespace,  @Nullable Deployment deployment,  Service service,  @Nullable Ingress ingress){\n    try {\n      if (deployment !\u003d null) {\n        client.apps().deployments().inNamespace(namespace).resource(deployment).delete();\n        waitForDeploymentToBeDeleted(namespace,deployment);\n      }\n      client.services().inNamespace(namespace).resource(service).delete();\n      if (ingress !\u003d null) {\n        client.network().v1().ingresses().inNamespace(namespace).resource(ingress).delete();\n        waitForIngressToBeDeleted(namespace,ingress);\n      }\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public void setUp(  String namespace) throws Exception {\n    InputStream serviceAccountAsStream\u003dinputStream(\"setup/service-account.yaml\");\n    InputStream roleBindingAsStream\u003dinputStream(\"setup/role-binding.yaml\");\n    InputStream roleAsStream\u003dinputStream(\"setup/role.yaml\");\n    innerSetup(namespace,serviceAccountAsStream,roleBindingAsStream,roleAsStream);\n  }\n  public InputStream inputStream(  String fileName){\n    return Util.class.getClassLoader().getResourceAsStream(fileName);\n  }\n  public void createNamespace(  String name){\n    try {\n      client.namespaces().resource(new NamespaceBuilder().withNewMetadata().withName(name).and().build()).create();\n      await().pollInterval(Duration.ofSeconds(1)).atMost(30,TimeUnit.SECONDS).until(() -\u003e client.namespaces().list().getItems().stream().anyMatch(x -\u003e x.getMetadata().getName().equals(name)));\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public void deleteNamespace(  String name){\n    try {\n      client.namespaces().resource(new NamespaceBuilder().withNewMetadata().withName(name).and().build()).delete();\n      await().pollInterval(Duration.ofSeconds(1)).atMost(30,TimeUnit.SECONDS).until(() -\u003e client.namespaces().list().getItems().stream().noneMatch(x -\u003e x.getMetadata().getName().equals(name)));\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public void setUpClusterWide(  String serviceAccountNamespace,  Set\u003cString\u003e namespaces){\n    InputStream clusterRoleBindingAsStream\u003dinputStream(\"cluster/cluster-role.yaml\");\n    InputStream serviceAccountAsStream\u003dinputStream(\"cluster/service-account.yaml\");\n    InputStream roleBindingAsStream\u003dinputStream(\"cluster/role-binding.yaml\");\n    ClusterRole clusterRole\u003dclient.rbac().clusterRoles().load(clusterRoleBindingAsStream).item();\n    if (client.rbac().clusterRoles().withName(clusterRole.getMetadata().getName()).get() \u003d\u003d null) {\n      client.rbac().clusterRoles().resource(clusterRole).create();\n    }\n    ServiceAccount serviceAccountFromStream\u003dclient.serviceAccounts().load(serviceAccountAsStream).item();\n    serviceAccountFromStream.getMetadata().setNamespace(serviceAccountNamespace);\n    if (client.serviceAccounts().inNamespace(serviceAccountNamespace).withName(serviceAccountFromStream.getMetadata().getName()).get() \u003d\u003d null) {\n      client.serviceAccounts().inNamespace(serviceAccountNamespace).resource(serviceAccountFromStream).create();\n    }\n    RoleBinding roleBindingFromStream\u003dclient.rbac().roleBindings().load(roleBindingAsStream).item();\n    namespaces.forEach(namespace -\u003e {\n      roleBindingFromStream.getMetadata().setNamespace(namespace);\n      if (client.rbac().roleBindings().inNamespace(namespace).withName(roleBindingFromStream.getMetadata().getName()).get() \u003d\u003d null) {\n        client.rbac().roleBindings().inNamespace(namespace).resource(roleBindingFromStream).create();\n      }\n    }\n);\n  }\n  public void createAndWait(  String namespace,  @Nullable ConfigMap configMap,  @Nullable Secret secret){\n    if (configMap !\u003d null) {\n      client.configMaps().resource(configMap).create();\n      waitForConfigMap(namespace,configMap,Phase.CREATE);\n    }\n    if (secret !\u003d null) {\n      client.secrets().resource(secret).create();\n      waitForSecret(namespace,secret,Phase.CREATE);\n    }\n  }\n  public void deleteAndWait(  String namespace,  @Nullable ConfigMap configMap,  @Nullable Secret secret){\n    if (configMap !\u003d null) {\n      client.configMaps().resource(configMap).delete();\n      waitForConfigMap(namespace,configMap,Phase.DELETE);\n    }\n    if (secret !\u003d null) {\n      client.secrets().resource(secret).delete();\n      waitForSecret(namespace,secret,Phase.DELETE);\n    }\n  }\n  public void setUpIstio(  String namespace){\n    InputStream serviceAccountAsStream\u003dinputStream(\"istio/service-account.yaml\");\n    InputStream roleBindingAsStream\u003dinputStream(\"istio/role-binding.yaml\");\n    InputStream roleAsStream\u003dinputStream(\"istio/role.yaml\");\n    innerSetup(namespace,serviceAccountAsStream,roleBindingAsStream,roleAsStream);\n  }\n  public void setUpIstioctl(  String namespace,  Phase phase){\n    InputStream istioctlDeploymentStream\u003dinputStream(\"istio/istioctl-deployment.yaml\");\n    Deployment istioctlDeployment\u003dSerialization.unmarshal(istioctlDeploymentStream,Deployment.class);\n    String imageWithoutVersion\u003distioctlDeployment.getSpec().getTemplate().getSpec().getContainers().get(0).getImage();\n    String imageWithVersion\u003dimageWithoutVersion + \":\" + Images.istioctlVersion();\n    istioctlDeployment.getSpec().getTemplate().getSpec().getContainers().get(0).setImage(imageWithVersion);\n    if (phase.equals(Phase.CREATE)) {\n      createAndWait(namespace,null,istioctlDeployment,null,null,false);\n    }\n else {\n      deleteAndWait(namespace,istioctlDeployment,null,null);\n    }\n  }\n  private void waitForConfigMap(  String namespace,  ConfigMap configMap,  Phase phase){\n    String configMapName\u003dconfigMapName(configMap);\n    await().pollInterval(Duration.ofSeconds(1)).atMost(600,TimeUnit.SECONDS).until(() -\u003e {\n      int size\u003d(int)client.configMaps().inNamespace(namespace).list().getItems().stream().filter(x -\u003e x.getMetadata().getName().equals(configMapName)).count();\n      if (size \u003d\u003d 0) {\n        return !phase.equals(Phase.CREATE);\n      }\n      return phase.equals(Phase.CREATE);\n    }\n);\n  }\n  public void wiremock(  String namespace,  String path,  Phase phase){\n    wiremock(namespace,path,phase,true);\n  }\n  public void wiremock(  String namespace,  String path,  Phase phase,  boolean withIngress){\n    InputStream deploymentStream\u003dinputStream(\"wiremock/wiremock-deployment.yaml\");\n    InputStream serviceStream\u003dinputStream(\"wiremock/wiremock-service.yaml\");\n    InputStream ingressStream\u003dinputStream(\"wiremock/wiremock-ingress.yaml\");\n    Deployment deployment\u003dclient.apps().deployments().load(deploymentStream).item();\n    String imageWithoutVersion\u003ddeployment.getSpec().getTemplate().getSpec().getContainers().get(0).getImage();\n    String imageWithVersion\u003dimageWithoutVersion + \":\" + Images.wiremockVersion();\n    deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setImage(imageWithVersion);\n    Service service\u003dclient.services().load(serviceStream).item();\n    Ingress ingress\u003dnull;\n    if (phase.equals(Phase.CREATE)) {\n      if (withIngress) {\n        ingress\u003dclient.network().v1().ingresses().load(ingressStream).get();\n        ingress.getMetadata().setNamespace(namespace);\n        ingress.getSpec().getRules().get(0).getHttp().getPaths().get(0).setPath(path);\n      }\n      deployment.getMetadata().setNamespace(namespace);\n      service.getMetadata().setNamespace(namespace);\n      createAndWait(namespace,\"wiremock\",deployment,service,ingress,false);\n    }\n else {\n      if (withIngress) {\n        ingress\u003dclient.network().v1().ingresses().load(ingressStream).get();\n      }\n      deleteAndWait(namespace,deployment,service,ingress);\n    }\n  }\n  private void waitForSecret(  String namespace,  Secret secret,  Phase phase){\n    String secretName\u003dsecretName(secret);\n    await().pollInterval(Duration.ofSeconds(1)).atMost(600,TimeUnit.SECONDS).until(() -\u003e {\n      int size\u003d(int)client.secrets().inNamespace(namespace).list().getItems().stream().filter(x -\u003e x.getMetadata().getName().equals(secretName)).count();\n      if (size \u003d\u003d 0) {\n        return !phase.equals(Phase.CREATE);\n      }\n      return phase.equals(Phase.CREATE);\n    }\n);\n  }\n  private void waitForIngressToBeDeleted(  String namespace,  Ingress ingress){\n    String ingressName\u003dingressName(ingress);\n    await().pollInterval(Duration.ofSeconds(1)).atMost(30,TimeUnit.SECONDS).until(() -\u003e {\n      Ingress inner\u003dclient.network().v1().ingresses().inNamespace(namespace).withName(ingressName).get();\n      return inner \u003d\u003d null;\n    }\n);\n  }\n  private void waitForDeploymentToBeDeleted(  String namespace,  Deployment deployment){\n    String deploymentName\u003ddeploymentName(deployment);\n    Map\u003cString,String\u003e matchLabels\u003ddeployment.getSpec().getSelector().getMatchLabels();\n    await().pollInterval(Duration.ofSeconds(1)).atMost(30,TimeUnit.SECONDS).until(() -\u003e {\n      Deployment inner\u003dclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get();\n      return inner \u003d\u003d null;\n    }\n);\n    await().pollInterval(Duration.ofSeconds(1)).atMost(60,TimeUnit.SECONDS).until(() -\u003e {\n      List\u003cPod\u003e podList\u003dclient.pods().inNamespace(namespace).withLabels(matchLabels).list().getItems();\n      return podList \u003d\u003d null || podList.isEmpty();\n    }\n);\n  }\n  private void waitForDeployment(  String namespace,  Deployment deployment){\n    String deploymentName\u003ddeploymentName(deployment);\n    await().pollInterval(Duration.ofSeconds(2)).atMost(600,TimeUnit.SECONDS).until(() -\u003e isDeploymentReady(namespace,deploymentName));\n  }\n  private boolean isDeploymentReady(  String namespace,  String deploymentName){\n    Deployment deployment\u003dclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get();\n    Integer availableReplicas\u003ddeployment.getStatus().getAvailableReplicas();\n    LOG.info(\"Available replicas for \" + deploymentName + \": \"+ ((availableReplicas \u003d\u003d null) ? 0 : 1));\n    return availableReplicas !\u003d null \u0026\u0026 availableReplicas \u003e\u003d 1;\n  }\n  public void waitForIngress(  String namespace,  Ingress ingress){\n    String ingressName\u003dingressName(ingress);\n    try {\n      await().pollInterval(Duration.ofSeconds(2)).atMost(180,TimeUnit.SECONDS).until(() -\u003e {\n        Ingress inner\u003dclient.network().v1().ingresses().inNamespace(namespace).withName(ingressName).get();\n        if (inner \u003d\u003d null) {\n          LOG.info(\"ingress : \" + ingressName + \" not ready yet present\");\n          return false;\n        }\n        List\u003cIngressLoadBalancerIngress\u003e loadBalancerIngress\u003dinner.getStatus().getLoadBalancer().getIngress();\n        if (loadBalancerIngress \u003d\u003d null || loadBalancerIngress.isEmpty()) {\n          LOG.info(\"ingress : \" + ingressName + \" not ready yet (loadbalancer ingress not yet present)\");\n          return false;\n        }\n        String ip\u003dloadBalancerIngress.get(0).getIp();\n        if (ip \u003d\u003d null) {\n          LOG.info(\"ingress : \" + ingressName + \" not ready yet\");\n          return false;\n        }\n        LOG.info(\"ingress : \" + ingressName + \" ready with ip : \"+ ip);\n        return true;\n      }\n);\n    }\n catch (    Exception e) {\n      LOG.error(\"Error waiting for ingress\");\n      e.printStackTrace();\n    }\n  }\n  public void patchWithReplace(  String imageName,  String deploymentName,  String namespace,  String patchBody,  Map\u003cString,String\u003e labels){\n    String body\u003dpatchBody.replace(\"image_name_here\",imageName);\n    client.apps().deployments().inNamespace(namespace).withName(deploymentName).patch(PatchContext.of(PatchType.JSON_MERGE),body);\n    waitForDeploymentAfterPatch(deploymentName,namespace,labels);\n  }\n  private void waitForDeploymentAfterPatch(  String deploymentName,  String namespace,  Map\u003cString,String\u003e labels){\n    try {\n      await().pollDelay(Duration.ofSeconds(4)).pollInterval(Duration.ofSeconds(3)).atMost(60,TimeUnit.SECONDS).until(() -\u003e isDeploymentReadyAfterPatch(deploymentName,namespace,labels));\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  private boolean isDeploymentReadyAfterPatch(  String deploymentName,  String namespace,  Map\u003cString,String\u003e labels){\n    DeploymentList deployments\u003dclient.apps().deployments().inNamespace(namespace).list();\n    if (deployments.getItems().isEmpty()) {\n      fail(\"No deployment with name \" + deploymentName);\n    }\n    Deployment deployment\u003ddeployments.getItems().stream().filter(x -\u003e x.getMetadata().getName().equals(deploymentName)).findFirst().orElseThrow();\n    int replicas\u003dOptional.ofNullable(deployment.getSpec().getReplicas()).orElse(1);\n    int numberOfPods\u003dclient.pods().inNamespace(namespace).withLabels(labels).list().getItems().size();\n    if (numberOfPods !\u003d replicas) {\n      LOG.info(\"number of pods not yet stabilized\");\n      return false;\n    }\n    return replicas \u003d\u003d Optional.ofNullable(deployment.getStatus().getReadyReplicas()).orElse(0);\n  }\n  private void innerSetup(  String namespace,  InputStream serviceAccountAsStream,  InputStream roleBindingAsStream,  InputStream roleAsStream){\n    ServiceAccount serviceAccountFromStream\u003dclient.serviceAccounts().inNamespace(namespace).load(serviceAccountAsStream).item();\n    if (client.serviceAccounts().inNamespace(namespace).withName(serviceAccountFromStream.getMetadata().getName()).get() \u003d\u003d null) {\n      client.serviceAccounts().inNamespace(namespace).resource(serviceAccountFromStream).create();\n    }\n    RoleBinding roleBindingFromStream\u003dclient.rbac().roleBindings().inNamespace(namespace).load(roleBindingAsStream).item();\n    if (client.rbac().roleBindings().inNamespace(namespace).withName(roleBindingFromStream.getMetadata().getName()).get() \u003d\u003d null) {\n      client.rbac().roleBindings().inNamespace(namespace).resource(roleBindingFromStream).create();\n    }\n    Role roleFromStream\u003dclient.rbac().roles().inNamespace(namespace).load(roleAsStream).item();\n    if (client.rbac().roles().inNamespace(namespace).withName(roleFromStream.getMetadata().getName()).get() \u003d\u003d null) {\n      client.rbac().roles().inNamespace(namespace).resource(roleFromStream).create();\n    }\n  }\n  private String deploymentName(  Deployment deployment){\n    return deployment.getMetadata().getName();\n  }\n  private String ingressName(  Ingress ingress){\n    return ingress.getMetadata().getName();\n  }\n  private String configMapName(  ConfigMap configMap){\n    return configMap.getMetadata().getName();\n  }\n  private String secretName(  Secret secret){\n    return secret.getMetadata().getName();\n  }\n  public KubernetesClient client(){\n    return client;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic final class Util {\n  private static final Log LOG\u003dLogFactory.getLog(Util.class);\n  /** \n * Image we get  {@code istioctl} from in order to install Istio. \n */\n  public static final String ISTIO_ISTIOCTL\u003d\"istio/istioctl\";\n  private final K3sContainer container;\n  private final KubernetesClient client;\n  public Util(  K3sContainer container);\n  /** \n * This is the preferred method to use when creating a deployment alongside with a service. It creates the given resources as-well as waits for them to be created. The delay check is intentionally not taken as an argument, so that it stays as tight as possible, providing reasonable defaults.\n */\n  public void createAndWait(  String namespace,  String name,  @Nullable Deployment deployment,  @Nullable Service service,  @Nullable Ingress ingress,  boolean changeVersion);\n  public void busybox(  String namespace,  Phase phase);\n  public void deleteAndWait(  String namespace,  @Nullable Deployment deployment,  Service service,  @Nullable Ingress ingress);\n  public void setUp(  String namespace) throws Exception;\n  public InputStream inputStream(  String fileName);\n  public void createNamespace(  String name);\n  public void deleteNamespace(  String name);\n  public void setUpClusterWide(  String serviceAccountNamespace,  Set\u003cString\u003e namespaces);\n  public void createAndWait(  String namespace,  @Nullable ConfigMap configMap,  @Nullable Secret secret);\n  public void deleteAndWait(  String namespace,  @Nullable ConfigMap configMap,  @Nullable Secret secret);\n  public void setUpIstio(  String namespace);\n  public void setUpIstioctl(  String namespace,  Phase phase);\n  private void waitForConfigMap(  String namespace,  ConfigMap configMap,  Phase phase);\n  public void wiremock(  String namespace,  String path,  Phase phase);\n  public void wiremock(  String namespace,  String path,  Phase phase,  boolean withIngress);\n  private void waitForSecret(  String namespace,  Secret secret,  Phase phase);\n  private void waitForIngressToBeDeleted(  String namespace,  Ingress ingress);\n  private void waitForDeploymentToBeDeleted(  String namespace,  Deployment deployment);\n  private void waitForDeployment(  String namespace,  Deployment deployment);\n  private boolean isDeploymentReady(  String namespace,  String deploymentName);\n  public void waitForIngress(  String namespace,  Ingress ingress);\n  public void patchWithReplace(  String imageName,  String deploymentName,  String namespace,  String patchBody,  Map\u003cString,String\u003e labels);\n  private void waitForDeploymentAfterPatch(  String deploymentName,  String namespace,  Map\u003cString,String\u003e labels);\n  private boolean isDeploymentReadyAfterPatch(  String deploymentName,  String namespace,  Map\u003cString,String\u003e labels);\n  private void innerSetup(  String namespace,  InputStream serviceAccountAsStream,  InputStream roleBindingAsStream,  InputStream roleAsStream);\n  private String deploymentName(  Deployment deployment);\n  private String ingressName(  Ingress ingress);\n  private String configMapName(  ConfigMap configMap);\n  private String secretName(  Secret secret);\n  public KubernetesClient client();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-test-support/src/main/java/org/springframework/cloud/kubernetes/integration/tests/commons/Commons.java",
        "name": "Commons",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.integration.tests.commons.Commons",
        "extend": "",
        "implements": "",
        "raw": "/** \n * A few commons things that can be re-used across clients. This is meant to be used for testing purposes only.\n * @author wind57\n */\npublic final class Commons {\n  private static final Log LOG\u003dLogFactory.getLog(Commons.class);\n  /** \n * this path is generated by the pipeline of github actions.\n */\n  private static final String TMP_IMAGES\u003d\"/tmp/docker/images\";\n  private Commons(){\n    throw new AssertionError(\"No instance provided\");\n  }\n  private static final String KUBERNETES_VERSION_FILE\u003d\"META-INF/springcloudkubernetes-version.txt\";\n  /** \n * Rancher version to use for test-containers.\n */\n  public static final String RANCHER\u003d\"rancher/k3s:v1.28.8-k3s1\";\n  /** \n * Command to use when starting rancher. Without \"server\" option, traefik is not installed\n */\n  public static final String RANCHER_COMMAND\u003d\"server\";\n  /** \n * Test containers exposed ports.\n */\n  public static final int[] EXPOSED_PORTS\u003dnew int[]{80,6443,8080,8888,9092};\n  /** \n * Temporary folder where to load images.\n */\n  public static final String TEMP_FOLDER\u003dnew File(System.getProperty(\"java.io.tmpdir\")).getAbsolutePath();\n  private static final K3sContainer CONTAINER\u003dnew FixedPortsK3sContainer(DockerImageName.parse(Commons.RANCHER)).configureFixedPorts(EXPOSED_PORTS).withFileSystemBind(TEMP_FOLDER,TEMP_FOLDER).withFileSystemBind(TMP_IMAGES,TMP_IMAGES).withCommand(Commons.RANCHER_COMMAND).withReuse(true);\n  public static K3sContainer container(){\n    return CONTAINER;\n  }\n  public static void loadSpringCloudKubernetesImage(  String project,  K3sContainer container) throws Exception {\n    loadImage(\"springcloud/\" + project,pomVersion(),project,container);\n  }\n  /** \n * assert that \"left\" is present and if so, \"right\" is not.\n */\n  public static void assertReloadLogStatements(  String left,  String right,  String appLabel){\n    try {\n      String appPodName\u003dCONTAINER.execInContainer(\"sh\",\"-c\",\"kubectl get pods -l app\u003d\" + appLabel + \" -o\u003dname --no-headers | tr -d \u0027\\n\u0027\").getStdout();\n      LOG.info(\"appPodName : -\u003e\" + appPodName + \"\u003c-\");\n      await().pollDelay(20,TimeUnit.SECONDS).pollInterval(Duration.ofSeconds(5)).atMost(Duration.ofSeconds(120)).until(() -\u003e {\n        Container.ExecResult result\u003dCONTAINER.execInContainer(\"sh\",\"-c\",\"kubectl logs \" + appPodName.trim() + \"| grep \"+ \"\u0027\"+ left+ \"\u0027\");\n        String error\u003dresult.getStderr();\n        String ok\u003dresult.getStdout();\n        LOG.info(\"error is : --\u003e\" + error + \"\u003c--\");\n        if (ok !\u003d null \u0026\u0026 !ok.isBlank()) {\n          if (!right.isBlank()) {\n            String notPresent\u003dCONTAINER.execInContainer(\"sh\",\"-c\",\"kubectl logs \" + appPodName.trim() + \"| grep \"+ \"\u0027\"+ right+ \"\u0027\").getStdout();\n            Assertions.assertTrue(notPresent \u003d\u003d null || notPresent.isBlank());\n          }\n          return true;\n        }\n        LOG.info(\"log statement not yet present\");\n        return false;\n      }\n);\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public static void loadImage(  String image,  String tag,  String tarName,  K3sContainer container) throws Exception {\n    try (SaveImageCmd saveImageCmd\u003dcontainer.getDockerClient().saveImageCmd(image)){\n      InputStream imageStream\u003dsaveImageCmd.withTag(tag).exec();\n      Path imagePath\u003dPaths.get(TEMP_FOLDER + \"/\" + tarName+ \".tar\");\n      Files.deleteIfExists(imagePath);\n      Files.copy(imageStream,imagePath);\n      await().atMost(Duration.ofMinutes(2)).pollInterval(Duration.ofSeconds(1)).until(() -\u003e {\n        Container.ExecResult result\u003dcontainer.execInContainer(\"ctr\",\"i\",\"import\",TEMP_FOLDER + \"/\" + tarName+ \".tar\");\n        boolean noErrors\u003dresult.getStderr() \u003d\u003d null || result.getStderr().isEmpty();\n        if (!noErrors) {\n          LOG.info(\"error is : \" + result.getStderr());\n        }\n        return noErrors;\n      }\n);\n    }\n   }\n  /** \n * either get the tar from \u0027/tmp/docker/images\u0027, or pull the image.\n */\n  public static void load(  K3sContainer container,  String tarName,  String imageNameForDownload,  String imageVersion){\n    File dockerImagesRootDir\u003dPaths.get(Commons.TMP_IMAGES).toFile();\n    if (dockerImagesRootDir.exists() \u0026\u0026 dockerImagesRootDir.isDirectory()) {\n      File[] tars\u003ddockerImagesRootDir.listFiles();\n      if (tars !\u003d null \u0026\u0026 tars.length \u003e 0) {\n        Optional\u003cString\u003e found\u003dArrays.stream(tars).map(File::getName).filter(x -\u003e x.contains(tarName)).findFirst();\n        if (found.isPresent()) {\n          LOG.info(\"running in github actions, will load from : \" + Commons.TMP_IMAGES + \" tar : \"+ found.get());\n          Commons.loadImageFromPath(found.get(),container);\n          return;\n        }\n else {\n          LOG.info(tarName + \" not found, resorting to pulling the image\");\n        }\n      }\n else {\n        LOG.info(\"no tars found, will resort to pulling the image\");\n      }\n    }\n else {\n      LOG.info(\"running outside github actions\");\n    }\n    try {\n      LOG.info(\"no tars found, will resort to pulling the image\");\n      LOG.info(\"using : \" + imageVersion + \" for : \"+ imageNameForDownload);\n      Commons.pullImage(imageNameForDownload,imageVersion,container);\n      Commons.loadImage(imageNameForDownload,imageVersion,tarName,container);\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  private static void loadImageFromPath(  String tarName,  K3sContainer container){\n    await().atMost(Duration.ofMinutes(2)).pollInterval(Duration.ofSeconds(1)).until(() -\u003e {\n      Container.ExecResult result\u003dcontainer.execInContainer(\"ctr\",\"i\",\"import\",TMP_IMAGES + \"/\" + tarName);\n      boolean noErrors\u003dresult.getStderr() \u003d\u003d null || result.getStderr().isEmpty();\n      if (!noErrors) {\n        LOG.info(\"error is : \" + result.getStderr());\n      }\n      return noErrors;\n    }\n);\n  }\n  public static void cleanUp(  String image,  K3sContainer container) throws Exception {\n    container.execInContainer(\"crictl\",\"rmi\",\"docker.io/springcloud/\" + image + \":\"+ pomVersion());\n    container.execInContainer(\"rm\",TEMP_FOLDER + \"/\" + image+ \".tar\");\n  }\n  public static void cleanUpDownloadedImage(  String image) throws Exception {\n    CONTAINER.execInContainer(\"crictl\",\"rmi\",image);\n  }\n  /** \n * validates that the provided image does exist in the local docker registry.\n */\n  public static void validateImage(  String image,  K3sContainer container){\n    try (ListImagesCmd listImagesCmd\u003dcontainer.getDockerClient().listImagesCmd()){\n      List\u003cImage\u003e images\u003dlistImagesCmd.exec();\n      images.stream().filter(x -\u003e Arrays.stream(x.getRepoTags() \u003d\u003d null ? new String[]{} : x.getRepoTags()).anyMatch(y -\u003e y.contains(image))).findFirst().orElseThrow(() -\u003e new IllegalArgumentException(\"Image : \" + image + \" not build locally. \"+ \"You need to build it first, and then run the test\"));\n    }\n   }\n  public static void pullImage(  String image,  String tag,  K3sContainer container) throws InterruptedException {\n    try (PullImageCmd pullImageCmd\u003dcontainer.getDockerClient().pullImageCmd(image)){\n      pullImageCmd.withTag(tag).start().awaitCompletion();\n    }\n   }\n  public static String processExecResult(  Container.ExecResult execResult){\n    if (execResult.getExitCode() !\u003d 0) {\n      throw new RuntimeException(\"stdout\u003d\" + execResult.getStdout() + \"\\n\"+ \"stderr\u003d\"+ execResult.getStderr());\n    }\n    return execResult.getStdout();\n  }\n  /** \n * equivalent of \u0027docker system prune\u0027, but for crictl.\n */\n  public static void systemPrune(){\n    try {\n      CONTAINER.execInContainer(\"sh\",\"-c\",\"crictl ps -a | grep -v Running | awk \u0027{print $1}\u0027 | xargs crictl rm \u0026\u0026 crictl rmi --prune\");\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public static String pomVersion(){\n    try (InputStream in\u003dnew ClassPathResource(KUBERNETES_VERSION_FILE).getInputStream()){\n      String version\u003dStreamUtils.copyToString(in,StandardCharsets.UTF_8);\n      if (StringUtils.hasText(version)) {\n        version\u003dversion.trim();\n      }\n      return version;\n    }\n catch (    IOException e) {\n      ReflectionUtils.rethrowRuntimeException(e);\n    }\n    return null;\n  }\n  /** \n * the assumption is that there is only a single pod that is \u0027Running\u0027.\n */\n  public static void waitForLogStatement(  String message,  K3sContainer k3sContainer,  String appLabelValue){\n    try {\n      await().atMost(Duration.ofMinutes(2)).pollInterval(Duration.ofSeconds(4)).until(() -\u003e {\n        String appPodName\u003dk3sContainer.execInContainer(\"sh\",\"-c\",\"kubectl get pods -l app\u003d\" + appLabelValue + \" -o custom-columns\u003dPOD:metadata.name,STATUS:status.phase\"+ \" | grep -i \u0027running\u0027 | awk \u0027{print $1}\u0027 | tr -d \u0027\\n\u0027 \").getStdout();\n        String execResult\u003dk3sContainer.execInContainer(\"sh\",\"-c\",\"kubectl logs \" + appPodName.trim()).getStdout();\n        return execResult.contains(message);\n      }\n);\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  /** \n * A K3sContainer, but with fixed port mappings. This is needed because of the nature of some integration tests.\n * @author wind57\n */\nprivate static final class FixedPortsK3sContainer extends K3sContainer {\n    private FixedPortsK3sContainer(    DockerImageName dockerImageName){\n      super(dockerImageName);\n    }\n    private FixedPortsK3sContainer configureFixedPorts(    int[] ports){\n      for (      int port : ports) {\n        super.addFixedExposedPort(port,port);\n      }\n      return this;\n    }\n  }\n}\n",
        "abstract": "/** \n * A few commons things that can be re-used across clients. This is meant to be used for testing purposes only.\n * @author wind57\n */\npublic final class Commons {\n  private static final Log LOG\u003dLogFactory.getLog(Commons.class);\n  /** \n * this path is generated by the pipeline of github actions.\n */\n  private static final String TMP_IMAGES\u003d\"/tmp/docker/images\";\n  private Commons();\n  private static final String KUBERNETES_VERSION_FILE\u003d\"META-INF/springcloudkubernetes-version.txt\";\n  /** \n * Rancher version to use for test-containers.\n */\n  public static final String RANCHER\u003d\"rancher/k3s:v1.28.8-k3s1\";\n  /** \n * Command to use when starting rancher. Without \"server\" option, traefik is not installed\n */\n  public static final String RANCHER_COMMAND\u003d\"server\";\n  /** \n * Test containers exposed ports.\n */\n  public static final int[] EXPOSED_PORTS\u003dnew int[]{80,6443,8080,8888,9092};\n  /** \n * Temporary folder where to load images.\n */\n  public static final String TEMP_FOLDER\u003dnew File(System.getProperty(\"java.io.tmpdir\")).getAbsolutePath();\n  private static final K3sContainer CONTAINER\u003dnew FixedPortsK3sContainer(DockerImageName.parse(Commons.RANCHER)).configureFixedPorts(EXPOSED_PORTS).withFileSystemBind(TEMP_FOLDER,TEMP_FOLDER).withFileSystemBind(TMP_IMAGES,TMP_IMAGES).withCommand(Commons.RANCHER_COMMAND).withReuse(true);\n  public static K3sContainer container();\n  public static void loadSpringCloudKubernetesImage(  String project,  K3sContainer container) throws Exception;\n  /** \n * assert that \"left\" is present and if so, \"right\" is not.\n */\n  public static void assertReloadLogStatements(  String left,  String right,  String appLabel);\n  public static void loadImage(  String image,  String tag,  String tarName,  K3sContainer container) throws Exception;\n  /** \n * either get the tar from \u0027/tmp/docker/images\u0027, or pull the image.\n */\n  public static void load(  K3sContainer container,  String tarName,  String imageNameForDownload,  String imageVersion);\n  private static void loadImageFromPath(  String tarName,  K3sContainer container);\n  public static void cleanUp(  String image,  K3sContainer container) throws Exception;\n  public static void cleanUpDownloadedImage(  String image) throws Exception;\n  /** \n * validates that the provided image does exist in the local docker registry.\n */\n  public static void validateImage(  String image,  K3sContainer container);\n  public static void pullImage(  String image,  String tag,  K3sContainer container) throws InterruptedException;\n  public static String processExecResult(  Container.ExecResult execResult);\n  /** \n * equivalent of \u0027docker system prune\u0027, but for crictl.\n */\n  public static void systemPrune();\n  public static String pomVersion();\n  /** \n * the assumption is that there is only a single pod that is \u0027Running\u0027.\n */\n  public static void waitForLogStatement(  String message,  K3sContainer k3sContainer,  String appLabelValue);\n  /** \n * A K3sContainer, but with fixed port mappings. This is needed because of the nature of some integration tests.\n * @author wind57\n */\nprivate static final class FixedPortsK3sContainer extends K3sContainer {\n    private FixedPortsK3sContainer(    DockerImageName dockerImageName);\n    private FixedPortsK3sContainer configureFixedPorts(    int[] ports);\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-test-support/src/main/java/org/springframework/cloud/kubernetes/integration/tests/commons/Phase.java",
        "name": "Phase",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.integration.tests.commons.Phase",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic enum Phase {/** \n * Apply the manifests.\n */\nCREATE, /** \n * Deleted the manifests.\n */\nDELETE}\n",
        "abstract": "/** \n * @author wind57\n */\npublic enum Phase {/** \n * Apply the manifests.\n */\nCREATE, /** \n * Deleted the manifests.\n */\nDELETE}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-test-support/src/main/java/org/springframework/cloud/kubernetes/integration/tests/commons/Images.java",
        "name": "Images",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.integration.tests.commons.Images",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic final class Images {\n  private static final String BUSYBOX\u003d\"busybox\";\n  private static final String BUSYBOX_TAR\u003dBUSYBOX + \":\" + busyboxVersion();\n  private static final String WIREMOCK\u003d\"wiremock/wiremock\";\n  private static final String WIREMOCK_TAR\u003dWIREMOCK.replace(\u0027/\u0027,\u0027-\u0027) + \":\" + wiremockVersion();\n  private static final String ISTIOCTL\u003d\"istio/istioctl\";\n  private static final String ISTIOCTL_TAR\u003dISTIOCTL.replace(\u0027/\u0027,\u0027-\u0027) + \":\" + istioctlVersion();\n  private static final String KAFKA\u003d\"confluentinc/cp-kafka\";\n  private static final String KAFKA_TAR\u003dKAFKA.replace(\u0027/\u0027,\u0027-\u0027) + kafkaVersion();\n  private static final String RABBITMQ\u003d\"rabbitmq\";\n  private static final String RABBITMQ_TAR\u003d\"rabbitmq\";\n  private Images(){\n  }\n  public static String busyboxVersion(){\n    return imageVersion(BUSYBOX);\n  }\n  public static String istioctlVersion(){\n    return imageVersion(ISTIOCTL);\n  }\n  public static String kafkaVersion(){\n    return imageVersion(KAFKA);\n  }\n  public static String rabbitMqVersion(){\n    return imageVersion(RABBITMQ);\n  }\n  public static String wiremockVersion(){\n    return imageVersion(WIREMOCK);\n  }\n  public static void loadBusybox(  K3sContainer container){\n    Commons.load(container,BUSYBOX_TAR,BUSYBOX,busyboxVersion());\n  }\n  public static void loadWiremock(  K3sContainer container){\n    Commons.load(container,WIREMOCK_TAR,WIREMOCK,wiremockVersion());\n  }\n  public static void loadIstioctl(  K3sContainer container){\n    Commons.load(container,ISTIOCTL_TAR,ISTIOCTL,istioctlVersion());\n  }\n  public static void loadKafka(  K3sContainer container){\n    Commons.load(container,KAFKA_TAR,KAFKA,kafkaVersion());\n  }\n  public static void loadRabbitmq(  K3sContainer container){\n    Commons.load(container,RABBITMQ_TAR,RABBITMQ,rabbitMqVersion());\n  }\n  private static String imageVersion(  String imageNameForDownload){\n    BufferedReader reader\u003dnew BufferedReader(new InputStreamReader(Commons.class.getClassLoader().getResourceAsStream(\"current-images.txt\")));\n    return reader.lines().filter(line -\u003e line.contains(imageNameForDownload)).map(line -\u003e line.split(\":\")[1]).findFirst().orElseThrow();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic final class Images {\n  private static final String BUSYBOX\u003d\"busybox\";\n  private static final String BUSYBOX_TAR\u003dBUSYBOX + \":\" + busyboxVersion();\n  private static final String WIREMOCK\u003d\"wiremock/wiremock\";\n  private static final String WIREMOCK_TAR\u003dWIREMOCK.replace(\u0027/\u0027,\u0027-\u0027) + \":\" + wiremockVersion();\n  private static final String ISTIOCTL\u003d\"istio/istioctl\";\n  private static final String ISTIOCTL_TAR\u003dISTIOCTL.replace(\u0027/\u0027,\u0027-\u0027) + \":\" + istioctlVersion();\n  private static final String KAFKA\u003d\"confluentinc/cp-kafka\";\n  private static final String KAFKA_TAR\u003dKAFKA.replace(\u0027/\u0027,\u0027-\u0027) + kafkaVersion();\n  private static final String RABBITMQ\u003d\"rabbitmq\";\n  private static final String RABBITMQ_TAR\u003d\"rabbitmq\";\n  private Images();\n  public static String busyboxVersion();\n  public static String istioctlVersion();\n  public static String kafkaVersion();\n  public static String rabbitMqVersion();\n  public static String wiremockVersion();\n  public static void loadBusybox(  K3sContainer container);\n  public static void loadWiremock(  K3sContainer container);\n  public static void loadIstioctl(  K3sContainer container);\n  public static void loadKafka(  K3sContainer container);\n  public static void loadRabbitmq(  K3sContainer container);\n  private static String imageVersion(  String imageNameForDownload);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-test-support/src/main/java/org/springframework/cloud/kubernetes/integration/tests/commons/K8SUtils.java",
        "name": "K8SUtils",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.integration.tests.commons.K8SUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class K8SUtils {\n  private static final String KUBERNETES_VERSION_FILE\u003d\"META-INF/springcloudkubernetes-version.txt\";\n  private static final String WIREMOCK_DEPLOYMENT_NAME\u003d\"servicea-wiremock-deployment\";\n  private static final String WIREMOCK_APP_NAME\u003d\"servicea-wiremock\";\n  private final Log log\u003dLogFactory.getLog(getClass());\n  private final CoreV1Api api;\n  private final AppsV1Api appsApi;\n  private final NetworkingV1Api networkingApi;\n  private final RbacAuthorizationV1Api rbacApi;\n  public static ApiClient createApiClient() throws IOException {\n    return createApiClient(false,Duration.ofSeconds(15));\n  }\n  public static String getPomVersion(){\n    try (InputStream in\u003dnew ClassPathResource(KUBERNETES_VERSION_FILE).getInputStream()){\n      String version\u003dStreamUtils.copyToString(in,StandardCharsets.UTF_8);\n      if (StringUtils.hasText(version)) {\n        version\u003dversion.trim();\n      }\n      return version;\n    }\n catch (    IOException e) {\n      ReflectionUtils.rethrowRuntimeException(e);\n    }\n    return null;\n  }\n  public static ApiClient createApiClient(  boolean debug,  Duration readTimeout) throws IOException {\n    ApiClient client\u003dConfig.defaultClient();\n    client.setHttpClient(client.getHttpClient().newBuilder().readTimeout(readTimeout).build());\n    client.setDebugging(debug);\n    Configuration.setDefaultApiClient(client);\n    return client;\n  }\n  public static ApiClient createApiClient(  String configFile) throws IOException {\n    ApiClient client\u003dConfig.fromConfig(new StringReader(configFile));\n    client.setHttpClient(client.getHttpClient().newBuilder().readTimeout(Duration.ofSeconds(15)).build());\n    client.setDebugging(false);\n    Configuration.setDefaultApiClient(client);\n    return client;\n  }\n  public K8SUtils(  CoreV1Api api,  AppsV1Api appsApi){\n    this.api\u003dapi;\n    this.appsApi\u003dappsApi;\n    this.networkingApi\u003dnew NetworkingV1Api();\n    this.rbacApi\u003dnew RbacAuthorizationV1Api();\n  }\n  public Object readYaml(  String urlString) throws Exception {\n    URL url\u003dnew URL(urlString);\n    BufferedReader reader\u003dnull;\n    Object yamlObj\u003dnull;\n    try {\n      reader\u003dnew BufferedReader(new InputStreamReader(url.openStream()));\n      yamlObj\u003dYaml.load(reader);\n    }\n catch (    Exception e) {\n      throw e;\n    }\n finally {\n      if (reader !\u003d null) {\n        reader.close();\n      }\n    }\n    return yamlObj;\n  }\n  public static Object readYamlFromClasspath(  String fileName) throws Exception {\n    ClassLoader classLoader\u003dK8SUtils.class.getClassLoader();\n    String file\u003dnew BufferedReader(new InputStreamReader(classLoader.getResourceAsStream(fileName))).lines().collect(Collectors.joining(\"\\n\"));\n    return Yaml.load(file);\n  }\n  public V1Service createService(  String name,  Map\u003cString,String\u003e labels,  Map\u003cString,String\u003e specSelectors,  String type,  String portName,  int port,  int targetPort,  String namespace) throws ApiException {\n    V1Service wiremockService\u003dnew V1ServiceBuilder().editOrNewMetadata().withName(name).addToLabels(labels).endMetadata().editOrNewSpec().addToSelector(specSelectors).withType(type).addNewPort().withName(portName).withPort(port).withNewTargetPort(targetPort).endPort().endSpec().build();\n    return api.createNamespacedService(namespace,wiremockService,null,null,null,null);\n  }\n  public V1Deployment createDeployment(  String name,  Map\u003cString,String\u003e selectorMatchLabels,  Map\u003cString,String\u003e templateMetadataLabels,  String containerName,  String image,  String pullPolicy,  int containerPort,  int readinessProbePort,  String readinessProbePath,  int livenessProbePort,  String livenessProbePath,  String serviceAccountName,  Collection\u003cV1EnvVar\u003e envVars,  String namespace) throws ApiException {\n    V1Deployment wiremockDeployment\u003dnew V1DeploymentBuilder().editOrNewMetadata().withName(name).endMetadata().editOrNewSpec().withNewSelector().addToMatchLabels(selectorMatchLabels).endSelector().editOrNewTemplate().editOrNewMetadata().addToLabels(templateMetadataLabels).endMetadata().editOrNewSpec().withServiceAccountName(serviceAccountName).addNewContainer().withName(containerName).withImage(image).withImagePullPolicy(pullPolicy).addNewPort().withContainerPort(containerPort).endPort().editOrNewReadinessProbe().editOrNewHttpGet().withNewPort(readinessProbePort).withPath(readinessProbePath).endHttpGet().endReadinessProbe().editOrNewLivenessProbe().editOrNewHttpGet().withNewPort(livenessProbePort).withPath(livenessProbePath).endHttpGet().endLivenessProbe().addAllToEnv(envVars).endContainer().endSpec().endTemplate().endSpec().build();\n    return appsApi.createNamespacedDeployment(namespace,wiremockDeployment,null,null,null,null);\n  }\n  public void waitForEndpointReady(  String name,  String namespace){\n    await().pollInterval(Duration.ofSeconds(1)).atMost(600,TimeUnit.SECONDS).until(() -\u003e isEndpointReady(name,namespace));\n  }\n  public boolean isEndpointReady(  String name,  String namespace) throws ApiException {\n    V1EndpointsList endpoints\u003dapi.listNamespacedEndpoints(namespace,null,null,null,\"metadata.name\u003d\" + name,null,null,null,null,null,null,null);\n    if (endpoints.getItems().isEmpty()) {\n      fail(\"no endpoints for \" + name);\n    }\n    V1Endpoints endpoint\u003dendpoints.getItems().get(0);\n    return endpoint.getSubsets().get(0).getAddresses().size() \u003e\u003d 1;\n  }\n  public void waitForReplicationController(  String name,  String namespace){\n    await().pollInterval(Duration.ofSeconds(1)).atMost(600,TimeUnit.SECONDS).until(() -\u003e isReplicationControllerReady(name,namespace));\n  }\n  public boolean isReplicationControllerReady(  String name,  String namespace) throws ApiException {\n    V1ReplicationControllerList controllerList\u003dapi.listNamespacedReplicationController(namespace,null,null,null,\"metadata.name\u003d\" + name,null,null,null,null,null,null,null);\n    if (controllerList.getItems().size() \u003c 1) {\n      fail(\"Replication controller with name \" + name + \"could not be found\");\n    }\n    V1ReplicationController replicationController\u003dcontrollerList.getItems().get(0);\n    Integer availableReplicas\u003dreplicationController.getStatus().getAvailableReplicas();\n    log.info(\"Available replicas for \" + name + \": \"+ (availableReplicas \u003d\u003d null ? 0 : availableReplicas));\n    return availableReplicas !\u003d null \u0026\u0026 availableReplicas \u003e\u003d 1;\n  }\n  public void waitForDeployment(  String deploymentName,  String namespace){\n    await().pollInterval(Duration.ofSeconds(1)).atMost(600,TimeUnit.SECONDS).until(() -\u003e isDeploymentReady(deploymentName,namespace));\n  }\n  public void waitForIngress(  String ingressName,  String namespace){\n    await().timeout(Duration.ofSeconds(90)).pollInterval(Duration.ofSeconds(3)).until(() -\u003e {\n      try {\n        V1IngressLoadBalancerStatus status\u003dnetworkingApi.readNamespacedIngress(ingressName,namespace,null).getStatus().getLoadBalancer();\n        if (status \u003d\u003d null) {\n          log.info(\"ingress : \" + ingressName + \" not ready yet (loadbalancer not yet present)\");\n          return false;\n        }\n        List\u003cV1IngressLoadBalancerIngress\u003e loadBalancerIngress\u003dstatus.getIngress();\n        if (loadBalancerIngress \u003d\u003d null) {\n          log.info(\"ingress : \" + ingressName + \" not ready yet (loadbalancer ingress not yet present)\");\n          return false;\n        }\n        String ip\u003dloadBalancerIngress.get(0).getIp();\n        if (ip \u003d\u003d null) {\n          log.info(\"ingress : \" + ingressName + \" not ready yet\");\n          return false;\n        }\n        log.info(\"ingress : \" + ingressName + \" ready with ip : \"+ ip);\n        return true;\n      }\n catch (      ApiException e) {\n        if (e.getCode() \u003d\u003d HttpURLConnection.HTTP_NOT_FOUND) {\n          return false;\n        }\n        throw new RuntimeException(e);\n      }\n    }\n);\n  }\n  public void waitForDeploymentToBeDeleted(  String deploymentName,  String namespace){\n    await().timeout(Duration.ofSeconds(90)).until(() -\u003e {\n      try {\n        appsApi.readNamespacedDeployment(deploymentName,namespace,null);\n        return false;\n      }\n catch (      ApiException e) {\n        if (e.getCode() \u003d\u003d HttpURLConnection.HTTP_NOT_FOUND) {\n          return true;\n        }\n        throw new RuntimeException(e);\n      }\n    }\n);\n  }\n  public boolean isDeploymentReady(  String deploymentName,  String namespace) throws ApiException {\n    V1DeploymentList deployments\u003dappsApi.listNamespacedDeployment(namespace,null,null,null,\"metadata.name\u003d\" + deploymentName,null,null,null,null,null,null,null);\n    if (deployments.getItems().size() \u003c 1) {\n      fail(\"No deployments with the name \" + deploymentName);\n    }\n    V1Deployment deployment\u003ddeployments.getItems().get(0);\n    Integer availableReplicas\u003ddeployment.getStatus().getAvailableReplicas();\n    log.info(\"Available replicas for \" + deploymentName + \": \"+ (availableReplicas \u003d\u003d null ? 0 : availableReplicas));\n    return availableReplicas !\u003d null \u0026\u0026 availableReplicas \u003e\u003d 1;\n  }\n  public void setUp(  String namespace) throws Exception {\n    V1ServiceAccount serviceAccount\u003dgetConfigK8sClientItServiceAccount();\n    CheckedSupplier\u003cV1ServiceAccount\u003e accountSupplier\u003d() -\u003e api.readNamespacedServiceAccount(serviceAccount.getMetadata().getName(),namespace,null);\n    CheckedSupplier\u003cV1ServiceAccount\u003e accountDefaulter\u003d() -\u003e api.createNamespacedServiceAccount(namespace,serviceAccount,null,null,null,null);\n    notExistsHandler(accountSupplier,accountDefaulter);\n    V1RoleBinding roleBinding\u003dgetConfigK8sClientItRoleBinding();\n    notExistsHandler(() -\u003e rbacApi.readNamespacedRoleBinding(roleBinding.getMetadata().getName(),namespace,null),() -\u003e rbacApi.createNamespacedRoleBinding(namespace,roleBinding,null,null,null,null));\n    V1Role role\u003dgetConfigK8sClientItRole();\n    notExistsHandler(() -\u003e rbacApi.readNamespacedRole(role.getMetadata().getName(),namespace,null),() -\u003e rbacApi.createNamespacedRole(namespace,role,null,null,null,null));\n  }\n  public void deleteNamespace(  String name) throws Exception {\n    api.deleteNamespace(name,null,null,null,null,null,null);\n    await().pollInterval(Duration.ofSeconds(1)).atMost(30,TimeUnit.SECONDS).until(() -\u003e api.listNamespace(null,null,null,null,null,null,null,null,null,null,null).getItems().stream().noneMatch(x -\u003e x.getMetadata().getName().equals(name)));\n  }\n  public void setUpClusterWide(  String serviceAccountNamespace,  Set\u003cString\u003e namespaces) throws Exception {\n    V1ServiceAccount serviceAccount\u003dgetConfigK8sClientItClusterServiceAccount();\n    CheckedSupplier\u003cV1ServiceAccount\u003e accountSupplier\u003d() -\u003e api.readNamespacedServiceAccount(serviceAccount.getMetadata().getName(),serviceAccountNamespace,null);\n    CheckedSupplier\u003cV1ServiceAccount\u003e accountDefaulter\u003d() -\u003e api.createNamespacedServiceAccount(serviceAccountNamespace,serviceAccount,null,null,null,null);\n    notExistsHandler(accountSupplier,accountDefaulter);\n    V1ClusterRole clusterRole\u003dgetConfigK8sClientItClusterRole();\n    notExistsHandler(() -\u003e rbacApi.readClusterRole(clusterRole.getMetadata().getName(),null),() -\u003e rbacApi.createClusterRole(clusterRole,null,null,null,null));\n    V1RoleBinding roleBinding\u003dgetConfigK8sClientItClusterRoleBinding();\n    namespaces.forEach(namespace -\u003e {\n      roleBinding.getMetadata().setNamespace(namespace);\n      try {\n        notExistsHandler(() -\u003e rbacApi.readNamespacedRoleBinding(roleBinding.getMetadata().getName(),namespace,null),() -\u003e rbacApi.createNamespacedRoleBinding(namespace,roleBinding,null,null,null,null));\n      }\n catch (      Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n);\n  }\n  public static V1ServiceAccount getConfigK8sClientItClusterServiceAccount() throws Exception {\n    return (V1ServiceAccount)K8SUtils.readYamlFromClasspath(\"cluster/service-account.yaml\");\n  }\n  public static V1ClusterRole getConfigK8sClientItClusterRole() throws Exception {\n    return (V1ClusterRole)K8SUtils.readYamlFromClasspath(\"cluster/cluster-role.yaml\");\n  }\n  public static V1RoleBinding getConfigK8sClientItClusterRoleBinding() throws Exception {\n    return (V1RoleBinding)K8SUtils.readYamlFromClasspath(\"cluster/role-binding.yaml\");\n  }\n  public static V1ServiceAccount getConfigK8sClientItServiceAccount() throws Exception {\n    return (V1ServiceAccount)K8SUtils.readYamlFromClasspath(\"setup/service-account.yaml\");\n  }\n  public static V1RoleBinding getConfigK8sClientItRoleBinding() throws Exception {\n    return (V1RoleBinding)K8SUtils.readYamlFromClasspath(\"setup/role-binding.yaml\");\n  }\n  public static V1Role getConfigK8sClientItRole() throws Exception {\n    return (V1Role)K8SUtils.readYamlFromClasspath(\"setup/role.yaml\");\n  }\n  public void deployWiremock(  String namespace,  boolean rootPath,  K3sContainer container) throws Exception {\n    innerDeployWiremock(namespace,rootPath,container);\n    waitForDeployment(WIREMOCK_DEPLOYMENT_NAME,namespace);\n    waitForEndpointReady(WIREMOCK_APP_NAME,namespace);\n  }\n  /** \n * this removes wiremock related manifests, but keeps the image loaded in the container. As such can be used across tests.\n */\n  public void cleanUpWiremock(  String namespace) throws Exception {\n    appsApi.deleteCollectionNamespacedDeployment(namespace,null,null,null,\"metadata.name\u003d\" + WIREMOCK_DEPLOYMENT_NAME,null,null,null,null,null,null,null,null,null,null);\n    api.deleteNamespacedService(WIREMOCK_APP_NAME,namespace,null,null,null,null,null,null);\n    networkingApi.deleteNamespacedIngress(\"wiremock-ingress\",namespace,null,null,null,null,null,null);\n    waitForDeploymentToBeDeleted(WIREMOCK_DEPLOYMENT_NAME,namespace);\n  }\n  /** \n * this one should be called once all tests in a suite are done, as it removes the image from a running container.\n */\n  public void removeWiremockImage() throws Exception {\n    V1Deployment wiremockDeployment\u003dgetWiremockDeployment();\n    String wiremockImage\u003dgetImageFromDeployment(wiremockDeployment);\n    Commons.cleanUpDownloadedImage(wiremockImage);\n  }\n  /** \n * Gets the image from a Kubernetes Client deployment yaml. Assumes there is only one container defined in the deployment.\n * @param deployment deployment yaml\n * @return An array where the first item is the mage name and the second item is thetag\n */\n  public static String getImageFromDeployment(  V1Deployment deployment){\n    return deployment.getSpec().getTemplate().getSpec().getContainers().get(0).getImage();\n  }\n  /** \n * Gets the image from a Fabric8 deployment yaml. Assumes there is only one container defined in the deployment.\n * @param deployment deployment yaml\n * @return An array where the first item is the mage name and the second item is thetag\n */\n  public static String getImageFromDeployment(  Deployment deployment){\n    return deployment.getSpec().getTemplate().getSpec().getContainers().get(0).getImage();\n  }\n  private void innerDeployWiremock(  String namespace,  boolean rootPath,  K3sContainer container) throws Exception {\n    V1Deployment deployment\u003dgetWiremockDeployment();\n    String[] image\u003dgetImageFromDeployment(deployment).split(\":\",2);\n    Commons.pullImage(image[0],image[1],container);\n    Commons.loadImage(image[0],image[1],\"wiremock\",container);\n    appsApi.createNamespacedDeployment(namespace,getWiremockDeployment(),null,null,null,null);\n    api.createNamespacedService(namespace,getWiremockAppService(),null,null,null,null);\n    V1Ingress ingress;\n    if (rootPath) {\n      ingress\u003dgetWiremockRootPathIngress();\n    }\n else {\n      ingress\u003dgetWiremockIngress();\n    }\n    networkingApi.createNamespacedIngress(namespace,ingress,null,null,null,null);\n    waitForIngress(ingress.getMetadata().getName(),namespace);\n  }\n  private static V1Ingress getWiremockIngress() throws Exception {\n    return (V1Ingress)K8SUtils.readYamlFromClasspath(\"wiremock/wiremock-ingress.yaml\");\n  }\n  private static V1Ingress getWiremockRootPathIngress() throws Exception {\n    return (V1Ingress)K8SUtils.readYamlFromClasspath(\"wiremock/wiremock-root-path-ingress.yaml\");\n  }\n  private static V1Service getWiremockAppService() throws Exception {\n    return (V1Service)K8SUtils.readYamlFromClasspath(\"wiremock/wiremock-service.yaml\");\n  }\n  private static V1Deployment getWiremockDeployment() throws Exception {\n    return (V1Deployment)K8SUtils.readYamlFromClasspath(\"wiremock/wiremock-deployment.yaml\");\n  }\n  private static \u003cT\u003evoid notExistsHandler(  CheckedSupplier\u003cT\u003e callee,  CheckedSupplier\u003cT\u003e defaulter) throws Exception {\n    try {\n      callee.get();\n    }\n catch (    Exception exception) {\n      if (exception instanceof ApiException) {\n        if (apiException.getCode() \u003d\u003d 404) {\n          defaulter.get();\n          return;\n        }\n      }\n      throw new RuntimeException(exception);\n    }\n  }\nprivate interface CheckedSupplier\u003cT\u003e {\n    T get() throws Exception ;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class K8SUtils {\n  private static final String KUBERNETES_VERSION_FILE\u003d\"META-INF/springcloudkubernetes-version.txt\";\n  private static final String WIREMOCK_DEPLOYMENT_NAME\u003d\"servicea-wiremock-deployment\";\n  private static final String WIREMOCK_APP_NAME\u003d\"servicea-wiremock\";\n  private final Log log\u003dLogFactory.getLog(getClass());\n  private final CoreV1Api api;\n  private final AppsV1Api appsApi;\n  private final NetworkingV1Api networkingApi;\n  private final RbacAuthorizationV1Api rbacApi;\n  public static ApiClient createApiClient() throws IOException;\n  public static String getPomVersion();\n  public static ApiClient createApiClient(  boolean debug,  Duration readTimeout) throws IOException;\n  public static ApiClient createApiClient(  String configFile) throws IOException;\n  public K8SUtils(  CoreV1Api api,  AppsV1Api appsApi);\n  public Object readYaml(  String urlString) throws Exception;\n  public static Object readYamlFromClasspath(  String fileName) throws Exception;\n  public V1Service createService(  String name,  Map\u003cString,String\u003e labels,  Map\u003cString,String\u003e specSelectors,  String type,  String portName,  int port,  int targetPort,  String namespace) throws ApiException;\n  public V1Deployment createDeployment(  String name,  Map\u003cString,String\u003e selectorMatchLabels,  Map\u003cString,String\u003e templateMetadataLabels,  String containerName,  String image,  String pullPolicy,  int containerPort,  int readinessProbePort,  String readinessProbePath,  int livenessProbePort,  String livenessProbePath,  String serviceAccountName,  Collection\u003cV1EnvVar\u003e envVars,  String namespace) throws ApiException;\n  public void waitForEndpointReady(  String name,  String namespace);\n  public boolean isEndpointReady(  String name,  String namespace) throws ApiException;\n  public void waitForReplicationController(  String name,  String namespace);\n  public boolean isReplicationControllerReady(  String name,  String namespace) throws ApiException;\n  public void waitForDeployment(  String deploymentName,  String namespace);\n  public void waitForIngress(  String ingressName,  String namespace);\n  public void waitForDeploymentToBeDeleted(  String deploymentName,  String namespace);\n  public boolean isDeploymentReady(  String deploymentName,  String namespace) throws ApiException;\n  public void setUp(  String namespace) throws Exception;\n  public void deleteNamespace(  String name) throws Exception;\n  public void setUpClusterWide(  String serviceAccountNamespace,  Set\u003cString\u003e namespaces) throws Exception;\n  public static V1ServiceAccount getConfigK8sClientItClusterServiceAccount() throws Exception;\n  public static V1ClusterRole getConfigK8sClientItClusterRole() throws Exception;\n  public static V1RoleBinding getConfigK8sClientItClusterRoleBinding() throws Exception;\n  public static V1ServiceAccount getConfigK8sClientItServiceAccount() throws Exception;\n  public static V1RoleBinding getConfigK8sClientItRoleBinding() throws Exception;\n  public static V1Role getConfigK8sClientItRole() throws Exception;\n  public void deployWiremock(  String namespace,  boolean rootPath,  K3sContainer container) throws Exception;\n  /** \n * this removes wiremock related manifests, but keeps the image loaded in the container. As such can be used across tests.\n */\n  public void cleanUpWiremock(  String namespace) throws Exception;\n  /** \n * this one should be called once all tests in a suite are done, as it removes the image from a running container.\n */\n  public void removeWiremockImage() throws Exception;\n  /** \n * Gets the image from a Kubernetes Client deployment yaml. Assumes there is only one container defined in the deployment.\n * @param deployment deployment yaml\n * @return An array where the first item is the mage name and the second item is thetag\n */\n  public static String getImageFromDeployment(  V1Deployment deployment);\n  /** \n * Gets the image from a Fabric8 deployment yaml. Assumes there is only one container defined in the deployment.\n * @param deployment deployment yaml\n * @return An array where the first item is the mage name and the second item is thetag\n */\n  public static String getImageFromDeployment(  Deployment deployment);\n  private void innerDeployWiremock(  String namespace,  boolean rootPath,  K3sContainer container) throws Exception;\n  private static V1Ingress getWiremockIngress() throws Exception;\n  private static V1Ingress getWiremockRootPathIngress() throws Exception;\n  private static V1Service getWiremockAppService() throws Exception;\n  private static V1Deployment getWiremockDeployment() throws Exception;\n  private static \u003cT\u003evoid notExistsHandler(  CheckedSupplier\u003cT\u003e callee,  CheckedSupplier\u003cT\u003e defaulter) throws Exception;\nprivate interface CheckedSupplier\u003cT\u003e {\n    T get() throws Exception ;\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-test-support/src/main/java/org/springframework/cloud/kubernetes/integration/tests/commons/native_client/Util.java",
        "name": "Util",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.integration.tests.commons.native_client.Util",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic final class Util {\n  private static final Log LOG\u003dLogFactory.getLog(Util.class);\n  private final CoreV1Api coreV1Api;\n  private final AppsV1Api appsV1Api;\n  private final NetworkingV1Api networkingV1Api;\n  private final RbacAuthorizationV1Api rbacApi;\n  private final K3sContainer container;\n  public Util(  K3sContainer container){\n    ApiClient client;\n    try {\n      client\u003dConfig.fromConfig(new StringReader(container.getKubeConfigYaml()));\n    }\n catch (    IOException e) {\n      throw new RuntimeException(e);\n    }\n    client.setHttpClient(client.getHttpClient().newBuilder().readTimeout(Duration.ofSeconds(15)).build());\n    client.setDebugging(false);\n    Configuration.setDefaultApiClient(client);\n    this.container\u003dcontainer;\n    this.coreV1Api\u003dnew CoreV1Api();\n    this.appsV1Api\u003dnew AppsV1Api();\n    this.networkingV1Api\u003dnew NetworkingV1Api();\n    rbacApi\u003dnew RbacAuthorizationV1Api();\n  }\n  /** \n * This is the preferred method to use when creating a deployment alongside with a service. It creates the given resources as-well as waits for them to be created. The delay check is intentionally not taken as an argument, so that it stays as tight as possible, providing reasonable defaults.\n */\n  public void createAndWait(  String namespace,  String name,  V1Deployment deployment,  V1Service service,  @Nullable V1Ingress ingress,  boolean changeVersion){\n    try {\n      coreV1Api.createNamespacedService(namespace,service,null,null,null,null);\n      if (deployment !\u003d null) {\n        String imageFromDeployment\u003ddeployment.getSpec().getTemplate().getSpec().getContainers().get(0).getImage();\n        if (changeVersion) {\n          deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setImage(imageFromDeployment + \":\" + pomVersion());\n        }\n else {\n          String[] image\u003dimageFromDeployment.split(\":\",2);\n          pullImage(image[0],image[1],container);\n          loadImage(image[0],image[1],name,container);\n        }\n        appsV1Api.createNamespacedDeployment(namespace,deployment,null,null,null,null);\n        waitForDeployment(namespace,deployment);\n      }\n      if (ingress !\u003d null) {\n        networkingV1Api.createNamespacedIngress(namespace,ingress,null,null,null,null);\n        waitForIngress(namespace,ingress);\n      }\n    }\n catch (    Exception e) {\n      if (e instanceof ApiException) {\n        System.out.println(apiException.getResponseBody());\n      }\n      throw new RuntimeException(e);\n    }\n  }\n  public void createAndWait(  String namespace,  @Nullable V1ConfigMap configMap,  @Nullable V1Secret secret){\n    try {\n      if (configMap !\u003d null) {\n        coreV1Api.createNamespacedConfigMap(namespace,configMap,null,null,null,null);\n        waitForConfigMap(namespace,configMap,Phase.CREATE);\n      }\n      if (secret !\u003d null) {\n        coreV1Api.createNamespacedSecret(namespace,secret,null,null,null,null);\n        waitForSecret(namespace,secret,Phase.CREATE);\n      }\n    }\n catch (    ApiException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public void deleteAndWait(  String namespace,  @Nullable V1ConfigMap configMap,  @Nullable V1Secret secret){\n    try {\n      if (configMap !\u003d null) {\n        String configMapName\u003dconfigMapName(configMap);\n        coreV1Api.deleteNamespacedConfigMap(configMapName,namespace,null,null,null,null,null,null);\n        waitForConfigMap(namespace,configMap,Phase.DELETE);\n      }\n      if (secret !\u003d null) {\n        String secretName\u003dsecretName(secret);\n        coreV1Api.deleteNamespacedSecret(secretName,namespace,null,null,null,null,null,null);\n        waitForSecret(namespace,secret,Phase.DELETE);\n      }\n    }\n catch (    ApiException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public void createNamespace(  String name){\n    try {\n      coreV1Api.createNamespace(new V1NamespaceBuilder().withNewMetadata().withName(name).and().build(),null,null,null,null);\n    }\n catch (    ApiException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public void deleteAndWait(  String namespace,  V1Deployment deployment,  V1Service service,  @Nullable V1Ingress ingress){\n    if (deployment !\u003d null) {\n      try {\n        String deploymentName\u003ddeploymentName(deployment);\n        Map\u003cString,String\u003e podLabels\u003dappsV1Api.readNamespacedDeployment(deploymentName,namespace,null).getSpec().getTemplate().getMetadata().getLabels();\n        appsV1Api.deleteNamespacedDeployment(deploymentName,namespace,null,null,null,null,null,null);\n        coreV1Api.deleteCollectionNamespacedPod(namespace,null,null,null,null,null,labelSelector(podLabels),null,null,null,null,null,null,null,null);\n        waitForDeploymentToBeDeleted(deploymentName,namespace);\n        waitForDeploymentPodsToBeDeleted(podLabels,namespace);\n      }\n catch (      Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    String serviceName\u003dserviceName(service);\n    try {\n      coreV1Api.deleteNamespacedService(serviceName,namespace,null,null,null,null,null,null);\n      if (ingress !\u003d null) {\n        String ingressName\u003dingressName(ingress);\n        networkingV1Api.deleteNamespacedIngress(ingressName,namespace,null,null,null,null,null,null);\n        waitForIngressToBeDeleted(ingressName,namespace);\n      }\n    }\n catch (    ApiException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public void busybox(  String namespace,  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)yaml(\"busybox/deployment.yaml\");\n    String imageWithoutVersion\u003ddeployment.getSpec().getTemplate().getSpec().getContainers().get(0).getImage();\n    String imageWithVersion\u003dimageWithoutVersion + \":\" + Images.busyboxVersion();\n    deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setImage(imageWithVersion);\n    V1Service service\u003d(V1Service)yaml(\"busybox/service.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      createAndWait(namespace,\"busybox\",deployment,service,null,false);\n    }\n else     if (phase.equals(Phase.DELETE)) {\n      deleteAndWait(namespace,deployment,service,null);\n    }\n  }\n  public void kafka(  String namespace,  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)yaml(\"kafka/kafka-deployment.yaml\");\n    String imageWithoutVersion\u003ddeployment.getSpec().getTemplate().getSpec().getContainers().get(0).getImage();\n    String imageWithVersion\u003dimageWithoutVersion + \":\" + Images.kafkaVersion();\n    deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setImage(imageWithVersion);\n    V1Service service\u003d(V1Service)yaml(\"kafka/kafka-service.yaml\");\n    V1ConfigMap configMap\u003d(V1ConfigMap)yaml(\"kafka/kafka-configmap-startup-script.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      createAndWait(namespace,configMap,null);\n      createAndWait(namespace,\"kafka\",deployment,service,null,false);\n    }\n else     if (phase.equals(Phase.DELETE)) {\n      deleteAndWait(namespace,configMap,null);\n      deleteAndWait(namespace,deployment,service,null);\n    }\n  }\n  public void rabbitMq(  String namespace,  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)yaml(\"rabbitmq/rabbitmq-deployment.yaml\");\n    String imageWithoutVersion\u003ddeployment.getSpec().getTemplate().getSpec().getContainers().get(0).getImage();\n    String imageWithVersion\u003dimageWithoutVersion + \":\" + Images.rabbitMqVersion();\n    deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setImage(imageWithVersion);\n    V1Service service\u003d(V1Service)yaml(\"rabbitmq/rabbitmq-service.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      createAndWait(namespace,\"rabbitmq\",deployment,service,null,false);\n    }\n else     if (phase.equals(Phase.DELETE)) {\n      deleteAndWait(namespace,deployment,service,null);\n    }\n  }\n  /** \n * reads a yaml from classpath, fails if not found.\n */\n  public Object yaml(  String fileName){\n    ClassLoader classLoader\u003dUtil.class.getClassLoader();\n    String file\u003dnew BufferedReader(new InputStreamReader(classLoader.getResourceAsStream(fileName))).lines().collect(Collectors.joining(\"\\n\"));\n    try {\n      return Yaml.load(file);\n    }\n catch (    IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public void setUp(  String namespace){\n    try {\n      V1ServiceAccount serviceAccount\u003d(V1ServiceAccount)yaml(\"setup/service-account.yaml\");\n      CheckedSupplier\u003cV1ServiceAccount\u003e accountSupplier\u003d() -\u003e coreV1Api.readNamespacedServiceAccount(serviceAccount.getMetadata().getName(),namespace,null);\n      CheckedSupplier\u003cV1ServiceAccount\u003e accountDefaulter\u003d() -\u003e coreV1Api.createNamespacedServiceAccount(namespace,serviceAccount,null,null,null,null);\n      notExistsHandler(accountSupplier,accountDefaulter);\n      V1RoleBinding roleBinding\u003d(V1RoleBinding)yaml(\"setup/role-binding.yaml\");\n      notExistsHandler(() -\u003e rbacApi.readNamespacedRoleBinding(roleBinding.getMetadata().getName(),namespace,null),() -\u003e rbacApi.createNamespacedRoleBinding(namespace,roleBinding,null,null,null,null));\n      V1Role role\u003d(V1Role)yaml(\"setup/role.yaml\");\n      notExistsHandler(() -\u003e rbacApi.readNamespacedRole(role.getMetadata().getName(),namespace,null),() -\u003e rbacApi.createNamespacedRole(namespace,role,null,null,null,null));\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public void setUpClusterWideClusterRoleBinding(  String serviceAccountNamespace){\n    try {\n      V1ServiceAccount serviceAccount\u003d(V1ServiceAccount)yaml(\"cluster/service-account.yaml\");\n      CheckedSupplier\u003cV1ServiceAccount\u003e accountSupplier\u003d() -\u003e coreV1Api.readNamespacedServiceAccount(serviceAccount.getMetadata().getName(),serviceAccountNamespace,null);\n      CheckedSupplier\u003cV1ServiceAccount\u003e accountDefaulter\u003d() -\u003e coreV1Api.createNamespacedServiceAccount(serviceAccountNamespace,serviceAccount,null,null,null,null);\n      notExistsHandler(accountSupplier,accountDefaulter);\n      V1ClusterRole clusterRole\u003d(V1ClusterRole)yaml(\"cluster/cluster-role.yaml\");\n      notExistsHandler(() -\u003e rbacApi.readClusterRole(clusterRole.getMetadata().getName(),null),() -\u003e rbacApi.createClusterRole(clusterRole,null,null,null,null));\n      V1ClusterRoleBinding clusterRoleBinding\u003d(V1ClusterRoleBinding)yaml(\"cluster/cluster-role-binding.yaml\");\n      notExistsHandler(() -\u003e rbacApi.readClusterRoleBinding(clusterRoleBinding.getMetadata().getName(),null),() -\u003e rbacApi.createClusterRoleBinding(clusterRoleBinding,null,null,null,null));\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n  public void deleteClusterWideClusterRoleBinding(  String serviceAccountNamespace){\n    try {\n      V1ServiceAccount serviceAccount\u003d(V1ServiceAccount)yaml(\"cluster/service-account.yaml\");\n      V1ClusterRole clusterRole\u003d(V1ClusterRole)yaml(\"cluster/cluster-role.yaml\");\n      V1ClusterRoleBinding clusterRoleBinding\u003d(V1ClusterRoleBinding)yaml(\"cluster/cluster-role-binding.yaml\");\n      coreV1Api.deleteNamespacedServiceAccount(serviceAccount.getMetadata().getName(),serviceAccountNamespace,null,null,null,null,null,null);\n      rbacApi.deleteClusterRole(clusterRole.getMetadata().getName(),null,null,null,null,null,null);\n      rbacApi.deleteClusterRoleBinding(clusterRoleBinding.getMetadata().getName(),null,null,null,null,null,null);\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n  public void setUpClusterWide(  String serviceAccountNamespace,  Set\u003cString\u003e namespaces){\n    try {\n      V1ServiceAccount serviceAccount\u003d(V1ServiceAccount)yaml(\"cluster/service-account.yaml\");\n      CheckedSupplier\u003cV1ServiceAccount\u003e accountSupplier\u003d() -\u003e coreV1Api.readNamespacedServiceAccount(serviceAccount.getMetadata().getName(),serviceAccountNamespace,null);\n      CheckedSupplier\u003cV1ServiceAccount\u003e accountDefaulter\u003d() -\u003e coreV1Api.createNamespacedServiceAccount(serviceAccountNamespace,serviceAccount,null,null,null,null);\n      notExistsHandler(accountSupplier,accountDefaulter);\n      V1ClusterRole clusterRole\u003d(V1ClusterRole)yaml(\"cluster/cluster-role.yaml\");\n      notExistsHandler(() -\u003e rbacApi.readClusterRole(clusterRole.getMetadata().getName(),null),() -\u003e rbacApi.createClusterRole(clusterRole,null,null,null,null));\n      V1RoleBinding roleBinding\u003d(V1RoleBinding)yaml(\"cluster/role-binding.yaml\");\n      namespaces.forEach(namespace -\u003e {\n        roleBinding.getMetadata().setNamespace(namespace);\n        try {\n          notExistsHandler(() -\u003e rbacApi.readNamespacedRoleBinding(roleBinding.getMetadata().getName(),namespace,null),() -\u003e rbacApi.createNamespacedRoleBinding(namespace,roleBinding,null,null,null,null));\n        }\n catch (        Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n);\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public void deleteClusterWide(  String serviceAccountNamespace,  Set\u003cString\u003e namespaces){\n    try {\n      V1ServiceAccount serviceAccount\u003d(V1ServiceAccount)yaml(\"cluster/service-account.yaml\");\n      V1ClusterRole clusterRole\u003d(V1ClusterRole)yaml(\"cluster/cluster-role.yaml\");\n      V1RoleBinding roleBinding\u003d(V1RoleBinding)yaml(\"cluster/role-binding.yaml\");\n      coreV1Api.deleteNamespacedServiceAccount(serviceAccount.getMetadata().getName(),serviceAccountNamespace,null,null,null,null,null,null);\n      rbacApi.deleteClusterRole(clusterRole.getMetadata().getName(),null,null,null,null,null,null);\n      namespaces.forEach(namespace -\u003e {\n        roleBinding.getMetadata().setNamespace(namespace);\n        try {\n          rbacApi.deleteNamespacedRoleBinding(roleBinding.getMetadata().getName(),namespace,null,null,null,null,null,null);\n        }\n catch (        Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n);\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public void deleteNamespace(  String name){\n    try {\n      coreV1Api.deleteNamespace(name,null,null,null,null,null,null);\n    }\n catch (    ApiException e) {\n      throw new RuntimeException(e);\n    }\n    await().pollInterval(Duration.ofSeconds(1)).atMost(30,TimeUnit.SECONDS).until(() -\u003e coreV1Api.listNamespace(null,null,null,null,null,null,null,null,null,null,null).getItems().stream().noneMatch(x -\u003e x.getMetadata().getName().equals(name)));\n  }\n  public void wiremock(  String namespace,  String path,  Phase phase){\n    wiremock(namespace,path,phase,true);\n  }\n  public void wiremock(  String namespace,  String path,  Phase phase,  boolean withIngress){\n    V1Deployment deployment\u003d(V1Deployment)yaml(\"wiremock/wiremock-deployment.yaml\");\n    String imageWithoutVersion\u003ddeployment.getSpec().getTemplate().getSpec().getContainers().get(0).getImage();\n    String imageWithVersion\u003dimageWithoutVersion + \":\" + Images.wiremockVersion();\n    deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setImage(imageWithVersion);\n    V1Service service\u003d(V1Service)yaml(\"wiremock/wiremock-service.yaml\");\n    V1Ingress ingress\u003dnull;\n    if (phase.equals(Phase.CREATE)) {\n      if (withIngress) {\n        ingress\u003d(V1Ingress)yaml(\"wiremock/wiremock-ingress.yaml\");\n        ingress.getMetadata().setNamespace(namespace);\n        ingress.getSpec().getRules().get(0).getHttp().getPaths().get(0).setPath(path);\n      }\n      deployment.getMetadata().setNamespace(namespace);\n      service.getMetadata().setNamespace(namespace);\n      createAndWait(namespace,\"wiremock\",deployment,service,ingress,false);\n    }\n else {\n      if (withIngress) {\n        ingress\u003d(V1Ingress)yaml(\"wiremock/wiremock-ingress.yaml\");\n      }\n      deleteAndWait(namespace,deployment,service,ingress);\n    }\n  }\n  public static void patchWithMerge(  String deploymentName,  String namespace,  String patchBody,  Map\u003cString,String\u003e podLabels){\n    try {\n      PatchUtils.patch(V1Deployment.class,() -\u003e new AppsV1Api().patchNamespacedDeploymentCall(deploymentName,namespace,new V1Patch(patchBody),null,null,null,null,null,null),V1Patch.PATCH_FORMAT_STRATEGIC_MERGE_PATCH,new CoreV1Api().getApiClient());\n    }\n catch (    ApiException e) {\n      LOG.error(\"error : \" + e.getResponseBody());\n      throw new RuntimeException(e);\n    }\n    waitForDeploymentAfterPatch(deploymentName,namespace,podLabels);\n  }\n  public static void patchWithReplace(  String imageName,  String deploymentName,  String namespace,  String patchBody,  Map\u003cString,String\u003e podLabels){\n    String body\u003dpatchBody.replace(\"image_name_here\",imageName);\n    try {\n      PatchUtils.patch(V1Deployment.class,() -\u003e new AppsV1Api().patchNamespacedDeploymentCall(deploymentName,namespace,new V1Patch(body),null,null,null,null,null,null),V1Patch.PATCH_FORMAT_JSON_MERGE_PATCH,new CoreV1Api().getApiClient());\n    }\n catch (    ApiException e) {\n      LOG.error(\"error : \" + e.getResponseBody());\n      throw new RuntimeException(e);\n    }\n    waitForDeploymentAfterPatch(deploymentName,namespace,podLabels);\n  }\n  private String deploymentName(  V1Deployment deployment){\n    return deployment.getMetadata().getName();\n  }\n  private String serviceName(  V1Service service){\n    return service.getMetadata().getName();\n  }\n  private String ingressName(  V1Ingress ingress){\n    return ingress.getMetadata().getName();\n  }\n  private String configMapName(  V1ConfigMap configMap){\n    return configMap.getMetadata().getName();\n  }\n  private String secretName(  V1Secret secret){\n    return secret.getMetadata().getName();\n  }\n  private void waitForDeployment(  String namespace,  V1Deployment deployment){\n    String deploymentName\u003ddeploymentName(deployment);\n    await().pollDelay(Duration.ofSeconds(5)).pollInterval(Duration.ofSeconds(5)).atMost(900,TimeUnit.SECONDS).until(() -\u003e isDeploymentReady(deploymentName,namespace));\n  }\n  private void waitForConfigMap(  String namespace,  V1ConfigMap configMap,  Phase phase){\n    String configMapName\u003dconfigMapName(configMap);\n    await().pollInterval(Duration.ofSeconds(1)).atMost(600,TimeUnit.SECONDS).until(() -\u003e {\n      try {\n        coreV1Api.readNamespacedConfigMap(configMapName,namespace,null);\n        return phase.equals(Phase.CREATE);\n      }\n catch (      ApiException e) {\n        if (e.getCode() \u003d\u003d HttpURLConnection.HTTP_NOT_FOUND) {\n          return !phase.equals(Phase.CREATE);\n        }\n        throw new RuntimeException(e);\n      }\n    }\n);\n  }\n  private void waitForSecret(  String namespace,  V1Secret secret,  Phase phase){\n    String secretName\u003dsecretName(secret);\n    await().pollInterval(Duration.ofSeconds(1)).atMost(600,TimeUnit.SECONDS).until(() -\u003e {\n      try {\n        coreV1Api.readNamespacedSecret(secretName,namespace,null);\n        return phase.equals(Phase.CREATE);\n      }\n catch (      ApiException e) {\n        if (e.getCode() \u003d\u003d HttpURLConnection.HTTP_NOT_FOUND) {\n          return !phase.equals(Phase.CREATE);\n        }\n        throw new RuntimeException(e);\n      }\n    }\n);\n  }\n  private void waitForIngress(  String namespace,  V1Ingress ingress){\n    String ingressName\u003dingressName(ingress);\n    await().timeout(Duration.ofSeconds(90)).pollInterval(Duration.ofSeconds(3)).until(() -\u003e {\n      try {\n        V1IngressLoadBalancerStatus status\u003dnetworkingV1Api.readNamespacedIngress(ingressName,namespace,null).getStatus().getLoadBalancer();\n        if (status \u003d\u003d null) {\n          LOG.info(\"ingress : \" + ingressName + \" not ready yet (loadbalancer not yet present)\");\n          return false;\n        }\n        List\u003cV1IngressLoadBalancerIngress\u003e loadBalancerIngress\u003dstatus.getIngress();\n        if (loadBalancerIngress \u003d\u003d null) {\n          LOG.info(\"ingress : \" + ingressName + \" not ready yet (loadbalancer ingress not yet present)\");\n          return false;\n        }\n        String ip\u003dloadBalancerIngress.get(0).getIp();\n        if (ip \u003d\u003d null) {\n          LOG.info(\"ingress : \" + ingressName + \" not ready yet\");\n          return false;\n        }\n        LOG.info(\"ingress : \" + ingressName + \" ready with ip : \"+ ip);\n        return true;\n      }\n catch (      ApiException e) {\n        if (e.getCode() \u003d\u003d HttpURLConnection.HTTP_NOT_FOUND) {\n          return false;\n        }\n        throw new RuntimeException(e);\n      }\n    }\n);\n  }\n  private void waitForDeploymentToBeDeleted(  String deploymentName,  String namespace){\n    await().timeout(Duration.ofSeconds(180)).until(() -\u003e {\n      try {\n        appsV1Api.readNamespacedDeployment(deploymentName,namespace,null);\n        return false;\n      }\n catch (      ApiException e) {\n        if (e.getCode() \u003d\u003d HttpURLConnection.HTTP_NOT_FOUND) {\n          return true;\n        }\n        throw new RuntimeException(e);\n      }\n    }\n);\n  }\n  private void waitForDeploymentPodsToBeDeleted(  Map\u003cString,String\u003e labels,  String namespace){\n    await().timeout(Duration.ofSeconds(180)).until(() -\u003e {\n      try {\n        int currentNumberOfPods\u003dcoreV1Api.listNamespacedPod(namespace,null,null,null,null,labelSelector(labels),null,null,null,null,null,null).getItems().size();\n        return currentNumberOfPods \u003d\u003d 0;\n      }\n catch (      ApiException e) {\n        if (e.getCode() \u003d\u003d HttpURLConnection.HTTP_NOT_FOUND) {\n          return true;\n        }\n        throw new RuntimeException(e);\n      }\n    }\n);\n  }\n  private void waitForIngressToBeDeleted(  String ingressName,  String namespace){\n    await().timeout(Duration.ofSeconds(90)).until(() -\u003e {\n      try {\n        networkingV1Api.readNamespacedIngress(ingressName,namespace,null);\n        return false;\n      }\n catch (      ApiException e) {\n        if (e.getCode() \u003d\u003d HttpURLConnection.HTTP_NOT_FOUND) {\n          return true;\n        }\n        throw new RuntimeException(e);\n      }\n    }\n);\n  }\n  private boolean isDeploymentReady(  String deploymentName,  String namespace) throws ApiException {\n    V1DeploymentList deployments\u003dappsV1Api.listNamespacedDeployment(namespace,null,null,null,\"metadata.name\u003d\" + deploymentName,null,null,null,null,null,null,null);\n    if (deployments.getItems().isEmpty()) {\n      fail(\"No deployments with the name \" + deploymentName);\n    }\n    V1Deployment deployment\u003ddeployments.getItems().get(0);\n    if (deployment.getStatus() !\u003d null) {\n      Integer availableReplicas\u003ddeployment.getStatus().getAvailableReplicas();\n      logDeploymentConditions(deployment.getStatus().getConditions());\n      LOG.info(\"Available replicas for \" + deploymentName + \": \"+ (availableReplicas \u003d\u003d null ? 0 : availableReplicas));\n      return availableReplicas !\u003d null \u0026\u0026 availableReplicas \u003e\u003d 1;\n    }\n else {\n      return false;\n    }\n  }\n  private void logDeploymentConditions(  List\u003cV1DeploymentCondition\u003e conditions){\n    if (conditions !\u003d null) {\n      for (      V1DeploymentCondition condition : conditions) {\n        LOG.info(\"Deployment Condition Type: \" + condition.getType());\n        LOG.info(\"Deployment Condition Status: \" + condition.getStatus());\n        LOG.info(\"Deployment Condition Message: \" + condition.getMessage());\n        LOG.info(\"Deployment Condition Reason: \" + condition.getReason());\n      }\n    }\n  }\n  private static void waitForDeploymentAfterPatch(  String deploymentName,  String namespace,  Map\u003cString,String\u003e podLabels){\n    try {\n      await().pollDelay(Duration.ofSeconds(4)).pollInterval(Duration.ofSeconds(3)).atMost(60,TimeUnit.SECONDS).until(() -\u003e isDeploymentReadyAfterPatch(deploymentName,namespace,podLabels));\n    }\n catch (    Exception e) {\n      if (e instanceof ApiException) {\n        LOG.error(\"Error: \");\n        LOG.error(apiException.getResponseBody());\n      }\n      throw new RuntimeException(e);\n    }\n  }\n  private static boolean isDeploymentReadyAfterPatch(  String deploymentName,  String namespace,  Map\u003cString,String\u003e podLabels) throws ApiException {\n    V1DeploymentList deployments\u003dnew AppsV1Api().listNamespacedDeployment(namespace,null,null,null,\"metadata.name\u003d\" + deploymentName,null,null,null,null,null,null,null);\n    if (deployments.getItems().isEmpty()) {\n      fail(\"No deployment with name \" + deploymentName);\n    }\n    V1Deployment deployment\u003ddeployments.getItems().get(0);\n    int replicas\u003dOptional.ofNullable(deployment.getSpec().getReplicas()).orElse(1);\n    int readyReplicas\u003dOptional.ofNullable(deployment.getStatus().getReadyReplicas()).orElse(0);\n    if (readyReplicas !\u003d replicas) {\n      LOG.info(\"ready replicas not yet same as replicas\");\n      return false;\n    }\n    int pods\u003dnew CoreV1Api().listNamespacedPod(namespace,null,null,null,null,labelSelector(podLabels),null,null,null,null,null,null).getItems().size();\n    if (pods !\u003d replicas) {\n      LOG.info(\"number of pods not yet stabilized\");\n      return false;\n    }\n    return true;\n  }\n  private static \u003cT\u003evoid notExistsHandler(  CheckedSupplier\u003cT\u003e callee,  CheckedSupplier\u003cT\u003e defaulter) throws Exception {\n    try {\n      callee.get();\n    }\n catch (    Exception exception) {\n      if (exception instanceof ApiException) {\n        if (apiException.getCode() \u003d\u003d 404) {\n          defaulter.get();\n          return;\n        }\n      }\n      throw new RuntimeException(exception);\n    }\n  }\n  private static String labelSelector(  Map\u003cString,String\u003e labels){\n    return labels.entrySet().stream().map(en -\u003e en.getKey() + \"\u003d\" + en.getValue()).collect(Collectors.joining(\",\"));\n  }\nprivate interface CheckedSupplier\u003cT\u003e {\n    T get() throws Exception ;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic final class Util {\n  private static final Log LOG\u003dLogFactory.getLog(Util.class);\n  private final CoreV1Api coreV1Api;\n  private final AppsV1Api appsV1Api;\n  private final NetworkingV1Api networkingV1Api;\n  private final RbacAuthorizationV1Api rbacApi;\n  private final K3sContainer container;\n  public Util(  K3sContainer container);\n  /** \n * This is the preferred method to use when creating a deployment alongside with a service. It creates the given resources as-well as waits for them to be created. The delay check is intentionally not taken as an argument, so that it stays as tight as possible, providing reasonable defaults.\n */\n  public void createAndWait(  String namespace,  String name,  V1Deployment deployment,  V1Service service,  @Nullable V1Ingress ingress,  boolean changeVersion);\n  public void createAndWait(  String namespace,  @Nullable V1ConfigMap configMap,  @Nullable V1Secret secret);\n  public void deleteAndWait(  String namespace,  @Nullable V1ConfigMap configMap,  @Nullable V1Secret secret);\n  public void createNamespace(  String name);\n  public void deleteAndWait(  String namespace,  V1Deployment deployment,  V1Service service,  @Nullable V1Ingress ingress);\n  public void busybox(  String namespace,  Phase phase);\n  public void kafka(  String namespace,  Phase phase);\n  public void rabbitMq(  String namespace,  Phase phase);\n  /** \n * reads a yaml from classpath, fails if not found.\n */\n  public Object yaml(  String fileName);\n  public void setUp(  String namespace);\n  public void setUpClusterWideClusterRoleBinding(  String serviceAccountNamespace);\n  public void deleteClusterWideClusterRoleBinding(  String serviceAccountNamespace);\n  public void setUpClusterWide(  String serviceAccountNamespace,  Set\u003cString\u003e namespaces);\n  public void deleteClusterWide(  String serviceAccountNamespace,  Set\u003cString\u003e namespaces);\n  public void deleteNamespace(  String name);\n  public void wiremock(  String namespace,  String path,  Phase phase);\n  public void wiremock(  String namespace,  String path,  Phase phase,  boolean withIngress);\n  public static void patchWithMerge(  String deploymentName,  String namespace,  String patchBody,  Map\u003cString,String\u003e podLabels);\n  public static void patchWithReplace(  String imageName,  String deploymentName,  String namespace,  String patchBody,  Map\u003cString,String\u003e podLabels);\n  private String deploymentName(  V1Deployment deployment);\n  private String serviceName(  V1Service service);\n  private String ingressName(  V1Ingress ingress);\n  private String configMapName(  V1ConfigMap configMap);\n  private String secretName(  V1Secret secret);\n  private void waitForDeployment(  String namespace,  V1Deployment deployment);\n  private void waitForConfigMap(  String namespace,  V1ConfigMap configMap,  Phase phase);\n  private void waitForSecret(  String namespace,  V1Secret secret,  Phase phase);\n  private void waitForIngress(  String namespace,  V1Ingress ingress);\n  private void waitForDeploymentToBeDeleted(  String deploymentName,  String namespace);\n  private void waitForDeploymentPodsToBeDeleted(  Map\u003cString,String\u003e labels,  String namespace);\n  private void waitForIngressToBeDeleted(  String ingressName,  String namespace);\n  private boolean isDeploymentReady(  String deploymentName,  String namespace) throws ApiException;\n  private void logDeploymentConditions(  List\u003cV1DeploymentCondition\u003e conditions);\n  private static void waitForDeploymentAfterPatch(  String deploymentName,  String namespace,  Map\u003cString,String\u003e podLabels);\n  private static boolean isDeploymentReadyAfterPatch(  String deploymentName,  String namespace,  Map\u003cString,String\u003e podLabels) throws ApiException;\n  private static \u003cT\u003evoid notExistsHandler(  CheckedSupplier\u003cT\u003e callee,  CheckedSupplier\u003cT\u003e defaulter) throws Exception;\n  private static String labelSelector(  Map\u003cString,String\u003e labels);\nprivate interface CheckedSupplier\u003cT\u003e {\n    T get() throws Exception ;\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-loadbalancer/src/main/java/org/springframework/cloud/kubernetes/client/loadbalancer/KubernetesClientLoadBalancerAutoConfiguration.java",
        "name": "KubernetesClientLoadBalancerAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @EnableConfigurationProperties(KubernetesLoadBalancerProperties.class) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesLoadBalancerEnabled @LoadBalancerClients(defaultConfiguration\u003dKubernetesClientLoadBalancerClientConfiguration.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.loadbalancer.KubernetesClientLoadBalancerAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @EnableConfigurationProperties(KubernetesLoadBalancerProperties.class) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesLoadBalancerEnabled @LoadBalancerClients(defaultConfiguration\u003dKubernetesClientLoadBalancerClientConfiguration.class) public class KubernetesClientLoadBalancerAutoConfiguration {\n  @Bean KubernetesClientServiceInstanceMapper mapper(  KubernetesLoadBalancerProperties properties,  KubernetesDiscoveryProperties discoveryProperties){\n    return new KubernetesClientServiceInstanceMapper(properties,discoveryProperties);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @EnableConfigurationProperties(KubernetesLoadBalancerProperties.class) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesLoadBalancerEnabled @LoadBalancerClients(defaultConfiguration\u003dKubernetesClientLoadBalancerClientConfiguration.class) public class KubernetesClientLoadBalancerAutoConfiguration {\n  @Bean KubernetesClientServiceInstanceMapper mapper(  KubernetesLoadBalancerProperties properties,  KubernetesDiscoveryProperties discoveryProperties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-loadbalancer/src/main/java/org/springframework/cloud/kubernetes/client/loadbalancer/KubernetesClientServicesListSupplier.java",
        "name": "KubernetesClientServicesListSupplier",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.loadbalancer.KubernetesClientServicesListSupplier",
        "extend": "KubernetesServicesListSupplier\u003cV1Service\u003e",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientServicesListSupplier extends KubernetesServicesListSupplier\u003cV1Service\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientServicesListSupplier.class));\n  private final CoreV1Api coreV1Api;\n  private final KubernetesNamespaceProvider kubernetesNamespaceProvider;\n  public KubernetesClientServicesListSupplier(  Environment environment,  KubernetesServiceInstanceMapper\u003cV1Service\u003e mapper,  KubernetesDiscoveryProperties discoveryProperties,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    super(environment,mapper,discoveryProperties);\n    this.coreV1Api\u003dcoreV1Api;\n    this.kubernetesNamespaceProvider\u003dkubernetesNamespaceProvider;\n  }\n  @Override public Flux\u003cList\u003cServiceInstance\u003e\u003e get(){\n    List\u003cServiceInstance\u003e result\u003dnew ArrayList\u003c\u003e();\n    String serviceName\u003dgetServiceId();\n    LOG.debug(() -\u003e \"serviceID : \" + serviceName);\n    if (discoveryProperties.allNamespaces()) {\n      LOG.debug(() -\u003e \"discovering services in all namespaces\");\n      List\u003cV1Service\u003e services\u003dservices(null,serviceName);\n      services.forEach(service -\u003e addMappedService(mapper,result,service));\n    }\n else     if (!discoveryProperties.namespaces().isEmpty()) {\n      List\u003cString\u003e selectiveNamespaces\u003ddiscoveryProperties.namespaces().stream().sorted().toList();\n      LOG.debug(() -\u003e \"discovering services in selective namespaces : \" + selectiveNamespaces);\n      selectiveNamespaces.forEach(selectiveNamespace -\u003e {\n        List\u003cV1Service\u003e services\u003dservices(selectiveNamespace,serviceName);\n        services.forEach(service -\u003e addMappedService(mapper,result,service));\n      }\n);\n    }\n else {\n      String namespace\u003dgetApplicationNamespace(null,\"loadbalancer-service\",kubernetesNamespaceProvider);\n      LOG.debug(() -\u003e \"discovering services in namespace : \" + namespace);\n      List\u003cV1Service\u003e services\u003dservices(namespace,serviceName);\n      services.forEach(service -\u003e addMappedService(mapper,result,service));\n    }\n    LOG.debug(() -\u003e \"found services : \" + result);\n    return Flux.defer(() -\u003e Flux.just(result));\n  }\n  private void addMappedService(  KubernetesServiceInstanceMapper\u003cV1Service\u003e mapper,  List\u003cServiceInstance\u003e services,  V1Service service){\n    services.add(mapper.map(service));\n  }\n  private List\u003cV1Service\u003e services(  String namespace,  String serviceName){\n    if (namespace \u003d\u003d null) {\n      try {\n        return coreV1Api.listServiceForAllNamespaces(null,null,\"metadata.name\u003d\" + serviceName,null,null,null,null,null,null,null,null).getItems();\n      }\n catch (      ApiException apiException) {\n        LOG.warn(apiException,\"Error retrieving services (in all namespaces) with name \" + serviceName);\n        return List.of();\n      }\n    }\n else {\n      try {\n        return coreV1Api.listNamespacedService(namespace,null,null,null,\"metadata.name\u003d\" + serviceName,null,null,null,null,null,null,null).getItems();\n      }\n catch (      ApiException apiException) {\n        LOG.warn(apiException,\"Error retrieving service with name \" + serviceName + \" in namespace : \"+ namespace);\n        return List.of();\n      }\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientServicesListSupplier extends KubernetesServicesListSupplier\u003cV1Service\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientServicesListSupplier.class));\n  private final CoreV1Api coreV1Api;\n  private final KubernetesNamespaceProvider kubernetesNamespaceProvider;\n  public KubernetesClientServicesListSupplier(  Environment environment,  KubernetesServiceInstanceMapper\u003cV1Service\u003e mapper,  KubernetesDiscoveryProperties discoveryProperties,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n  @Override public Flux\u003cList\u003cServiceInstance\u003e\u003e get();\n  private void addMappedService(  KubernetesServiceInstanceMapper\u003cV1Service\u003e mapper,  List\u003cServiceInstance\u003e services,  V1Service service);\n  private List\u003cV1Service\u003e services(  String namespace,  String serviceName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-loadbalancer/src/main/java/org/springframework/cloud/kubernetes/client/loadbalancer/KubernetesClientLoadBalancerClientConfiguration.java",
        "name": "KubernetesClientLoadBalancerClientConfiguration",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.loadbalancer.KubernetesClientLoadBalancerClientConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientLoadBalancerClientConfiguration {\n  @Bean @ConditionalOnKubernetesLoadBalancerServiceModeEnabled ServiceInstanceListSupplier kubernetesServicesListSupplier(  Environment environment,  CoreV1Api coreV1Api,  KubernetesClientServiceInstanceMapper mapper,  KubernetesDiscoveryProperties discoveryProperties,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurableApplicationContext context){\n    return ServiceInstanceListSupplier.builder().withBase(new KubernetesClientServicesListSupplier(environment,mapper,discoveryProperties,coreV1Api,kubernetesNamespaceProvider)).withCaching().build(context);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientLoadBalancerClientConfiguration {\n  @Bean @ConditionalOnKubernetesLoadBalancerServiceModeEnabled ServiceInstanceListSupplier kubernetesServicesListSupplier(  Environment environment,  CoreV1Api coreV1Api,  KubernetesClientServiceInstanceMapper mapper,  KubernetesDiscoveryProperties discoveryProperties,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurableApplicationContext context);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-loadbalancer/src/main/java/org/springframework/cloud/kubernetes/client/loadbalancer/KubernetesClientServiceInstanceMapper.java",
        "name": "KubernetesClientServiceInstanceMapper",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.loadbalancer.KubernetesClientServiceInstanceMapper",
        "extend": "",
        "implements": "KubernetesServiceInstanceMapper\u003cV1Service\u003e",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientServiceInstanceMapper implements KubernetesServiceInstanceMapper\u003cV1Service\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientServiceInstanceMapper.class));\n  /** \n * empty on purpose, load balancer implementation does not need them.\n */\n  private static final Map\u003cString,Integer\u003e PORTS_DATA\u003dMap.of();\n  private final KubernetesLoadBalancerProperties properties;\n  private final KubernetesDiscoveryProperties discoveryProperties;\n  private final ServicePortSecureResolver resolver;\n  public KubernetesClientServiceInstanceMapper(  KubernetesLoadBalancerProperties properties,  KubernetesDiscoveryProperties discoveryProperties){\n    this.properties\u003dproperties;\n    this.discoveryProperties\u003ddiscoveryProperties;\n    resolver\u003dnew ServicePortSecureResolver(discoveryProperties);\n  }\n  @Override public KubernetesServiceInstance map(  V1Service service){\n    V1ObjectMeta metadata\u003dservice.getMetadata();\n    List\u003cV1ServicePort\u003e ports\u003dofNullable(service.getSpec()).map(V1ServiceSpec::getPorts).orElse(List.of());\n    V1ServicePort port;\n    if (ports.isEmpty()) {\n      LOG.warn(() -\u003e \"service : \" + metadata.getName() + \" does not have any ServicePort(s),\"+ \" will not consider it for load balancing\");\n      return null;\n    }\n    if (ports.size() \u003d\u003d 1) {\n      LOG.debug(() -\u003e \"single ServicePort found, will use it as-is \" + \"(without checking \" + PORT_NAME_PROPERTY + \")\");\n      port\u003dports.get(0);\n    }\n else {\n      String portNameFromProperties\u003dproperties.getPortName();\n      if (StringUtils.hasText(portNameFromProperties)) {\n        Optional\u003cV1ServicePort\u003e optionalPort\u003dports.stream().filter(x -\u003e Objects.equals(x.getName(),portNameFromProperties)).findAny();\n        if (optionalPort.isPresent()) {\n          LOG.debug(() -\u003e \"found port name that matches : \" + portNameFromProperties);\n          port\u003doptionalPort.get();\n        }\n else {\n          logWarning(portNameFromProperties);\n          port\u003dports.get(0);\n        }\n      }\n else {\n        LOG.warn(() -\u003e PORT_NAME_PROPERTY + \" is not set\");\n        LOG.warn(() -\u003e NON_DETERMINISTIC_PORT_MESSAGE);\n        port\u003dports.get(0);\n      }\n    }\n    String host\u003dKubernetesServiceInstanceMapper.createHost(service.getMetadata().getName(),service.getMetadata().getNamespace(),properties.getClusterDomain());\n    boolean secure\u003dsecure(port,service);\n    return new DefaultKubernetesServiceInstance(metadata.getUid(),metadata.getName(),host,port.getPort(),serviceMetadata(service),secure);\n  }\n  private Map\u003cString,String\u003e serviceMetadata(  V1Service service){\n    V1ObjectMeta metadata\u003dservice.getMetadata();\n    V1ServiceSpec serviceSpec\u003dservice.getSpec();\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(metadata.getName(),metadata.getNamespace(),serviceSpec.getType(),metadata.getLabels(),metadata.getAnnotations());\n    return DiscoveryClientUtils.serviceInstanceMetadata(PORTS_DATA,serviceMetadata,discoveryProperties);\n  }\n  private boolean secure(  V1ServicePort port,  V1Service service){\n    V1ObjectMeta metadata\u003dservice.getMetadata();\n    ServicePortNameAndNumber portNameAndNumber\u003dnew ServicePortNameAndNumber(port.getPort(),port.getName());\n    Input input\u003dnew Input(portNameAndNumber,metadata.getName(),metadata.getLabels(),metadata.getAnnotations());\n    return resolver.resolve(input);\n  }\n  private void logWarning(  String portNameFromProperties){\n    LOG.warn(() -\u003e \"Did not find a port name that is equal to the value \" + portNameFromProperties);\n    LOG.warn(() -\u003e NON_DETERMINISTIC_PORT_MESSAGE);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientServiceInstanceMapper implements KubernetesServiceInstanceMapper\u003cV1Service\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientServiceInstanceMapper.class));\n  /** \n * empty on purpose, load balancer implementation does not need them.\n */\n  private static final Map\u003cString,Integer\u003e PORTS_DATA\u003dMap.of();\n  private final KubernetesLoadBalancerProperties properties;\n  private final KubernetesDiscoveryProperties discoveryProperties;\n  private final ServicePortSecureResolver resolver;\n  public KubernetesClientServiceInstanceMapper(  KubernetesLoadBalancerProperties properties,  KubernetesDiscoveryProperties discoveryProperties);\n  @Override public KubernetesServiceInstance map(  V1Service service);\n  private Map\u003cString,String\u003e serviceMetadata(  V1Service service);\n  private boolean secure(  V1ServicePort port,  V1Service service);\n  private void logWarning(  String portNameFromProperties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/client/loadbalancer/it/Util.java",
        "name": "Util",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.loadbalancer.it.Util",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic final class Util {\n  private Util(){\n  }\n  public static V1Service service(  String namespace,  String name,  int port){\n    return new V1ServiceBuilder().withNewMetadata().withNamespace(namespace).withName(name).endMetadata().withSpec(new V1ServiceSpecBuilder().withPorts(new V1ServicePortBuilder().withName(\"http\").withPort(port).build()).build()).build();\n  }\n  public static V1Endpoints endpoints(  String namespace,  String name,  int port,  String host){\n    return new V1EndpointsBuilder().withSubsets(new V1EndpointSubsetBuilder().withPorts(new CoreV1EndpointPortBuilder().withPort(port).build()).withAddresses(new V1EndpointAddressBuilder().withIp(host).build()).build()).withMetadata(new V1ObjectMetaBuilder().withName(name).withNamespace(namespace).build()).build();\n  }\n  public static void servicesPodMode(  WireMockServer server,  V1ServiceList serviceList){\n    server.stubFor(WireMock.get(WireMock.urlPathMatching(\"^/api/v1/services*\")).willReturn(WireMock.aResponse().withBody(new JSON().serialize(serviceList)).withStatus(200)));\n  }\n  public static void servicesServiceMode(  WireMockServer server,  V1ServiceList serviceList,  String serviceName){\n    server.stubFor(WireMock.get(WireMock.urlPathMatching(\"^/api/v1/services*\")).withQueryParam(\"resourceVersion\",WireMock.equalTo(\"0\")).willReturn(WireMock.aResponse().withBody(new JSON().serialize(serviceList)).withStatus(200)));\n    server.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/services?fieldSelector\u003dmetadata.name%3D\" + serviceName)).willReturn(WireMock.aResponse().withBody(new JSON().serialize(serviceList)).withStatus(200)));\n  }\n  public static void endpointsPodMode(  WireMockServer server,  V1EndpointsList endpointsList){\n    server.stubFor(WireMock.get(WireMock.urlPathMatching(\"^/api/v1/endpoints*\")).willReturn(WireMock.aResponse().withBody(new JSON().serialize(endpointsList)).withStatus(200)));\n  }\n  public static void endpointsServiceMode(  WireMockServer server,  V1EndpointsList endpointsList,  String endpointsName){\n    server.stubFor(WireMock.get(WireMock.urlPathMatching(\"^/api/v1/endpoints*\")).withQueryParam(\"resourceVersion\",WireMock.equalTo(\"0\")).willReturn(WireMock.aResponse().withBody(new JSON().serialize(endpointsList)).withStatus(200)));\n    server.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/endpoints?fieldSelector\u003dmetadata.name%3D\" + endpointsName)).willReturn(WireMock.aResponse().withBody(new JSON().serialize(endpointsList)).withStatus(200)));\n  }\n  public static void servicesInNamespacePodMode(  WireMockServer server,  V1ServiceList serviceList,  String namespace){\n    server.stubFor(WireMock.get(WireMock.urlPathMatching(\"^/api/v1/namespaces/\" + namespace + \"/services*\")).willReturn(WireMock.aResponse().withBody(new JSON().serialize(serviceList)).withStatus(200)));\n  }\n  public static void servicesInNamespaceServiceMode(  WireMockServer server,  V1ServiceList serviceList,  String namespace,  String serviceName){\n    server.stubFor(WireMock.get(WireMock.urlPathMatching(\"^/api/v1/namespaces/\" + namespace + \"/services*\")).withQueryParam(\"resourceVersion\",WireMock.equalTo(\"0\")).willReturn(WireMock.aResponse().withBody(new JSON().serialize(serviceList)).withStatus(200)));\n    server.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/\" + namespace + \"/services?fieldSelector\u003dmetadata.name%3D\"+ serviceName)).willReturn(WireMock.aResponse().withBody(new JSON().serialize(serviceList)).withStatus(200)));\n  }\n  public static void endpointsInNamespacePodMode(  WireMockServer server,  V1EndpointsList endpointsList,  String namespace){\n    server.stubFor(WireMock.get(WireMock.urlPathMatching(\"^/api/v1/namespaces/\" + namespace + \"/endpoints*\")).willReturn(WireMock.aResponse().withBody(new JSON().serialize(endpointsList)).withStatus(200)));\n  }\n  public static void endpointsInNamespaceServiceMode(  WireMockServer server,  V1EndpointsList endpointsList,  String namespace,  String endpointsName){\n    server.stubFor(WireMock.get(WireMock.urlPathMatching(\"^/api/v1/namespaces/\" + namespace + \"/endpoints*\")).withQueryParam(\"resourceVersion\",WireMock.equalTo(\"0\")).willReturn(WireMock.aResponse().withBody(new JSON().serialize(endpointsList)).withStatus(200)));\n    server.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/\" + namespace + \"/endpoints?fieldSelector\u003dmetadata.name%3D\"+ endpointsName)).willReturn(WireMock.aResponse().withBody(new JSON().serialize(endpointsList)).withStatus(200)));\n  }\n@TestConfiguration public static class LoadBalancerConfiguration {\n    @Bean @LoadBalanced WebClient.Builder client(){\n      return WebClient.builder();\n    }\n  }\n@SpringBootApplication public static class Configuration {\n    public static void main(    String[] args){\n      SpringApplication.run(Configuration.class);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic final class Util {\n  private Util();\n  public static V1Service service(  String namespace,  String name,  int port);\n  public static V1Endpoints endpoints(  String namespace,  String name,  int port,  String host);\n  public static void servicesPodMode(  WireMockServer server,  V1ServiceList serviceList);\n  public static void servicesServiceMode(  WireMockServer server,  V1ServiceList serviceList,  String serviceName);\n  public static void endpointsPodMode(  WireMockServer server,  V1EndpointsList endpointsList);\n  public static void endpointsServiceMode(  WireMockServer server,  V1EndpointsList endpointsList,  String endpointsName);\n  public static void servicesInNamespacePodMode(  WireMockServer server,  V1ServiceList serviceList,  String namespace);\n  public static void servicesInNamespaceServiceMode(  WireMockServer server,  V1ServiceList serviceList,  String namespace,  String serviceName);\n  public static void endpointsInNamespacePodMode(  WireMockServer server,  V1EndpointsList endpointsList,  String namespace);\n  public static void endpointsInNamespaceServiceMode(  WireMockServer server,  V1EndpointsList endpointsList,  String namespace,  String endpointsName);\n@TestConfiguration public static class LoadBalancerConfiguration {\n    @Bean @LoadBalanced WebClient.Builder client();\n  }\n@SpringBootApplication public static class Configuration {\n    public static void main(    String[] args);\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/client/loadbalancer/it/mode/service/SpecificNamespaceTest.java",
        "name": "SpecificNamespaceTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003da\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.loadbalancer.it.mode.service.SpecificNamespaceTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003da\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class SpecificNamespaceTest {\n  private static final String SERVICE_A_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtils;\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    mockWatchers();\n    serviceAMockServer\u003dnew WireMockServer(SERVICE_A_PORT);\n    serviceAMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_A_PORT);\n    serviceBMockServer\u003dnew WireMockServer(SERVICE_B_PORT);\n    serviceBMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_B_PORT);\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"a\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"b\",\"cluster.local\")).thenReturn(\"localhost\");\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    clientUtils\u003dmockStatic(KubernetesClientUtils.class,Mockito.CALLS_REAL_METHODS);\n    clientUtils.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(client);\n  }\n  @AfterAll static void afterAll(){\n    wireMockServer.stop();\n    serviceAMockServer.stop();\n    serviceBMockServer.stop();\n    MOCKED_STATIC.close();\n    clientUtils.close();\n  }\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - we enable search in namespace \u0027a\u0027 - load balancer mode is \u0027POD\u0027 - as such, only my-service in namespace a is load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the POD mode. \u003c/pre\u003e\n */\n  @Test void test(){\n    serviceAMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-a-reached\").withStatus(200)));\n    serviceBMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-b-reached\").withStatus(200)));\n    String serviceAResult\u003dbuilder.baseUrl(SERVICE_A_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    Assertions.assertThat(serviceAResult).isEqualTo(\"service-a-reached\");\n    CachingServiceInstanceListSupplier supplier\u003d(CachingServiceInstanceListSupplier)loadBalancerClientFactory.getIfAvailable().getProvider(\"my-service\",ServiceInstanceListSupplier.class).getIfAvailable();\n    Assertions.assertThat(supplier.getDelegate().getClass()).isSameAs(KubernetesClientServicesListSupplier.class);\n  }\n  private static void mockWatchers(){\n    V1Service serviceA\u003dUtil.service(\"a\",\"my-service\",SERVICE_A_PORT);\n    V1Service serviceB\u003dUtil.service(\"b\",\"my-service\",SERVICE_B_PORT);\n    V1ServiceList serviceListA\u003dnew V1ServiceListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(serviceA).build();\n    V1ServiceList serviceListB\u003dnew V1ServiceListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(serviceB).build();\n    Util.servicesInNamespaceServiceMode(wireMockServer,serviceListA,\"a\",\"my-service\");\n    Util.servicesInNamespaceServiceMode(wireMockServer,serviceListB,\"b\",\"my-service\");\n    V1Endpoints endpointsA\u003dUtil.endpoints(\"a\",\"my-service\",SERVICE_A_PORT,\"127.0.0.1\");\n    V1Endpoints endpointsB\u003dUtil.endpoints(\"b\",\"my-service\",SERVICE_B_PORT,\"127.0.0.1\");\n    V1EndpointsList endpointsListA\u003dnew V1EndpointsListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(endpointsA).build();\n    V1EndpointsList endpointsListB\u003dnew V1EndpointsListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(endpointsB).build();\n    Util.endpointsInNamespaceServiceMode(wireMockServer,endpointsListA,\"a\",\"my-service\");\n    Util.endpointsInNamespaceServiceMode(wireMockServer,endpointsListB,\"b\",\"my-service\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003da\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class SpecificNamespaceTest {\n  private static final String SERVICE_A_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtils;\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - we enable search in namespace \u0027a\u0027 - load balancer mode is \u0027POD\u0027 - as such, only my-service in namespace a is load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the POD mode. \u003c/pre\u003e\n */\n  @Test void test();\n  private static void mockWatchers();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/client/loadbalancer/it/mode/service/AllNamespacesTest.java",
        "name": "AllNamespacesTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dtrue\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.loadbalancer.it.mode.service.AllNamespacesTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dtrue\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class AllNamespacesTest {\n  private static final String SERVICE_A_URL\u003d\"http://service-a\";\n  private static final String SERVICE_B_URL\u003d\"http://service-b\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtils;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    mockWatchers();\n    serviceAMockServer\u003dnew WireMockServer(SERVICE_A_PORT);\n    serviceAMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_A_PORT);\n    serviceBMockServer\u003dnew WireMockServer(SERVICE_B_PORT);\n    serviceBMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_B_PORT);\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"service-a\",\"a\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"service-b\",\"b\",\"cluster.local\")).thenReturn(\"localhost\");\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    clientUtils\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtils.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(client);\n  }\n  @AfterAll static void afterAll(){\n    wireMockServer.stop();\n    serviceAMockServer.stop();\n    serviceBMockServer.stop();\n    MOCKED_STATIC.close();\n    clientUtils.close();\n  }\n  /** \n * \u003cpre\u003e - service-a is present in namespace a with exposed port 8888 - service-b is present in namespace b with exposed port 8889 - we make two calls to them via the load balancer \u003c/pre\u003e\n */\n  @Test void test(){\n    serviceAMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-a-reached\").withStatus(200)));\n    serviceBMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-b-reached\").withStatus(200)));\n    String serviceAResult\u003dbuilder.baseUrl(SERVICE_A_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    Assertions.assertThat(serviceAResult).isEqualTo(\"service-a-reached\");\n    String serviceBResult\u003dbuilder.baseUrl(SERVICE_B_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    Assertions.assertThat(serviceBResult).isEqualTo(\"service-b-reached\");\n    CachingServiceInstanceListSupplier supplier\u003d(CachingServiceInstanceListSupplier)loadBalancerClientFactory.getIfAvailable().getProvider(\"service-a\",ServiceInstanceListSupplier.class).getIfAvailable();\n    Assertions.assertThat(supplier.getDelegate().getClass()).isSameAs(KubernetesClientServicesListSupplier.class);\n  }\n  private static void mockWatchers(){\n    V1Service serviceA\u003dUtil.service(\"a\",\"service-a\",SERVICE_A_PORT);\n    V1ServiceList serviceListA\u003dnew V1ServiceListBuilder().withKind(\"V1ServiceList\").withMetadata(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(serviceA).build();\n    Util.servicesServiceMode(wireMockServer,serviceListA,\"service-a\");\n    V1Service serviceB\u003dUtil.service(\"b\",\"service-b\",SERVICE_B_PORT);\n    V1ServiceList serviceListB\u003dnew V1ServiceListBuilder().withKind(\"V1ServiceList\").withMetadata(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(serviceB).build();\n    Util.servicesServiceMode(wireMockServer,serviceListB,\"service-b\");\n    V1Endpoints endpointsA\u003dUtil.endpoints(\"a\",\"service-a\",SERVICE_A_PORT,\"127.0.0.1\");\n    V1EndpointsList endpointsListA\u003dnew V1EndpointsListBuilder().withKind(\"V1EndpointsList\").withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(endpointsA).build();\n    Util.endpointsServiceMode(wireMockServer,endpointsListA,\"service-a\");\n    V1Endpoints endpointsB\u003dUtil.endpoints(\"b\",\"service-b\",SERVICE_B_PORT,\"127.0.0.1\");\n    V1EndpointsList endpointsListB\u003dnew V1EndpointsListBuilder().withKind(\"V1EndpointsList\").withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(endpointsB).build();\n    Util.endpointsServiceMode(wireMockServer,endpointsListB,\"service-b\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dtrue\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class AllNamespacesTest {\n  private static final String SERVICE_A_URL\u003d\"http://service-a\";\n  private static final String SERVICE_B_URL\u003d\"http://service-b\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtils;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e - service-a is present in namespace a with exposed port 8888 - service-b is present in namespace b with exposed port 8889 - we make two calls to them via the load balancer \u003c/pre\u003e\n */\n  @Test void test();\n  private static void mockWatchers();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/client/loadbalancer/it/mode/service/SelectiveNamespacesTest.java",
        "name": "SelectiveNamespacesTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces.[0]\u003da\",\"spring.cloud.kubernetes.discovery.namespaces.[1]\u003db\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.loadbalancer.it.mode.service.SelectiveNamespacesTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces.[0]\u003da\",\"spring.cloud.kubernetes.discovery.namespaces.[1]\u003db\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class SelectiveNamespacesTest {\n  private static final String MY_SERVICE_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8887;\n  private static final int SERVICE_B_PORT\u003d8888;\n  private static final int SERVICE_C_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static WireMockServer serviceCMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtils;\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    mockWatchers();\n    serviceAMockServer\u003dnew WireMockServer(SERVICE_A_PORT);\n    serviceAMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_A_PORT);\n    serviceBMockServer\u003dnew WireMockServer(SERVICE_B_PORT);\n    serviceBMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_B_PORT);\n    serviceCMockServer\u003dnew WireMockServer(SERVICE_C_PORT);\n    serviceCMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_C_PORT);\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"a\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"b\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"c\",\"cluster.local\")).thenReturn(\"localhost\");\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    clientUtils\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtils.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(client);\n  }\n  @AfterAll static void afterAll(){\n    wireMockServer.stop();\n    serviceAMockServer.stop();\n    serviceBMockServer.stop();\n    serviceCMockServer.stop();\n    MOCKED_STATIC.close();\n    clientUtils.close();\n  }\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - my-service is present in \u0027c\u0027 namespace - we enable search in selective namespaces [a, b] - load balancer mode is \u0027POD\u0027 - as such, only service in namespace a and b are load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the POD mode. \u003c/pre\u003e\n */\n  @Test void test(){\n    serviceAMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-a-reached\").withStatus(200)));\n    serviceBMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-b-reached\").withStatus(200)));\n    serviceCMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-c-reached\").withStatus(200)));\n    String firstCallResult\u003dbuilder.baseUrl(MY_SERVICE_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    String secondCallResult\u003dbuilder.baseUrl(MY_SERVICE_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    if (firstCallResult.equals(\"service-a-reached\")) {\n      Assertions.assertThat(secondCallResult).isEqualTo(\"service-b-reached\");\n    }\n else {\n      Assertions.assertThat(firstCallResult).isEqualTo(\"service-b-reached\");\n      Assertions.assertThat(secondCallResult).isEqualTo(\"service-a-reached\");\n    }\n    CachingServiceInstanceListSupplier supplier\u003d(CachingServiceInstanceListSupplier)loadBalancerClientFactory.getIfAvailable().getProvider(\"my-service\",ServiceInstanceListSupplier.class).getIfAvailable();\n    Assertions.assertThat(supplier.getDelegate().getClass()).isSameAs(KubernetesClientServicesListSupplier.class);\n  }\n  private static void mockWatchers(){\n    V1Service serviceA\u003dUtil.service(\"a\",\"my-service\",SERVICE_A_PORT);\n    V1Service serviceB\u003dUtil.service(\"b\",\"my-service\",SERVICE_B_PORT);\n    V1Service serviceC\u003dUtil.service(\"c\",\"my-service\",SERVICE_C_PORT);\n    V1ServiceList serviceListA\u003dnew V1ServiceListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(serviceA).build();\n    V1ServiceList serviceListB\u003dnew V1ServiceListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(serviceB).build();\n    V1ServiceList serviceListC\u003dnew V1ServiceListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(serviceC).build();\n    Util.servicesInNamespaceServiceMode(wireMockServer,serviceListA,\"a\",\"my-service\");\n    Util.servicesInNamespaceServiceMode(wireMockServer,serviceListB,\"b\",\"my-service\");\n    Util.servicesInNamespaceServiceMode(wireMockServer,serviceListC,\"c\",\"my-service\");\n    V1Endpoints endpointsA\u003dUtil.endpoints(\"a\",\"my-service\",SERVICE_A_PORT,\"127.0.0.1\");\n    V1Endpoints endpointsB\u003dUtil.endpoints(\"b\",\"my-service\",SERVICE_B_PORT,\"127.0.0.1\");\n    V1Endpoints endpointsC\u003dUtil.endpoints(\"c\",\"my-service\",SERVICE_C_PORT,\"127.0.0.1\");\n    V1EndpointsList endpointsListA\u003dnew V1EndpointsListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(endpointsA).build();\n    V1EndpointsList endpointsListB\u003dnew V1EndpointsListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(endpointsB).build();\n    V1EndpointsList endpointsListC\u003dnew V1EndpointsListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(endpointsC).build();\n    Util.endpointsInNamespaceServiceMode(wireMockServer,endpointsListA,\"a\",\"my-service\");\n    Util.endpointsInNamespaceServiceMode(wireMockServer,endpointsListB,\"b\",\"my-service\");\n    Util.endpointsInNamespaceServiceMode(wireMockServer,endpointsListC,\"c\",\"my-service\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces.[0]\u003da\",\"spring.cloud.kubernetes.discovery.namespaces.[1]\u003db\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class SelectiveNamespacesTest {\n  private static final String MY_SERVICE_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8887;\n  private static final int SERVICE_B_PORT\u003d8888;\n  private static final int SERVICE_C_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static WireMockServer serviceCMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtils;\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - my-service is present in \u0027c\u0027 namespace - we enable search in selective namespaces [a, b] - load balancer mode is \u0027POD\u0027 - as such, only service in namespace a and b are load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the POD mode. \u003c/pre\u003e\n */\n  @Test void test();\n  private static void mockWatchers();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/client/loadbalancer/it/mode/pod/SpecificNamespaceTest.java",
        "name": "SpecificNamespaceTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003da\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.loadbalancer.it.mode.pod.SpecificNamespaceTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003da\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class SpecificNamespaceTest {\n  private static final String SERVICE_A_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtils;\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    mockWatchers();\n    serviceAMockServer\u003dnew WireMockServer(SERVICE_A_PORT);\n    serviceAMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_A_PORT);\n    serviceBMockServer\u003dnew WireMockServer(SERVICE_B_PORT);\n    serviceBMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_B_PORT);\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"a\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"b\",\"cluster.local\")).thenReturn(\"localhost\");\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    clientUtils\u003dmockStatic(KubernetesClientUtils.class,Mockito.CALLS_REAL_METHODS);\n    clientUtils.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(client);\n  }\n  @AfterAll static void afterAll(){\n    wireMockServer.stop();\n    serviceAMockServer.stop();\n    serviceBMockServer.stop();\n    MOCKED_STATIC.close();\n    clientUtils.close();\n  }\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - we enable search in namespace \u0027a\u0027 - load balancer mode is \u0027POD\u0027 - as such, only my-service in namespace a is load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the POD mode. \u003c/pre\u003e\n */\n  @Test void test(){\n    serviceAMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-a-reached\").withStatus(200)));\n    serviceBMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-b-reached\").withStatus(200)));\n    String serviceAResult\u003dbuilder.baseUrl(SERVICE_A_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    Assertions.assertThat(serviceAResult).isEqualTo(\"service-a-reached\");\n    CachingServiceInstanceListSupplier supplier\u003d(CachingServiceInstanceListSupplier)loadBalancerClientFactory.getIfAvailable().getProvider(\"my-service\",ServiceInstanceListSupplier.class).getIfAvailable();\n    Assertions.assertThat(supplier.getDelegate().getClass()).isSameAs(DiscoveryClientServiceInstanceListSupplier.class);\n  }\n  private static void mockWatchers(){\n    V1Service serviceA\u003dUtil.service(\"a\",\"my-service\",SERVICE_A_PORT);\n    V1Service serviceB\u003dUtil.service(\"b\",\"my-service\",SERVICE_B_PORT);\n    V1ServiceList serviceListA\u003dnew V1ServiceListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(serviceA).build();\n    V1ServiceList serviceListB\u003dnew V1ServiceListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(serviceB).build();\n    Util.servicesInNamespacePodMode(wireMockServer,serviceListA,\"a\");\n    Util.servicesInNamespacePodMode(wireMockServer,serviceListB,\"b\");\n    V1Endpoints endpointsA\u003dUtil.endpoints(\"a\",\"my-service\",SERVICE_A_PORT,\"127.0.0.1\");\n    V1Endpoints endpointsB\u003dUtil.endpoints(\"b\",\"my-service\",SERVICE_B_PORT,\"127.0.0.1\");\n    V1EndpointsList endpointsListA\u003dnew V1EndpointsListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(endpointsA).build();\n    V1EndpointsList endpointsListB\u003dnew V1EndpointsListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(endpointsB).build();\n    Util.endpointsInNamespacePodMode(wireMockServer,endpointsListA,\"a\");\n    Util.endpointsInNamespacePodMode(wireMockServer,endpointsListB,\"b\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003da\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class SpecificNamespaceTest {\n  private static final String SERVICE_A_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtils;\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - we enable search in namespace \u0027a\u0027 - load balancer mode is \u0027POD\u0027 - as such, only my-service in namespace a is load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the POD mode. \u003c/pre\u003e\n */\n  @Test void test();\n  private static void mockWatchers();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/client/loadbalancer/it/mode/pod/AllNamespacesTest.java",
        "name": "AllNamespacesTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dtrue\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.loadbalancer.it.mode.pod.AllNamespacesTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dtrue\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class AllNamespacesTest {\n  private static final String SERVICE_A_URL\u003d\"http://service-a\";\n  private static final String SERVICE_B_URL\u003d\"http://service-b\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtils;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    mockWatchers();\n    serviceAMockServer\u003dnew WireMockServer(SERVICE_A_PORT);\n    serviceAMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_A_PORT);\n    serviceBMockServer\u003dnew WireMockServer(SERVICE_B_PORT);\n    serviceBMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_B_PORT);\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"service-a\",\"a\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"service-b\",\"b\",\"cluster.local\")).thenReturn(\"localhost\");\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    clientUtils\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtils.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(client);\n  }\n  @AfterAll static void afterAll(){\n    wireMockServer.stop();\n    serviceAMockServer.stop();\n    serviceBMockServer.stop();\n    MOCKED_STATIC.close();\n    clientUtils.close();\n  }\n  /** \n * \u003cpre\u003e - service-a is present in namespace a with exposed port 8888 - service-b is present in namespace b with exposed port 8889 - we make two calls to them via the load balancer \u003c/pre\u003e\n */\n  @Test void test(){\n    serviceAMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-a-reached\").withStatus(200)));\n    serviceBMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-b-reached\").withStatus(200)));\n    String serviceAResult\u003dbuilder.baseUrl(SERVICE_A_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    Assertions.assertThat(serviceAResult).isEqualTo(\"service-a-reached\");\n    String serviceBResult\u003dbuilder.baseUrl(SERVICE_B_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    Assertions.assertThat(serviceBResult).isEqualTo(\"service-b-reached\");\n    CachingServiceInstanceListSupplier supplier\u003d(CachingServiceInstanceListSupplier)loadBalancerClientFactory.getIfAvailable().getProvider(\"service-a\",ServiceInstanceListSupplier.class).getIfAvailable();\n    Assertions.assertThat(supplier.getDelegate().getClass()).isSameAs(DiscoveryClientServiceInstanceListSupplier.class);\n  }\n  private static void mockWatchers(){\n    V1Service serviceA\u003dUtil.service(\"a\",\"service-a\",SERVICE_A_PORT);\n    V1Service serviceB\u003dUtil.service(\"b\",\"service-b\",SERVICE_B_PORT);\n    V1ServiceList serviceList\u003dnew V1ServiceListBuilder().withKind(\"V1ServiceList\").withMetadata(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(serviceA,serviceB).build();\n    Util.servicesPodMode(wireMockServer,serviceList);\n    V1Endpoints endpointsA\u003dUtil.endpoints(\"a\",\"service-a\",SERVICE_A_PORT,\"127.0.0.1\");\n    V1Endpoints endpointsB\u003dUtil.endpoints(\"b\",\"service-b\",SERVICE_B_PORT,\"127.0.0.1\");\n    V1EndpointsList endpointsList\u003dnew V1EndpointsListBuilder().withKind(\"V1EndpointsList\").withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(endpointsA,endpointsB).build();\n    Util.endpointsPodMode(wireMockServer,endpointsList);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dtrue\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class AllNamespacesTest {\n  private static final String SERVICE_A_URL\u003d\"http://service-a\";\n  private static final String SERVICE_B_URL\u003d\"http://service-b\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtils;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e - service-a is present in namespace a with exposed port 8888 - service-b is present in namespace b with exposed port 8889 - we make two calls to them via the load balancer \u003c/pre\u003e\n */\n  @Test void test();\n  private static void mockWatchers();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/client/loadbalancer/it/mode/pod/SelectiveNamespacesTest.java",
        "name": "SelectiveNamespacesTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces.[0]\u003da\",\"spring.cloud.kubernetes.discovery.namespaces.[1]\u003db\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.loadbalancer.it.mode.pod.SelectiveNamespacesTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces.[0]\u003da\",\"spring.cloud.kubernetes.discovery.namespaces.[1]\u003db\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class SelectiveNamespacesTest {\n  private static final String MY_SERVICE_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8887;\n  private static final int SERVICE_B_PORT\u003d8888;\n  private static final int SERVICE_C_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static WireMockServer serviceCMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtils;\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    mockWatchers();\n    serviceAMockServer\u003dnew WireMockServer(SERVICE_A_PORT);\n    serviceAMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_A_PORT);\n    serviceBMockServer\u003dnew WireMockServer(SERVICE_B_PORT);\n    serviceBMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_B_PORT);\n    serviceCMockServer\u003dnew WireMockServer(SERVICE_C_PORT);\n    serviceCMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_C_PORT);\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"a\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"b\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"c\",\"cluster.local\")).thenReturn(\"localhost\");\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    clientUtils\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtils.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(client);\n  }\n  @AfterAll static void afterAll(){\n    wireMockServer.stop();\n    serviceAMockServer.stop();\n    serviceBMockServer.stop();\n    serviceCMockServer.stop();\n    MOCKED_STATIC.close();\n    clientUtils.close();\n  }\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - my-service is present in \u0027c\u0027 namespace - we enable search in selective namespaces [a, b] - load balancer mode is \u0027POD\u0027 - as such, only service in namespace a and b are load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the POD mode. \u003c/pre\u003e\n */\n  @Test void test(){\n    serviceAMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-a-reached\").withStatus(200)));\n    serviceBMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-b-reached\").withStatus(200)));\n    serviceCMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-c-reached\").withStatus(200)));\n    String firstCallResult\u003dbuilder.baseUrl(MY_SERVICE_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    String secondCallResult\u003dbuilder.baseUrl(MY_SERVICE_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    if (firstCallResult.equals(\"service-a-reached\")) {\n      Assertions.assertThat(secondCallResult).isEqualTo(\"service-b-reached\");\n    }\n else {\n      Assertions.assertThat(firstCallResult).isEqualTo(\"service-b-reached\");\n      Assertions.assertThat(secondCallResult).isEqualTo(\"service-a-reached\");\n    }\n    CachingServiceInstanceListSupplier supplier\u003d(CachingServiceInstanceListSupplier)loadBalancerClientFactory.getIfAvailable().getProvider(\"my-service\",ServiceInstanceListSupplier.class).getIfAvailable();\n    Assertions.assertThat(supplier.getDelegate().getClass()).isSameAs(DiscoveryClientServiceInstanceListSupplier.class);\n  }\n  private static void mockWatchers(){\n    V1Service serviceA\u003dUtil.service(\"a\",\"my-service\",SERVICE_A_PORT);\n    V1Service serviceB\u003dUtil.service(\"b\",\"my-service\",SERVICE_B_PORT);\n    V1Service serviceC\u003dUtil.service(\"c\",\"my-service\",SERVICE_C_PORT);\n    V1ServiceList serviceListA\u003dnew V1ServiceListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(serviceA).build();\n    V1ServiceList serviceListB\u003dnew V1ServiceListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(serviceB).build();\n    V1ServiceList serviceListC\u003dnew V1ServiceListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(serviceC).build();\n    Util.servicesInNamespacePodMode(wireMockServer,serviceListA,\"a\");\n    Util.servicesInNamespacePodMode(wireMockServer,serviceListB,\"b\");\n    Util.servicesInNamespacePodMode(wireMockServer,serviceListC,\"c\");\n    V1Endpoints endpointsA\u003dUtil.endpoints(\"a\",\"my-service\",SERVICE_A_PORT,\"127.0.0.1\");\n    V1Endpoints endpointsB\u003dUtil.endpoints(\"b\",\"my-service\",SERVICE_B_PORT,\"127.0.0.1\");\n    V1Endpoints endpointsC\u003dUtil.endpoints(\"c\",\"my-service\",SERVICE_C_PORT,\"127.0.0.1\");\n    V1EndpointsList endpointsListA\u003dnew V1EndpointsListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(endpointsA).build();\n    V1EndpointsList endpointsListB\u003dnew V1EndpointsListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(endpointsB).build();\n    V1EndpointsList endpointsListC\u003dnew V1EndpointsListBuilder().withNewMetadataLike(new V1ListMetaBuilder().withResourceVersion(\"0\").build()).endMetadata().withItems(endpointsC).build();\n    Util.endpointsInNamespacePodMode(wireMockServer,endpointsListA,\"a\");\n    Util.endpointsInNamespacePodMode(wireMockServer,endpointsListB,\"b\");\n    Util.endpointsInNamespacePodMode(wireMockServer,endpointsListC,\"c\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces.[0]\u003da\",\"spring.cloud.kubernetes.discovery.namespaces.[1]\u003db\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class SelectiveNamespacesTest {\n  private static final String MY_SERVICE_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8887;\n  private static final int SERVICE_B_PORT\u003d8888;\n  private static final int SERVICE_C_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static WireMockServer serviceCMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtils;\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - my-service is present in \u0027c\u0027 namespace - we enable search in selective namespaces [a, b] - load balancer mode is \u0027POD\u0027 - as such, only service in namespace a and b are load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the POD mode. \u003c/pre\u003e\n */\n  @Test void test();\n  private static void mockWatchers();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/client/loadbalancer/KubernetesClientServiceInstanceMapperTests.java",
        "name": "KubernetesClientServiceInstanceMapperTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.loadbalancer.KubernetesClientServiceInstanceMapperTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesClientServiceInstanceMapperTests {\n  @Test void singlePortNonSecure(){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    KubernetesClientServiceInstanceMapper mapper\u003dnew KubernetesClientServiceInstanceMapper(loadBalancerProperties,KubernetesDiscoveryProperties.DEFAULT);\n    Map\u003cString,String\u003e annotations\u003dMap.of(\"org.springframework.cloud\",\"true\");\n    Map\u003cString,String\u003e labels\u003dMap.of(\"beta\",\"true\");\n    List\u003cV1ServicePort\u003e servicePorts\u003dList.of(new V1ServicePortBuilder().withName(\"http\").withPort(80).build());\n    V1Service service\u003dcreateService(\"database\",\"default\",annotations,labels,servicePorts);\n    KubernetesServiceInstance serviceInstance\u003dmapper.map(service);\n    Map\u003cString,String\u003e metadata\u003dMap.of(\"org.springframework.cloud\",\"true\",\"beta\",\"true\",\"k8s_namespace\",\"default\",\"type\",\"V1Service\");\n    DefaultKubernetesServiceInstance result\u003dnew DefaultKubernetesServiceInstance(\"0\",\"database\",\"database.default.svc.cluster.local\",80,metadata,false);\n    assertThat(serviceInstance).isEqualTo(result);\n  }\n  @Test void singlePortSecure(){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    KubernetesClientServiceInstanceMapper mapper\u003dnew KubernetesClientServiceInstanceMapper(loadBalancerProperties,KubernetesDiscoveryProperties.DEFAULT);\n    Map\u003cString,String\u003e annotations\u003dMap.of(\"org.springframework.cloud\",\"true\",\"secured\",\"true\");\n    Map\u003cString,String\u003e labels\u003dMap.of(\"beta\",\"true\");\n    List\u003cV1ServicePort\u003e servicePorts\u003dList.of(new V1ServicePortBuilder().withName(\"http\").withPort(80).build());\n    V1Service service\u003dcreateService(\"database\",\"default\",annotations,labels,servicePorts);\n    KubernetesServiceInstance serviceInstance\u003dmapper.map(service);\n    Map\u003cString,String\u003e metadata\u003dMap.of(\"org.springframework.cloud\",\"true\",\"beta\",\"true\",\"secured\",\"true\",\"k8s_namespace\",\"default\",\"type\",\"V1Service\");\n    DefaultKubernetesServiceInstance result\u003dnew DefaultKubernetesServiceInstance(\"0\",\"database\",\"database.default.svc.cluster.local\",80,metadata,true);\n    assertThat(serviceInstance).isEqualTo(result);\n  }\n  @Test void multiplePortsSecure(){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    loadBalancerProperties.setPortName(\"https\");\n    KubernetesClientServiceInstanceMapper mapper\u003dnew KubernetesClientServiceInstanceMapper(loadBalancerProperties,KubernetesDiscoveryProperties.DEFAULT);\n    Map\u003cString,String\u003e annotations\u003dMap.of(\"org.springframework.cloud\",\"true\");\n    Map\u003cString,String\u003e labels\u003dMap.of(\"beta\",\"true\");\n    List\u003cV1ServicePort\u003e servicePorts\u003dList.of(new V1ServicePortBuilder().withName(\"http\").withPort(80).build(),new V1ServicePortBuilder().withName(\"https\").withPort(443).build());\n    V1Service service\u003dcreateService(\"database\",\"default\",annotations,labels,servicePorts);\n    Map\u003cString,String\u003e metadata\u003dMap.of(\"org.springframework.cloud\",\"true\",\"beta\",\"true\",\"k8s_namespace\",\"default\",\"type\",\"V1Service\");\n    KubernetesServiceInstance serviceInstance\u003dmapper.map(service);\n    DefaultKubernetesServiceInstance result\u003dnew DefaultKubernetesServiceInstance(\"0\",\"database\",\"database.default.svc.cluster.local\",443,metadata,true);\n    assertThat(serviceInstance).isEqualTo(result);\n  }\n  @Test void testEmptyPorts(  CapturedOutput output){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    loadBalancerProperties.setPortName(\"https\");\n    KubernetesClientServiceInstanceMapper mapper\u003dnew KubernetesClientServiceInstanceMapper(loadBalancerProperties,KubernetesDiscoveryProperties.DEFAULT);\n    Map\u003cString,String\u003e annotations\u003dMap.of(\"org.springframework.cloud\",\"true\");\n    Map\u003cString,String\u003e labels\u003dMap.of(\"beta\",\"true\");\n    List\u003cV1ServicePort\u003e servicePorts\u003dList.of();\n    V1Service service\u003dcreateService(\"database\",\"default\",annotations,labels,servicePorts);\n    KubernetesServiceInstance serviceInstance\u003dmapper.map(service);\n    Assertions.assertNull(serviceInstance);\n    Assertions.assertTrue(output.getOut().contains(\"service : database does not have any ServicePort(s), will not consider it for load balancing\"));\n  }\n  @Test void singlePortNameMatchesProperty(  CapturedOutput output){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    loadBalancerProperties.setPortName(\"http\");\n    KubernetesClientServiceInstanceMapper mapper\u003dnew KubernetesClientServiceInstanceMapper(loadBalancerProperties,KubernetesDiscoveryProperties.DEFAULT);\n    Map\u003cString,String\u003e annotations\u003dMap.of(\"org.springframework.cloud\",\"true\");\n    Map\u003cString,String\u003e labels\u003dMap.of(\"beta\",\"true\");\n    List\u003cV1ServicePort\u003e servicePorts\u003dList.of(new V1ServicePortBuilder().withName(\"http\").withPort(80).build());\n    V1Service service\u003dcreateService(\"database\",\"default\",annotations,labels,servicePorts);\n    KubernetesServiceInstance serviceInstance\u003dmapper.map(service);\n    Assertions.assertNotNull(serviceInstance);\n    Assertions.assertTrue(output.getOut().contains(\"single ServicePort found, \" + \"will use it as-is (without checking \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027)\"));\n  }\n  @Test void singlePortNameDoesNotMatchProperty(  CapturedOutput output){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    loadBalancerProperties.setPortName(\"http-api\");\n    KubernetesClientServiceInstanceMapper mapper\u003dnew KubernetesClientServiceInstanceMapper(loadBalancerProperties,KubernetesDiscoveryProperties.DEFAULT);\n    Map\u003cString,String\u003e annotations\u003dMap.of(\"org.springframework.cloud\",\"true\");\n    Map\u003cString,String\u003e labels\u003dMap.of(\"beta\",\"true\");\n    List\u003cV1ServicePort\u003e servicePorts\u003dList.of(new V1ServicePortBuilder().withName(\"http\").withPort(80).build());\n    V1Service service\u003dcreateService(\"database\",\"default\",annotations,labels,servicePorts);\n    KubernetesServiceInstance serviceInstance\u003dmapper.map(service);\n    Assertions.assertNotNull(serviceInstance);\n    Assertions.assertTrue(output.getOut().contains(\"single ServicePort found, \" + \"will use it as-is (without checking \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027)\"));\n  }\n  @Test void multiplePortsNameMatchesProperty(  CapturedOutput output){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    loadBalancerProperties.setPortName(\"http\");\n    KubernetesClientServiceInstanceMapper mapper\u003dnew KubernetesClientServiceInstanceMapper(loadBalancerProperties,KubernetesDiscoveryProperties.DEFAULT);\n    Map\u003cString,String\u003e annotations\u003dMap.of(\"org.springframework.cloud\",\"true\");\n    Map\u003cString,String\u003e labels\u003dMap.of(\"beta\",\"true\");\n    List\u003cV1ServicePort\u003e servicePorts\u003dList.of(new V1ServicePortBuilder().withName(\"http\").withPort(80).build(),new V1ServicePortBuilder().withName(\"https\").withPort(443).build());\n    V1Service service\u003dcreateService(\"database\",\"default\",annotations,labels,servicePorts);\n    KubernetesServiceInstance serviceInstance\u003dmapper.map(service);\n    Assertions.assertNotNull(serviceInstance);\n    Assertions.assertTrue(output.getOut().contains(\"found port name that matches : http\"));\n    Assertions.assertEquals(serviceInstance.getPort(),80);\n  }\n  @Test void multiplePortsNameDoesNotMatchProperty(  CapturedOutput output){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    loadBalancerProperties.setPortName(\"http\");\n    KubernetesClientServiceInstanceMapper mapper\u003dnew KubernetesClientServiceInstanceMapper(loadBalancerProperties,KubernetesDiscoveryProperties.DEFAULT);\n    Map\u003cString,String\u003e annotations\u003dMap.of(\"org.springframework.cloud\",\"true\");\n    Map\u003cString,String\u003e labels\u003dMap.of(\"beta\",\"true\");\n    List\u003cV1ServicePort\u003e servicePorts\u003dList.of(new V1ServicePortBuilder().withName(\"http-api\").withPort(80).build(),new V1ServicePortBuilder().withName(\"https\").withPort(443).build());\n    V1Service service\u003dcreateService(\"database\",\"default\",annotations,labels,servicePorts);\n    KubernetesServiceInstance serviceInstance\u003dmapper.map(service);\n    Assertions.assertNotNull(serviceInstance);\n    Assertions.assertTrue(output.getOut().contains(\"Did not find a port name that is equal to the value http\"));\n    Assertions.assertTrue(output.getOut().contains(\"Will return \u0027first\u0027 port found, which is non-deterministic\"));\n    Assertions.assertTrue(serviceInstance.getPort() \u003d\u003d 80 || serviceInstance.getPort() \u003d\u003d 443);\n  }\n  @Test void multiPortsEmptyPortNameProperty(  CapturedOutput output){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    loadBalancerProperties.setPortName(\"\");\n    KubernetesClientServiceInstanceMapper mapper\u003dnew KubernetesClientServiceInstanceMapper(loadBalancerProperties,KubernetesDiscoveryProperties.DEFAULT);\n    Map\u003cString,String\u003e annotations\u003dMap.of(\"org.springframework.cloud\",\"true\");\n    Map\u003cString,String\u003e labels\u003dMap.of(\"beta\",\"true\");\n    List\u003cV1ServicePort\u003e servicePorts\u003dList.of(new V1ServicePortBuilder().withName(\"http-api\").withPort(80).build(),new V1ServicePortBuilder().withName(\"https\").withPort(443).build());\n    V1Service service\u003dcreateService(\"database\",\"default\",annotations,labels,servicePorts);\n    KubernetesServiceInstance serviceInstance\u003dmapper.map(service);\n    Assertions.assertNotNull(serviceInstance);\n    Assertions.assertTrue(output.getOut().contains(\"\u0027spring.cloud.kubernetes.loadbalancer.portName\u0027 is not set\"));\n    Assertions.assertTrue(output.getOut().contains(\"Will return \u0027first\u0027 port found, which is non-deterministic\"));\n    Assertions.assertTrue(serviceInstance.getPort() \u003d\u003d 80 || serviceInstance.getPort() \u003d\u003d 443);\n  }\n  private V1Service createService(  String name,  String namespace,  Map\u003cString,String\u003e annotations,  Map\u003cString,String\u003e labels,  List\u003cV1ServicePort\u003e servicePorts){\n    return new V1ServiceBuilder().withMetadata(new V1ObjectMetaBuilder().withName(name).withUid(\"0\").withNamespace(namespace).addToAnnotations(annotations).addToLabels(labels).build()).withSpec(new V1ServiceSpecBuilder().addAllToPorts(servicePorts).withType(\"V1Service\").build()).build();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesClientServiceInstanceMapperTests {\n  @Test void singlePortNonSecure();\n  @Test void singlePortSecure();\n  @Test void multiplePortsSecure();\n  @Test void testEmptyPorts(  CapturedOutput output);\n  @Test void singlePortNameMatchesProperty(  CapturedOutput output);\n  @Test void singlePortNameDoesNotMatchProperty(  CapturedOutput output);\n  @Test void multiplePortsNameMatchesProperty(  CapturedOutput output);\n  @Test void multiplePortsNameDoesNotMatchProperty(  CapturedOutput output);\n  @Test void multiPortsEmptyPortNameProperty(  CapturedOutput output);\n  private V1Service createService(  String name,  String namespace,  Map\u003cString,String\u003e annotations,  Map\u003cString,String\u003e labels,  List\u003cV1ServicePort\u003e servicePorts);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/client/loadbalancer/KubernetesClientServicesListSupplierTests.java",
        "name": "KubernetesClientServicesListSupplierTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.loadbalancer.KubernetesClientServicesListSupplierTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesClientServicesListSupplierTests {\n  private static final V1Service SERVICE_A_DEFAULT_NAMESPACE\u003dnew V1ServiceBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"service-a\").withNamespace(\"default\").withUid(\"0\").addToLabels(\"beta\",\"true\").addToAnnotations(\"org.springframework.cloud\",\"true\").build()).withSpec(new V1ServiceSpecBuilder().withType(\"V1Service\").addToPorts(new V1ServicePortBuilder().withPort(80).withName(\"http\").build()).build()).build();\n  private static final V1Service SERVICE_A_TEST_NAMESPACE\u003dnew V1ServiceBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"service-a\").withNamespace(\"test\").withUid(\"1\").build()).withSpec(new V1ServiceSpecBuilder().withType(\"V1Service\").addToPorts(new V1ServicePortBuilder().withPort(80).withName(\"http\").build(),new V1ServicePortBuilder().withPort(443).withName(\"https\").build()).build()).build();\n  private static final V1ServiceList SINGLE_NAMESPACE_SERVICES\u003dnew V1ServiceList().addItemsItem(SERVICE_A_DEFAULT_NAMESPACE);\n  private static final V1ServiceList SERVICE_LIST_ALL_NAMESPACE\u003dnew V1ServiceList().addItemsItem(SERVICE_A_DEFAULT_NAMESPACE).addItemsItem(SERVICE_A_TEST_NAMESPACE);\n  private static final V1ServiceList SERVICE_A_DEFAULT_NAMESPACE_SELECTIVE_NAMESPACES\u003dnew V1ServiceList().addItemsItem(SERVICE_A_DEFAULT_NAMESPACE);\n  private static final V1ServiceList SERVICE_A_TEST_NAMESPACE_SELECTIVE_NAMESPACES\u003dnew V1ServiceList().addItemsItem(SERVICE_A_TEST_NAMESPACE);\n  private static WireMockServer wireMockServer;\n  @BeforeAll static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    Configuration.setDefaultApiClient(client);\n  }\n  @AfterAll static void after(){\n    wireMockServer.stop();\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n  }\n  @Test void singleNamespaceTest(  CapturedOutput output){\n    MockEnvironment env\u003dnew MockEnvironment().withProperty(PROPERTY_NAME,\"service-a\");\n    KubernetesNamespaceProvider kubernetesNamespaceProvider\u003dmock(KubernetesNamespaceProvider.class);\n    when(kubernetesNamespaceProvider.getNamespace()).thenReturn(\"default\");\n    CoreV1Api coreV1Api\u003dnew CoreV1Api();\n    KubernetesClientServiceInstanceMapper mapper\u003dnew KubernetesClientServiceInstanceMapper(new KubernetesLoadBalancerProperties(),KubernetesDiscoveryProperties.DEFAULT);\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e selectiveNamespaces\u003dSet.of();\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,selectiveNamespaces,true,60,false,null,Set.of(443,8443,12345),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesClientServicesListSupplier listSupplier\u003dnew KubernetesClientServicesListSupplier(env,mapper,discoveryProperties,coreV1Api,kubernetesNamespaceProvider);\n    stubFor(get(urlEqualTo(\"/api/v1/namespaces/default/services?fieldSelector\u003dmetadata.name%3Dservice-a\")).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(SINGLE_NAMESPACE_SERVICES))));\n    Flux\u003cList\u003cServiceInstance\u003e\u003e instances\u003dlistSupplier.get();\n    Map\u003cString,String\u003e metadata\u003dMap.of(\"org.springframework.cloud\",\"true\",\"beta\",\"true\",\"k8s_namespace\",\"default\",\"type\",\"V1Service\");\n    DefaultKubernetesServiceInstance serviceA\u003dnew DefaultKubernetesServiceInstance(\"0\",\"service-a\",\"service-a.default.svc.cluster.local\",80,metadata,false);\n    List\u003cServiceInstance\u003e services\u003dnew ArrayList\u003c\u003e();\n    services.add(serviceA);\n    StepVerifier.create(instances).expectNext(services).verifyComplete();\n    Assertions.assertTrue(output.getOut().contains(\"serviceID : service-a\"));\n    Assertions.assertTrue(output.getOut().contains(\"discovering services in namespace : default\"));\n  }\n  @Test void singleNamespaceNoServicePresentTest(  CapturedOutput output){\n    MockEnvironment env\u003dnew MockEnvironment().withProperty(PROPERTY_NAME,\"service-a\");\n    KubernetesNamespaceProvider kubernetesNamespaceProvider\u003dmock(KubernetesNamespaceProvider.class);\n    when(kubernetesNamespaceProvider.getNamespace()).thenReturn(\"default\");\n    CoreV1Api coreV1Api\u003dnew CoreV1Api();\n    KubernetesClientServiceInstanceMapper mapper\u003dnew KubernetesClientServiceInstanceMapper(new KubernetesLoadBalancerProperties(),KubernetesDiscoveryProperties.DEFAULT);\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e selectiveNamespaces\u003dSet.of();\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,selectiveNamespaces,true,60,false,null,Set.of(443,8443,12345),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    KubernetesClientServicesListSupplier listSupplier\u003dnew KubernetesClientServicesListSupplier(env,mapper,discoveryProperties,coreV1Api,kubernetesNamespaceProvider);\n    stubFor(get(urlEqualTo(\"/api/v1/namespaces/default/services?fieldSelector\u003dmetadata.name%3Dservice-a\")).willReturn(aResponse().withStatus(404)));\n    Flux\u003cList\u003cServiceInstance\u003e\u003e instances\u003dlistSupplier.get();\n    List\u003cServiceInstance\u003e services\u003dList.of();\n    StepVerifier.create(instances).expectNext(services).verifyComplete();\n    Assertions.assertTrue(output.getOut().contains(\"serviceID : service-a\"));\n    Assertions.assertTrue(output.getOut().contains(\"discovering services in namespace : default\"));\n    Assertions.assertTrue(output.getOut().contains(\"Error retrieving service with name service-a\"));\n  }\n  @Test void allNamespacesTest(  CapturedOutput output){\n    MockEnvironment env\u003dnew MockEnvironment().withProperty(PROPERTY_NAME,\"service-a\");\n    KubernetesNamespaceProvider kubernetesNamespaceProvider\u003dmock(KubernetesNamespaceProvider.class);\n    when(kubernetesNamespaceProvider.getNamespace()).thenReturn(\"default\");\n    boolean allNamespaces\u003dtrue;\n    Set\u003cString\u003e selectiveNamespaces\u003dSet.of();\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,selectiveNamespaces,true,60,false,null,Set.of(443,8443,12345),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    CoreV1Api coreV1Api\u003dnew CoreV1Api();\n    KubernetesClientServiceInstanceMapper mapper\u003dnew KubernetesClientServiceInstanceMapper(new KubernetesLoadBalancerProperties(),discoveryProperties);\n    KubernetesClientServicesListSupplier listSupplier\u003dnew KubernetesClientServicesListSupplier(env,mapper,discoveryProperties,coreV1Api,kubernetesNamespaceProvider);\n    stubFor(get(urlEqualTo(\"/api/v1/services?fieldSelector\u003dmetadata.name%3Dservice-a\")).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(SERVICE_LIST_ALL_NAMESPACE))));\n    Flux\u003cList\u003cServiceInstance\u003e\u003e instances\u003dlistSupplier.get();\n    Map\u003cString,String\u003e metadata\u003dMap.of(\"org.springframework.cloud\",\"true\",\"beta\",\"true\",\"k8s_namespace\",\"default\",\"type\",\"V1Service\");\n    DefaultKubernetesServiceInstance serviceADefaultNamespace\u003dnew DefaultKubernetesServiceInstance(\"0\",\"service-a\",\"service-a.default.svc.cluster.local\",80,metadata,false);\n    DefaultKubernetesServiceInstance serviceATestNamespace\u003dnew DefaultKubernetesServiceInstance(\"1\",\"service-a\",\"service-a.test.svc.cluster.local\",80,Map.of(\"k8s_namespace\",\"test\",\"type\",\"V1Service\"),false);\n    List\u003cServiceInstance\u003e services\u003dnew ArrayList\u003c\u003e();\n    services.add(serviceADefaultNamespace);\n    services.add(serviceATestNamespace);\n    StepVerifier.create(instances).expectNext(services).verifyComplete();\n    Assertions.assertTrue(output.getOut().contains(\"discovering services in all namespaces\"));\n  }\n  @Test void selectiveNamespacesTest(  CapturedOutput output){\n    MockEnvironment env\u003dnew MockEnvironment().withProperty(PROPERTY_NAME,\"service-a\");\n    KubernetesNamespaceProvider kubernetesNamespaceProvider\u003dmock(KubernetesNamespaceProvider.class);\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e selectiveNamespaces\u003dSet.of(\"default\",\"test\",\"no-service\");\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,selectiveNamespaces,true,60,false,null,Set.of(443,8443,12345),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    CoreV1Api coreV1Api\u003dnew CoreV1Api();\n    KubernetesClientServiceInstanceMapper mapper\u003dnew KubernetesClientServiceInstanceMapper(new KubernetesLoadBalancerProperties(),discoveryProperties);\n    KubernetesClientServicesListSupplier listSupplier\u003dnew KubernetesClientServicesListSupplier(env,mapper,discoveryProperties,coreV1Api,kubernetesNamespaceProvider);\n    stubFor(get(urlEqualTo(\"/api/v1/namespaces/default/services?fieldSelector\u003dmetadata.name%3Dservice-a\")).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(SERVICE_A_DEFAULT_NAMESPACE_SELECTIVE_NAMESPACES))));\n    stubFor(get(urlEqualTo(\"/api/v1/namespaces/test/services?fieldSelector\u003dmetadata.name%3Dservice-a\")).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(SERVICE_A_TEST_NAMESPACE_SELECTIVE_NAMESPACES))));\n    stubFor(get(urlEqualTo(\"/api/v1/namespaces/no-service/services?fieldSelector\u003dmetadata.name%3Dservice-a\")).willReturn(aResponse().withStatus(404)));\n    Flux\u003cList\u003cServiceInstance\u003e\u003e instances\u003dlistSupplier.get();\n    Map\u003cString,String\u003e metadata\u003dMap.of(\"org.springframework.cloud\",\"true\",\"beta\",\"true\",\"k8s_namespace\",\"default\",\"type\",\"V1Service\");\n    DefaultKubernetesServiceInstance serviceADefaultNamespace\u003dnew DefaultKubernetesServiceInstance(\"0\",\"service-a\",\"service-a.default.svc.cluster.local\",80,metadata,false);\n    DefaultKubernetesServiceInstance serviceATestNamespace\u003dnew DefaultKubernetesServiceInstance(\"1\",\"service-a\",\"service-a.test.svc.cluster.local\",80,Map.of(\"k8s_namespace\",\"test\",\"type\",\"V1Service\"),false);\n    List\u003cServiceInstance\u003e services\u003dnew ArrayList\u003c\u003e();\n    services.add(serviceADefaultNamespace);\n    services.add(serviceATestNamespace);\n    StepVerifier.create(instances).expectNext(services).verifyComplete();\n    Assertions.assertTrue(output.getOut().contains(\"Error retrieving service with name service-a in namespace : no-service\"));\n    Assertions.assertTrue(output.getOut().contains(\"discovering services in selective namespaces : [default, no-service, test]\"));\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesClientServicesListSupplierTests {\n  private static final V1Service SERVICE_A_DEFAULT_NAMESPACE\u003dnew V1ServiceBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"service-a\").withNamespace(\"default\").withUid(\"0\").addToLabels(\"beta\",\"true\").addToAnnotations(\"org.springframework.cloud\",\"true\").build()).withSpec(new V1ServiceSpecBuilder().withType(\"V1Service\").addToPorts(new V1ServicePortBuilder().withPort(80).withName(\"http\").build()).build()).build();\n  private static final V1Service SERVICE_A_TEST_NAMESPACE\u003dnew V1ServiceBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"service-a\").withNamespace(\"test\").withUid(\"1\").build()).withSpec(new V1ServiceSpecBuilder().withType(\"V1Service\").addToPorts(new V1ServicePortBuilder().withPort(80).withName(\"http\").build(),new V1ServicePortBuilder().withPort(443).withName(\"https\").build()).build()).build();\n  private static final V1ServiceList SINGLE_NAMESPACE_SERVICES\u003dnew V1ServiceList().addItemsItem(SERVICE_A_DEFAULT_NAMESPACE);\n  private static final V1ServiceList SERVICE_LIST_ALL_NAMESPACE\u003dnew V1ServiceList().addItemsItem(SERVICE_A_DEFAULT_NAMESPACE).addItemsItem(SERVICE_A_TEST_NAMESPACE);\n  private static final V1ServiceList SERVICE_A_DEFAULT_NAMESPACE_SELECTIVE_NAMESPACES\u003dnew V1ServiceList().addItemsItem(SERVICE_A_DEFAULT_NAMESPACE);\n  private static final V1ServiceList SERVICE_A_TEST_NAMESPACE_SELECTIVE_NAMESPACES\u003dnew V1ServiceList().addItemsItem(SERVICE_A_TEST_NAMESPACE);\n  private static WireMockServer wireMockServer;\n  @BeforeAll static void setup();\n  @AfterAll static void after();\n  @AfterEach void afterEach();\n  @Test void singleNamespaceTest(  CapturedOutput output);\n  @Test void singleNamespaceNoServicePresentTest(  CapturedOutput output);\n  @Test void allNamespacesTest(  CapturedOutput output);\n  @Test void selectiveNamespacesTest(  CapturedOutput output);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/main/java/org/springframework/cloud/kubernetes/configserver/KubernetesPropertySourceSupplier.java",
        "name": "KubernetesPropertySourceSupplier",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.KubernetesPropertySourceSupplier",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic interface KubernetesPropertySourceSupplier {\n  List\u003cMapPropertySource\u003e get(  CoreV1Api coreV1Api,  String name,  String namespace,  Environment environment);\n  static List\u003cString\u003e namespaceSplitter(  String namespacesString,  String currentNamespace){\n    List\u003cString\u003e namespaces\u003dList.of(currentNamespace);\n    String[] namespacesArray\u003dStringUtils.commaDelimitedListToStringArray(namespacesString);\n    if (namespacesArray.length \u003e 0) {\n      namespaces\u003dList.of(namespacesArray);\n    }\n    return namespaces;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic interface KubernetesPropertySourceSupplier {\n  List\u003cMapPropertySource\u003e get(  CoreV1Api coreV1Api,  String name,  String namespace,  Environment environment);\n  static List\u003cString\u003e namespaceSplitter(  String namespacesString,  String currentNamespace);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/main/java/org/springframework/cloud/kubernetes/configserver/KubernetesEnvironmentRepository.java",
        "name": "KubernetesEnvironmentRepository",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.KubernetesEnvironmentRepository",
        "extend": "",
        "implements": "EnvironmentRepository",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesEnvironmentRepository implements EnvironmentRepository {\n  private static final Log LOG\u003dLogFactory.getLog(KubernetesEnvironmentRepository.class);\n  private final CoreV1Api coreApi;\n  private final List\u003cKubernetesPropertySourceSupplier\u003e kubernetesPropertySourceSuppliers;\n  private final String namespace;\n  public KubernetesEnvironmentRepository(  CoreV1Api coreApi,  List\u003cKubernetesPropertySourceSupplier\u003e kubernetesPropertySourceSuppliers,  String namespace){\n    this.coreApi\u003dcoreApi;\n    this.kubernetesPropertySourceSuppliers\u003dkubernetesPropertySourceSuppliers;\n    this.namespace\u003dnamespace;\n  }\n  @Override public Environment findOne(  String application,  String profile,  String label){\n    return findOne(application,profile,label,true);\n  }\n  @Override public Environment findOne(  String application,  String profile,  String label,  boolean includeOrigin){\n    if (!StringUtils.hasText(profile)) {\n      profile\u003d\"default\";\n    }\n    List\u003cString\u003e profiles\u003dnew ArrayList\u003c\u003e(List.of(StringUtils.commaDelimitedListToStringArray(profile)));\n    Collections.reverse(profiles);\n    if (!profiles.contains(\"default\")) {\n      profiles.add(\"default\");\n    }\n    Environment environment\u003dnew Environment(application,profiles.toArray(profiles.toArray(new String[0])),label,null,null);\n    LOG.info(\"Profiles: \" + profile);\n    LOG.info(\"Application: \" + application);\n    LOG.info(\"Label: \" + label);\n    for (    String activeProfile : profiles) {\n      try {\n        StandardEnvironment springEnv\u003dnew KubernetesConfigServerEnvironment(createPropertySources(application));\n        springEnv.setActiveProfiles(activeProfile);\n        if (!\"application\".equalsIgnoreCase(application)) {\n          addApplicationConfiguration(environment,springEnv,application);\n        }\n      }\n catch (      Exception e) {\n        LOG.warn(e);\n      }\n    }\n    StandardEnvironment springEnv\u003dnew KubernetesConfigServerEnvironment(createPropertySources(\"application\"));\n    addApplicationConfiguration(environment,springEnv,\"application\");\n    return environment;\n  }\n  private MutablePropertySources createPropertySources(  String application){\n    Map\u003cString,Object\u003e applicationProperties\u003dMap.of(\"spring.application.name\",application);\n    MapPropertySource propertySource\u003dnew MapPropertySource(\"kubernetes-config-server\",applicationProperties);\n    MutablePropertySources mutablePropertySources\u003dnew MutablePropertySources();\n    mutablePropertySources.addFirst(propertySource);\n    return mutablePropertySources;\n  }\n  private void addApplicationConfiguration(  Environment environment,  StandardEnvironment springEnv,  String applicationName){\n    kubernetesPropertySourceSuppliers.forEach(supplier -\u003e {\n      List\u003cMapPropertySource\u003e propertySources\u003dsupplier.get(coreApi,applicationName,namespace,springEnv);\n      propertySources.forEach(propertySource -\u003e {\n        if (propertySource.getPropertyNames().length \u003e 0) {\n          LOG.debug(\"Adding PropertySource \" + propertySource.getName());\n          LOG.debug(\"PropertySource Names: \" + StringUtils.arrayToCommaDelimitedString(propertySource.getPropertyNames()));\n          environment.add(new PropertySource(propertySource.getName(),propertySource.getSource()));\n        }\n      }\n);\n    }\n);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesEnvironmentRepository implements EnvironmentRepository {\n  private static final Log LOG\u003dLogFactory.getLog(KubernetesEnvironmentRepository.class);\n  private final CoreV1Api coreApi;\n  private final List\u003cKubernetesPropertySourceSupplier\u003e kubernetesPropertySourceSuppliers;\n  private final String namespace;\n  public KubernetesEnvironmentRepository(  CoreV1Api coreApi,  List\u003cKubernetesPropertySourceSupplier\u003e kubernetesPropertySourceSuppliers,  String namespace);\n  @Override public Environment findOne(  String application,  String profile,  String label);\n  @Override public Environment findOne(  String application,  String profile,  String label,  boolean includeOrigin);\n  private MutablePropertySources createPropertySources(  String application);\n  private void addApplicationConfiguration(  Environment environment,  StandardEnvironment springEnv,  String applicationName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/main/java/org/springframework/cloud/kubernetes/configserver/KubernetesConfigServerEnvironment.java",
        "name": "KubernetesConfigServerEnvironment",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.KubernetesConfigServerEnvironment",
        "extend": "StandardEnvironment",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesConfigServerEnvironment extends StandardEnvironment {\n  KubernetesConfigServerEnvironment(  MutablePropertySources mutablePropertySources){\n    super(mutablePropertySources);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesConfigServerEnvironment extends StandardEnvironment {\n  KubernetesConfigServerEnvironment(  MutablePropertySources mutablePropertySources);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/main/java/org/springframework/cloud/kubernetes/configserver/KubernetesConfigServerProperties.java",
        "name": "KubernetesConfigServerProperties",
        "modifiers": "@ConfigurationProperties(\"spring.cloud.kubernetes.configserver\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.KubernetesConfigServerProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@ConfigurationProperties(\"spring.cloud.kubernetes.configserver\") public class KubernetesConfigServerProperties {\n  private String configMapNamespaces\u003d\"\";\n  private String secretsNamespaces\u003d\"\";\n  public String getConfigMapNamespaces(){\n    return configMapNamespaces;\n  }\n  public void setConfigMapNamespaces(  String configMapNamespaces){\n    this.configMapNamespaces\u003dconfigMapNamespaces;\n  }\n  public String getSecretsNamespaces(){\n    return secretsNamespaces;\n  }\n  public void setSecretsNamespaces(  String secretsNamespaces){\n    this.secretsNamespaces\u003dsecretsNamespaces;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@ConfigurationProperties(\"spring.cloud.kubernetes.configserver\") public class KubernetesConfigServerProperties {\n  private String configMapNamespaces\u003d\"\";\n  private String secretsNamespaces\u003d\"\";\n  public String getConfigMapNamespaces();\n  public void setConfigMapNamespaces(  String configMapNamespaces);\n  public String getSecretsNamespaces();\n  public void setSecretsNamespaces(  String secretsNamespaces);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/main/java/org/springframework/cloud/kubernetes/configserver/KubernetesConfigServerApplication.java",
        "name": "KubernetesConfigServerApplication",
        "modifiers": "@SpringBootApplication @EnableConfigServer public",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.KubernetesConfigServerApplication",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootApplication @EnableConfigServer public class KubernetesConfigServerApplication {\n  public static void main(  String[] args){\n    new SpringApplicationBuilder(ConfigServerApplication.class).run(args);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootApplication @EnableConfigServer public class KubernetesConfigServerApplication {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/main/java/org/springframework/cloud/kubernetes/configserver/KubernetesConfigServerAutoConfiguration.java",
        "name": "KubernetesConfigServerAutoConfiguration",
        "modifiers": "@Configuration @AutoConfigureAfter({KubernetesClientAutoConfiguration.class}) @AutoConfigureBefore({ConfigServerAutoConfiguration.class}) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @EnableConfigurationProperties(KubernetesConfigServerProperties.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.KubernetesConfigServerAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Configuration @AutoConfigureAfter({KubernetesClientAutoConfiguration.class}) @AutoConfigureBefore({ConfigServerAutoConfiguration.class}) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @EnableConfigurationProperties(KubernetesConfigServerProperties.class) public class KubernetesConfigServerAutoConfiguration {\n  @Bean @Profile(\"kubernetes\") public EnvironmentRepository kubernetesEnvironmentRepository(  CoreV1Api coreV1Api,  List\u003cKubernetesPropertySourceSupplier\u003e kubernetesPropertySourceSuppliers,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    return new KubernetesEnvironmentRepository(coreV1Api,kubernetesPropertySourceSuppliers,kubernetesNamespaceProvider.getNamespace());\n  }\n  @Bean @ConditionalOnKubernetesConfigEnabled @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.config.enableApi\",matchIfMissing\u003dtrue) public KubernetesPropertySourceSupplier configMapPropertySourceSupplier(  KubernetesConfigServerProperties properties){\n    return (coreApi,applicationName,namespace,springEnv) -\u003e {\n      List\u003cString\u003e namespaces\u003dnamespaceSplitter(properties.getConfigMapNamespaces(),namespace);\n      List\u003cMapPropertySource\u003e propertySources\u003dnew ArrayList\u003c\u003e();\n      namespaces.forEach(space -\u003e {\n        NamedConfigMapNormalizedSource source\u003dnew NamedConfigMapNormalizedSource(applicationName,space,false,ConfigUtils.Prefix.DEFAULT,true,true);\n        KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(coreApi,source,space,springEnv,false);\n        propertySources.add(new KubernetesClientConfigMapPropertySource(context));\n      }\n);\n      return propertySources;\n    }\n;\n  }\n  @Bean @ConditionalOnKubernetesSecretsEnabled @ConditionalOnProperty(\"spring.cloud.kubernetes.secrets.enableApi\") public KubernetesPropertySourceSupplier secretsPropertySourceSupplier(  KubernetesConfigServerProperties properties){\n    return (coreApi,applicationName,namespace,springEnv) -\u003e {\n      List\u003cString\u003e namespaces\u003dnamespaceSplitter(properties.getSecretsNamespaces(),namespace);\n      List\u003cMapPropertySource\u003e propertySources\u003dnew ArrayList\u003c\u003e();\n      namespaces.forEach(space -\u003e {\n        NormalizedSource source\u003dnew NamedSecretNormalizedSource(applicationName,space,false,ConfigUtils.Prefix.DEFAULT,true,true);\n        KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(coreApi,source,space,springEnv,false);\n        propertySources.add(new KubernetesClientSecretsPropertySource(context));\n      }\n);\n      return propertySources;\n    }\n;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Configuration @AutoConfigureAfter({KubernetesClientAutoConfiguration.class}) @AutoConfigureBefore({ConfigServerAutoConfiguration.class}) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @EnableConfigurationProperties(KubernetesConfigServerProperties.class) public class KubernetesConfigServerAutoConfiguration {\n  @Bean @Profile(\"kubernetes\") public EnvironmentRepository kubernetesEnvironmentRepository(  CoreV1Api coreV1Api,  List\u003cKubernetesPropertySourceSupplier\u003e kubernetesPropertySourceSuppliers,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n  @Bean @ConditionalOnKubernetesConfigEnabled @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.config.enableApi\",matchIfMissing\u003dtrue) public KubernetesPropertySourceSupplier configMapPropertySourceSupplier(  KubernetesConfigServerProperties properties);\n  @Bean @ConditionalOnKubernetesSecretsEnabled @ConditionalOnProperty(\"spring.cloud.kubernetes.secrets.enableApi\") public KubernetesPropertySourceSupplier secretsPropertySourceSupplier(  KubernetesConfigServerProperties properties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/it/ConfigServerIntegrationTest.java",
        "name": "ConfigServerIntegrationTest",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.it.ConfigServerIntegrationTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nabstract class ConfigServerIntegrationTest {\n  @Autowired private TestRestTemplate testRestTemplate;\n  @Autowired WireMockServer wireMockServer;\n  @BeforeEach void beforeEach(){\n    V1ConfigMapList TEST_CONFIGMAP\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"test-cm\").withNamespace(\"default\").withResourceVersion(\"1\").build()).addToData(\"test-cm-dev.yaml\",\"dummy:\\n  property:\\n    string2: \\\"dev\\\"\\n    int2: 1\\n    bool2: false\\n\").addToData(\"test-cm-qa.yaml\",\"dummy:\\n  property:\\n    string2: \\\"qa\\\"\\n    int2: 2\\n    bool2: true\\n\").addToData(\"test-cm-prod.yaml\",\"dummy:\\n  property:\\n    string2: \\\"prod\\\"\\n    int2: 3\\n    bool2: true\\n\").addToData(\"test-cm.yaml\",\"dummy:\\n  property:\\n    string2: \\\"default\\\"\\n    int2: 4\\n    bool2: true\\n\").addToData(\"app.name\",\"test\").build());\n    V1SecretList TEST_SECRET\u003dnew V1SecretListBuilder().withMetadata(new V1ListMetaBuilder().withResourceVersion(\"1\").build()).addToItems(new V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"test-cm\").withResourceVersion(\"0\").withNamespace(\"default\").build()).addToData(\"password\",\"p455w0rd\".getBytes()).addToData(\"username\",\"user\".getBytes()).build()).build();\n    WireMock.stubFor(get(urlMatching(\"^/api/v1/namespaces/default/configmaps.*\")).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(TEST_CONFIGMAP))));\n    WireMock.stubFor(get(urlMatching(\"^/api/v1/namespaces/default/secrets.*\")).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(TEST_SECRET))));\n  }\n  @Test void enabled(){\n    Environment env\u003dtestRestTemplate.getForObject(\"/test-cm/default\",Environment.class);\n    assertThat(env.getPropertySources().size()).isEqualTo(2);\n    assertThat(env.getPropertySources().get(0).getName().equals(\"configmap.test-cm.default.default\")).isTrue();\n    assertThat(env.getPropertySources().get(0).getSource().get(\"app.name\")).isEqualTo(\"test\");\n    assertThat(env.getPropertySources().get(1).getName().equals(\"secret.test-cm.default.default\")).isTrue();\n    assertThat(env.getPropertySources().get(1).getSource().get(\"password\")).isEqualTo(\"p455w0rd\");\n    assertThat(env.getPropertySources().get(1).getSource().get(\"username\")).isEqualTo(\"user\");\n    Environment devprod\u003dtestRestTemplate.getForObject(\"/test-cm/dev,prod\",Environment.class);\n    assertThat(devprod.getPropertySources().size()).isEqualTo(4);\n    assertThat(devprod.getPropertySources().get(0).getName().equals(\"configmap.test-cm.default.prod\")).isTrue();\n    assertThat(devprod.getPropertySources().get(0).getSource().size()).isEqualTo(3);\n    assertThat(devprod.getPropertySources().get(0).getSource().get(\"dummy.property.int2\")).isEqualTo(3);\n    assertThat(devprod.getPropertySources().get(0).getSource().get(\"dummy.property.bool2\")).isEqualTo(true);\n    assertThat(devprod.getPropertySources().get(0).getSource().get(\"dummy.property.string2\")).isEqualTo(\"prod\");\n    assertThat(devprod.getPropertySources().get(1).getName().equals(\"configmap.test-cm.default.dev\")).isTrue();\n    assertThat(devprod.getPropertySources().get(1).getSource().size()).isEqualTo(3);\n    assertThat(devprod.getPropertySources().get(1).getSource().get(\"dummy.property.int2\")).isEqualTo(1);\n    assertThat(devprod.getPropertySources().get(1).getSource().get(\"dummy.property.bool2\")).isEqualTo(false);\n    assertThat(devprod.getPropertySources().get(1).getSource().get(\"dummy.property.string2\")).isEqualTo(\"dev\");\n    assertThat(devprod.getPropertySources().get(2).getName().equals(\"configmap.test-cm.default.default\")).isTrue();\n    assertThat(devprod.getPropertySources().get(2).getSource().size()).isEqualTo(4);\n    assertThat(devprod.getPropertySources().get(2).getSource().get(\"app.name\")).isEqualTo(\"test\");\n    assertThat(devprod.getPropertySources().get(2).getSource().get(\"dummy.property.int2\")).isEqualTo(4);\n    assertThat(devprod.getPropertySources().get(2).getSource().get(\"dummy.property.bool2\")).isEqualTo(true);\n    assertThat(devprod.getPropertySources().get(2).getSource().get(\"dummy.property.string2\")).isEqualTo(\"default\");\n    assertThat(devprod.getPropertySources().get(3).getName().equals(\"secret.test-cm.default.default\")).isTrue();\n    assertThat(devprod.getPropertySources().get(3).getSource().size()).isEqualTo(2);\n    assertThat(devprod.getPropertySources().get(3).getSource().get(\"password\")).isEqualTo(\"p455w0rd\");\n    assertThat(devprod.getPropertySources().get(3).getSource().get(\"username\")).isEqualTo(\"user\");\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nabstract class ConfigServerIntegrationTest {\n  @Autowired private TestRestTemplate testRestTemplate;\n  @Autowired WireMockServer wireMockServer;\n  @BeforeEach void beforeEach();\n  @Test void enabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/it/BootstrapConfigServerIntegrationTest.java",
        "name": "BootstrapConfigServerIntegrationTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003d{KubernetesConfigServerApplication.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.it.BootstrapConfigServerIntegrationTest",
        "extend": "ConfigServerIntegrationTest",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003d{KubernetesConfigServerApplication.class}) class BootstrapConfigServerIntegrationTest extends ConfigServerIntegrationTest {\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003d{KubernetesConfigServerApplication.class}) class BootstrapConfigServerIntegrationTest extends ConfigServerIntegrationTest {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/it/ConfigDataConfigServerIntegrationTest.java",
        "name": "ConfigDataConfigServerIntegrationTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\"},classes\u003d{KubernetesConfigServerApplication.class,TestBootstrapConfig.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.it.ConfigDataConfigServerIntegrationTest",
        "extend": "ConfigServerIntegrationTest",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\"},classes\u003d{KubernetesConfigServerApplication.class,TestBootstrapConfig.class}) class ConfigDataConfigServerIntegrationTest extends ConfigServerIntegrationTest {\n  private MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeEach void setup(){\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build());\n  }\n  @AfterEach void teardown(){\n    clientUtilsMock.close();\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\"},classes\u003d{KubernetesConfigServerApplication.class,TestBootstrapConfig.class}) class ConfigDataConfigServerIntegrationTest extends ConfigServerIntegrationTest {\n  private MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeEach void setup();\n  @AfterEach void teardown();\n  @AfterEach void afterEach();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/MockConfig.java",
        "name": "MockConfig",
        "modifiers": "@Configuration",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.MockConfig",
        "extend": "",
        "implements": "",
        "raw": "@Configuration class MockConfig {\n  @Bean @Profile(\"kubernetesdisabled\") public EnvironmentRepository environmentRepository(){\n    return mock(EnvironmentRepository.class);\n  }\n}\n",
        "abstract": "@Configuration class MockConfig {\n  @Bean @Profile(\"kubernetesdisabled\") public EnvironmentRepository environmentRepository();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/KubernetesPropertySourceSupplierTests.java",
        "name": "KubernetesPropertySourceSupplierTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.KubernetesPropertySourceSupplierTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Tests for verifying the behavior of the  {@link KubernetesPropertySourceSupplier} beansfor ConfigMaps and Secrets created by the auto-configuration.\n * @author Thomas Vitale\n */\nclass KubernetesPropertySourceSupplierTests {\n  private static final CoreV1Api coreApi\u003dmock(CoreV1Api.class);\n  private static final V1ConfigMapList CONFIGMAP_DEFAULT_LIST\u003dnew V1ConfigMapList().addItemsItem(buildConfigMap(\"gateway\",\"default\"));\n  private static final V1ConfigMapList CONFIGMAP_TEAM_A_LIST\u003dnew V1ConfigMapList().addItemsItem(buildConfigMap(\"stores\",\"team-a\"));\n  private static final V1ConfigMapList CONFIGMAP_TEAM_B_LIST\u003dnew V1ConfigMapList().addItemsItem(buildConfigMap(\"orders\",\"team-b\"));\n  private static final V1SecretList SECRET_DEFAULT_LIST\u003dnew V1SecretListBuilder().addToItems(buildSecret(\"gateway\",\"default\")).build();\n  private static final V1SecretList SECRET_TEAM_A_LIST\u003dnew V1SecretListBuilder().addToItems(buildSecret(\"stores\",\"team-a\")).build();\n  private static final V1SecretList SECRET_TEAM_B_LIST\u003dnew V1SecretListBuilder().addToItems(buildSecret(\"orders\",\"team-b\")).build();\n  @BeforeAll public static void before() throws ApiException {\n    when(coreApi.listNamespacedConfigMap(eq(\"default\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(CONFIGMAP_DEFAULT_LIST);\n    when(coreApi.listNamespacedConfigMap(eq(\"team-a\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(CONFIGMAP_TEAM_A_LIST);\n    when(coreApi.listNamespacedConfigMap(eq(\"team-b\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(CONFIGMAP_TEAM_B_LIST);\n    when(coreApi.listNamespacedSecret(eq(\"default\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(SECRET_DEFAULT_LIST);\n    when(coreApi.listNamespacedSecret(eq(\"team-a\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(SECRET_TEAM_A_LIST);\n    when(coreApi.listNamespacedSecret(eq(\"team-b\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(SECRET_TEAM_B_LIST);\n  }\n  @Test void whenCurrentAndExtraNamespacesAddedThenAllConfigMapsAreIncluded(){\n    KubernetesConfigServerProperties kubernetesConfigServerProperties\u003dnew KubernetesConfigServerProperties();\n    kubernetesConfigServerProperties.setConfigMapNamespaces(\"default,team-a,team-b\");\n    KubernetesPropertySourceSupplier kubernetesPropertySourceSupplier\u003dnew KubernetesConfigServerAutoConfiguration().configMapPropertySourceSupplier(kubernetesConfigServerProperties);\n    KubernetesEnvironmentRepository environmentRepository\u003dnew KubernetesEnvironmentRepository(coreApi,Collections.singletonList(kubernetesPropertySourceSupplier),\"default\");\n    Environment environmentGateway\u003denvironmentRepository.findOne(\"gateway\",\"\",\"\");\n    assertThat(environmentGateway.getPropertySources().size()).isEqualTo(1);\n    Environment environmentStores\u003denvironmentRepository.findOne(\"stores\",\"\",\"\");\n    assertThat(environmentStores.getPropertySources().size()).isEqualTo(1);\n    Environment environmentOrders\u003denvironmentRepository.findOne(\"orders\",\"\",\"\");\n    assertThat(environmentOrders.getPropertySources().size()).isEqualTo(1);\n  }\n  @Test void whenExtraNamespacesAddedThenConfigMapsInCurrentNamespaceAreNotIncluded(){\n    KubernetesConfigServerProperties kubernetesConfigServerProperties\u003dnew KubernetesConfigServerProperties();\n    kubernetesConfigServerProperties.setConfigMapNamespaces(\"team-a,team-b\");\n    KubernetesPropertySourceSupplier kubernetesPropertySourceSupplier\u003dnew KubernetesConfigServerAutoConfiguration().configMapPropertySourceSupplier(kubernetesConfigServerProperties);\n    KubernetesEnvironmentRepository environmentRepository\u003dnew KubernetesEnvironmentRepository(coreApi,Collections.singletonList(kubernetesPropertySourceSupplier),\"default\");\n    Environment environmentGateway\u003denvironmentRepository.findOne(\"gateway\",\"\",\"\");\n    assertThat(environmentGateway.getPropertySources().size()).isEqualTo(0);\n    Environment environmentStores\u003denvironmentRepository.findOne(\"stores\",\"\",\"\");\n    assertThat(environmentStores.getPropertySources().size()).isEqualTo(1);\n    Environment environmentOrders\u003denvironmentRepository.findOne(\"orders\",\"\",\"\");\n    assertThat(environmentOrders.getPropertySources().size()).isEqualTo(1);\n  }\n  @Test void whenCurrentAndExtraNamespacesAddedThenAllSecretsAreIncluded(){\n    KubernetesConfigServerProperties kubernetesConfigServerProperties\u003dnew KubernetesConfigServerProperties();\n    kubernetesConfigServerProperties.setSecretsNamespaces(\"default,team-a,team-b\");\n    KubernetesPropertySourceSupplier kubernetesPropertySourceSupplier\u003dnew KubernetesConfigServerAutoConfiguration().secretsPropertySourceSupplier(kubernetesConfigServerProperties);\n    KubernetesEnvironmentRepository environmentRepository\u003dnew KubernetesEnvironmentRepository(coreApi,Collections.singletonList(kubernetesPropertySourceSupplier),\"default\");\n    Environment environmentGateway\u003denvironmentRepository.findOne(\"gateway\",\"\",\"\");\n    assertThat(environmentGateway.getPropertySources().size()).isEqualTo(1);\n    Environment environmentStores\u003denvironmentRepository.findOne(\"stores\",\"\",\"\");\n    assertThat(environmentStores.getPropertySources().size()).isEqualTo(1);\n    Environment environmentOrders\u003denvironmentRepository.findOne(\"orders\",\"\",\"\");\n    assertThat(environmentOrders.getPropertySources().size()).isEqualTo(1);\n  }\n  @Test void whenExtraNamespacesAddedThenSecretsInCurrentNamespaceAreNotIncluded(){\n    KubernetesConfigServerProperties kubernetesConfigServerProperties\u003dnew KubernetesConfigServerProperties();\n    kubernetesConfigServerProperties.setSecretsNamespaces(\"team-a,team-b\");\n    KubernetesPropertySourceSupplier kubernetesPropertySourceSupplier\u003dnew KubernetesConfigServerAutoConfiguration().secretsPropertySourceSupplier(kubernetesConfigServerProperties);\n    KubernetesEnvironmentRepository environmentRepository\u003dnew KubernetesEnvironmentRepository(coreApi,Collections.singletonList(kubernetesPropertySourceSupplier),\"default\");\n    Environment environmentGateway\u003denvironmentRepository.findOne(\"gateway\",\"\",\"\");\n    assertThat(environmentGateway.getPropertySources().size()).isEqualTo(0);\n    Environment environmentStores\u003denvironmentRepository.findOne(\"stores\",\"\",\"\");\n    assertThat(environmentStores.getPropertySources().size()).isEqualTo(1);\n    Environment environmentOrders\u003denvironmentRepository.findOne(\"orders\",\"\",\"\");\n    assertThat(environmentOrders.getPropertySources().size()).isEqualTo(1);\n  }\n  private static V1ConfigMap buildConfigMap(  String name,  String namespace){\n    return new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(name).withNamespace(namespace).withResourceVersion(\"1\").build()).addToData(\"application.yaml\",\"dummy:\\n  property:\\n    string: \\\"\" + name + \"\\\"\\n\").build();\n  }\n  private static V1Secret buildSecret(  String name,  String namespace){\n    return new V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(name).withResourceVersion(\"0\").withNamespace(namespace).build()).addToData(\"password\",\"p455w0rd\".getBytes()).addToData(\"username\",\"user\".getBytes()).build();\n  }\n}\n",
        "abstract": "/** \n * Tests for verifying the behavior of the  {@link KubernetesPropertySourceSupplier} beansfor ConfigMaps and Secrets created by the auto-configuration.\n * @author Thomas Vitale\n */\nclass KubernetesPropertySourceSupplierTests {\n  private static final CoreV1Api coreApi\u003dmock(CoreV1Api.class);\n  private static final V1ConfigMapList CONFIGMAP_DEFAULT_LIST\u003dnew V1ConfigMapList().addItemsItem(buildConfigMap(\"gateway\",\"default\"));\n  private static final V1ConfigMapList CONFIGMAP_TEAM_A_LIST\u003dnew V1ConfigMapList().addItemsItem(buildConfigMap(\"stores\",\"team-a\"));\n  private static final V1ConfigMapList CONFIGMAP_TEAM_B_LIST\u003dnew V1ConfigMapList().addItemsItem(buildConfigMap(\"orders\",\"team-b\"));\n  private static final V1SecretList SECRET_DEFAULT_LIST\u003dnew V1SecretListBuilder().addToItems(buildSecret(\"gateway\",\"default\")).build();\n  private static final V1SecretList SECRET_TEAM_A_LIST\u003dnew V1SecretListBuilder().addToItems(buildSecret(\"stores\",\"team-a\")).build();\n  private static final V1SecretList SECRET_TEAM_B_LIST\u003dnew V1SecretListBuilder().addToItems(buildSecret(\"orders\",\"team-b\")).build();\n  @BeforeAll public static void before() throws ApiException;\n  @Test void whenCurrentAndExtraNamespacesAddedThenAllConfigMapsAreIncluded();\n  @Test void whenExtraNamespacesAddedThenConfigMapsInCurrentNamespaceAreNotIncluded();\n  @Test void whenCurrentAndExtraNamespacesAddedThenAllSecretsAreIncluded();\n  @Test void whenExtraNamespacesAddedThenSecretsInCurrentNamespaceAreNotIncluded();\n  private static V1ConfigMap buildConfigMap(  String name,  String namespace);\n  private static V1Secret buildSecret(  String name,  String namespace);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedConfigMapDisabled.java",
        "name": "ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedConfigMapDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedConfigMapDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"}) class ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedConfigMapDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest(){\n    assertThat(context.getBeanNamesForType(KubernetesEnvironmentRepository.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(KubernetesPropertySourceSupplier.class)).hasSize(0);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"}) class ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedConfigMapDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedConfigApiDisabled.java",
        "name": "ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedConfigApiDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.enableApi\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedConfigApiDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.enableApi\u003dfalse\"}) class ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedConfigApiDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest(){\n    assertThat(context.getBeanNamesForType(KubernetesEnvironmentRepository.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(KubernetesPropertySourceSupplier.class)).hasSize(0);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.enableApi\u003dfalse\"}) class ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedConfigApiDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/KubernetesEnvironmentRepositoryTests.java",
        "name": "KubernetesEnvironmentRepositoryTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.KubernetesEnvironmentRepositoryTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass KubernetesEnvironmentRepositoryTests {\n  private static final List\u003cKubernetesPropertySourceSupplier\u003e KUBERNETES_PROPERTY_SOURCE_SUPPLIER\u003dnew ArrayList\u003c\u003e();\n  private static final String VALUE\u003d\"dummy:\\n  property:\\n    string2: \\\"a\\\"\\n    int2: 1\\n    bool2: true\\n\";\n  private static final String DEFAULT_NAMESPACE\u003d\"default\";\n  private static final V1ConfigMapList CONFIGMAP_ONE_LIST\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"storessingle\").withNamespace(DEFAULT_NAMESPACE).build()).addToData(\"storessingle.yaml\",VALUE).addToData(\"storessingle-dev.yaml\",\"dummy:\\n  property:\\n    string2: \\\"dev\\\"\\n    int2: 1\\n    bool2: false\\n\").addToData(\"storessingle-qa.yaml\",\"dummy:\\n  property:\\n    string2: \\\"qa\\\"\\n    int2: 2\\n    bool2: true\\n\").addToData(\"storessingle-prod.yaml\",\"dummy:\\n  property:\\n    string2: \\\"prod\\\"\\n    int2: 3\\n    bool2: true\\n\").build());\n  private static final V1ConfigMapList CONFIGMAP_DEFAULT_LIST\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"application\").withNamespace(DEFAULT_NAMESPACE).build()).addToData(\"application.yaml\",VALUE).build()).addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"stores\").withNamespace(DEFAULT_NAMESPACE).build()).addToData(\"application.yaml\",VALUE).build()).addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"stores-dev\").withNamespace(DEFAULT_NAMESPACE).build()).addToData(\"application.yaml\",\"dummy:\\n  property:\\n    string1: \\\"a\\\"\\n    string2: \\\"b\\\"\\n    int2: 2\\n    bool2: false\\n\").build());\n  private static final V1ConfigMapList CONFIGMAP_DEV_LIST\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"stores\").withNamespace(\"dev\").withResourceVersion(\"1\").build()).addToData(\"application.yaml\",\"dummy:\\n  property:\\n    string2: \\\"dev\\\"\\n    int2: 1\\n    bool2: true\\n\").build());\n  private static final V1SecretList SECRET_LIST\u003dnew V1SecretListBuilder().addToItems(new V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"application\").withResourceVersion(\"0\").withNamespace(\"default\").build()).addToData(\"password\",\"p455w0rd\".getBytes()).addToData(\"username\",\"user\".getBytes()).build()).addToItems(new V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"stores\").withResourceVersion(\"0\").withNamespace(\"default\").build()).addToData(\"password\",\"password-from-stores\".getBytes()).addToData(\"username\",\"stores\".getBytes()).build()).addToItems(new V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"stores-dev\").withResourceVersion(\"0\").withNamespace(\"default\").build()).addToData(\"password\",\"password-from-stores-dev\".getBytes()).addToData(\"username\",\"stores-dev\".getBytes()).build()).build();\n  @BeforeAll public static void before(){\n    KUBERNETES_PROPERTY_SOURCE_SUPPLIER.add((coreApi,applicationName,namespace,springEnv) -\u003e {\n      List\u003cMapPropertySource\u003e propertySources\u003dnew ArrayList\u003c\u003e();\n      NormalizedSource defaultSource\u003dnew NamedConfigMapNormalizedSource(applicationName,\"default\",false,true);\n      KubernetesClientConfigContext defaultContext\u003dnew KubernetesClientConfigContext(coreApi,defaultSource,\"default\",springEnv);\n      propertySources.add(new KubernetesClientConfigMapPropertySource(defaultContext));\n      if (\"stores\".equals(applicationName) \u0026\u0026 \"dev\".equals(namespace)) {\n        NormalizedSource devSource\u003dnew NamedConfigMapNormalizedSource(applicationName,\"dev\",false,true);\n        KubernetesClientConfigContext devContext\u003dnew KubernetesClientConfigContext(coreApi,devSource,\"dev\",springEnv);\n        propertySources.add(new KubernetesClientConfigMapPropertySource(devContext));\n      }\n      return propertySources;\n    }\n);\n    KUBERNETES_PROPERTY_SOURCE_SUPPLIER.add((coreApi,applicationName,namespace,springEnv) -\u003e {\n      List\u003cMapPropertySource\u003e propertySources\u003dnew ArrayList\u003c\u003e();\n      NormalizedSource source\u003dnew NamedSecretNormalizedSource(applicationName,\"default\",false,true);\n      KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(coreApi,source,\"default\",springEnv);\n      propertySources.add(new KubernetesClientSecretsPropertySource(context));\n      return propertySources;\n    }\n);\n  }\n  @AfterEach public void after(){\n    new KubernetesClientConfigMapsCache().discardAll();\n  }\n  @Test public void testApplicationCase() throws ApiException {\n    CoreV1Api coreApi\u003dmock(CoreV1Api.class);\n    when(coreApi.listNamespacedConfigMap(eq(\"default\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(CONFIGMAP_DEFAULT_LIST);\n    when(coreApi.listNamespacedSecret(eq(\"default\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(SECRET_LIST);\n    when(coreApi.listNamespacedConfigMap(eq(\"dev\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(CONFIGMAP_DEV_LIST);\n    KubernetesEnvironmentRepository environmentRepository\u003dnew KubernetesEnvironmentRepository(coreApi,KUBERNETES_PROPERTY_SOURCE_SUPPLIER,\"default\");\n    Environment environment\u003denvironmentRepository.findOne(\"application\",\"\",\"\");\n    assertThat(environment.getPropertySources().size()).isEqualTo(2);\n    environment.getPropertySources().forEach(propertySource -\u003e {\n      assertThat(propertySource.getName().equals(\"configmap.application.default\") || propertySource.getName().equals(\"secret.application.default\")).isTrue();\n      if (propertySource.getName().equals(\"configmap.application.default\")) {\n        assertThat(propertySource.getSource().size()).isEqualTo(3);\n        assertThat(propertySource.getSource().get(\"dummy.property.int2\")).isEqualTo(1);\n        assertThat(propertySource.getSource().get(\"dummy.property.bool2\")).isEqualTo(true);\n        assertThat(propertySource.getSource().get(\"dummy.property.string2\")).isEqualTo(\"a\");\n      }\n      if (propertySource.getName().equals(\"secrets.application.default\")) {\n        assertThat(propertySource.getSource().size()).isEqualTo(2);\n        assertThat(propertySource.getSource().get(\"username\")).isEqualTo(\"user\");\n        assertThat(propertySource.getSource().get(\"password\")).isEqualTo(\"p455w0rd\");\n      }\n    }\n);\n  }\n  @Test public void testStoresCase() throws ApiException {\n    CoreV1Api coreApi\u003dmock(CoreV1Api.class);\n    when(coreApi.listNamespacedConfigMap(eq(\"default\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(CONFIGMAP_DEFAULT_LIST);\n    when(coreApi.listNamespacedConfigMap(eq(\"dev\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(CONFIGMAP_DEV_LIST);\n    when(coreApi.listNamespacedSecret(eq(\"default\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(SECRET_LIST);\n    KubernetesEnvironmentRepository environmentRepository\u003dnew KubernetesEnvironmentRepository(coreApi,KUBERNETES_PROPERTY_SOURCE_SUPPLIER,\"default\");\n    Environment environment\u003denvironmentRepository.findOne(\"stores\",\"\",\"\");\n    assertThat(environment.getPropertySources().size()).isEqualTo(4);\n    environment.getPropertySources().forEach(propertySource -\u003e {\n      assertThat(propertySource.getName().equals(\"configmap.application.default\") || propertySource.getName().equals(\"secret.application.default\") || propertySource.getName().equals(\"configmap.stores.default\")|| propertySource.getName().equals(\"secret.stores.default\")).isTrue();\n      if (propertySource.getName().equals(\"configmap.application.default\")) {\n        assertThat(propertySource.getSource().size()).isEqualTo(3);\n        assertThat(propertySource.getSource().get(\"dummy.property.int2\")).isEqualTo(1);\n        assertThat(propertySource.getSource().get(\"dummy.property.bool2\")).isEqualTo(true);\n        assertThat(propertySource.getSource().get(\"dummy.property.string2\")).isEqualTo(\"a\");\n      }\n      if (propertySource.getName().equals(\"secret.application.default\")) {\n        assertThat(propertySource.getSource().size()).isEqualTo(2);\n        assertThat(propertySource.getSource().get(\"username\")).isEqualTo(\"user\");\n        assertThat(propertySource.getSource().get(\"password\")).isEqualTo(\"p455w0rd\");\n      }\n      if (propertySource.getName().equals(\"configmap.stores.default\")) {\n        assertThat(propertySource.getSource().size()).isEqualTo(3);\n        assertThat(propertySource.getSource().get(\"dummy.property.int2\")).isEqualTo(1);\n        assertThat(propertySource.getSource().get(\"dummy.property.bool2\")).isEqualTo(true);\n        assertThat(propertySource.getSource().get(\"dummy.property.string2\")).isEqualTo(\"a\");\n      }\n      if (propertySource.getName().equals(\"secret.stores.default\")) {\n        assertThat(propertySource.getSource().size()).isEqualTo(2);\n        assertThat(propertySource.getSource().get(\"username\")).isEqualTo(\"stores\");\n        assertThat(propertySource.getSource().get(\"password\")).isEqualTo(\"password-from-stores\");\n      }\n    }\n);\n  }\n  @Test public void testStoresProfileCase() throws ApiException {\n    CoreV1Api coreApi\u003dmock(CoreV1Api.class);\n    when(coreApi.listNamespacedConfigMap(eq(\"default\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(CONFIGMAP_DEFAULT_LIST);\n    when(coreApi.listNamespacedSecret(eq(\"default\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(SECRET_LIST);\n    when(coreApi.listNamespacedConfigMap(eq(\"dev\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(CONFIGMAP_DEV_LIST);\n    KubernetesEnvironmentRepository environmentRepository\u003dnew KubernetesEnvironmentRepository(coreApi,KUBERNETES_PROPERTY_SOURCE_SUPPLIER,\"default\");\n    Environment environment\u003denvironmentRepository.findOne(\"stores\",\"dev\",\"\");\n    assertThat(environment.getPropertySources().size()).isEqualTo(6);\n    environment.getPropertySources().forEach(propertySource -\u003e {\n      assertThat(propertySource.getName().equals(\"configmap.application.default\") || propertySource.getName().equals(\"secret.application.default\") || propertySource.getName().equals(\"configmap.stores.stores-dev.default\")|| propertySource.getName().equals(\"secret.stores.default\")|| propertySource.getName().equals(\"secret.stores.stores-dev.default\")|| propertySource.getName().equals(\"configmap.stores.default\")).isTrue();\n      if (propertySource.getName().equals(\"configmap.application.default\")) {\n        assertThat(propertySource.getSource().size()).isEqualTo(3);\n        assertThat(propertySource.getSource().get(\"dummy.property.int2\")).isEqualTo(1);\n        assertThat(propertySource.getSource().get(\"dummy.property.bool2\")).isEqualTo(true);\n        assertThat(propertySource.getSource().get(\"dummy.property.string2\")).isEqualTo(\"a\");\n      }\n else       if (propertySource.getName().equals(\"secret.application.default\")) {\n        assertThat(propertySource.getSource().size()).isEqualTo(2);\n        assertThat(propertySource.getSource().get(\"username\")).isEqualTo(\"user\");\n        assertThat(propertySource.getSource().get(\"password\")).isEqualTo(\"p455w0rd\");\n      }\n else       if (propertySource.getName().equals(\"secret.stores.stores-dev.default\")) {\n        assertThat(propertySource.getSource().size()).isEqualTo(2);\n        assertThat(propertySource.getSource().get(\"username\")).isEqualTo(\"stores-dev\");\n        assertThat(propertySource.getSource().get(\"password\")).isEqualTo(\"password-from-stores-dev\");\n      }\n else       if (propertySource.getName().equals(\"configmap.stores.stores-dev.default\")) {\n        assertThat(propertySource.getSource().size()).isEqualTo(4);\n        assertThat(propertySource.getSource().get(\"dummy.property.int2\")).isEqualTo(2);\n        assertThat(propertySource.getSource().get(\"dummy.property.bool2\")).isEqualTo(false);\n        assertThat(propertySource.getSource().get(\"dummy.property.string1\")).isEqualTo(\"a\");\n        assertThat(propertySource.getSource().get(\"dummy.property.string2\")).isEqualTo(\"b\");\n      }\n else       if (propertySource.getName().equals(\"configmap.stores.default\")) {\n        assertThat(propertySource.getSource().size()).isEqualTo(3);\n        assertThat(propertySource.getSource().get(\"dummy.property.int2\")).isEqualTo(1);\n        assertThat(propertySource.getSource().get(\"dummy.property.bool2\")).isEqualTo(true);\n        assertThat(propertySource.getSource().get(\"dummy.property.string2\")).isEqualTo(\"a\");\n      }\n else       if (propertySource.getName().equals(\"secret.stores.default\")) {\n        assertThat(propertySource.getSource().size()).isEqualTo(2);\n        assertThat(propertySource.getSource().get(\"username\")).isEqualTo(\"stores\");\n        assertThat(propertySource.getSource().get(\"password\")).isEqualTo(\"password-from-stores\");\n      }\n else {\n        Assertions.fail(\"no match in property source names\");\n      }\n    }\n);\n  }\n  @Test public void testApplicationPropertiesAnSecretsOverride() throws ApiException {\n    CoreV1Api coreApi\u003dmock(CoreV1Api.class);\n    when(coreApi.listNamespacedConfigMap(eq(\"default\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(CONFIGMAP_DEFAULT_LIST);\n    when(coreApi.listNamespacedSecret(eq(\"default\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(SECRET_LIST);\n    when(coreApi.listNamespacedConfigMap(eq(\"dev\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(CONFIGMAP_DEV_LIST);\n    KubernetesEnvironmentRepository environmentRepository\u003dnew KubernetesEnvironmentRepository(coreApi,KUBERNETES_PROPERTY_SOURCE_SUPPLIER,\"default\");\n    Environment environment\u003denvironmentRepository.findOne(\"stores-dev\",\"\",\"\");\n    environment.getPropertySources().stream().filter(propertySource -\u003e propertySource.getName().startsWith(\"configmap\")).reduce((first,second) -\u003e second).ifPresent(propertySource -\u003e {\n      assertThat(propertySource.getName()).isEqualTo(\"configmap.application.default\");\n    }\n);\n    environment.getPropertySources().stream().filter(propertySource -\u003e propertySource.getName().startsWith(\"configmap\")).findFirst().ifPresent(propertySource -\u003e {\n      assertThat(propertySource.getSource().get(\"dummy.property.int2\")).isEqualTo(2);\n      assertThat(propertySource.getSource().get(\"dummy.property.bool2\")).isEqualTo(false);\n      assertThat(propertySource.getSource().get(\"dummy.property.string2\")).isEqualTo(\"b\");\n    }\n);\n    environment.getPropertySources().stream().filter(propertySource -\u003e propertySource.getName().startsWith(\"secrets\")).findFirst().ifPresent(propertySource -\u003e {\n      assertThat(propertySource.getSource().get(\"username\")).isEqualTo(\"stores-dev\");\n      assertThat(propertySource.getSource().get(\"password\")).isEqualTo(\"p455w0rd\");\n    }\n);\n  }\n  @Test public void testSingleConfigMapMultipleSources() throws ApiException {\n    CoreV1Api coreApi\u003dmock(CoreV1Api.class);\n    when(coreApi.listNamespacedConfigMap(eq(\"default\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(CONFIGMAP_ONE_LIST);\n    when(coreApi.listNamespacedSecret(eq(\"default\"),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null),eq(null))).thenReturn(new V1SecretList());\n    List\u003cKubernetesPropertySourceSupplier\u003e suppliers\u003dnew ArrayList\u003c\u003e();\n    suppliers.add((coreV1Api,name,namespace,environment) -\u003e {\n      List\u003cMapPropertySource\u003e propertySources\u003dnew ArrayList\u003c\u003e();\n      NormalizedSource devSource\u003dnew NamedConfigMapNormalizedSource(name,namespace,false,ConfigUtils.Prefix.DEFAULT,true,true);\n      KubernetesClientConfigContext devContext\u003dnew KubernetesClientConfigContext(coreApi,devSource,\"default\",environment);\n      propertySources.add(new KubernetesClientConfigMapPropertySource(devContext));\n      return propertySources;\n    }\n);\n    KubernetesEnvironmentRepository environmentRepository\u003dnew KubernetesEnvironmentRepository(coreApi,suppliers,\"default\");\n    Environment environment\u003denvironmentRepository.findOne(\"storessingle\",\"\",\"\");\n    assertThat(environment.getPropertySources().size()).isEqualTo(1);\n    assertThat(environment.getPropertySources().get(0).getName()).isEqualTo(\"configmap.storessingle.default.default\");\n    environment\u003denvironmentRepository.findOne(\"storessingle\",\"dev\",\"\");\n    assertThat(environment.getPropertySources().size()).isEqualTo(2);\n    assertThat(environment.getPropertySources().get(0).getName()).isEqualTo(\"configmap.storessingle.default.dev\");\n    assertThat(environment.getPropertySources().get(1).getName()).isEqualTo(\"configmap.storessingle.default.default\");\n    environment\u003denvironmentRepository.findOne(\"storessingle\",\"dev,prod\",\"\");\n    assertThat(environment.getPropertySources().size()).isEqualTo(3);\n    assertThat(environment.getPropertySources().get(0).getName()).isEqualTo(\"configmap.storessingle.default.prod\");\n    assertThat(environment.getPropertySources().get(0).getSource().get(\"dummy.property.int2\")).isEqualTo(3);\n    assertThat(environment.getPropertySources().get(0).getSource().get(\"dummy.property.bool2\")).isEqualTo(true);\n    assertThat(environment.getPropertySources().get(0).getSource().get(\"dummy.property.string2\")).isEqualTo(\"prod\");\n    assertThat(environment.getPropertySources().get(1).getName()).isEqualTo(\"configmap.storessingle.default.dev\");\n    assertThat(environment.getPropertySources().get(1).getSource().get(\"dummy.property.int2\")).isEqualTo(1);\n    assertThat(environment.getPropertySources().get(1).getSource().get(\"dummy.property.bool2\")).isEqualTo(false);\n    assertThat(environment.getPropertySources().get(1).getSource().get(\"dummy.property.string2\")).isEqualTo(\"dev\");\n    assertThat(environment.getPropertySources().get(2).getName()).isEqualTo(\"configmap.storessingle.default.default\");\n    assertThat(environment.getPropertySources().get(2).getSource().get(\"dummy.property.int2\")).isEqualTo(1);\n    assertThat(environment.getPropertySources().get(2).getSource().get(\"dummy.property.bool2\")).isEqualTo(true);\n    assertThat(environment.getPropertySources().get(2).getSource().get(\"dummy.property.string2\")).isEqualTo(\"a\");\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass KubernetesEnvironmentRepositoryTests {\n  private static final List\u003cKubernetesPropertySourceSupplier\u003e KUBERNETES_PROPERTY_SOURCE_SUPPLIER\u003dnew ArrayList\u003c\u003e();\n  private static final String VALUE\u003d\"dummy:\\n  property:\\n    string2: \\\"a\\\"\\n    int2: 1\\n    bool2: true\\n\";\n  private static final String DEFAULT_NAMESPACE\u003d\"default\";\n  private static final V1ConfigMapList CONFIGMAP_ONE_LIST\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"storessingle\").withNamespace(DEFAULT_NAMESPACE).build()).addToData(\"storessingle.yaml\",VALUE).addToData(\"storessingle-dev.yaml\",\"dummy:\\n  property:\\n    string2: \\\"dev\\\"\\n    int2: 1\\n    bool2: false\\n\").addToData(\"storessingle-qa.yaml\",\"dummy:\\n  property:\\n    string2: \\\"qa\\\"\\n    int2: 2\\n    bool2: true\\n\").addToData(\"storessingle-prod.yaml\",\"dummy:\\n  property:\\n    string2: \\\"prod\\\"\\n    int2: 3\\n    bool2: true\\n\").build());\n  private static final V1ConfigMapList CONFIGMAP_DEFAULT_LIST\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"application\").withNamespace(DEFAULT_NAMESPACE).build()).addToData(\"application.yaml\",VALUE).build()).addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"stores\").withNamespace(DEFAULT_NAMESPACE).build()).addToData(\"application.yaml\",VALUE).build()).addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"stores-dev\").withNamespace(DEFAULT_NAMESPACE).build()).addToData(\"application.yaml\",\"dummy:\\n  property:\\n    string1: \\\"a\\\"\\n    string2: \\\"b\\\"\\n    int2: 2\\n    bool2: false\\n\").build());\n  private static final V1ConfigMapList CONFIGMAP_DEV_LIST\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"stores\").withNamespace(\"dev\").withResourceVersion(\"1\").build()).addToData(\"application.yaml\",\"dummy:\\n  property:\\n    string2: \\\"dev\\\"\\n    int2: 1\\n    bool2: true\\n\").build());\n  private static final V1SecretList SECRET_LIST\u003dnew V1SecretListBuilder().addToItems(new V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"application\").withResourceVersion(\"0\").withNamespace(\"default\").build()).addToData(\"password\",\"p455w0rd\".getBytes()).addToData(\"username\",\"user\".getBytes()).build()).addToItems(new V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"stores\").withResourceVersion(\"0\").withNamespace(\"default\").build()).addToData(\"password\",\"password-from-stores\".getBytes()).addToData(\"username\",\"stores\".getBytes()).build()).addToItems(new V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"stores-dev\").withResourceVersion(\"0\").withNamespace(\"default\").build()).addToData(\"password\",\"password-from-stores-dev\".getBytes()).addToData(\"username\",\"stores-dev\".getBytes()).build()).build();\n  @BeforeAll public static void before();\n  @AfterEach public void after();\n  @Test public void testApplicationCase() throws ApiException;\n  @Test public void testStoresCase() throws ApiException;\n  @Test public void testStoresProfileCase() throws ApiException;\n  @Test public void testApplicationPropertiesAnSecretsOverride() throws ApiException;\n  @Test public void testSingleConfigMapMultipleSources() throws ApiException;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedSecretsApiEnabled.java",
        "name": "ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedSecretsApiEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.profiles.include\u003dkubernetes\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedSecretsApiEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.profiles.include\u003dkubernetes\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\"}) class ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedSecretsApiEnabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest(){\n    assertThat(context.getBeanNamesForType(KubernetesEnvironmentRepository.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(KubernetesPropertySourceSupplier.class)).hasSize(2);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.profiles.include\u003dkubernetes\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.enableApi\u003dtrue\"}) class ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedSecretsApiEnabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/ConfigServerAutoConfigurationKubernetesDisabled.java",
        "name": "ConfigServerAutoConfigurationKubernetesDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.profiles.include\u003dkubernetes,kubernetesdisabled\"},classes\u003d{KubernetesConfigServerApplication.class,MockConfig.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.ConfigServerAutoConfigurationKubernetesDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.profiles.include\u003dkubernetes,kubernetesdisabled\"},classes\u003d{KubernetesConfigServerApplication.class,MockConfig.class}) class ConfigServerAutoConfigurationKubernetesDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest(){\n    assertThat(context.getBeanNamesForType(KubernetesEnvironmentRepository.class)).hasSize(0);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.profiles.include\u003dkubernetes,kubernetesdisabled\"},classes\u003d{KubernetesConfigServerApplication.class,MockConfig.class}) class ConfigServerAutoConfigurationKubernetesDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedSecretsApiDisabled.java",
        "name": "ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedSecretsApiDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedSecretsApiDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\"}) class ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedSecretsApiDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest(){\n    assertThat(context.getBeanNamesForType(KubernetesEnvironmentRepository.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(KubernetesPropertySourceSupplier.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(KubernetesPropertySourceSupplier.class)[0]).isEqualTo(\"configMapPropertySourceSupplier\");\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\"}) class ConfigServerAutoConfigurationKubernetesEnabledProfileIncludedSecretsApiDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/ConfigServerAutoConfigurationKubernetesEnabledProfileIncluded.java",
        "name": "ConfigServerAutoConfigurationKubernetesEnabledProfileIncluded",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.ConfigServerAutoConfigurationKubernetesEnabledProfileIncluded",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\"}) class ConfigServerAutoConfigurationKubernetesEnabledProfileIncluded {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest(){\n    assertThat(context.getBeanNamesForType(KubernetesEnvironmentRepository.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(KubernetesPropertySourceSupplier.class)).hasSize(1);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class},properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.profiles.include\u003dkubernetes\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\"}) class ConfigServerAutoConfigurationKubernetesEnabledProfileIncluded {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/ConfigServerAutoConfigurationKubernetesProfileMissing.java",
        "name": "ConfigServerAutoConfigurationKubernetesProfileMissing",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class,MockConfig.class},properties\u003d{\"spring.profiles.include\u003dkubernetes,kubernetesdisabled\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.ConfigServerAutoConfigurationKubernetesProfileMissing",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class,MockConfig.class},properties\u003d{\"spring.profiles.include\u003dkubernetes,kubernetesdisabled\"}) class ConfigServerAutoConfigurationKubernetesProfileMissing {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest(){\n    assertThat(context.getBeanNamesForType(KubernetesEnvironmentRepository.class)).hasSize(0);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003d{KubernetesConfigServerApplication.class,MockConfig.class},properties\u003d{\"spring.profiles.include\u003dkubernetes,kubernetesdisabled\"}) class ConfigServerAutoConfigurationKubernetesProfileMissing {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void runTest();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver/src/test/java/org/springframework/cloud/kubernetes/configserver/TestBootstrapConfig.java",
        "name": "TestBootstrapConfig",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.configserver.TestBootstrapConfig",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class TestBootstrapConfig {\n  @Bean WireMockServer wireMockServer(){\n    WireMockServer wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    return wireMockServer;\n  }\n  @Bean ApiClient apiClient(  WireMockServer wireMockServer){\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(wireMockServer.baseUrl()).build();\n    apiClient.setDebugging(true);\n    return apiClient;\n  }\n  @Bean CoreV1Api coreApi(  ApiClient apiClient){\n    return new CoreV1Api(apiClient);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class TestBootstrapConfig {\n  @Bean WireMockServer wireMockServer();\n  @Bean ApiClient apiClient(  WireMockServer wireMockServer);\n  @Bean CoreV1Api coreApi(  ApiClient apiClient);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/main/java/org/springframework/cloud/kubernetes/discoveryserver/DiscoveryServerApplication.java",
        "name": "DiscoveryServerApplication",
        "modifiers": "@SpringBootApplication @EnableScheduling public",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryserver.DiscoveryServerApplication",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootApplication @EnableScheduling public class DiscoveryServerApplication {\n  public static void main(  String[] args){\n    new SpringApplicationBuilder(DiscoveryServerApplication.class).run(args);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootApplication @EnableScheduling public class DiscoveryServerApplication {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/main/java/org/springframework/cloud/kubernetes/discoveryserver/DiscoveryServerController.java",
        "name": "DiscoveryServerController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryserver.DiscoveryServerController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@RestController public class DiscoveryServerController {\n  private final KubernetesInformerReactiveDiscoveryClient reactiveDiscoveryClient;\n  public DiscoveryServerController(  KubernetesInformerReactiveDiscoveryClient reactiveDiscoveryClient){\n    this.reactiveDiscoveryClient\u003dreactiveDiscoveryClient;\n  }\n  @GetMapping(\"/apps\") public Flux\u003cService\u003e apps(){\n    return reactiveDiscoveryClient.getServices().flatMap(service -\u003e reactiveDiscoveryClient.getInstances(service).collectList().flatMap(serviceInstances -\u003e Mono.just(new Service(service,serviceInstances.stream().map(x -\u003e (DefaultKubernetesServiceInstance)x).toList()))));\n  }\n  @GetMapping(\"/apps/{name}\") public Flux\u003cServiceInstance\u003e appInstances(  @PathVariable String name){\n    return reactiveDiscoveryClient.getInstances(name);\n  }\n  /** \n * use the \"appInstanceNonDeprecated\" instead.\n */\n  @Deprecated(forRemoval\u003dtrue) @GetMapping(\"/app/{name}/{instanceId}\") public Mono\u003cServiceInstance\u003e appInstance(  @PathVariable String name,  @PathVariable String instanceId){\n    return innerAppInstance(name,instanceId);\n  }\n  @GetMapping(\"/apps/{name}/{instanceId}\") Mono\u003cServiceInstance\u003e appInstanceNonDeprecated(  @PathVariable String name,  @PathVariable String instanceId){\n    return innerAppInstance(name,instanceId);\n  }\n  private Mono\u003cServiceInstance\u003e innerAppInstance(  String name,  String instanceId){\n    return reactiveDiscoveryClient.getInstances(name).filter(serviceInstance -\u003e serviceInstance.getInstanceId().equals(instanceId)).singleOrEmpty();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@RestController public class DiscoveryServerController {\n  private final KubernetesInformerReactiveDiscoveryClient reactiveDiscoveryClient;\n  public DiscoveryServerController(  KubernetesInformerReactiveDiscoveryClient reactiveDiscoveryClient);\n  @GetMapping(\"/apps\") public Flux\u003cService\u003e apps();\n  @GetMapping(\"/apps/{name}\") public Flux\u003cServiceInstance\u003e appInstances(  @PathVariable String name);\n  /** \n * use the \"appInstanceNonDeprecated\" instead.\n */\n  @Deprecated(forRemoval\u003dtrue) @GetMapping(\"/app/{name}/{instanceId}\") public Mono\u003cServiceInstance\u003e appInstance(  @PathVariable String name,  @PathVariable String instanceId);\n  @GetMapping(\"/apps/{name}/{instanceId}\") Mono\u003cServiceInstance\u003e appInstanceNonDeprecated(  @PathVariable String name,  @PathVariable String instanceId);\n  private Mono\u003cServiceInstance\u003e innerAppInstance(  String name,  String instanceId);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/main/java/org/springframework/cloud/kubernetes/discoveryserver/HeartBeatListener.java",
        "name": "HeartBeatListener",
        "modifiers": "@Component @ConditionalOnKubernetesCatalogEnabled @ConditionalOnHttpDiscoveryCatalogWatcherEnabled",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryserver.HeartBeatListener",
        "extend": "",
        "implements": "ApplicationListener\u003cHeartbeatEvent\u003e",
        "raw": "/** \n * Listener for a HeartbeatEvent that comes from KubernetesCatalogWatch.\n * @author wind57\n */\n@Component @ConditionalOnKubernetesCatalogEnabled @ConditionalOnHttpDiscoveryCatalogWatcherEnabled class HeartBeatListener implements ApplicationListener\u003cHeartbeatEvent\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(HeartBeatListener.class));\n  private final AtomicReference\u003cList\u003cEndpointNameAndNamespace\u003e\u003e lastState\u003dnew AtomicReference\u003c\u003e(List.of());\n  HeartBeatListener(  Environment environment){\n    String watchDelay\u003denvironment.getProperty(CATALOG_WATCH_PROPERTY_NAME);\n    if (watchDelay !\u003d null) {\n      LOG.debug(\"using delay : \" + watchDelay);\n    }\n else {\n      LOG.debug(\"using default watch delay : \" + CATALOG_WATCHER_DEFAULT_DELAY);\n    }\n  }\n  @Override @SuppressWarnings(\"unchecked\") public void onApplicationEvent(  HeartbeatEvent event){\n    LOG.debug(() -\u003e \"received heartbeat event\");\n    List\u003cEndpointNameAndNamespace\u003e state\u003d(List\u003cEndpointNameAndNamespace\u003e)event.getValue();\n    LOG.debug(() -\u003e \"state received : \" + state);\n    lastState.set(state);\n  }\n  AtomicReference\u003cList\u003cEndpointNameAndNamespace\u003e\u003e lastState(){\n    return lastState;\n  }\n}\n",
        "abstract": "/** \n * Listener for a HeartbeatEvent that comes from KubernetesCatalogWatch.\n * @author wind57\n */\n@Component @ConditionalOnKubernetesCatalogEnabled @ConditionalOnHttpDiscoveryCatalogWatcherEnabled class HeartBeatListener implements ApplicationListener\u003cHeartbeatEvent\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(HeartBeatListener.class));\n  private final AtomicReference\u003cList\u003cEndpointNameAndNamespace\u003e\u003e lastState\u003dnew AtomicReference\u003c\u003e(List.of());\n  HeartBeatListener(  Environment environment);\n  @Override @SuppressWarnings(\"unchecked\") public void onApplicationEvent(  HeartbeatEvent event);\n  AtomicReference\u003cList\u003cEndpointNameAndNamespace\u003e\u003e lastState();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/main/java/org/springframework/cloud/kubernetes/discoveryserver/DiscoveryCatalogWatcherController.java",
        "name": "DiscoveryCatalogWatcherController",
        "modifiers": "@RestController @ConditionalOnKubernetesCatalogEnabled @ConditionalOnHttpDiscoveryCatalogWatcherEnabled",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryserver.DiscoveryCatalogWatcherController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController @ConditionalOnKubernetesCatalogEnabled @ConditionalOnHttpDiscoveryCatalogWatcherEnabled class DiscoveryCatalogWatcherController {\n  private final HeartBeatListener heartBeatListener;\n  DiscoveryCatalogWatcherController(  HeartBeatListener heartBeatListener){\n    this.heartBeatListener\u003dheartBeatListener;\n  }\n  @GetMapping(\"/state\") Mono\u003cList\u003cEndpointNameAndNamespace\u003e\u003e state(){\n    return Mono.defer(() -\u003e Mono.just(heartBeatListener.lastState().get()));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController @ConditionalOnKubernetesCatalogEnabled @ConditionalOnHttpDiscoveryCatalogWatcherEnabled class DiscoveryCatalogWatcherController {\n  private final HeartBeatListener heartBeatListener;\n  DiscoveryCatalogWatcherController(  HeartBeatListener heartBeatListener);\n  @GetMapping(\"/state\") Mono\u003cList\u003cEndpointNameAndNamespace\u003e\u003e state();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/test/java/org/springframework/cloud/kubernetes/client/discovery/reactive/HandleToReactiveDiscoveryClient.java",
        "name": "HandleToReactiveDiscoveryClient",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.discovery.reactive.HandleToReactiveDiscoveryClient",
        "extend": "KubernetesInformerReactiveDiscoveryClient",
        "implements": "",
        "raw": "/** \n * A way to get the reactive discovery client instance that is package-private. This is only needed for tests.\n * @author wind57\n */\npublic class HandleToReactiveDiscoveryClient extends KubernetesInformerReactiveDiscoveryClient {\n  public HandleToReactiveDiscoveryClient(  KubernetesInformerDiscoveryClient kubernetesDiscoveryClient){\n    super(kubernetesDiscoveryClient);\n  }\n}\n",
        "abstract": "/** \n * A way to get the reactive discovery client instance that is package-private. This is only needed for tests.\n * @author wind57\n */\npublic class HandleToReactiveDiscoveryClient extends KubernetesInformerReactiveDiscoveryClient {\n  public HandleToReactiveDiscoveryClient(  KubernetesInformerDiscoveryClient kubernetesDiscoveryClient);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/test/java/org/springframework/cloud/kubernetes/discoveryserver/DiscoveryServerApplicationContextTests.java",
        "name": "DiscoveryServerApplicationContextTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryserver.DiscoveryServerApplicationContextTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass DiscoveryServerApplicationContextTests {\n@Nested @SpringBootTest(classes\u003dTestConfig.class,properties\u003d{\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\",\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class BothControllersPresent {\n    @Autowired private ObjectProvider\u003cDiscoveryServerController\u003e discoveryServerController;\n    @Autowired private ObjectProvider\u003cDiscoveryCatalogWatcherController\u003e discoveryCatalogWatcherController;\n    @Autowired private ObjectProvider\u003cHeartBeatListener\u003e heartBeatListener;\n    @Test void test(){\n      Assertions.assertNotNull(discoveryServerController.getIfAvailable());\n      Assertions.assertNotNull(discoveryCatalogWatcherController.getIfAvailable());\n      Assertions.assertNotNull(heartBeatListener.getIfAvailable());\n    }\n  }\n@Nested @SpringBootTest(classes\u003dTestConfig.class,properties\u003d{\"spring.cloud.kubernetes.discovery.catalog-services-watch.enabled\u003dfalse\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\",\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class CatalogControllerNotPresentOne {\n    @Autowired private ObjectProvider\u003cDiscoveryServerController\u003e discoveryServerController;\n    @Autowired private ObjectProvider\u003cDiscoveryCatalogWatcherController\u003e discoveryCatalogWatcherController;\n    @Autowired private ObjectProvider\u003cHeartBeatListener\u003e heartBeatListener;\n    @Test void test(){\n      Assertions.assertNotNull(discoveryServerController.getIfAvailable());\n      Assertions.assertNull(discoveryCatalogWatcherController.getIfAvailable());\n      Assertions.assertNull(heartBeatListener.getIfAvailable());\n    }\n  }\n@Nested @SpringBootTest(classes\u003dTestConfig.class,properties\u003d{\"spring.cloud.kubernetes.discovery.catalog-services-watch.enabled\u003dtrue\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dfalse\",\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class CatalogControllerNotPresentTwo {\n    @Autowired private ObjectProvider\u003cDiscoveryServerController\u003e discoveryServerController;\n    @Autowired private ObjectProvider\u003cDiscoveryCatalogWatcherController\u003e discoveryCatalogWatcherController;\n    @Autowired private ObjectProvider\u003cHeartBeatListener\u003e heartBeatListener;\n    @Test void test(){\n      Assertions.assertNotNull(discoveryServerController.getIfAvailable());\n      Assertions.assertNull(discoveryCatalogWatcherController.getIfAvailable());\n      Assertions.assertNull(heartBeatListener.getIfAvailable());\n    }\n  }\n@Nested @SpringBootTest(classes\u003dTestConfig.class,properties\u003d{\"spring.cloud.kubernetes.discovery.catalog-services-watch.enabled\u003dfalse\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dfalse\",\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class CatalogControllerNotPresentThree {\n    @Autowired private ObjectProvider\u003cDiscoveryServerController\u003e discoveryServerController;\n    @Autowired private ObjectProvider\u003cDiscoveryCatalogWatcherController\u003e discoveryCatalogWatcherController;\n    @Autowired private ObjectProvider\u003cHeartBeatListener\u003e heartBeatListener;\n    @Test void test(){\n      Assertions.assertNotNull(discoveryServerController.getIfAvailable());\n      Assertions.assertNull(discoveryCatalogWatcherController.getIfAvailable());\n      Assertions.assertNull(heartBeatListener.getIfAvailable());\n    }\n  }\n@TestConfiguration static class TestConfig {\n    @Bean KubernetesInformerReactiveDiscoveryClient discoveryClient(){\n      return Mockito.mock(KubernetesInformerReactiveDiscoveryClient.class);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass DiscoveryServerApplicationContextTests {\n@Nested @SpringBootTest(classes\u003dTestConfig.class,properties\u003d{\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\",\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class BothControllersPresent {\n    @Autowired private ObjectProvider\u003cDiscoveryServerController\u003e discoveryServerController;\n    @Autowired private ObjectProvider\u003cDiscoveryCatalogWatcherController\u003e discoveryCatalogWatcherController;\n    @Autowired private ObjectProvider\u003cHeartBeatListener\u003e heartBeatListener;\n    @Test void test();\n  }\n@Nested @SpringBootTest(classes\u003dTestConfig.class,properties\u003d{\"spring.cloud.kubernetes.discovery.catalog-services-watch.enabled\u003dfalse\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\",\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class CatalogControllerNotPresentOne {\n    @Autowired private ObjectProvider\u003cDiscoveryServerController\u003e discoveryServerController;\n    @Autowired private ObjectProvider\u003cDiscoveryCatalogWatcherController\u003e discoveryCatalogWatcherController;\n    @Autowired private ObjectProvider\u003cHeartBeatListener\u003e heartBeatListener;\n    @Test void test();\n  }\n@Nested @SpringBootTest(classes\u003dTestConfig.class,properties\u003d{\"spring.cloud.kubernetes.discovery.catalog-services-watch.enabled\u003dtrue\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dfalse\",\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class CatalogControllerNotPresentTwo {\n    @Autowired private ObjectProvider\u003cDiscoveryServerController\u003e discoveryServerController;\n    @Autowired private ObjectProvider\u003cDiscoveryCatalogWatcherController\u003e discoveryCatalogWatcherController;\n    @Autowired private ObjectProvider\u003cHeartBeatListener\u003e heartBeatListener;\n    @Test void test();\n  }\n@Nested @SpringBootTest(classes\u003dTestConfig.class,properties\u003d{\"spring.cloud.kubernetes.discovery.catalog-services-watch.enabled\u003dfalse\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dfalse\",\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class CatalogControllerNotPresentThree {\n    @Autowired private ObjectProvider\u003cDiscoveryServerController\u003e discoveryServerController;\n    @Autowired private ObjectProvider\u003cDiscoveryCatalogWatcherController\u003e discoveryCatalogWatcherController;\n    @Autowired private ObjectProvider\u003cHeartBeatListener\u003e heartBeatListener;\n    @Test void test();\n  }\n@TestConfiguration static class TestConfig {\n    @Bean KubernetesInformerReactiveDiscoveryClient discoveryClient();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/test/java/org/springframework/cloud/kubernetes/discoveryserver/DiscoveryCatalogWatcherControllerTests.java",
        "name": "DiscoveryCatalogWatcherControllerTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryserver.DiscoveryCatalogWatcherControllerTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass DiscoveryCatalogWatcherControllerTests {\n  private final HeartBeatListener heartBeatListener\u003dMockito.mock(HeartBeatListener.class);\n  @Test void test(){\n    Mockito.when(heartBeatListener.lastState()).thenReturn(new AtomicReference\u003c\u003e(List.of(new EndpointNameAndNamespace(\"one\",\"two\"))));\n    DiscoveryCatalogWatcherController catalogWatcherController\u003dnew DiscoveryCatalogWatcherController(heartBeatListener);\n    StepVerifier.create(catalogWatcherController.state()).expectNext(List.of(new EndpointNameAndNamespace(\"one\",\"two\"))).verifyComplete();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass DiscoveryCatalogWatcherControllerTests {\n  private final HeartBeatListener heartBeatListener\u003dMockito.mock(HeartBeatListener.class);\n  @Test void test();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/test/java/org/springframework/cloud/kubernetes/discoveryserver/Util.java",
        "name": "Util",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryserver.Util",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class Util {\n  private Util(){\n  }\n  static Lister\u003cV1Service\u003e setupServiceLister(  V1Service... services){\n    Cache\u003cV1Service\u003e serviceCache\u003dnew Cache\u003c\u003e();\n    Lister\u003cV1Service\u003e serviceLister\u003dnew Lister\u003c\u003e(serviceCache);\n    for (    V1Service svc : services) {\n      serviceCache.add(svc);\n    }\n    return serviceLister;\n  }\n  static Lister\u003cV1Endpoints\u003e setupEndpointsLister(  V1Endpoints... endpoints){\n    Cache\u003cV1Endpoints\u003e endpointsCache\u003dnew Cache\u003c\u003e();\n    Lister\u003cV1Endpoints\u003e endpointsLister\u003dnew Lister\u003c\u003e(endpointsCache);\n    for (    V1Endpoints ep : endpoints) {\n      endpointsCache.add(ep);\n    }\n    return endpointsLister;\n  }\n  record InstanceForTest(  String name,  List\u003cDefaultKubernetesServiceInstance\u003e serviceInstances){\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class Util {\n  private Util();\n  static Lister\u003cV1Service\u003e setupServiceLister(  V1Service... services);\n  static Lister\u003cV1Endpoints\u003e setupEndpointsLister(  V1Endpoints... endpoints);\n  record InstanceForTest(  String name,  List\u003cDefaultKubernetesServiceInstance\u003e serviceInstances);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/test/java/org/springframework/cloud/kubernetes/discoveryserver/DiscoveryServerIntegrationAppsEndpointTest.java",
        "name": "DiscoveryServerIntegrationAppsEndpointTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dDiscoveryServerIntegrationAppsEndpointTest.TestConfig.class,properties\u003d{\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryserver.DiscoveryServerIntegrationAppsEndpointTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dDiscoveryServerIntegrationAppsEndpointTest.TestConfig.class,properties\u003d{\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class DiscoveryServerIntegrationAppsEndpointTest {\n  private static final String NAMESPACE\u003d\"namespace\";\n  private static final SharedInformerFactory SHARED_INFORMER_FACTORY\u003dMockito.mock(SharedInformerFactory.class);\n  private static final V1Service TEST_SERVICE_A\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(NAMESPACE)).spec(new V1ServiceSpec().type(\"ClusterIP\"));\n  private static final V1Service TEST_SERVICE_B\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"test-svc-2\").namespace(NAMESPACE).putLabelsItem(\"spring\",\"true\").putLabelsItem(\"k8s\",\"true\")).spec(new V1ServiceSpec().type(\"ClusterIP\"));\n  private static final V1Endpoints TEST_ENDPOINTS_A\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(NAMESPACE)).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080).name(\"http\")).addAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\").targetRef(new V1ObjectReferenceBuilder().withUid(\"uid1\").build())));\n  private static final V1Endpoints TEST_ENDPOINTS_B\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-2\").namespace(NAMESPACE)).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080).name(\"http\")).addAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\").targetRef(new V1ObjectReferenceBuilder().withUid(\"uid2\").build())));\n  @Autowired private WebTestClient webTestClient;\n  @Test void apps(){\n    Map\u003cString,String\u003e metadataA\u003dnew HashMap\u003c\u003e();\n    metadataA.put(\"type\",\"ClusterIP\");\n    metadataA.put(\"port.http\",\"8080\");\n    metadataA.put(\"k8s_namespace\",\"namespace\");\n    Map\u003cString,String\u003e metadataB\u003dnew HashMap\u003c\u003e(metadataA);\n    metadataB.put(\"spring\",\"true\");\n    metadataB.put(\"k8s\",\"true\");\n    DefaultKubernetesServiceInstance kubernetesServiceInstance1\u003dnew DefaultKubernetesServiceInstance(TEST_ENDPOINTS_A.getSubsets().get(0).getAddresses().get(0).getTargetRef().getUid(),TEST_SERVICE_A.getMetadata().getName(),TEST_ENDPOINTS_A.getSubsets().get(0).getAddresses().get(0).getIp(),TEST_ENDPOINTS_A.getSubsets().get(0).getPorts().get(0).getPort(),metadataA,false,TEST_SERVICE_A.getMetadata().getNamespace(),null);\n    DefaultKubernetesServiceInstance kubernetesServiceInstance2\u003dnew DefaultKubernetesServiceInstance(TEST_ENDPOINTS_B.getSubsets().get(0).getAddresses().get(0).getTargetRef().getUid(),TEST_SERVICE_B.getMetadata().getName(),TEST_ENDPOINTS_B.getSubsets().get(0).getAddresses().get(0).getIp(),TEST_ENDPOINTS_B.getSubsets().get(0).getPorts().get(0).getPort(),metadataB,false,TEST_SERVICE_B.getMetadata().getNamespace(),null);\n    webTestClient.get().uri(\"/apps\").exchange().expectBodyList(Util.InstanceForTest.class).hasSize(2).contains(new Util.InstanceForTest(TEST_SERVICE_A.getMetadata().getName(),Collections.singletonList(kubernetesServiceInstance1)),new Util.InstanceForTest(TEST_SERVICE_B.getMetadata().getName(),Collections.singletonList(kubernetesServiceInstance2)));\n  }\n@TestConfiguration static class TestConfig {\n    @Bean KubernetesNamespaceProvider kubernetesNamespaceProvider(){\n      KubernetesNamespaceProvider provider\u003dmock(KubernetesNamespaceProvider.class);\n      when(provider.getNamespace()).thenReturn(NAMESPACE);\n      return provider;\n    }\n    @Bean KubernetesInformerReactiveDiscoveryClient discoveryClient(){\n      return new HandleToReactiveDiscoveryClient(kubernetesInformerDiscoveryClient());\n    }\n    private KubernetesInformerDiscoveryClient kubernetesInformerDiscoveryClient(){\n      Lister\u003cV1Service\u003e serviceLister\u003dUtil.setupServiceLister(TEST_SERVICE_A,TEST_SERVICE_B);\n      Lister\u003cV1Endpoints\u003e endpointsLister\u003dUtil.setupEndpointsLister(TEST_ENDPOINTS_A,TEST_ENDPOINTS_B);\n      return new KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,KubernetesDiscoveryProperties.DEFAULT);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dDiscoveryServerIntegrationAppsEndpointTest.TestConfig.class,properties\u003d{\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class DiscoveryServerIntegrationAppsEndpointTest {\n  private static final String NAMESPACE\u003d\"namespace\";\n  private static final SharedInformerFactory SHARED_INFORMER_FACTORY\u003dMockito.mock(SharedInformerFactory.class);\n  private static final V1Service TEST_SERVICE_A\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(NAMESPACE)).spec(new V1ServiceSpec().type(\"ClusterIP\"));\n  private static final V1Service TEST_SERVICE_B\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"test-svc-2\").namespace(NAMESPACE).putLabelsItem(\"spring\",\"true\").putLabelsItem(\"k8s\",\"true\")).spec(new V1ServiceSpec().type(\"ClusterIP\"));\n  private static final V1Endpoints TEST_ENDPOINTS_A\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-1\").namespace(NAMESPACE)).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080).name(\"http\")).addAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\").targetRef(new V1ObjectReferenceBuilder().withUid(\"uid1\").build())));\n  private static final V1Endpoints TEST_ENDPOINTS_B\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-2\").namespace(NAMESPACE)).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080).name(\"http\")).addAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\").targetRef(new V1ObjectReferenceBuilder().withUid(\"uid2\").build())));\n  @Autowired private WebTestClient webTestClient;\n  @Test void apps();\n@TestConfiguration static class TestConfig {\n    @Bean KubernetesNamespaceProvider kubernetesNamespaceProvider();\n    @Bean KubernetesInformerReactiveDiscoveryClient discoveryClient();\n    private KubernetesInformerDiscoveryClient kubernetesInformerDiscoveryClient();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/test/java/org/springframework/cloud/kubernetes/discoveryserver/DiscoveryServerIntegrationAppsNameEndpointTest.java",
        "name": "DiscoveryServerIntegrationAppsNameEndpointTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dDiscoveryServerIntegrationAppsNameEndpointTest.TestConfig.class,properties\u003d{\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryserver.DiscoveryServerIntegrationAppsNameEndpointTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dDiscoveryServerIntegrationAppsNameEndpointTest.TestConfig.class,properties\u003d{\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class DiscoveryServerIntegrationAppsNameEndpointTest {\n  private static final String NAMESPACE\u003d\"namespace\";\n  private static final SharedInformerFactory SHARED_INFORMER_FACTORY\u003dMockito.mock(SharedInformerFactory.class);\n  private static final V1Service TEST_SERVICE\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"test-svc-3\").namespace(NAMESPACE).putLabelsItem(\"spring\",\"true\").putLabelsItem(\"k8s\",\"true\")).spec(new V1ServiceSpec().loadBalancerIP(\"1.1.1.1\").type(\"ClusterIP\")).status(new V1ServiceStatus());\n  private static final V1Endpoints TEST_ENDPOINTS\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-3\").namespace(NAMESPACE)).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080).name(\"http\")).addAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\").targetRef(new V1ObjectReferenceBuilder().withUid(\"uid2\").build())));\n  @Autowired private WebTestClient webTestClient;\n  @Test void appsName(){\n    Map\u003cString,String\u003e metadata\u003dnew HashMap\u003c\u003e();\n    metadata.put(\"spring\",\"true\");\n    metadata.put(\"port.http\",\"8080\");\n    metadata.put(\"k8s_namespace\",\"namespace\");\n    metadata.put(\"type\",\"ClusterIP\");\n    metadata.put(\"k8s\",\"true\");\n    DefaultKubernetesServiceInstance kubernetesServiceInstance\u003dnew DefaultKubernetesServiceInstance(TEST_ENDPOINTS.getSubsets().get(0).getAddresses().get(0).getTargetRef().getUid(),TEST_SERVICE.getMetadata().getName(),TEST_ENDPOINTS.getSubsets().get(0).getAddresses().get(0).getIp(),TEST_ENDPOINTS.getSubsets().get(0).getPorts().get(0).getPort(),metadata,false,TEST_SERVICE.getMetadata().getNamespace(),null);\n    webTestClient.get().uri(\"/apps/test-svc-3\").exchange().expectBodyList(DefaultKubernetesServiceInstance.class).hasSize(1).contains(kubernetesServiceInstance);\n  }\n@TestConfiguration static class TestConfig {\n    @Bean KubernetesNamespaceProvider kubernetesNamespaceProvider(){\n      KubernetesNamespaceProvider provider\u003dmock(KubernetesNamespaceProvider.class);\n      when(provider.getNamespace()).thenReturn(NAMESPACE);\n      return provider;\n    }\n    @Bean KubernetesInformerReactiveDiscoveryClient discoveryClient(){\n      return new HandleToReactiveDiscoveryClient(kubernetesInformerDiscoveryClient());\n    }\n    private KubernetesInformerDiscoveryClient kubernetesInformerDiscoveryClient(){\n      Lister\u003cV1Service\u003e serviceLister\u003dUtil.setupServiceLister(TEST_SERVICE);\n      Lister\u003cV1Endpoints\u003e endpointsLister\u003dUtil.setupEndpointsLister(TEST_ENDPOINTS);\n      return new KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,KubernetesDiscoveryProperties.DEFAULT);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dDiscoveryServerIntegrationAppsNameEndpointTest.TestConfig.class,properties\u003d{\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class DiscoveryServerIntegrationAppsNameEndpointTest {\n  private static final String NAMESPACE\u003d\"namespace\";\n  private static final SharedInformerFactory SHARED_INFORMER_FACTORY\u003dMockito.mock(SharedInformerFactory.class);\n  private static final V1Service TEST_SERVICE\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"test-svc-3\").namespace(NAMESPACE).putLabelsItem(\"spring\",\"true\").putLabelsItem(\"k8s\",\"true\")).spec(new V1ServiceSpec().loadBalancerIP(\"1.1.1.1\").type(\"ClusterIP\")).status(new V1ServiceStatus());\n  private static final V1Endpoints TEST_ENDPOINTS\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-3\").namespace(NAMESPACE)).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080).name(\"http\")).addAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\").targetRef(new V1ObjectReferenceBuilder().withUid(\"uid2\").build())));\n  @Autowired private WebTestClient webTestClient;\n  @Test void appsName();\n@TestConfiguration static class TestConfig {\n    @Bean KubernetesNamespaceProvider kubernetesNamespaceProvider();\n    @Bean KubernetesInformerReactiveDiscoveryClient discoveryClient();\n    private KubernetesInformerDiscoveryClient kubernetesInformerDiscoveryClient();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/test/java/org/springframework/cloud/kubernetes/discoveryserver/HeartbeatTest.java",
        "name": "HeartbeatTest",
        "modifiers": "@SpringBootTest(classes\u003dHeartbeatTest.TestConfig.class,properties\u003d{\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\",\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) @AutoConfigureWebTestClient",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryserver.HeartbeatTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(classes\u003dHeartbeatTest.TestConfig.class,properties\u003d{\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\",\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) @AutoConfigureWebTestClient class HeartbeatTest {\n  @Autowired private WebTestClient client;\n  @Autowired private ApplicationContext context;\n  @Test void testHeartbeat(){\n    Assertions.assertTrue(true);\n    client.get().uri(\"/state\").exchange().expectStatus().is2xxSuccessful().expectBody().json(\"[]\");\n    context.getBean(HeartbeatPublisher.class).publishEvent();\n    client.get().uri(\"/state\").exchange().expectStatus().is2xxSuccessful().expectBody().json(null);\n  }\n@TestConfiguration static class TestConfig {\n    @Bean KubernetesInformerReactiveDiscoveryClient client(){\n      return Mockito.mock(KubernetesInformerReactiveDiscoveryClient.class);\n    }\n    @Bean HeartbeatPublisher heartbeatPublisher(){\n      return new HeartbeatPublisher();\n    }\n  }\nstatic class HeartbeatPublisher implements ApplicationEventPublisherAware {\n    private ApplicationEventPublisher publisher;\n    @Override public void setApplicationEventPublisher(    ApplicationEventPublisher publisher){\n      this.publisher\u003dpublisher;\n    }\n    void publishEvent(){\n      publisher.publishEvent(new HeartbeatEvent(\"test\",List.of(new EndpointNameAndNamespace(\"endpoint-name\",\"namespaceA\"))));\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(classes\u003dHeartbeatTest.TestConfig.class,properties\u003d{\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\",\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) @AutoConfigureWebTestClient class HeartbeatTest {\n  @Autowired private WebTestClient client;\n  @Autowired private ApplicationContext context;\n  @Test void testHeartbeat();\n@TestConfiguration static class TestConfig {\n    @Bean KubernetesInformerReactiveDiscoveryClient client();\n    @Bean HeartbeatPublisher heartbeatPublisher();\n  }\nstatic class HeartbeatPublisher implements ApplicationEventPublisherAware {\n    private ApplicationEventPublisher publisher;\n    @Override public void setApplicationEventPublisher(    ApplicationEventPublisher publisher);\n    void publishEvent();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/test/java/org/springframework/cloud/kubernetes/discoveryserver/DiscoveryServerControllerTests.java",
        "name": "DiscoveryServerControllerTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryserver.DiscoveryServerControllerTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass DiscoveryServerControllerTests {\n  private static final DefaultKubernetesServiceInstance SERVICE_A_INSTANCE_1\u003dnew DefaultKubernetesServiceInstance(\"serviceAInstance1\",\"serviceAInstance1\",\"2.2.2.2\",8080,Map.of(),false,\"namespace1\",null);\n  private static final DefaultKubernetesServiceInstance SERVICE_A_INSTANCE_2\u003dnew DefaultKubernetesServiceInstance(\"serviceAInstance2\",\"serviceAInstance2\",\"2.2.2.2\",8080,Map.of(),false,\"namespace1\",null);\n  private static final DefaultKubernetesServiceInstance SERVICE_A_INSTANCE_3\u003dnew DefaultKubernetesServiceInstance(\"serviceAInstance3\",\"serviceAInstance3\",\"2.2.2.2\",8080,Map.of(),false,\"namespace2\",null);\n  private static final DefaultKubernetesServiceInstance SERVICE_B_INSTANCE_1\u003dnew DefaultKubernetesServiceInstance(\"serviceBInstance1\",\"serviceBInstance1\",\"2.2.2.2\",8080,Map.of(),false,\"namespace1\",null);\n  private static final DefaultKubernetesServiceInstance SERVICE_C_INSTANCE_1\u003dnew DefaultKubernetesServiceInstance(\"serviceCInstance1\",\"serviceCInstance1\",\"2.2.2.2\",8080,Map.of(),false,\"namespace2\",null);\n  private static Service serviceA;\n  private static Service serviceB;\n  private static Service serviceC;\n  private static KubernetesInformerReactiveDiscoveryClient discoveryClient;\n  @BeforeAll static void beforeAll(){\n    Flux\u003cString\u003e services\u003dFlux.just(\"serviceA\",\"serviceB\",\"serviceC\");\n    List\u003cDefaultKubernetesServiceInstance\u003e serviceAInstanceList\u003dnew ArrayList\u003c\u003e();\n    serviceAInstanceList.add(SERVICE_A_INSTANCE_1);\n    serviceAInstanceList.add(SERVICE_A_INSTANCE_2);\n    serviceAInstanceList.add(SERVICE_A_INSTANCE_3);\n    Flux\u003cServiceInstance\u003e serviceAInstances\u003dFlux.fromIterable(serviceAInstanceList);\n    List\u003cDefaultKubernetesServiceInstance\u003e serviceBInstanceList\u003dCollections.singletonList(SERVICE_B_INSTANCE_1);\n    Flux\u003cServiceInstance\u003e serviceBInstances\u003dFlux.fromIterable(serviceBInstanceList);\n    List\u003cDefaultKubernetesServiceInstance\u003e serviceCInstanceList\u003dCollections.singletonList(SERVICE_C_INSTANCE_1);\n    Flux\u003cServiceInstance\u003e serviceCInstances\u003dFlux.fromIterable(serviceCInstanceList);\n    discoveryClient\u003dmock(KubernetesInformerReactiveDiscoveryClient.class);\n    when(discoveryClient.getServices()).thenReturn(services);\n    when(discoveryClient.getInstances(eq(\"serviceA\"))).thenReturn(serviceAInstances);\n    when(discoveryClient.getInstances(eq(\"serviceB\"))).thenReturn(serviceBInstances);\n    when(discoveryClient.getInstances(eq(\"serviceC\"))).thenReturn(serviceCInstances);\n    when(discoveryClient.getInstances(eq(\"serviceD\"))).thenReturn(Flux.empty());\n    serviceA\u003dnew Service(\"serviceA\",serviceAInstanceList);\n    serviceB\u003dnew Service(\"serviceB\",serviceBInstanceList);\n    serviceC\u003dnew Service(\"serviceC\",serviceCInstanceList);\n  }\n  @Test void apps(){\n    DiscoveryServerController controller\u003dnew DiscoveryServerController(discoveryClient);\n    StepVerifier.create(controller.apps()).expectNext(serviceA,serviceB,serviceC).verifyComplete();\n  }\n  @Test void appInstances(){\n    DiscoveryServerController controller\u003dnew DiscoveryServerController(discoveryClient);\n    StepVerifier.create(controller.appInstances(\"serviceA\")).expectNext(SERVICE_A_INSTANCE_1,SERVICE_A_INSTANCE_2,SERVICE_A_INSTANCE_3).verifyComplete();\n    StepVerifier.create(controller.appInstances(\"serviceB\")).expectNext(SERVICE_B_INSTANCE_1).verifyComplete();\n    StepVerifier.create(controller.appInstances(\"serviceC\")).expectNext(SERVICE_C_INSTANCE_1).verifyComplete();\n    StepVerifier.create(controller.appInstances(\"serviceD\")).expectNextCount(0).verifyComplete();\n  }\n  @Test void appInstance(){\n    DiscoveryServerController controller\u003dnew DiscoveryServerController(discoveryClient);\n    StepVerifier.create(controller.appInstance(\"serviceA\",\"serviceAInstance2\")).expectNext(SERVICE_A_INSTANCE_2).verifyComplete();\n    StepVerifier.create(controller.appInstance(\"serviceB\",\"doesnotexist\")).expectNextCount(0).verifyComplete();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass DiscoveryServerControllerTests {\n  private static final DefaultKubernetesServiceInstance SERVICE_A_INSTANCE_1\u003dnew DefaultKubernetesServiceInstance(\"serviceAInstance1\",\"serviceAInstance1\",\"2.2.2.2\",8080,Map.of(),false,\"namespace1\",null);\n  private static final DefaultKubernetesServiceInstance SERVICE_A_INSTANCE_2\u003dnew DefaultKubernetesServiceInstance(\"serviceAInstance2\",\"serviceAInstance2\",\"2.2.2.2\",8080,Map.of(),false,\"namespace1\",null);\n  private static final DefaultKubernetesServiceInstance SERVICE_A_INSTANCE_3\u003dnew DefaultKubernetesServiceInstance(\"serviceAInstance3\",\"serviceAInstance3\",\"2.2.2.2\",8080,Map.of(),false,\"namespace2\",null);\n  private static final DefaultKubernetesServiceInstance SERVICE_B_INSTANCE_1\u003dnew DefaultKubernetesServiceInstance(\"serviceBInstance1\",\"serviceBInstance1\",\"2.2.2.2\",8080,Map.of(),false,\"namespace1\",null);\n  private static final DefaultKubernetesServiceInstance SERVICE_C_INSTANCE_1\u003dnew DefaultKubernetesServiceInstance(\"serviceCInstance1\",\"serviceCInstance1\",\"2.2.2.2\",8080,Map.of(),false,\"namespace2\",null);\n  private static Service serviceA;\n  private static Service serviceB;\n  private static Service serviceC;\n  private static KubernetesInformerReactiveDiscoveryClient discoveryClient;\n  @BeforeAll static void beforeAll();\n  @Test void apps();\n  @Test void appInstances();\n  @Test void appInstance();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/test/java/org/springframework/cloud/kubernetes/discoveryserver/DiscoveryServerIntegrationInstanceEndpointTest.java",
        "name": "DiscoveryServerIntegrationInstanceEndpointTest",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dDiscoveryServerIntegrationInstanceEndpointTest.TestConfig.class,properties\u003d{\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryserver.DiscoveryServerIntegrationInstanceEndpointTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dDiscoveryServerIntegrationInstanceEndpointTest.TestConfig.class,properties\u003d{\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class DiscoveryServerIntegrationInstanceEndpointTest {\n  private static final String NAMESPACE\u003d\"namespace\";\n  private static final SharedInformerFactory SHARED_INFORMER_FACTORY\u003dMockito.mock(SharedInformerFactory.class);\n  private static final V1Service TEST_SERVICE\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"test-svc-3\").namespace(NAMESPACE).putLabelsItem(\"spring\",\"true\").putLabelsItem(\"k8s\",\"true\")).spec(new V1ServiceSpec().loadBalancerIP(\"1.1.1.1\").type(\"ClusterIP\")).status(new V1ServiceStatus());\n  private static final V1Endpoints TEST_ENDPOINTS\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-3\").namespace(NAMESPACE)).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080).name(\"http\")).addAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\").targetRef(new V1ObjectReferenceBuilder().withUid(\"uid2\").build())));\n  @Autowired private WebTestClient webTestClient;\n  @Test void instanceDeprecated(){\n    Map\u003cString,String\u003e metadata\u003dnew HashMap\u003c\u003e();\n    metadata.put(\"spring\",\"true\");\n    metadata.put(\"port.http\",\"8080\");\n    metadata.put(\"k8s_namespace\",\"namespace\");\n    metadata.put(\"type\",\"ClusterIP\");\n    metadata.put(\"k8s\",\"true\");\n    DefaultKubernetesServiceInstance kubernetesServiceInstance\u003dnew DefaultKubernetesServiceInstance(TEST_ENDPOINTS.getSubsets().get(0).getAddresses().get(0).getTargetRef().getUid(),TEST_SERVICE.getMetadata().getName(),TEST_ENDPOINTS.getSubsets().get(0).getAddresses().get(0).getIp(),TEST_ENDPOINTS.getSubsets().get(0).getPorts().get(0).getPort(),metadata,false,TEST_SERVICE.getMetadata().getNamespace(),null);\n    webTestClient.get().uri(\"/app/test-svc-3/uid2\").exchange().expectBody(DefaultKubernetesServiceInstance.class).isEqualTo(kubernetesServiceInstance);\n  }\n  @Test void instance(){\n    Map\u003cString,String\u003e metadata\u003dnew HashMap\u003c\u003e();\n    metadata.put(\"spring\",\"true\");\n    metadata.put(\"port.http\",\"8080\");\n    metadata.put(\"k8s_namespace\",\"namespace\");\n    metadata.put(\"type\",\"ClusterIP\");\n    metadata.put(\"k8s\",\"true\");\n    DefaultKubernetesServiceInstance kubernetesServiceInstance\u003dnew DefaultKubernetesServiceInstance(TEST_ENDPOINTS.getSubsets().get(0).getAddresses().get(0).getTargetRef().getUid(),TEST_SERVICE.getMetadata().getName(),TEST_ENDPOINTS.getSubsets().get(0).getAddresses().get(0).getIp(),TEST_ENDPOINTS.getSubsets().get(0).getPorts().get(0).getPort(),metadata,false,TEST_SERVICE.getMetadata().getNamespace(),null);\n    webTestClient.get().uri(\"/apps/test-svc-3/uid2\").exchange().expectBody(DefaultKubernetesServiceInstance.class).isEqualTo(kubernetesServiceInstance);\n  }\n@TestConfiguration static class TestConfig {\n    @Bean KubernetesNamespaceProvider kubernetesNamespaceProvider(){\n      KubernetesNamespaceProvider provider\u003dmock(KubernetesNamespaceProvider.class);\n      when(provider.getNamespace()).thenReturn(NAMESPACE);\n      return provider;\n    }\n    @Bean KubernetesInformerReactiveDiscoveryClient discoveryClient(){\n      return new HandleToReactiveDiscoveryClient(kubernetesInformerDiscoveryClient());\n    }\n    private KubernetesInformerDiscoveryClient kubernetesInformerDiscoveryClient(){\n      Lister\u003cV1Service\u003e serviceLister\u003dUtil.setupServiceLister(TEST_SERVICE);\n      Lister\u003cV1Endpoints\u003e endpointsLister\u003dUtil.setupEndpointsLister(TEST_ENDPOINTS);\n      return new KubernetesInformerDiscoveryClient(SHARED_INFORMER_FACTORY,serviceLister,endpointsLister,null,null,KubernetesDiscoveryProperties.DEFAULT);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dDiscoveryServerIntegrationInstanceEndpointTest.TestConfig.class,properties\u003d{\"management.health.livenessstate.enabled\u003dtrue\",\"management.endpoint.health.group.liveness.include\u003dlivenessState\",\"management.health.readinessstate.enabled\u003dtrue\",\"management.endpoint.health.group.readiness.include\u003dreadinessState\"}) class DiscoveryServerIntegrationInstanceEndpointTest {\n  private static final String NAMESPACE\u003d\"namespace\";\n  private static final SharedInformerFactory SHARED_INFORMER_FACTORY\u003dMockito.mock(SharedInformerFactory.class);\n  private static final V1Service TEST_SERVICE\u003dnew V1Service().metadata(new V1ObjectMeta().name(\"test-svc-3\").namespace(NAMESPACE).putLabelsItem(\"spring\",\"true\").putLabelsItem(\"k8s\",\"true\")).spec(new V1ServiceSpec().loadBalancerIP(\"1.1.1.1\").type(\"ClusterIP\")).status(new V1ServiceStatus());\n  private static final V1Endpoints TEST_ENDPOINTS\u003dnew V1Endpoints().metadata(new V1ObjectMeta().name(\"test-svc-3\").namespace(NAMESPACE)).addSubsetsItem(new V1EndpointSubset().addPortsItem(new CoreV1EndpointPort().port(8080).name(\"http\")).addAddressesItem(new V1EndpointAddress().ip(\"2.2.2.2\").targetRef(new V1ObjectReferenceBuilder().withUid(\"uid2\").build())));\n  @Autowired private WebTestClient webTestClient;\n  @Test void instanceDeprecated();\n  @Test void instance();\n@TestConfiguration static class TestConfig {\n    @Bean KubernetesNamespaceProvider kubernetesNamespaceProvider();\n    @Bean KubernetesInformerReactiveDiscoveryClient discoveryClient();\n    private KubernetesInformerDiscoveryClient kubernetesInformerDiscoveryClient();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/ConfigurationWatcherAutoConfiguration.java",
        "name": "ConfigurationWatcherAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @EnableConfigurationProperties({ConfigurationWatcherConfigurationProperties.class}) @Import({ConfigurationWatcherAutoConfiguration.RefreshTriggerConfiguration.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.ConfigurationWatcherAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\n@Configuration(proxyBeanMethods\u003dfalse) @EnableConfigurationProperties({ConfigurationWatcherConfigurationProperties.class}) @Import({ConfigurationWatcherAutoConfiguration.RefreshTriggerConfiguration.class}) public class ConfigurationWatcherAutoConfiguration {\n  private static final String AMQP\u003d\"bus-amqp\";\n  private static final String KAFKA\u003d\"bus-kafka\";\n  @Bean @ConditionalOnMissingBean public WebClient webClient(  WebClient.Builder webClientBuilder){\n    return webClientBuilder.build();\n  }\n  @Bean @ConditionalOnMissingBean(ConfigMapWatcherChangeDetector.class) @ConditionalOnBean(KubernetesClientConfigMapPropertySourceLocator.class) public ConfigMapWatcherChangeDetector httpBasedConfigMapWatchChangeDetector(  AbstractEnvironment environment,  CoreV1Api coreV1Api,  KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  KubernetesNamespaceProvider namespaceProvider,  ThreadPoolTaskExecutor threadFactory,  HttpRefreshTrigger httpRefreshTrigger){\n    return new HttpBasedConfigMapWatchChangeDetector(coreV1Api,environment,properties,strategy,configMapPropertySourceLocator,namespaceProvider,k8SConfigurationProperties,threadFactory,httpRefreshTrigger);\n  }\n  @Bean @ConditionalOnMissingBean @ConditionalOnBean(KubernetesClientSecretsPropertySourceLocator.class) public SecretsWatcherChangeDetector httpBasedSecretsWatchChangeDetector(  AbstractEnvironment environment,  CoreV1Api coreV1Api,  KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator,  KubernetesNamespaceProvider namespaceProvider,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadFactory,  HttpRefreshTrigger httpRefreshTrigger){\n    return new HttpBasedSecretsWatchChangeDetector(coreV1Api,environment,properties,strategy,secretsPropertySourceLocator,namespaceProvider,k8SConfigurationProperties,threadFactory,httpRefreshTrigger);\n  }\n@Configuration @Profile(AMQP) @Import({ContextFunctionCatalogAutoConfiguration.class,RabbitHealthContributorAutoConfiguration.class,RefreshTriggerConfiguration.class}) static class BusRabbitConfiguration {\n    @Bean @ConditionalOnMissingBean(ConfigMapWatcherChangeDetector.class) @ConditionalOnBean(KubernetesClientConfigMapPropertySourceLocator.class) public ConfigMapWatcherChangeDetector busConfigMapChangeWatcher(    AbstractEnvironment environment,    CoreV1Api coreV1Api,    KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator,    KubernetesNamespaceProvider kubernetesNamespaceProvider,    ConfigReloadProperties properties,    ConfigurationUpdateStrategy strategy,    ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,    ThreadPoolTaskExecutor threadFactory,    BusRefreshTrigger busRefreshTrigger){\n      return new BusEventBasedConfigMapWatcherChangeDetector(coreV1Api,environment,properties,strategy,configMapPropertySourceLocator,kubernetesNamespaceProvider,k8SConfigurationProperties,threadFactory,busRefreshTrigger);\n    }\n    @Bean @ConditionalOnMissingBean(SecretsWatcherChangeDetector.class) @ConditionalOnBean(KubernetesClientSecretsPropertySourceLocator.class) public SecretsWatcherChangeDetector busSecretsChangeWatcher(    AbstractEnvironment environment,    CoreV1Api coreV1Api,    KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator,    ConfigReloadProperties properties,    KubernetesNamespaceProvider kubernetesNamespaceProvider,    ConfigurationUpdateStrategy strategy,    ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,    ThreadPoolTaskExecutor threadFactory,    BusRefreshTrigger busRefreshTrigger){\n      return new BusEventBasedSecretsWatcherChangeDetector(coreV1Api,environment,properties,strategy,secretsPropertySourceLocator,kubernetesNamespaceProvider,k8SConfigurationProperties,threadFactory,busRefreshTrigger);\n    }\n  }\n@Configuration @Profile(KAFKA) @Import({ContextFunctionCatalogAutoConfiguration.class,RefreshTriggerConfiguration.class}) static class BusKafkaConfiguration {\n    @Bean @ConditionalOnMissingBean(ConfigMapWatcherChangeDetector.class) @ConditionalOnBean(KubernetesClientConfigMapPropertySourceLocator.class) public ConfigMapWatcherChangeDetector busConfigMapChangeWatcher(    AbstractEnvironment environment,    CoreV1Api coreV1Api,    KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator,    ConfigReloadProperties properties,    KubernetesNamespaceProvider namespaceProvider,    ConfigurationUpdateStrategy strategy,    ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,    ThreadPoolTaskExecutor threadFactory,    BusRefreshTrigger busRefreshTrigger){\n      return new BusEventBasedConfigMapWatcherChangeDetector(coreV1Api,environment,properties,strategy,configMapPropertySourceLocator,namespaceProvider,k8SConfigurationProperties,threadFactory,busRefreshTrigger);\n    }\n    @Bean @ConditionalOnMissingBean(SecretsWatcherChangeDetector.class) @ConditionalOnBean(KubernetesClientSecretsPropertySourceLocator.class) public SecretsWatcherChangeDetector busSecretsChangeWatcher(    AbstractEnvironment environment,    CoreV1Api coreV1Api,    KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator,    ConfigReloadProperties properties,    ConfigurationUpdateStrategy strategy,    ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,    ThreadPoolTaskExecutor threadFactory,    KubernetesNamespaceProvider namespaceProvider,    BusRefreshTrigger busRefreshTrigger){\n      return new BusEventBasedSecretsWatcherChangeDetector(coreV1Api,environment,properties,strategy,secretsPropertySourceLocator,namespaceProvider,k8SConfigurationProperties,threadFactory,busRefreshTrigger);\n    }\n  }\n@AutoConfiguration static class RefreshTriggerConfiguration {\n    @Bean @ConditionalOnMissingBean @Profile({AMQP,KAFKA}) public BusRefreshTrigger busRefreshTrigger(    ApplicationEventPublisher applicationEventPublisher,    BusProperties busProperties){\n      return new BusRefreshTrigger(applicationEventPublisher,busProperties.getId());\n    }\n    @Bean @ConditionalOnMissingBean public HttpRefreshTrigger httpRefreshTrigger(    KubernetesInformerReactiveDiscoveryClient client,    ConfigurationWatcherConfigurationProperties properties,    WebClient webClient){\n      return new HttpRefreshTrigger(client,properties,webClient);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\n@Configuration(proxyBeanMethods\u003dfalse) @EnableConfigurationProperties({ConfigurationWatcherConfigurationProperties.class}) @Import({ConfigurationWatcherAutoConfiguration.RefreshTriggerConfiguration.class}) public class ConfigurationWatcherAutoConfiguration {\n  private static final String AMQP\u003d\"bus-amqp\";\n  private static final String KAFKA\u003d\"bus-kafka\";\n  @Bean @ConditionalOnMissingBean public WebClient webClient(  WebClient.Builder webClientBuilder);\n  @Bean @ConditionalOnMissingBean(ConfigMapWatcherChangeDetector.class) @ConditionalOnBean(KubernetesClientConfigMapPropertySourceLocator.class) public ConfigMapWatcherChangeDetector httpBasedConfigMapWatchChangeDetector(  AbstractEnvironment environment,  CoreV1Api coreV1Api,  KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  KubernetesNamespaceProvider namespaceProvider,  ThreadPoolTaskExecutor threadFactory,  HttpRefreshTrigger httpRefreshTrigger);\n  @Bean @ConditionalOnMissingBean @ConditionalOnBean(KubernetesClientSecretsPropertySourceLocator.class) public SecretsWatcherChangeDetector httpBasedSecretsWatchChangeDetector(  AbstractEnvironment environment,  CoreV1Api coreV1Api,  KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator,  KubernetesNamespaceProvider namespaceProvider,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadFactory,  HttpRefreshTrigger httpRefreshTrigger);\n@Configuration @Profile(AMQP) @Import({ContextFunctionCatalogAutoConfiguration.class,RabbitHealthContributorAutoConfiguration.class,RefreshTriggerConfiguration.class}) static class BusRabbitConfiguration {\n    @Bean @ConditionalOnMissingBean(ConfigMapWatcherChangeDetector.class) @ConditionalOnBean(KubernetesClientConfigMapPropertySourceLocator.class) public ConfigMapWatcherChangeDetector busConfigMapChangeWatcher(    AbstractEnvironment environment,    CoreV1Api coreV1Api,    KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator,    KubernetesNamespaceProvider kubernetesNamespaceProvider,    ConfigReloadProperties properties,    ConfigurationUpdateStrategy strategy,    ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,    ThreadPoolTaskExecutor threadFactory,    BusRefreshTrigger busRefreshTrigger);\n    @Bean @ConditionalOnMissingBean(SecretsWatcherChangeDetector.class) @ConditionalOnBean(KubernetesClientSecretsPropertySourceLocator.class) public SecretsWatcherChangeDetector busSecretsChangeWatcher(    AbstractEnvironment environment,    CoreV1Api coreV1Api,    KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator,    ConfigReloadProperties properties,    KubernetesNamespaceProvider kubernetesNamespaceProvider,    ConfigurationUpdateStrategy strategy,    ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,    ThreadPoolTaskExecutor threadFactory,    BusRefreshTrigger busRefreshTrigger);\n  }\n@Configuration @Profile(KAFKA) @Import({ContextFunctionCatalogAutoConfiguration.class,RefreshTriggerConfiguration.class}) static class BusKafkaConfiguration {\n    @Bean @ConditionalOnMissingBean(ConfigMapWatcherChangeDetector.class) @ConditionalOnBean(KubernetesClientConfigMapPropertySourceLocator.class) public ConfigMapWatcherChangeDetector busConfigMapChangeWatcher(    AbstractEnvironment environment,    CoreV1Api coreV1Api,    KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator,    ConfigReloadProperties properties,    KubernetesNamespaceProvider namespaceProvider,    ConfigurationUpdateStrategy strategy,    ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,    ThreadPoolTaskExecutor threadFactory,    BusRefreshTrigger busRefreshTrigger);\n    @Bean @ConditionalOnMissingBean(SecretsWatcherChangeDetector.class) @ConditionalOnBean(KubernetesClientSecretsPropertySourceLocator.class) public SecretsWatcherChangeDetector busSecretsChangeWatcher(    AbstractEnvironment environment,    CoreV1Api coreV1Api,    KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator,    ConfigReloadProperties properties,    ConfigurationUpdateStrategy strategy,    ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,    ThreadPoolTaskExecutor threadFactory,    KubernetesNamespaceProvider namespaceProvider,    BusRefreshTrigger busRefreshTrigger);\n  }\n@AutoConfiguration static class RefreshTriggerConfiguration {\n    @Bean @ConditionalOnMissingBean @Profile({AMQP,KAFKA}) public BusRefreshTrigger busRefreshTrigger(    ApplicationEventPublisher applicationEventPublisher,    BusProperties busProperties);\n    @Bean @ConditionalOnMissingBean public HttpRefreshTrigger httpRefreshTrigger(    KubernetesInformerReactiveDiscoveryClient client,    ConfigurationWatcherConfigurationProperties properties,    WebClient webClient);\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/ConfigurationWatcherConfigurationProperties.java",
        "name": "ConfigurationWatcherConfigurationProperties",
        "modifiers": "@ConfigurationProperties(\"spring.cloud.kubernetes.configuration.watcher\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.ConfigurationWatcherConfigurationProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@ConfigurationProperties(\"spring.cloud.kubernetes.configuration.watcher\") public class ConfigurationWatcherConfigurationProperties {\n  /** \n * label to enable refresh/restart when using configmaps.\n */\n  public static final String CONFIG_MAP_LABEL\u003d\"spring.cloud.kubernetes.config\";\n  /** \n * label to enable refresh/restart when using secrets.\n */\n  public static final String SECRET_LABEL\u003d\"spring.cloud.kubernetes.secret\";\n  /** \n * annotation name to enable refresh/restart for specific apps when using configmaps.\n */\n  public static final String CONFIG_MAP_APPS_ANNOTATION\u003d\"spring.cloud.kubernetes.configmap.apps\";\n  /** \n * annotation name to enable refresh/restart for specific apps when using secrets.\n */\n  public static final String SECRET_APPS_ANNOTATION\u003d\"spring.cloud.kubernetes.secret.apps\";\n  /** \n * Annotation key for actuator port and path.\n */\n  public static final String ANNOTATION_KEY\u003d\"boot.spring.io/actuator\";\n  /** \n * Amount of time to delay the posting of the event to allow the app volume to update data.\n */\n  @DurationUnit(ChronoUnit.MILLIS) private Duration refreshDelay\u003dDuration.ofMillis(120000);\n  private int threadPoolSize\u003d1;\n  private String actuatorPath\u003d\"/actuator\";\n  private Integer actuatorPort\u003d-1;\n  public String getActuatorPath(){\n    return actuatorPath;\n  }\n  public void setActuatorPath(  String actuatorPath){\n    String normalizedPath\u003dactuatorPath;\n    if (!normalizedPath.startsWith(\"/\")) {\n      normalizedPath\u003d\"/\" + normalizedPath;\n    }\n    if (normalizedPath.endsWith(\"/\")) {\n      normalizedPath\u003dnormalizedPath.substring(0,normalizedPath.length() - 1);\n    }\n    this.actuatorPath\u003dnormalizedPath;\n  }\n  public Integer getActuatorPort(){\n    return actuatorPort;\n  }\n  public void setActuatorPort(  Integer actuatorPort){\n    this.actuatorPort\u003dactuatorPort;\n  }\n  public Duration getRefreshDelay(){\n    return refreshDelay;\n  }\n  public void setRefreshDelay(  Duration refreshDelay){\n    this.refreshDelay\u003drefreshDelay;\n  }\n  public int getThreadPoolSize(){\n    return threadPoolSize;\n  }\n  public void setThreadPoolSize(  int threadPoolSize){\n    this.threadPoolSize\u003dthreadPoolSize;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@ConfigurationProperties(\"spring.cloud.kubernetes.configuration.watcher\") public class ConfigurationWatcherConfigurationProperties {\n  /** \n * label to enable refresh/restart when using configmaps.\n */\n  public static final String CONFIG_MAP_LABEL\u003d\"spring.cloud.kubernetes.config\";\n  /** \n * label to enable refresh/restart when using secrets.\n */\n  public static final String SECRET_LABEL\u003d\"spring.cloud.kubernetes.secret\";\n  /** \n * annotation name to enable refresh/restart for specific apps when using configmaps.\n */\n  public static final String CONFIG_MAP_APPS_ANNOTATION\u003d\"spring.cloud.kubernetes.configmap.apps\";\n  /** \n * annotation name to enable refresh/restart for specific apps when using secrets.\n */\n  public static final String SECRET_APPS_ANNOTATION\u003d\"spring.cloud.kubernetes.secret.apps\";\n  /** \n * Annotation key for actuator port and path.\n */\n  public static final String ANNOTATION_KEY\u003d\"boot.spring.io/actuator\";\n  /** \n * Amount of time to delay the posting of the event to allow the app volume to update data.\n */\n  @DurationUnit(ChronoUnit.MILLIS) private Duration refreshDelay\u003dDuration.ofMillis(120000);\n  private int threadPoolSize\u003d1;\n  private String actuatorPath\u003d\"/actuator\";\n  private Integer actuatorPort\u003d-1;\n  public String getActuatorPath();\n  public void setActuatorPath(  String actuatorPath);\n  public Integer getActuatorPort();\n  public void setActuatorPort(  Integer actuatorPort);\n  public Duration getRefreshDelay();\n  public void setRefreshDelay(  Duration refreshDelay);\n  public int getThreadPoolSize();\n  public void setThreadPoolSize(  int threadPoolSize);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/ConfigUpdateStrategyAutoConfiguration.java",
        "name": "ConfigUpdateStrategyAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.reload.enabled\",havingValue\u003d\"false\",matchIfMissing\u003dtrue)",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.ConfigUpdateStrategyAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.reload.enabled\",havingValue\u003d\"false\",matchIfMissing\u003dtrue) class ConfigUpdateStrategyAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(ConfigUpdateStrategyAutoConfiguration.class));\n  @Bean @ConditionalOnMissingBean ConfigurationUpdateStrategy noopConfigurationUpdateStrategy(){\n    LOG.debug(() -\u003e \"creating NOOP strategy because reload is disabled\");\n    return ConfigurationUpdateStrategy.NOOP;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.reload.enabled\",havingValue\u003d\"false\",matchIfMissing\u003dtrue) class ConfigUpdateStrategyAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(ConfigUpdateStrategyAutoConfiguration.class));\n  @Bean @ConditionalOnMissingBean ConfigurationUpdateStrategy noopConfigurationUpdateStrategy();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/ConfigurationWatcherApplication.java",
        "name": "ConfigurationWatcherApplication",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @SpringBootApplication(exclude\u003d{ContextFunctionCatalogAutoConfiguration.class,RabbitHealthContributorAutoConfiguration.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.ConfigurationWatcherApplication",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @SpringBootApplication(exclude\u003d{ContextFunctionCatalogAutoConfiguration.class,RabbitHealthContributorAutoConfiguration.class}) public class ConfigurationWatcherApplication {\n  public static void main(  String[] args){\n    new SpringApplicationBuilder(ConfigurationWatcherApplication.class).run(args);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @SpringBootApplication(exclude\u003d{ContextFunctionCatalogAutoConfiguration.class,RabbitHealthContributorAutoConfiguration.class}) public class ConfigurationWatcherApplication {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/SecretsWatcherChangeDetector.java",
        "name": "SecretsWatcherChangeDetector",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.SecretsWatcherChangeDetector",
        "extend": "KubernetesClientEventBasedSecretsChangeDetector",
        "implements": "RefreshTrigger",
        "raw": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\nclass SecretsWatcherChangeDetector extends KubernetesClientEventBasedSecretsChangeDetector implements RefreshTrigger {\n  permits BusEventBasedSecretsWatcherChangeDetector, HttpBasedSecretsWatchChangeDetector;\n{\n  }\n  private final ScheduledExecutorService executorService;\n  private final long refreshDelay;\n  SecretsWatcherChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientSecretsPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadPoolTaskExecutor){\n    super(coreV1Api,environment,properties,strategy,propertySourceLocator,kubernetesNamespaceProvider);\n    this.executorService\u003dExecutors.newScheduledThreadPool(k8SConfigurationProperties.getThreadPoolSize(),threadPoolTaskExecutor);\n    this.refreshDelay\u003dk8SConfigurationProperties.getRefreshDelay().toMillis();\n  }\n  @Override protected final void onEvent(  KubernetesObject secret){\n    WatcherUtil.onEvent(secret,SECRET_LABEL,SECRET_APPS_ANNOTATION,refreshDelay,executorService,\"secret\",this::triggerRefresh);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\nclass SecretsWatcherChangeDetector extends KubernetesClientEventBasedSecretsChangeDetector implements RefreshTrigger {\n  permits BusEventBasedSecretsWatcherChangeDetector, HttpBasedSecretsWatchChangeDetector;\n{\n  }\n  private final ScheduledExecutorService executorService;\n  private final long refreshDelay;\n  SecretsWatcherChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientSecretsPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadPoolTaskExecutor);\n  @Override protected final void onEvent(  KubernetesObject secret);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/ConfigMapWatcherChangeDetector.java",
        "name": "ConfigMapWatcherChangeDetector",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.ConfigMapWatcherChangeDetector",
        "extend": "KubernetesClientEventBasedConfigMapChangeDetector",
        "implements": "RefreshTrigger",
        "raw": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\nclass ConfigMapWatcherChangeDetector extends KubernetesClientEventBasedConfigMapChangeDetector implements RefreshTrigger {\n  permits BusEventBasedConfigMapWatcherChangeDetector, HttpBasedConfigMapWatchChangeDetector;\n{\n  }\n  private final ScheduledExecutorService executorService;\n  private final long refreshDelay;\n  ConfigMapWatcherChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientConfigMapPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadPoolTaskExecutor){\n    super(coreV1Api,environment,properties,strategy,propertySourceLocator,kubernetesNamespaceProvider);\n    this.executorService\u003dExecutors.newScheduledThreadPool(k8SConfigurationProperties.getThreadPoolSize(),threadPoolTaskExecutor);\n    this.refreshDelay\u003dk8SConfigurationProperties.getRefreshDelay().toMillis();\n  }\n  @Override protected final void onEvent(  KubernetesObject configMap){\n    WatcherUtil.onEvent(configMap,CONFIG_MAP_LABEL,CONFIG_MAP_APPS_ANNOTATION,refreshDelay,executorService,\"config-map\",this::triggerRefresh);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\nclass ConfigMapWatcherChangeDetector extends KubernetesClientEventBasedConfigMapChangeDetector implements RefreshTrigger {\n  permits BusEventBasedConfigMapWatcherChangeDetector, HttpBasedConfigMapWatchChangeDetector;\n{\n  }\n  private final ScheduledExecutorService executorService;\n  private final long refreshDelay;\n  ConfigMapWatcherChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientConfigMapPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadPoolTaskExecutor);\n  @Override protected final void onEvent(  KubernetesObject configMap);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/WatcherUtil.java",
        "name": "WatcherUtil",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.WatcherUtil",
        "extend": "",
        "implements": "",
        "raw": "/** \n * A common place where \u0027onEvent\u0027 code delegates to.\n * @author wind57\n */\nfinal class WatcherUtil {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(WatcherUtil.class));\n  private WatcherUtil(){\n  }\n  static void onEvent(  KubernetesObject kubernetesObject,  String label,  String annotationName,  long refreshDelay,  ScheduledExecutorService executorService,  String type,  BiFunction\u003cKubernetesObject,String,Mono\u003cVoid\u003e\u003e triggerRefresh){\n    String name\u003dkubernetesObject.getMetadata().getName();\n    boolean isSpringCloudKubernetes\u003disSpringCloudKubernetes(kubernetesObject,label);\n    if (isSpringCloudKubernetes) {\n      Set\u003cString\u003e apps\u003dapps(kubernetesObject,annotationName);\n      if (apps.isEmpty()) {\n        apps.add(name);\n      }\n      LOG.info(() -\u003e \"will schedule remote refresh based on apps : \" + apps);\n      apps.forEach(appName -\u003e schedule(type,appName,refreshDelay,executorService,triggerRefresh,kubernetesObject));\n    }\n else {\n      LOG.debug(() -\u003e \"Not publishing event.\" + type + \": \"+ name+ \" does not contain the label \"+ label);\n    }\n  }\n  static boolean isSpringCloudKubernetes(  KubernetesObject kubernetesObject,  String label){\n    if (kubernetesObject.getMetadata() \u003d\u003d null) {\n      return false;\n    }\n    return Boolean.parseBoolean(labels(kubernetesObject).getOrDefault(label,\"false\"));\n  }\n  static Set\u003cString\u003e apps(  KubernetesObject kubernetesObject,  String annotationName){\n    Set\u003cString\u003e apps\u003dnew HashSet\u003c\u003e(1);\n    Map\u003cString,String\u003e annotations\u003dannotations(kubernetesObject);\n    if (annotations.isEmpty()) {\n      LOG.debug(() -\u003e annotationName + \" not present (empty data)\");\n      return apps;\n    }\n    String appsValue\u003dannotations.get(annotationName);\n    if (appsValue \u003d\u003d null) {\n      LOG.debug(() -\u003e annotationName + \" not present (missing in annotations)\");\n      return apps;\n    }\n    if (appsValue.isBlank()) {\n      LOG.debug(() -\u003e appsValue + \" not present (blanks only)\");\n      return apps;\n    }\n    return Arrays.stream(appsValue.split(\",\")).map(String::trim).collect(Collectors.toSet());\n  }\n  static Map\u003cString,String\u003e labels(  KubernetesObject kubernetesObject){\n    return Optional.ofNullable(kubernetesObject.getMetadata()).map(V1ObjectMeta::getLabels).orElse(Map.of());\n  }\n  static Map\u003cString,String\u003e annotations(  KubernetesObject kubernetesObject){\n    return Optional.ofNullable(kubernetesObject.getMetadata()).map(V1ObjectMeta::getAnnotations).orElse(Map.of());\n  }\n  private static void schedule(  String type,  String appName,  long refreshDelay,  ScheduledExecutorService executorService,  BiFunction\u003cKubernetesObject,String,Mono\u003cVoid\u003e\u003e triggerRefresh,  KubernetesObject kubernetesObject){\n    LOG.debug(() -\u003e \"Scheduling remote refresh event to be published for \" + type + \": with appName : \"+ appName+ \" to be published in \"+ refreshDelay+ \" milliseconds\");\n    executorService.schedule(() -\u003e {\n      try {\n        triggerRefresh.apply(kubernetesObject,appName).subscribe();\n      }\n catch (      Throwable t) {\n        LOG.warn(t,\"Error when refreshing appName \" + appName);\n      }\n    }\n,refreshDelay,TimeUnit.MILLISECONDS);\n  }\n}\n",
        "abstract": "/** \n * A common place where \u0027onEvent\u0027 code delegates to.\n * @author wind57\n */\nfinal class WatcherUtil {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(WatcherUtil.class));\n  private WatcherUtil();\n  static void onEvent(  KubernetesObject kubernetesObject,  String label,  String annotationName,  long refreshDelay,  ScheduledExecutorService executorService,  String type,  BiFunction\u003cKubernetesObject,String,Mono\u003cVoid\u003e\u003e triggerRefresh);\n  static boolean isSpringCloudKubernetes(  KubernetesObject kubernetesObject,  String label);\n  static Set\u003cString\u003e apps(  KubernetesObject kubernetesObject,  String annotationName);\n  static Map\u003cString,String\u003e labels(  KubernetesObject kubernetesObject);\n  static Map\u003cString,String\u003e annotations(  KubernetesObject kubernetesObject);\n  private static void schedule(  String type,  String appName,  long refreshDelay,  ScheduledExecutorService executorService,  BiFunction\u003cKubernetesObject,String,Mono\u003cVoid\u003e\u003e triggerRefresh,  KubernetesObject kubernetesObject);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/BusRefreshTrigger.java",
        "name": "BusRefreshTrigger",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.BusRefreshTrigger",
        "extend": "",
        "implements": "RefreshTrigger",
        "raw": "/** \n * An event publisher for an \u0027event bus\u0027 type of application.\n * @author wind57\n */\nfinal class BusRefreshTrigger implements RefreshTrigger {\n  private final ApplicationEventPublisher applicationEventPublisher;\n  private final String busId;\n  BusRefreshTrigger(  ApplicationEventPublisher applicationEventPublisher,  String busId){\n    this.applicationEventPublisher\u003dapplicationEventPublisher;\n    this.busId\u003dbusId;\n  }\n  @Override public Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject configMap,  String appName){\n    applicationEventPublisher.publishEvent(new RefreshRemoteApplicationEvent(configMap,busId,new PathDestinationFactory().getDestination(appName)));\n    return Mono.empty();\n  }\n}\n",
        "abstract": "/** \n * An event publisher for an \u0027event bus\u0027 type of application.\n * @author wind57\n */\nfinal class BusRefreshTrigger implements RefreshTrigger {\n  private final ApplicationEventPublisher applicationEventPublisher;\n  private final String busId;\n  BusRefreshTrigger(  ApplicationEventPublisher applicationEventPublisher,  String busId);\n  @Override public Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject configMap,  String appName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/HttpBasedSecretsWatchChangeDetector.java",
        "name": "HttpBasedSecretsWatchChangeDetector",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.HttpBasedSecretsWatchChangeDetector",
        "extend": "SecretsWatcherChangeDetector",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\nfinal class HttpBasedSecretsWatchChangeDetector extends SecretsWatcherChangeDetector {\n  private final HttpRefreshTrigger httpRefreshTrigger;\n  HttpBasedSecretsWatchChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientSecretsPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadPoolTaskExecutor,  HttpRefreshTrigger httpRefreshTrigger){\n    super(coreV1Api,environment,properties,strategy,propertySourceLocator,kubernetesNamespaceProvider,k8SConfigurationProperties,threadPoolTaskExecutor);\n    this.httpRefreshTrigger\u003dhttpRefreshTrigger;\n  }\n  @Override public Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject secret,  String appName){\n    return httpRefreshTrigger.triggerRefresh(secret,appName);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\nfinal class HttpBasedSecretsWatchChangeDetector extends SecretsWatcherChangeDetector {\n  private final HttpRefreshTrigger httpRefreshTrigger;\n  HttpBasedSecretsWatchChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientSecretsPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadPoolTaskExecutor,  HttpRefreshTrigger httpRefreshTrigger);\n  @Override public Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject secret,  String appName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/HttpBasedConfigMapWatchChangeDetector.java",
        "name": "HttpBasedConfigMapWatchChangeDetector",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.HttpBasedConfigMapWatchChangeDetector",
        "extend": "ConfigMapWatcherChangeDetector",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\nfinal class HttpBasedConfigMapWatchChangeDetector extends ConfigMapWatcherChangeDetector {\n  private final HttpRefreshTrigger httpRefreshTrigger;\n  HttpBasedConfigMapWatchChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientConfigMapPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadPoolTaskExecutor,  HttpRefreshTrigger httpRefreshTrigger){\n    super(coreV1Api,environment,properties,strategy,propertySourceLocator,kubernetesNamespaceProvider,k8SConfigurationProperties,threadPoolTaskExecutor);\n    this.httpRefreshTrigger\u003dhttpRefreshTrigger;\n  }\n  @Override public Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject configMap,  String appName){\n    return httpRefreshTrigger.triggerRefresh(configMap,appName);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\nfinal class HttpBasedConfigMapWatchChangeDetector extends ConfigMapWatcherChangeDetector {\n  private final HttpRefreshTrigger httpRefreshTrigger;\n  HttpBasedConfigMapWatchChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientConfigMapPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadPoolTaskExecutor,  HttpRefreshTrigger httpRefreshTrigger);\n  @Override public Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject configMap,  String appName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/BusEventBasedConfigMapWatcherChangeDetector.java",
        "name": "BusEventBasedConfigMapWatcherChangeDetector",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.BusEventBasedConfigMapWatcherChangeDetector",
        "extend": "ConfigMapWatcherChangeDetector",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\nfinal class BusEventBasedConfigMapWatcherChangeDetector extends ConfigMapWatcherChangeDetector {\n  private final BusRefreshTrigger busRefreshTrigger;\n  BusEventBasedConfigMapWatcherChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientConfigMapPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadPoolTaskExecutor,  BusRefreshTrigger busRefreshTrigger){\n    super(coreV1Api,environment,properties,strategy,propertySourceLocator,kubernetesNamespaceProvider,k8SConfigurationProperties,threadPoolTaskExecutor);\n    this.busRefreshTrigger\u003dbusRefreshTrigger;\n  }\n  @Override public Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject configMap,  String appName){\n    return busRefreshTrigger.triggerRefresh(configMap,appName);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\nfinal class BusEventBasedConfigMapWatcherChangeDetector extends ConfigMapWatcherChangeDetector {\n  private final BusRefreshTrigger busRefreshTrigger;\n  BusEventBasedConfigMapWatcherChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientConfigMapPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadPoolTaskExecutor,  BusRefreshTrigger busRefreshTrigger);\n  @Override public Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject configMap,  String appName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/RefreshTrigger.java",
        "name": "RefreshTrigger",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.RefreshTrigger",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Defines the refresh trigger contract.\n * @author wind57\n */\ninterface RefreshTrigger {\n  permits BusRefreshTrigger, ConfigMapWatcherChangeDetector, HttpRefreshTrigger, SecretsWatcherChangeDetector;\n{\n  }\n  /** \n * @param kubernetesObject either a config-map or secret at the moment.\n * @param appName which is not necessarily equal tokubernetesObject.getMetadata().getName()\n */\n  Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject kubernetesObject,  String appName);\n}\n",
        "abstract": "/** \n * Defines the refresh trigger contract.\n * @author wind57\n */\ninterface RefreshTrigger {\n  permits BusRefreshTrigger, ConfigMapWatcherChangeDetector, HttpRefreshTrigger, SecretsWatcherChangeDetector;\n{\n  }\n  /** \n * @param kubernetesObject either a config-map or secret at the moment.\n * @param appName which is not necessarily equal tokubernetesObject.getMetadata().getName()\n */\n  Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject kubernetesObject,  String appName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/HttpRefreshTrigger.java",
        "name": "HttpRefreshTrigger",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.HttpRefreshTrigger",
        "extend": "",
        "implements": "RefreshTrigger",
        "raw": "/** \n * @author wind57\n */\nfinal class HttpRefreshTrigger implements RefreshTrigger {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientEventBasedSecretsChangeDetector.class));\n  private final KubernetesInformerReactiveDiscoveryClient kubernetesReactiveDiscoveryClient;\n  private final ConfigurationWatcherConfigurationProperties k8SConfigurationProperties;\n  private final WebClient webClient;\n  HttpRefreshTrigger(  KubernetesInformerReactiveDiscoveryClient kubernetesReactiveDiscoveryClient,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  WebClient webClient){\n    this.kubernetesReactiveDiscoveryClient\u003dkubernetesReactiveDiscoveryClient;\n    this.k8SConfigurationProperties\u003dk8SConfigurationProperties;\n    this.webClient\u003dwebClient;\n  }\n  @Override public Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject kubernetesObject,  String appName){\n    return kubernetesReactiveDiscoveryClient.getInstances(appName).flatMap(si -\u003e {\n      URI actuatorUri\u003dgetActuatorUri(si,k8SConfigurationProperties.getActuatorPath(),k8SConfigurationProperties.getActuatorPort());\n      LOG.debug(() -\u003e \"Sending refresh request for \" + appName + \" to URI \"+ actuatorUri);\n      return webClient.post().uri(actuatorUri).retrieve().toBodilessEntity().doOnSuccess(onSuccess(appName,actuatorUri)).doOnError(onError(appName));\n    }\n).then();\n  }\n  private Consumer\u003cResponseEntity\u003cVoid\u003e\u003e onSuccess(  String name,  URI actuatorUri){\n    return re -\u003e LOG.debug(() -\u003e \"Refresh sent to \" + name + \" at URI address \"+ actuatorUri+ \" returned a \"+ re.getStatusCode());\n  }\n  private Consumer\u003cThrowable\u003e onError(  String name){\n    return t -\u003e LOG.warn(t,() -\u003e \"Refresh sent to \" + name + \" failed\");\n  }\n  private URI getActuatorUri(  ServiceInstance si,  String actuatorPath,  int actuatorPort){\n    String metadataUri\u003dsi.getMetadata().getOrDefault(ConfigurationWatcherConfigurationProperties.ANNOTATION_KEY,\"\");\n    LOG.debug(() -\u003e \"Metadata actuator uri is: \" + metadataUri);\n    UriComponentsBuilder actuatorUriBuilder\u003dUriComponentsBuilder.newInstance().scheme(si.getScheme()).host(si.getHost());\n    if (StringUtils.hasText(metadataUri)) {\n      LOG.debug(() -\u003e \"Found actuator URI in service instance metadata\");\n      setActuatorUriFromAnnotation(actuatorUriBuilder,metadataUri);\n    }\n else {\n      int port\u003dactuatorPort \u003c 0 ? si.getPort() : actuatorPort;\n      actuatorUriBuilder\u003dactuatorUriBuilder.path(actuatorPath + \"/refresh\").port(port);\n    }\n    return actuatorUriBuilder.build().toUri();\n  }\n  private void setActuatorUriFromAnnotation(  UriComponentsBuilder actuatorUriBuilder,  String metadataUri){\n    URI annotationUri\u003dURI.create(metadataUri);\n    actuatorUriBuilder.path(annotationUri.getPath() + \"/refresh\");\n    if (annotationUri.getPort() \u003c 0) {\n      if (annotationUri.getAuthority() !\u003d null) {\n        actuatorUriBuilder.port(annotationUri.getAuthority().replaceFirst(\":\",\"\"));\n      }\n    }\n else {\n      actuatorUriBuilder.port(annotationUri.getPort());\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class HttpRefreshTrigger implements RefreshTrigger {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientEventBasedSecretsChangeDetector.class));\n  private final KubernetesInformerReactiveDiscoveryClient kubernetesReactiveDiscoveryClient;\n  private final ConfigurationWatcherConfigurationProperties k8SConfigurationProperties;\n  private final WebClient webClient;\n  HttpRefreshTrigger(  KubernetesInformerReactiveDiscoveryClient kubernetesReactiveDiscoveryClient,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  WebClient webClient);\n  @Override public Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject kubernetesObject,  String appName);\n  private Consumer\u003cResponseEntity\u003cVoid\u003e\u003e onSuccess(  String name,  URI actuatorUri);\n  private Consumer\u003cThrowable\u003e onError(  String name);\n  private URI getActuatorUri(  ServiceInstance si,  String actuatorPath,  int actuatorPort);\n  private void setActuatorUriFromAnnotation(  UriComponentsBuilder actuatorUriBuilder,  String metadataUri);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/BusEventBasedSecretsWatcherChangeDetector.java",
        "name": "BusEventBasedSecretsWatcherChangeDetector",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.BusEventBasedSecretsWatcherChangeDetector",
        "extend": "SecretsWatcherChangeDetector",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\nfinal class BusEventBasedSecretsWatcherChangeDetector extends SecretsWatcherChangeDetector {\n  private final BusRefreshTrigger busRefreshTrigger;\n  BusEventBasedSecretsWatcherChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientSecretsPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadPoolTaskExecutor,  BusRefreshTrigger busRefreshTrigger){\n    super(coreV1Api,environment,properties,strategy,propertySourceLocator,kubernetesNamespaceProvider,k8SConfigurationProperties,threadPoolTaskExecutor);\n    this.busRefreshTrigger\u003dbusRefreshTrigger;\n  }\n  @Override public Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject secret,  String appName){\n    return busRefreshTrigger.triggerRefresh(secret,appName);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\nfinal class BusEventBasedSecretsWatcherChangeDetector extends SecretsWatcherChangeDetector {\n  private final BusRefreshTrigger busRefreshTrigger;\n  BusEventBasedSecretsWatcherChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientSecretsPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  ConfigurationWatcherConfigurationProperties k8SConfigurationProperties,  ThreadPoolTaskExecutor threadPoolTaskExecutor,  BusRefreshTrigger busRefreshTrigger);\n  @Override public Mono\u003cVoid\u003e triggerRefresh(  KubernetesObject secret,  String appName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/test/java/org/springframework/cloud/kubernetes/configuration/watcher/HttpBasedConfigMapWatchChangeDetectorTests.java",
        "name": "HttpBasedConfigMapWatchChangeDetectorTests",
        "modifiers": "@ExtendWith(MockitoExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.HttpBasedConfigMapWatchChangeDetectorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\n@ExtendWith(MockitoExtension.class) class HttpBasedConfigMapWatchChangeDetectorTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  private static final WireMockServer WIRE_MOCK_SERVER\u003dnew WireMockServer(WireMockConfiguration.options().dynamicPort());\n  @Mock private CoreV1Api coreV1Api;\n  @Mock private KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator;\n  @Mock private ThreadPoolTaskExecutor threadPoolTaskExecutor;\n  @Mock private KubernetesInformerReactiveDiscoveryClient reactiveDiscoveryClient;\n  private HttpBasedConfigMapWatchChangeDetector changeDetector;\n  private ConfigurationWatcherConfigurationProperties configurationWatcherConfigurationProperties;\n  @BeforeAll static void beforeAll(){\n    WIRE_MOCK_SERVER.start();\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::createApiClientForInformerClient).thenReturn(new ClientBuilder().setBasePath(WIRE_MOCK_SERVER.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"default\");\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n  @BeforeEach void setup(){\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setProperty(NAMESPACE_PROPERTY,\"default\");\n    configurationWatcherConfigurationProperties\u003dnew ConfigurationWatcherConfigurationProperties();\n    WebClient webClient\u003dWebClient.builder().build();\n    ConfigurationUpdateStrategy strategy\u003dnew ConfigurationUpdateStrategy(\"refresh\",() -\u003e {\n    }\n);\n    changeDetector\u003dnew HttpBasedConfigMapWatchChangeDetector(coreV1Api,mockEnvironment,ConfigReloadProperties.DEFAULT,strategy,configMapPropertySourceLocator,new KubernetesNamespaceProvider(mockEnvironment),configurationWatcherConfigurationProperties,threadPoolTaskExecutor,new HttpRefreshTrigger(reactiveDiscoveryClient,configurationWatcherConfigurationProperties,webClient));\n  }\n  @Test void triggerConfigMapRefresh(){\n    stubReactiveCall();\n    V1ConfigMap configMap\u003dnew V1ConfigMap();\n    V1ObjectMeta objectMeta\u003dnew V1ObjectMeta();\n    objectMeta.setName(\"foo\");\n    configMap.setMetadata(objectMeta);\n    WireMock.configureFor(\"localhost\",WIRE_MOCK_SERVER.port());\n    WireMock.stubFor(WireMock.post(WireMock.urlEqualTo(\"/actuator/refresh\")).willReturn(WireMock.aResponse().withStatus(200)));\n    StepVerifier.create(changeDetector.triggerRefresh(configMap,configMap.getMetadata().getName())).verifyComplete();\n    WireMock.verify(WireMock.postRequestedFor(WireMock.urlEqualTo(\"/actuator/refresh\")));\n  }\n  @Test void triggerConfigMapRefreshWithPropertiesBasedActuatorPath(){\n    stubReactiveCall();\n    configurationWatcherConfigurationProperties.setActuatorPath(\"/my/custom/actuator\");\n    V1ConfigMap configMap\u003dnew V1ConfigMap();\n    V1ObjectMeta objectMeta\u003dnew V1ObjectMeta();\n    objectMeta.setName(\"foo\");\n    configMap.setMetadata(objectMeta);\n    WireMock.configureFor(\"localhost\",WIRE_MOCK_SERVER.port());\n    WireMock.stubFor(WireMock.post(WireMock.urlEqualTo(\"/my/custom/actuator/refresh\")).willReturn(WireMock.aResponse().withStatus(200)));\n    StepVerifier.create(changeDetector.triggerRefresh(configMap,configMap.getMetadata().getName())).verifyComplete();\n    WireMock.verify(WireMock.postRequestedFor(WireMock.urlEqualTo(\"/my/custom/actuator/refresh\")));\n  }\n  @Test void triggerConfigMapRefreshWithAnnotationActuatorPath(){\n    int port\u003dWIRE_MOCK_SERVER.port();\n    WireMock.configureFor(\"localhost\",port);\n    Map\u003cString,String\u003e metadata\u003dnew HashMap\u003c\u003e();\n    metadata.put(ConfigurationWatcherConfigurationProperties.ANNOTATION_KEY,\"http://:\" + port + \"/my/custom/actuator\");\n    V1EndpointAddress fooEndpointAddress\u003dnew V1EndpointAddress();\n    fooEndpointAddress.setIp(\"127.0.0.1\");\n    fooEndpointAddress.setHostname(\"localhost\");\n    CoreV1EndpointPort fooEndpointPort\u003dnew CoreV1EndpointPort();\n    fooEndpointPort.setPort(port);\n    List\u003cServiceInstance\u003e instances\u003dnew ArrayList\u003c\u003e();\n    DefaultKubernetesServiceInstance fooServiceInstance\u003dnew DefaultKubernetesServiceInstance(\"foo\",\"foo\",fooEndpointAddress.getIp(),fooEndpointPort.getPort(),metadata,false);\n    instances.add(fooServiceInstance);\n    when(reactiveDiscoveryClient.getInstances(eq(\"foo\"))).thenReturn(Flux.fromIterable(instances));\n    V1ConfigMap configMap\u003dnew V1ConfigMap();\n    V1ObjectMeta objectMeta\u003dnew V1ObjectMeta();\n    objectMeta.setName(\"foo\");\n    configMap.setMetadata(objectMeta);\n    WireMock.stubFor(WireMock.post(WireMock.urlEqualTo(\"/my/custom/actuator/refresh\")).willReturn(WireMock.aResponse().withStatus(200)));\n    StepVerifier.create(changeDetector.triggerRefresh(configMap,configMap.getMetadata().getName())).verifyComplete();\n    WireMock.verify(WireMock.postRequestedFor(WireMock.urlEqualTo(\"/my/custom/actuator/refresh\")));\n  }\n  private void stubReactiveCall(){\n    V1EndpointAddress fooEndpointAddress\u003dnew V1EndpointAddress();\n    fooEndpointAddress.setIp(\"127.0.0.1\");\n    fooEndpointAddress.setHostname(\"localhost\");\n    CoreV1EndpointPort fooEndpointPort\u003dnew CoreV1EndpointPort();\n    fooEndpointPort.setPort(WIRE_MOCK_SERVER.port());\n    List\u003cServiceInstance\u003e instances\u003dnew ArrayList\u003c\u003e();\n    DefaultKubernetesServiceInstance fooServiceInstance\u003dnew DefaultKubernetesServiceInstance(\"foo\",\"foo\",fooEndpointAddress.getIp(),fooEndpointPort.getPort(),new HashMap\u003c\u003e(),false);\n    instances.add(fooServiceInstance);\n    when(reactiveDiscoveryClient.getInstances(eq(\"foo\"))).thenReturn(Flux.fromIterable(instances));\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\n@ExtendWith(MockitoExtension.class) class HttpBasedConfigMapWatchChangeDetectorTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  private static final WireMockServer WIRE_MOCK_SERVER\u003dnew WireMockServer(WireMockConfiguration.options().dynamicPort());\n  @Mock private CoreV1Api coreV1Api;\n  @Mock private KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator;\n  @Mock private ThreadPoolTaskExecutor threadPoolTaskExecutor;\n  @Mock private KubernetesInformerReactiveDiscoveryClient reactiveDiscoveryClient;\n  private HttpBasedConfigMapWatchChangeDetector changeDetector;\n  private ConfigurationWatcherConfigurationProperties configurationWatcherConfigurationProperties;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void teardown();\n  @BeforeEach void setup();\n  @Test void triggerConfigMapRefresh();\n  @Test void triggerConfigMapRefreshWithPropertiesBasedActuatorPath();\n  @Test void triggerConfigMapRefreshWithAnnotationActuatorPath();\n  private void stubReactiveCall();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/test/java/org/springframework/cloud/kubernetes/configuration/watcher/BusEventBasedSecretsWatcherChangeDetectorTests.java",
        "name": "BusEventBasedSecretsWatcherChangeDetectorTests",
        "modifiers": "@ExtendWith(MockitoExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.BusEventBasedSecretsWatcherChangeDetectorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\n@ExtendWith(MockitoExtension.class) class BusEventBasedSecretsWatcherChangeDetectorTests {\n  private static final ConfigurationUpdateStrategy UPDATE_STRATEGY\u003dnew ConfigurationUpdateStrategy(\"strategy\",() -\u003e {\n  }\n);\n  @Mock private CoreV1Api coreV1Api;\n  @Mock private KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator;\n  @Mock private ThreadPoolTaskExecutor threadPoolTaskExecutor;\n  @Mock private ApplicationEventPublisher applicationEventPublisher;\n  private BusEventBasedSecretsWatcherChangeDetector changeDetector;\n  private BusProperties busProperties;\n  @BeforeEach void setup(){\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setProperty(NAMESPACE_PROPERTY,\"default\");\n    ConfigurationWatcherConfigurationProperties configurationWatcherConfigurationProperties\u003dnew ConfigurationWatcherConfigurationProperties();\n    busProperties\u003dnew BusProperties();\n    changeDetector\u003dnew BusEventBasedSecretsWatcherChangeDetector(coreV1Api,mockEnvironment,ConfigReloadProperties.DEFAULT,UPDATE_STRATEGY,secretsPropertySourceLocator,new KubernetesNamespaceProvider(mockEnvironment),configurationWatcherConfigurationProperties,threadPoolTaskExecutor,new BusRefreshTrigger(applicationEventPublisher,busProperties.getId()));\n  }\n  @Test void triggerRefreshWithSecret(){\n    V1ObjectMeta objectMeta\u003dnew V1ObjectMeta();\n    objectMeta.setName(\"foo\");\n    V1Secret secret\u003dnew V1Secret();\n    secret.setMetadata(objectMeta);\n    changeDetector.triggerRefresh(secret,secret.getMetadata().getName());\n    ArgumentCaptor\u003cRefreshRemoteApplicationEvent\u003e argumentCaptor\u003dArgumentCaptor.forClass(RefreshRemoteApplicationEvent.class);\n    verify(applicationEventPublisher).publishEvent(argumentCaptor.capture());\n    assertThat(argumentCaptor.getValue().getSource()).isEqualTo(secret);\n    assertThat(argumentCaptor.getValue().getOriginService()).isEqualTo(busProperties.getId());\n    assertThat(argumentCaptor.getValue().getDestinationService()).isEqualTo(\"foo:**\");\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\n@ExtendWith(MockitoExtension.class) class BusEventBasedSecretsWatcherChangeDetectorTests {\n  private static final ConfigurationUpdateStrategy UPDATE_STRATEGY\u003dnew ConfigurationUpdateStrategy(\"strategy\",() -\u003e {\n  }\n);\n  @Mock private CoreV1Api coreV1Api;\n  @Mock private KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator;\n  @Mock private ThreadPoolTaskExecutor threadPoolTaskExecutor;\n  @Mock private ApplicationEventPublisher applicationEventPublisher;\n  private BusEventBasedSecretsWatcherChangeDetector changeDetector;\n  private BusProperties busProperties;\n  @BeforeEach void setup();\n  @Test void triggerRefreshWithSecret();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/test/java/org/springframework/cloud/kubernetes/configuration/watcher/WatcherUtilTests.java",
        "name": "WatcherUtilTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.WatcherUtilTests",
        "extend": "",
        "implements": "",
        "raw": "class WatcherUtilTests {\n  @Test void isSpringCloudKubernetesConfigFalse(){\n    V1ConfigMap configMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMeta().labels(Map.of())).build();\n    boolean present\u003dWatcherUtil.isSpringCloudKubernetes(configMap,CONFIG_MAP_LABEL);\n    Assertions.assertFalse(present);\n  }\n  @Test void isSpringCloudKubernetesConfigTrue(){\n    V1ConfigMap configMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMeta().labels(Map.of(CONFIG_MAP_LABEL,\"true\"))).build();\n    boolean present\u003dWatcherUtil.isSpringCloudKubernetes(configMap,CONFIG_MAP_LABEL);\n    Assertions.assertTrue(present);\n  }\n  @Test void isSpringCloudKubernetesSecretFalse(){\n    V1Secret secret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMeta().labels(Map.of())).build();\n    boolean present\u003dWatcherUtil.isSpringCloudKubernetes(secret,SECRET_LABEL);\n    Assertions.assertFalse(present);\n  }\n  @Test void isSpringCloudKubernetesSecretTrue(){\n    V1Secret secret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMeta().labels(Map.of(SECRET_LABEL,\"true\"))).build();\n    boolean present\u003dWatcherUtil.isSpringCloudKubernetes(secret,SECRET_LABEL);\n    Assertions.assertTrue(present);\n  }\n  @Test void labelsMissing(){\n    V1Secret secret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMeta()).build();\n    Map\u003cString,String\u003e res\u003dWatcherUtil.labels(secret);\n    Assertions.assertEquals(res.size(),0);\n  }\n  @Test void labelsPresent(){\n    V1Secret secret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMeta().labels(Map.of(\"a\",\"b\"))).build();\n    Map\u003cString,String\u003e res\u003dWatcherUtil.labels(secret);\n    Assertions.assertEquals(res.size(),1);\n  }\n  @Test void appsNoMetadata(){\n    V1Secret secret\u003dnew V1SecretBuilder().build();\n    Set\u003cString\u003e apps\u003dWatcherUtil.apps(secret,SECRET_APPS_ANNOTATION);\n    Assertions.assertEquals(apps.size(),0);\n  }\n  @Test void appsNoAnnotations(){\n    V1Secret secret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMeta().annotations(Map.of())).build();\n    Set\u003cString\u003e apps\u003dWatcherUtil.apps(secret,SECRET_APPS_ANNOTATION);\n    Assertions.assertEquals(apps.size(),0);\n  }\n  @Test void appsAnnotationNotFound(){\n    V1Secret secret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMeta().annotations(Map.of(\"a\",\"b\"))).build();\n    Set\u003cString\u003e apps\u003dWatcherUtil.apps(secret,SECRET_APPS_ANNOTATION);\n    Assertions.assertEquals(apps.size(),0);\n  }\n  @Test void appsSingleResult(){\n    V1Secret secret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMeta().annotations(Map.of(SECRET_APPS_ANNOTATION,\"one-app\"))).build();\n    Set\u003cString\u003e apps\u003dWatcherUtil.apps(secret,SECRET_APPS_ANNOTATION);\n    Assertions.assertEquals(apps.size(),1);\n    Assertions.assertEquals(apps.iterator().next(),\"one-app\");\n  }\n  @Test void appsMultipleResults(){\n    V1Secret secret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMeta().annotations(Map.of(SECRET_APPS_ANNOTATION,\"one, two,  three \"))).build();\n    Set\u003cString\u003e apps\u003dWatcherUtil.apps(secret,SECRET_APPS_ANNOTATION);\n    Assertions.assertEquals(apps.size(),3);\n    Assertions.assertTrue(apps.contains(\"one\"));\n    Assertions.assertTrue(apps.contains(\"two\"));\n    Assertions.assertTrue(apps.contains(\"three\"));\n  }\n}\n",
        "abstract": "class WatcherUtilTests {\n  @Test void isSpringCloudKubernetesConfigFalse();\n  @Test void isSpringCloudKubernetesConfigTrue();\n  @Test void isSpringCloudKubernetesSecretFalse();\n  @Test void isSpringCloudKubernetesSecretTrue();\n  @Test void labelsMissing();\n  @Test void labelsPresent();\n  @Test void appsNoMetadata();\n  @Test void appsNoAnnotations();\n  @Test void appsAnnotationNotFound();\n  @Test void appsSingleResult();\n  @Test void appsMultipleResults();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/test/java/org/springframework/cloud/kubernetes/configuration/watcher/HttpBasedSecretsWatchChangeDetectorTests.java",
        "name": "HttpBasedSecretsWatchChangeDetectorTests",
        "modifiers": "@ExtendWith(MockitoExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.HttpBasedSecretsWatchChangeDetectorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\n@ExtendWith(MockitoExtension.class) class HttpBasedSecretsWatchChangeDetectorTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  private static final WireMockServer WIRE_MOCK_SERVER\u003dnew WireMockServer(WireMockConfiguration.options().dynamicPort());\n  @Mock private CoreV1Api coreV1Api;\n  @Mock private ConfigurationUpdateStrategy updateStrategy;\n  @Mock private KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator;\n  @Mock private ThreadPoolTaskExecutor threadPoolTaskExecutor;\n  @Mock private KubernetesInformerReactiveDiscoveryClient reactiveDiscoveryClient;\n  private HttpBasedSecretsWatchChangeDetector changeDetector;\n  private ConfigurationWatcherConfigurationProperties configurationWatcherConfigurationProperties;\n  @BeforeEach void setup(){\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setProperty(NAMESPACE_PROPERTY,\"default\");\n    configurationWatcherConfigurationProperties\u003dnew ConfigurationWatcherConfigurationProperties();\n    WebClient webClient\u003dWebClient.builder().build();\n    changeDetector\u003dnew HttpBasedSecretsWatchChangeDetector(coreV1Api,mockEnvironment,ConfigReloadProperties.DEFAULT,updateStrategy,secretsPropertySourceLocator,new KubernetesNamespaceProvider(mockEnvironment),configurationWatcherConfigurationProperties,threadPoolTaskExecutor,new HttpRefreshTrigger(reactiveDiscoveryClient,configurationWatcherConfigurationProperties,webClient));\n  }\n  @BeforeAll static void beforeAll(){\n    WIRE_MOCK_SERVER.start();\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::createApiClientForInformerClient).thenReturn(new ClientBuilder().setBasePath(WIRE_MOCK_SERVER.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"default\");\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n  @Test void triggerSecretRefresh(){\n    stubReactiveCall();\n    V1Secret secret\u003dnew V1Secret();\n    V1ObjectMeta objectMeta\u003dnew V1ObjectMeta();\n    objectMeta.setName(\"foo\");\n    secret.setMetadata(objectMeta);\n    WireMock.configureFor(\"localhost\",WIRE_MOCK_SERVER.port());\n    WireMock.stubFor(WireMock.post(WireMock.urlEqualTo(\"/actuator/refresh\")).willReturn(WireMock.aResponse().withStatus(200)));\n    StepVerifier.create(changeDetector.triggerRefresh(secret,secret.getMetadata().getName())).verifyComplete();\n    WireMock.verify(WireMock.postRequestedFor(WireMock.urlEqualTo(\"/actuator/refresh\")));\n  }\n  @Test void triggerSecretRefreshWithPropertiesBasedActuatorPath(){\n    stubReactiveCall();\n    configurationWatcherConfigurationProperties.setActuatorPath(\"/my/custom/actuator\");\n    V1Secret secret\u003dnew V1Secret();\n    V1ObjectMeta objectMeta\u003dnew V1ObjectMeta();\n    objectMeta.setName(\"foo\");\n    secret.setMetadata(objectMeta);\n    WireMock.configureFor(\"localhost\",WIRE_MOCK_SERVER.port());\n    WireMock.stubFor(WireMock.post(WireMock.urlEqualTo(\"/my/custom/actuator/refresh\")).willReturn(WireMock.aResponse().withStatus(200)));\n    StepVerifier.create(changeDetector.triggerRefresh(secret,secret.getMetadata().getName())).verifyComplete();\n    WireMock.verify(WireMock.postRequestedFor(WireMock.urlEqualTo(\"/my/custom/actuator/refresh\")));\n  }\n  @Test void triggerSecretRefreshWithAnnotationActuatorPath(){\n    WireMock.configureFor(\"localhost\",WIRE_MOCK_SERVER.port());\n    Map\u003cString,String\u003e metadata\u003dnew HashMap\u003c\u003e();\n    metadata.put(ConfigurationWatcherConfigurationProperties.ANNOTATION_KEY,\"http://:\" + WIRE_MOCK_SERVER.port() + \"/my/custom/actuator\");\n    V1EndpointAddress fooEndpointAddress\u003dnew V1EndpointAddress();\n    fooEndpointAddress.setIp(\"127.0.0.1\");\n    fooEndpointAddress.setHostname(\"localhost\");\n    CoreV1EndpointPort fooEndpointPort\u003dnew CoreV1EndpointPort();\n    fooEndpointPort.setPort(WIRE_MOCK_SERVER.port());\n    List\u003cServiceInstance\u003e instances\u003dnew ArrayList\u003c\u003e();\n    DefaultKubernetesServiceInstance fooServiceInstance\u003dnew DefaultKubernetesServiceInstance(\"foo\",\"foo\",fooEndpointAddress.getIp(),fooEndpointPort.getPort(),metadata,false);\n    instances.add(fooServiceInstance);\n    when(reactiveDiscoveryClient.getInstances(eq(\"foo\"))).thenReturn(Flux.fromIterable(instances));\n    V1Secret secret\u003dnew V1Secret();\n    V1ObjectMeta objectMeta\u003dnew V1ObjectMeta();\n    objectMeta.setName(\"foo\");\n    secret.setMetadata(objectMeta);\n    WireMock.stubFor(WireMock.post(WireMock.urlEqualTo(\"/my/custom/actuator/refresh\")).willReturn(WireMock.aResponse().withStatus(200)));\n    StepVerifier.create(changeDetector.triggerRefresh(secret,secret.getMetadata().getName())).verifyComplete();\n    WireMock.verify(WireMock.postRequestedFor(WireMock.urlEqualTo(\"/my/custom/actuator/refresh\")));\n  }\n  private void stubReactiveCall(){\n    V1EndpointAddress fooEndpointAddress\u003dnew V1EndpointAddress();\n    fooEndpointAddress.setIp(\"127.0.0.1\");\n    fooEndpointAddress.setHostname(\"localhost\");\n    CoreV1EndpointPort fooEndpointPort\u003dnew CoreV1EndpointPort();\n    fooEndpointPort.setPort(WIRE_MOCK_SERVER.port());\n    List\u003cServiceInstance\u003e instances\u003dnew ArrayList\u003c\u003e();\n    DefaultKubernetesServiceInstance fooServiceInstance\u003dnew DefaultKubernetesServiceInstance(\"foo\",\"foo\",fooEndpointAddress.getIp(),fooEndpointPort.getPort(),new HashMap\u003c\u003e(),false);\n    instances.add(fooServiceInstance);\n    when(reactiveDiscoveryClient.getInstances(eq(\"foo\"))).thenReturn(Flux.fromIterable(instances));\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\n@ExtendWith(MockitoExtension.class) class HttpBasedSecretsWatchChangeDetectorTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  private static final WireMockServer WIRE_MOCK_SERVER\u003dnew WireMockServer(WireMockConfiguration.options().dynamicPort());\n  @Mock private CoreV1Api coreV1Api;\n  @Mock private ConfigurationUpdateStrategy updateStrategy;\n  @Mock private KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator;\n  @Mock private ThreadPoolTaskExecutor threadPoolTaskExecutor;\n  @Mock private KubernetesInformerReactiveDiscoveryClient reactiveDiscoveryClient;\n  private HttpBasedSecretsWatchChangeDetector changeDetector;\n  private ConfigurationWatcherConfigurationProperties configurationWatcherConfigurationProperties;\n  @BeforeEach void setup();\n  @BeforeAll static void beforeAll();\n  @AfterAll static void teardown();\n  @Test void triggerSecretRefresh();\n  @Test void triggerSecretRefreshWithPropertiesBasedActuatorPath();\n  @Test void triggerSecretRefreshWithAnnotationActuatorPath();\n  private void stubReactiveCall();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/test/java/org/springframework/cloud/kubernetes/configuration/watcher/ConfigurationWatcherConfigurationPropertiesTests.java",
        "name": "ConfigurationWatcherConfigurationPropertiesTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.ConfigurationWatcherConfigurationPropertiesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass ConfigurationWatcherConfigurationPropertiesTests {\n  @Test void setActuatorPath(){\n    ConfigurationWatcherConfigurationProperties properties\u003dnew ConfigurationWatcherConfigurationProperties();\n    properties.setActuatorPath(\"foo\");\n    assertThat(properties.getActuatorPath()).isEqualTo(\"/foo\");\n    properties.setActuatorPath(\"/foo/bar/\");\n    assertThat(properties.getActuatorPath()).isEqualTo(\"/foo/bar\");\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass ConfigurationWatcherConfigurationPropertiesTests {\n  @Test void setActuatorPath();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher/src/test/java/org/springframework/cloud/kubernetes/configuration/watcher/BusEventBasedConfigMapWatcherChangeDetectorTests.java",
        "name": "BusEventBasedConfigMapWatcherChangeDetectorTests",
        "modifiers": "@ExtendWith(MockitoExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.BusEventBasedConfigMapWatcherChangeDetectorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\n@ExtendWith(MockitoExtension.class) class BusEventBasedConfigMapWatcherChangeDetectorTests {\n  private static final ConfigurationUpdateStrategy UPDATE_STRATEGY\u003dnew ConfigurationUpdateStrategy(\"strategy\",() -\u003e {\n  }\n);\n  @Mock private CoreV1Api coreV1Api;\n  @Mock private KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator;\n  @Mock private ThreadPoolTaskExecutor threadPoolTaskExecutor;\n  @Mock private ApplicationEventPublisher applicationEventPublisher;\n  private BusEventBasedConfigMapWatcherChangeDetector changeDetector;\n  private BusProperties busProperties;\n  @BeforeEach void setup(){\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setProperty(NAMESPACE_PROPERTY,\"default\");\n    ConfigurationWatcherConfigurationProperties configurationWatcherConfigurationProperties\u003dnew ConfigurationWatcherConfigurationProperties();\n    busProperties\u003dnew BusProperties();\n    changeDetector\u003dnew BusEventBasedConfigMapWatcherChangeDetector(coreV1Api,mockEnvironment,ConfigReloadProperties.DEFAULT,UPDATE_STRATEGY,configMapPropertySourceLocator,new KubernetesNamespaceProvider(mockEnvironment),configurationWatcherConfigurationProperties,threadPoolTaskExecutor,new BusRefreshTrigger(applicationEventPublisher,busProperties.getId()));\n  }\n  @Test void triggerRefreshWithConfigMap(){\n    V1ObjectMeta objectMeta\u003dnew V1ObjectMeta();\n    objectMeta.setName(\"foo\");\n    V1ConfigMap configMap\u003dnew V1ConfigMap();\n    configMap.setMetadata(objectMeta);\n    changeDetector.triggerRefresh(configMap,configMap.getMetadata().getName());\n    ArgumentCaptor\u003cRefreshRemoteApplicationEvent\u003e argumentCaptor\u003dArgumentCaptor.forClass(RefreshRemoteApplicationEvent.class);\n    verify(applicationEventPublisher).publishEvent(argumentCaptor.capture());\n    assertThat(argumentCaptor.getValue().getSource()).isEqualTo(configMap);\n    assertThat(argumentCaptor.getValue().getOriginService()).isEqualTo(busProperties.getId());\n    assertThat(argumentCaptor.getValue().getDestinationService()).isEqualTo(\"foo:**\");\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Kris Iyer\n */\n@ExtendWith(MockitoExtension.class) class BusEventBasedConfigMapWatcherChangeDetectorTests {\n  private static final ConfigurationUpdateStrategy UPDATE_STRATEGY\u003dnew ConfigurationUpdateStrategy(\"strategy\",() -\u003e {\n  }\n);\n  @Mock private CoreV1Api coreV1Api;\n  @Mock private KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator;\n  @Mock private ThreadPoolTaskExecutor threadPoolTaskExecutor;\n  @Mock private ApplicationEventPublisher applicationEventPublisher;\n  private BusEventBasedConfigMapWatcherChangeDetector changeDetector;\n  private BusProperties busProperties;\n  @BeforeEach void setup();\n  @Test void triggerRefreshWithConfigMap();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-catalog-watcher/src/main/java/org/springframework/cloud/kubernetes/k8s/client/catalog/watcher/Application.java",
        "name": "Application",
        "modifiers": "@SpringBootApplication @EnableScheduling public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.catalog.watcher.Application",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableScheduling public class Application {\n  public static void main(  String[] args){\n    SpringApplication.run(Application.class,args);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableScheduling public class Application {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-catalog-watcher/src/main/java/org/springframework/cloud/kubernetes/k8s/client/catalog/watcher/EndpointNameAndNamespaceService.java",
        "name": "EndpointNameAndNamespaceService",
        "modifiers": "@Service public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.catalog.watcher.EndpointNameAndNamespaceService",
        "extend": "",
        "implements": "",
        "raw": "/** \n * holds an EndpointNameAndNamespace object, needed so that the controller can poll to see if anything has changed. And we call the controller from our tests.\n * @author wind57\n */\n@Service public class EndpointNameAndNamespaceService {\n  private List\u003cEndpointNameAndNamespace\u003e result;\n  public List\u003cEndpointNameAndNamespace\u003e result(){\n    return result;\n  }\n  public void setResult(  List\u003cEndpointNameAndNamespace\u003e result){\n    this.result\u003dresult;\n  }\n}\n",
        "abstract": "/** \n * holds an EndpointNameAndNamespace object, needed so that the controller can poll to see if anything has changed. And we call the controller from our tests.\n * @author wind57\n */\n@Service public class EndpointNameAndNamespaceService {\n  private List\u003cEndpointNameAndNamespace\u003e result;\n  public List\u003cEndpointNameAndNamespace\u003e result();\n  public void setResult(  List\u003cEndpointNameAndNamespace\u003e result);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-catalog-watcher/src/main/java/org/springframework/cloud/kubernetes/k8s/client/catalog/watcher/HeartBeatListener.java",
        "name": "HeartBeatListener",
        "modifiers": "@Component public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.catalog.watcher.HeartBeatListener",
        "extend": "",
        "implements": "ApplicationListener\u003cApplicationEvent\u003e",
        "raw": "/** \n * Listener that will catch events from KubernetesCatalogWatch.\n * @author wind57\n */\n@Component public class HeartBeatListener implements ApplicationListener\u003cApplicationEvent\u003e {\n  private final EndpointNameAndNamespaceService service;\n  public HeartBeatListener(  EndpointNameAndNamespaceService service){\n    this.service\u003dservice;\n  }\n  @SuppressWarnings(\"unchecked\") @Override public void onApplicationEvent(  ApplicationEvent event){\n    if (event instanceof HeartbeatEvent) {\n      List\u003cEndpointNameAndNamespace\u003e result\u003d(List\u003cEndpointNameAndNamespace\u003e)heartbeatEvent.getValue();\n      service.setResult(result);\n    }\n  }\n}\n",
        "abstract": "/** \n * Listener that will catch events from KubernetesCatalogWatch.\n * @author wind57\n */\n@Component public class HeartBeatListener implements ApplicationListener\u003cApplicationEvent\u003e {\n  private final EndpointNameAndNamespaceService service;\n  public HeartBeatListener(  EndpointNameAndNamespaceService service);\n  @SuppressWarnings(\"unchecked\") @Override public void onApplicationEvent(  ApplicationEvent event);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-catalog-watcher/src/main/java/org/springframework/cloud/kubernetes/k8s/client/catalog/watcher/HeartbeatController.java",
        "name": "HeartbeatController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.catalog.watcher.HeartbeatController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class HeartbeatController {\n  private final EndpointNameAndNamespaceService service;\n  public HeartbeatController(  EndpointNameAndNamespaceService service){\n    this.service\u003dservice;\n  }\n  @GetMapping(\"/result\") public List\u003cEndpointNameAndNamespace\u003e result(){\n    return service.result();\n  }\n}\n",
        "abstract": "@RestController public class HeartbeatController {\n  private final EndpointNameAndNamespaceService service;\n  public HeartbeatController(  EndpointNameAndNamespaceService service);\n  @GetMapping(\"/result\") public List\u003cEndpointNameAndNamespace\u003e result();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-catalog-watcher/src/test/java/org/springframework/cloud/kubernetes/k8s/client/catalog/watcher/KubernetesClientCatalogWatchIT.java",
        "name": "KubernetesClientCatalogWatchIT",
        "modifiers": "@TestMethodOrder(MethodOrderer.OrderAnnotation.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.catalog.watcher.KubernetesClientCatalogWatchIT",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class) class KubernetesClientCatalogWatchIT {\n  private static final String APP_NAME\u003d\"spring-cloud-kubernetes-k8s-client-catalog-watcher\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String NAMESPACE_A\u003d\"namespacea\";\n  private static final String NAMESPACE_B\u003d\"namespaceb\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + APP_NAME + \":\"+ Commons.pomVersion();\n  private static Util util;\n  @BeforeAll static void beforeAll() throws Exception {\n    K3S.start();\n    Commons.validateImage(APP_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(APP_NAME,K3S);\n    Images.loadBusybox(K3S);\n    util\u003dnew Util(K3S);\n    util.setUp(NAMESPACE);\n    app(Phase.CREATE);\n  }\n  @AfterAll static void afterAll(){\n    util.deleteClusterWide(NAMESPACE,Set.of(NAMESPACE_A,NAMESPACE_B));\n    util.deleteNamespace(NAMESPACE_A);\n    util.deleteNamespace(NAMESPACE_B);\n    app(Phase.DELETE);\n    Commons.systemPrune();\n  }\n  @BeforeEach void beforeEach(){\n    util.busybox(NAMESPACE,Phase.CREATE);\n  }\n  /** \n * \u003cpre\u003e - we deploy a busybox service with 2 replica pods - we receive an event from KubernetesCatalogWatcher, assert what is inside it - delete the busybox service - assert that we receive only spring-cloud-kubernetes-client-catalog-watcher pod \u003c/pre\u003e\n */\n  @Test @Order(1) void testCatalogWatchWithEndpoints(){\n    waitForLogStatement(\"stateGenerator is of type: KubernetesEndpointsCatalogWatch\",K3S,APP_NAME);\n    test();\n  }\n  @Test @Order(2) void testCatalogWatchWithEndpointSlices(){\n    KubernetesClientCatalogWatchUtils.patchForEndpointSlices(APP_NAME,NAMESPACE,DOCKER_IMAGE);\n    waitForLogStatement(\"stateGenerator is of type: KubernetesEndpointSlicesCatalogWatch\",K3S,APP_NAME);\n    test();\n    testCatalogWatchWithEndpointsNamespaces();\n  }\n  void testCatalogWatchWithEndpointsNamespaces(){\n    util.createNamespace(NAMESPACE_A);\n    util.createNamespace(NAMESPACE_B);\n    util.setUpClusterWide(NAMESPACE,Set.of(NAMESPACE_A,NAMESPACE_B));\n    util.busybox(NAMESPACE_A,Phase.CREATE);\n    util.busybox(NAMESPACE_B,Phase.CREATE);\n    KubernetesClientCatalogWatchUtils.patchForEndpointsNamespaces(APP_NAME,NAMESPACE,DOCKER_IMAGE);\n    KubernetesClientCatalogWatchNamespacesDelegate.testCatalogWatchWithEndpointsNamespaces(APP_NAME);\n    util.busybox(NAMESPACE_A,Phase.CREATE);\n    util.busybox(NAMESPACE_B,Phase.CREATE);\n    KubernetesClientCatalogWatchUtils.patchForEndpointSlicesNamespaces(APP_NAME,NAMESPACE,DOCKER_IMAGE);\n    KubernetesClientCatalogWatchNamespacesDelegate.testCatalogWatchWithEndpointSlicesNamespaces(APP_NAME);\n  }\n  /** \n * the test is the same for both endpoints and endpoint slices, the set-up for them is different.\n */\n  private void test(){\n    WebClient client\u003dbuilder().baseUrl(\"http://localhost/result\").build();\n    EndpointNameAndNamespace[] holder\u003dnew EndpointNameAndNamespace[2];\n    ResolvableType resolvableType\u003dResolvableType.forClassWithGenerics(List.class,EndpointNameAndNamespace.class);\n    await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(240)).until(() -\u003e {\n      List\u003cEndpointNameAndNamespace\u003e result\u003d(List\u003cEndpointNameAndNamespace\u003e)client.method(HttpMethod.GET).retrieve().bodyToMono(ParameterizedTypeReference.forType(resolvableType.getType())).retryWhen(retrySpec()).block();\n      if (result !\u003d null) {\n        if (result.size() !\u003d 3) {\n          return false;\n        }\n        holder[0]\u003dresult.get(0);\n        holder[1]\u003dresult.get(1);\n        return true;\n      }\n      return false;\n    }\n);\n    EndpointNameAndNamespace resultOne\u003dholder[0];\n    EndpointNameAndNamespace resultTwo\u003dholder[1];\n    Assertions.assertNotNull(resultOne);\n    Assertions.assertNotNull(resultTwo);\n    Assertions.assertTrue(resultOne.endpointName().contains(\"busybox\"));\n    Assertions.assertTrue(resultTwo.endpointName().contains(\"busybox\"));\n    Assertions.assertEquals(\"default\",resultOne.namespace());\n    Assertions.assertEquals(\"default\",resultTwo.namespace());\n    util.busybox(NAMESPACE,Phase.DELETE);\n    EndpointNameAndNamespace[] afterDelete\u003dnew EndpointNameAndNamespace[1];\n    await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(240)).until(() -\u003e {\n      List\u003cEndpointNameAndNamespace\u003e result\u003d(List\u003cEndpointNameAndNamespace\u003e)client.method(HttpMethod.GET).retrieve().bodyToMono(ParameterizedTypeReference.forType(resolvableType.getType())).retryWhen(retrySpec()).block();\n      if (result !\u003d null \u0026\u0026 result.size() !\u003d 1) {\n        return false;\n      }\n      if (result !\u003d null) {\n        afterDelete[0]\u003dresult.get(0);\n        return true;\n      }\n      return false;\n    }\n);\n    Assertions.assertTrue(afterDelete[0].endpointName().contains(APP_NAME));\n    Assertions.assertEquals(\"default\",afterDelete[0].namespace());\n  }\n  private static void app(  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"app/watcher-deployment.yaml\");\n    V1Service service\u003d(V1Service)util.yaml(\"app/watcher-service.yaml\");\n    V1Ingress ingress\u003d(V1Ingress)util.yaml(\"app/watcher-ingress.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(NAMESPACE,null,deployment,service,ingress,true);\n    }\n else     if (phase.equals(Phase.DELETE)) {\n      util.deleteAndWait(NAMESPACE,deployment,service,ingress);\n    }\n  }\n  private WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class) class KubernetesClientCatalogWatchIT {\n  private static final String APP_NAME\u003d\"spring-cloud-kubernetes-k8s-client-catalog-watcher\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String NAMESPACE_A\u003d\"namespacea\";\n  private static final String NAMESPACE_B\u003d\"namespaceb\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + APP_NAME + \":\"+ Commons.pomVersion();\n  private static Util util;\n  @BeforeAll static void beforeAll() throws Exception;\n  @AfterAll static void afterAll();\n  @BeforeEach void beforeEach();\n  /** \n * \u003cpre\u003e - we deploy a busybox service with 2 replica pods - we receive an event from KubernetesCatalogWatcher, assert what is inside it - delete the busybox service - assert that we receive only spring-cloud-kubernetes-client-catalog-watcher pod \u003c/pre\u003e\n */\n  @Test @Order(1) void testCatalogWatchWithEndpoints();\n  @Test @Order(2) void testCatalogWatchWithEndpointSlices();\n  void testCatalogWatchWithEndpointsNamespaces();\n  /** \n * the test is the same for both endpoints and endpoint slices, the set-up for them is different.\n */\n  private void test();\n  private static void app(  Phase phase);\n  private WebClient.Builder builder();\n  private RetryBackoffSpec retrySpec();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-catalog-watcher/src/test/java/org/springframework/cloud/kubernetes/k8s/client/catalog/watcher/KubernetesClientCatalogWatchNamespacesDelegate.java",
        "name": "KubernetesClientCatalogWatchNamespacesDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.catalog.watcher.KubernetesClientCatalogWatchNamespacesDelegate",
        "extend": "",
        "implements": "",
        "raw": "final class KubernetesClientCatalogWatchNamespacesDelegate {\n  private KubernetesClientCatalogWatchNamespacesDelegate(){\n  }\n  private static final String NAMESPACE_A\u003d\"namespacea\";\n  private static final String NAMESPACE_B\u003d\"namespaceb\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  /** \n * \u003cpre\u003e - we deploy one busybox service with 2 replica pods in namespace namespacea - we deploy one busybox service with 2 replica pods in namespace namespaceb - we enable the search to be made in namespacea and default ones - we receive an event from KubernetesCatalogWatcher, assert what is inside it - delete both busybox services in namespacea and namespaceb - assert that we receive only spring-cloud-kubernetes-client-catalog-watcher pod \u003c/pre\u003e\n */\n  static void testCatalogWatchWithEndpointsNamespaces(  String deploymentName){\n    waitForLogStatement(\"stateGenerator is of type: KubernetesEndpointsCatalogWatch\",K3S,deploymentName);\n    testForNamespacesFilter();\n  }\n  static void testCatalogWatchWithEndpointSlicesNamespaces(  String deploymentName){\n    waitForLogStatement(\"stateGenerator is of type: KubernetesEndpointSlicesCatalogWatch\",K3S,deploymentName);\n    testForNamespacesFilter();\n  }\n  /** \n * the test is the same for both endpoints and endpoint slices, the set-up for them is different.\n */\n  private static void testForNamespacesFilter(){\n    WebClient client\u003dbuilder().baseUrl(\"http://localhost/result\").build();\n    EndpointNameAndNamespace[] holder\u003dnew EndpointNameAndNamespace[4];\n    ResolvableType resolvableType\u003dResolvableType.forClassWithGenerics(List.class,EndpointNameAndNamespace.class);\n    await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(240)).until(() -\u003e {\n      List\u003cEndpointNameAndNamespace\u003e result\u003d(List\u003cEndpointNameAndNamespace\u003e)client.method(HttpMethod.GET).retrieve().bodyToMono(ParameterizedTypeReference.forType(resolvableType.getType())).retryWhen(retrySpec()).block();\n      if (result !\u003d null) {\n        Assertions.assertEquals(result.size(),4);\n        holder[0]\u003dresult.get(0);\n        holder[1]\u003dresult.get(1);\n        holder[2]\u003dresult.get(2);\n        holder[3]\u003dresult.get(3);\n        return true;\n      }\n      return false;\n    }\n);\n    EndpointNameAndNamespace resultOne\u003dholder[0];\n    EndpointNameAndNamespace resultTwo\u003dholder[1];\n    EndpointNameAndNamespace resultThree\u003dholder[2];\n    EndpointNameAndNamespace resultFour\u003dholder[3];\n    Assertions.assertTrue(resultOne.endpointName().contains(\"busybox\"));\n    Assertions.assertTrue(resultTwo.endpointName().contains(\"busybox\"));\n    Assertions.assertTrue(resultThree.endpointName().contains(\"busybox\"));\n    Assertions.assertTrue(resultFour.endpointName().contains(\"busybox\"));\n    List\u003cEndpointNameAndNamespace\u003e sorted\u003dArrays.stream(holder).sorted(Comparator.comparing(EndpointNameAndNamespace::namespace)).toList();\n    Assertions.assertEquals(NAMESPACE_A,sorted.get(0).namespace());\n    Assertions.assertEquals(NAMESPACE_A,sorted.get(1).namespace());\n    Assertions.assertEquals(NAMESPACE_B,sorted.get(2).namespace());\n    Assertions.assertEquals(NAMESPACE_B,sorted.get(3).namespace());\n    util\u003dnew Util(K3S);\n    util.busybox(NAMESPACE_A,Phase.DELETE);\n    util.busybox(NAMESPACE_B,Phase.DELETE);\n    await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(240)).until(() -\u003e {\n      List\u003cEndpointNameAndNamespace\u003e result\u003d(List\u003cEndpointNameAndNamespace\u003e)client.method(HttpMethod.GET).retrieve().bodyToMono(ParameterizedTypeReference.forType(resolvableType.getType())).retryWhen(retrySpec()).block();\n      return result.size() \u003d\u003d 0;\n    }\n);\n  }\n  private static WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private static RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n}\n",
        "abstract": "final class KubernetesClientCatalogWatchNamespacesDelegate {\n  private KubernetesClientCatalogWatchNamespacesDelegate();\n  private static final String NAMESPACE_A\u003d\"namespacea\";\n  private static final String NAMESPACE_B\u003d\"namespaceb\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  /** \n * \u003cpre\u003e - we deploy one busybox service with 2 replica pods in namespace namespacea - we deploy one busybox service with 2 replica pods in namespace namespaceb - we enable the search to be made in namespacea and default ones - we receive an event from KubernetesCatalogWatcher, assert what is inside it - delete both busybox services in namespacea and namespaceb - assert that we receive only spring-cloud-kubernetes-client-catalog-watcher pod \u003c/pre\u003e\n */\n  static void testCatalogWatchWithEndpointsNamespaces(  String deploymentName);\n  static void testCatalogWatchWithEndpointSlicesNamespaces(  String deploymentName);\n  /** \n * the test is the same for both endpoints and endpoint slices, the set-up for them is different.\n */\n  private static void testForNamespacesFilter();\n  private static WebClient.Builder builder();\n  private static RetryBackoffSpec retrySpec();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-catalog-watcher/src/test/java/org/springframework/cloud/kubernetes/k8s/client/catalog/watcher/KubernetesClientCatalogWatchUtils.java",
        "name": "KubernetesClientCatalogWatchUtils",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.catalog.watcher.KubernetesClientCatalogWatchUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class KubernetesClientCatalogWatchUtils {\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-cloud-kubernetes-k8s-client-catalog-watcher\");\n  private KubernetesClientCatalogWatchUtils(){\n  }\n  private static final String BODY_ONE\u003dnull;\n  private static final String BODY_TWO\u003dnull;\n  private static final String BODY_THREE\u003dnull;\n  static void patchForEndpointSlices(  String deploymentName,  String namespace,  String imageName){\n    patchWithReplace(imageName,deploymentName,namespace,BODY_ONE,POD_LABELS);\n  }\n  static void patchForEndpointsNamespaces(  String deploymentName,  String namespace,  String imageName){\n    patchWithReplace(imageName,deploymentName,namespace,BODY_TWO,POD_LABELS);\n  }\n  static void patchForEndpointSlicesNamespaces(  String deploymentName,  String namespace,  String imageName){\n    patchWithReplace(imageName,deploymentName,namespace,BODY_THREE,POD_LABELS);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class KubernetesClientCatalogWatchUtils {\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-cloud-kubernetes-k8s-client-catalog-watcher\");\n  private KubernetesClientCatalogWatchUtils();\n  private static final String BODY_ONE\u003dnull;\n  private static final String BODY_TWO\u003dnull;\n  private static final String BODY_THREE\u003dnull;\n  static void patchForEndpointSlices(  String deploymentName,  String namespace,  String imageName);\n  static void patchForEndpointsNamespaces(  String deploymentName,  String namespace,  String imageName);\n  static void patchForEndpointSlicesNamespaces(  String deploymentName,  String namespace,  String imageName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-kafka-configmap-reload-multiple-apps/kafka-configmap-app-b/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/appB/AppBTestApplication.java",
        "name": "AppBTestApplication",
        "modifiers": "@SpringBootApplication @RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.appB.AppBTestApplication",
        "extend": "",
        "implements": "ApplicationListener\u003cRefreshRemoteApplicationEvent\u003e",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication @RestController public class AppBTestApplication implements ApplicationListener\u003cRefreshRemoteApplicationEvent\u003e {\n  private final Log LOG\u003dLogFactory.getLog(getClass());\n  private boolean value\u003dfalse;\n  public static void main(  String[] args){\n    SpringApplication.run(AppBTestApplication.class,args);\n  }\n  @GetMapping(\"/app-b\") public boolean index(){\n    LOG.info(\"Current value: \" + value);\n    return value;\n  }\n  @Override public void onApplicationEvent(  RefreshRemoteApplicationEvent refreshRemoteApplicationEvent){\n    LOG.info(\"Received remote refresh event from origin: \" + refreshRemoteApplicationEvent.getOriginService() + \" to destination : \"+ refreshRemoteApplicationEvent.getDestinationService());\n    this.value\u003dtrue;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication @RestController public class AppBTestApplication implements ApplicationListener\u003cRefreshRemoteApplicationEvent\u003e {\n  private final Log LOG\u003dLogFactory.getLog(getClass());\n  private boolean value\u003dfalse;\n  public static void main(  String[] args);\n  @GetMapping(\"/app-b\") public boolean index();\n  @Override public void onApplicationEvent(  RefreshRemoteApplicationEvent refreshRemoteApplicationEvent);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-kafka-configmap-reload-multiple-apps/kafka-configmap-test-app/src/test/java/org/springframework/cloud/kubernetes/configuration/watcher/multiple/apps/ConfigurationWatcherMultipleAppsIT.java",
        "name": "ConfigurationWatcherMultipleAppsIT",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.multiple.apps.ConfigurationWatcherMultipleAppsIT",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass ConfigurationWatcherMultipleAppsIT {\n  private static final String CONFIG_WATCHER_APP_A_IMAGE\u003d\"kafka-configmap-app-a\";\n  private static final String CONFIG_WATCHER_APP_B_IMAGE\u003d\"kafka-configmap-app-b\";\n  private static final String SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME\u003d\"spring-cloud-kubernetes-configuration-watcher\";\n  private static final String CONFIG_MAP_NAME\u003d\"multiple-apps\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  @BeforeAll static void beforeAll() throws Exception {\n    K3S.start();\n    util\u003dnew Util(K3S);\n    Commons.validateImage(SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME,K3S);\n    Commons.validateImage(CONFIG_WATCHER_APP_A_IMAGE,K3S);\n    Commons.loadSpringCloudKubernetesImage(CONFIG_WATCHER_APP_A_IMAGE,K3S);\n    Commons.validateImage(CONFIG_WATCHER_APP_B_IMAGE,K3S);\n    Commons.loadSpringCloudKubernetesImage(CONFIG_WATCHER_APP_B_IMAGE,K3S);\n    Images.loadKafka(K3S);\n    util\u003dnew Util(K3S);\n    util.setUp(NAMESPACE);\n  }\n  @AfterAll static void afterAll() throws Exception {\n    Commons.cleanUp(SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME,K3S);\n    Commons.cleanUp(CONFIG_WATCHER_APP_A_IMAGE,K3S);\n    Commons.cleanUp(CONFIG_WATCHER_APP_B_IMAGE,K3S);\n    Commons.systemPrune();\n  }\n  @BeforeEach void setup(){\n    util.kafka(NAMESPACE,Phase.CREATE);\n    appA(Phase.CREATE);\n    appB(Phase.CREATE);\n    configWatcher(Phase.CREATE);\n  }\n  @AfterEach void afterEach(){\n    util.kafka(NAMESPACE,Phase.DELETE);\n    appA(Phase.DELETE);\n    appB(Phase.DELETE);\n    configWatcher(Phase.DELETE);\n  }\n  @Test void testRefresh(){\n    V1ConfigMap configMap\u003dnew V1ConfigMapBuilder().editOrNewMetadata().withName(CONFIG_MAP_NAME).addToLabels(\"spring.cloud.kubernetes.config\",\"true\").addToAnnotations(\"spring.cloud.kubernetes.configmap.apps\",\"spring-cloud-kubernetes-client-configuration-watcher-configmap-app-a, \" + \"spring-cloud-kubernetes-client-configuration-watcher-configmap-app-b\").endMetadata().addToData(\"foo\",\"hello world\").build();\n    util.createAndWait(NAMESPACE,configMap,null);\n    WebClient.Builder builderA\u003dbuilder();\n    WebClient serviceClientA\u003dbuilderA.baseUrl(\"http://localhost:80/app-a\").build();\n    WebClient.Builder builderB\u003dbuilder();\n    WebClient serviceClientB\u003dbuilderB.baseUrl(\"http://localhost:80/app-b\").build();\n    Boolean[] valueA\u003dnew Boolean[1];\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(240)).until(() -\u003e {\n      valueA[0]\u003dserviceClientA.method(HttpMethod.GET).retrieve().bodyToMono(Boolean.class).retryWhen(retrySpec()).block();\n      return valueA[0];\n    }\n);\n    Assertions.assertTrue(valueA[0]);\n    Boolean[] valueB\u003dnew Boolean[1];\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(240)).until(() -\u003e {\n      valueB[0]\u003dserviceClientB.method(HttpMethod.GET).retrieve().bodyToMono(Boolean.class).retryWhen(retrySpec()).block();\n      return valueB[0];\n    }\n);\n    Assertions.assertTrue(valueB[0]);\n    util.deleteAndWait(NAMESPACE,configMap,null);\n  }\n  private void appA(  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"app-a/app-a-deployment.yaml\");\n    V1Service service\u003d(V1Service)util.yaml(\"app-a/app-a-service.yaml\");\n    V1Ingress ingress\u003d(V1Ingress)util.yaml(\"ingress/spring-cloud-kubernetes-configuration-watcher-multiple-apps-ingress.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(NAMESPACE,null,deployment,service,ingress,true);\n    }\n else     if (phase.equals(Phase.DELETE)) {\n      util.deleteAndWait(NAMESPACE,deployment,service,ingress);\n    }\n  }\n  private void appB(  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"app-b/app-b-deployment.yaml\");\n    V1Service service\u003d(V1Service)util.yaml(\"app-b/app-b-service.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(NAMESPACE,null,deployment,service,null,true);\n    }\n else     if (phase.equals(Phase.DELETE)) {\n      util.deleteAndWait(NAMESPACE,deployment,service,null);\n    }\n  }\n  private void configWatcher(  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"config-watcher/spring-cloud-kubernetes-configuration-watcher-bus-kafka-deployment.yaml\");\n    V1Service service\u003d(V1Service)util.yaml(\"config-watcher/spring-cloud-kubernetes-configuration-watcher-service.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(NAMESPACE,null,deployment,service,null,true);\n    }\n else     if (phase.equals(Phase.DELETE)) {\n      util.deleteAndWait(NAMESPACE,deployment,service,null);\n    }\n  }\n  private WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(240,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass ConfigurationWatcherMultipleAppsIT {\n  private static final String CONFIG_WATCHER_APP_A_IMAGE\u003d\"kafka-configmap-app-a\";\n  private static final String CONFIG_WATCHER_APP_B_IMAGE\u003d\"kafka-configmap-app-b\";\n  private static final String SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME\u003d\"spring-cloud-kubernetes-configuration-watcher\";\n  private static final String CONFIG_MAP_NAME\u003d\"multiple-apps\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  @BeforeAll static void beforeAll() throws Exception;\n  @AfterAll static void afterAll() throws Exception;\n  @BeforeEach void setup();\n  @AfterEach void afterEach();\n  @Test void testRefresh();\n  private void appA(  Phase phase);\n  private void appB(  Phase phase);\n  private void configWatcher(  Phase phase);\n  private WebClient.Builder builder();\n  private RetryBackoffSpec retrySpec();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-kafka-configmap-reload-multiple-apps/kafka-configmap-app-a/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/appA/AppATestApplication.java",
        "name": "AppATestApplication",
        "modifiers": "@SpringBootApplication @RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.appA.AppATestApplication",
        "extend": "",
        "implements": "ApplicationListener\u003cRefreshRemoteApplicationEvent\u003e",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication @RestController public class AppATestApplication implements ApplicationListener\u003cRefreshRemoteApplicationEvent\u003e {\n  private final Log LOG\u003dLogFactory.getLog(getClass());\n  private boolean value\u003dfalse;\n  public static void main(  String[] args){\n    SpringApplication.run(AppATestApplication.class,args);\n  }\n  @GetMapping(\"/app-a\") public boolean index(){\n    LOG.info(\"Current value: \" + value);\n    return value;\n  }\n  @Override public void onApplicationEvent(  RefreshRemoteApplicationEvent refreshRemoteApplicationEvent){\n    LOG.info(\"Received remote refresh event from origin: \" + refreshRemoteApplicationEvent.getOriginService() + \" to destination : \"+ refreshRemoteApplicationEvent.getDestinationService());\n    this.value\u003dtrue;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication @RestController public class AppATestApplication implements ApplicationListener\u003cRefreshRemoteApplicationEvent\u003e {\n  private final Log LOG\u003dLogFactory.getLog(getClass());\n  private boolean value\u003dfalse;\n  public static void main(  String[] args);\n  @GetMapping(\"/app-a\") public boolean index();\n  @Override public void onApplicationEvent(  RefreshRemoteApplicationEvent refreshRemoteApplicationEvent);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-configuration-watcher/src/test/java/org/springframework/cloud/kubernetes/configuration/watcher/TestUtil.java",
        "name": "TestUtil",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.TestUtil",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class TestUtil {\n  private TestUtil(){\n  }\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-cloud-kubernetes-configuration-watcher\");\n  private static final String BODY_ONE\u003dnull;\n  static void patchForDisabledReload(  String deploymentName,  String namespace,  String imageName){\n    patchWithReplace(imageName,deploymentName,namespace,BODY_ONE,POD_LABELS);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class TestUtil {\n  private TestUtil();\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-cloud-kubernetes-configuration-watcher\");\n  private static final String BODY_ONE\u003dnull;\n  static void patchForDisabledReload(  String deploymentName,  String namespace,  String imageName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-configuration-watcher/src/test/java/org/springframework/cloud/kubernetes/configuration/watcher/ActuatorRefreshIT.java",
        "name": "ActuatorRefreshIT",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.ActuatorRefreshIT",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass ActuatorRefreshIT {\n  private static final String SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME\u003d\"spring-cloud-kubernetes-configuration-watcher\";\n  private static final String WIREMOCK_HOST\u003d\"localhost\";\n  private static final String WIREMOCK_PATH\u003d\"/\";\n  private static final int WIREMOCK_PORT\u003d80;\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME + \":\"+ Commons.pomVersion();\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  @BeforeAll static void beforeAll() throws Exception {\n    K3S.start();\n    Commons.validateImage(SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME,K3S);\n    Images.loadWiremock(K3S);\n    util\u003dnew Util(K3S);\n    util.setUp(NAMESPACE);\n    configWatcher(Phase.CREATE);\n  }\n  @AfterAll static void afterAll() throws Exception {\n    configWatcher(Phase.DELETE);\n    Commons.cleanUp(SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME,K3S);\n    Commons.systemPrune();\n  }\n  @BeforeEach void setup(){\n    util.wiremock(NAMESPACE,WIREMOCK_PATH,Phase.CREATE);\n  }\n  @AfterEach void after(){\n    util.wiremock(NAMESPACE,WIREMOCK_PATH,Phase.DELETE);\n  }\n  @Test void testActuatorRefresh(){\n    WireMock.configureFor(WIREMOCK_HOST,WIREMOCK_PORT);\n    await().timeout(Duration.ofSeconds(60)).ignoreException(SocketTimeoutException.class).until(() -\u003e WireMock.stubFor(WireMock.post(WireMock.urlEqualTo(\"/actuator/refresh\")).willReturn(WireMock.aResponse().withBody(\"{}\").withStatus(200))).getResponse().wasConfigured());\n    createConfigMap();\n    await().atMost(Duration.ofSeconds(30)).until(() -\u003e !WireMock.findAll(WireMock.postRequestedFor(WireMock.urlEqualTo(\"/actuator/refresh\"))).isEmpty());\n    WireMock.verify(WireMock.postRequestedFor(WireMock.urlEqualTo(\"/actuator/refresh\")));\n    deleteConfigMap();\n    testActuatorRefreshReloadDisabled();\n  }\n  void testActuatorRefreshReloadDisabled(){\n    TestUtil.patchForDisabledReload(SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME,NAMESPACE,DOCKER_IMAGE);\n    WireMock.configureFor(WIREMOCK_HOST,WIREMOCK_PORT);\n    await().timeout(Duration.ofSeconds(60)).until(() -\u003e WireMock.stubFor(WireMock.post(WireMock.urlEqualTo(\"/actuator/refresh\")).willReturn(WireMock.aResponse().withBody(\"{}\").withStatus(200))).getResponse().wasConfigured());\n    createConfigMap();\n    await().atMost(Duration.ofSeconds(30)).until(() -\u003e !WireMock.findAll(WireMock.postRequestedFor(WireMock.urlEqualTo(\"/actuator/refresh\"))).isEmpty());\n    Commons.waitForLogStatement(\"creating NOOP strategy because reload is disabled\",K3S,SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME);\n    Assertions.assertFalse(logs().contains(\"ConfigReloadUtil\"));\n    WireMock.verify(WireMock.postRequestedFor(WireMock.urlEqualTo(\"/actuator/refresh\")));\n    deleteConfigMap();\n  }\n  private static void configWatcher(  Phase phase){\n    V1ConfigMap configMap\u003d(V1ConfigMap)util.yaml(\"config-watcher/spring-cloud-kubernetes-configuration-watcher-configmap.yaml\");\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"config-watcher/spring-cloud-kubernetes-configuration-watcher-deployment.yaml\");\n    V1Service service\u003d(V1Service)util.yaml(\"config-watcher/spring-cloud-kubernetes-configuration-watcher-service.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(NAMESPACE,configMap,null);\n      util.createAndWait(NAMESPACE,null,deployment,service,null,true);\n    }\n else {\n      util.deleteAndWait(NAMESPACE,configMap,null);\n      util.deleteAndWait(NAMESPACE,deployment,service,null);\n    }\n  }\n  private void createConfigMap(){\n    V1ConfigMap configMap\u003dnew V1ConfigMapBuilder().editOrNewMetadata().withName(\"service-wiremock\").addToLabels(\"spring.cloud.kubernetes.config\",\"true\").endMetadata().addToData(\"foo\",\"bar\").build();\n    util.createAndWait(NAMESPACE,configMap,null);\n  }\n  private void deleteConfigMap(){\n    V1ConfigMap configMap\u003dnew V1ConfigMapBuilder().editOrNewMetadata().withName(\"service-wiremock\").addToLabels(\"spring.cloud.kubernetes.config\",\"true\").endMetadata().addToData(\"foo\",\"bar\").build();\n    util.deleteAndWait(NAMESPACE,configMap,null);\n  }\n  private String logs(){\n    try {\n      String appPodName\u003dK3S.execInContainer(\"sh\",\"-c\",\"kubectl get pods -l app\u003d\" + SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME + \" -o\u003dname --no-headers | tr -d \u0027\\n\u0027\").getStdout();\n      Container.ExecResult execResult\u003dK3S.execInContainer(\"sh\",\"-c\",\"kubectl logs \" + appPodName.trim());\n      return execResult.getStdout();\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass ActuatorRefreshIT {\n  private static final String SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME\u003d\"spring-cloud-kubernetes-configuration-watcher\";\n  private static final String WIREMOCK_HOST\u003d\"localhost\";\n  private static final String WIREMOCK_PATH\u003d\"/\";\n  private static final int WIREMOCK_PORT\u003d80;\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME + \":\"+ Commons.pomVersion();\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  @BeforeAll static void beforeAll() throws Exception;\n  @AfterAll static void afterAll() throws Exception;\n  @BeforeEach void setup();\n  @AfterEach void after();\n  @Test void testActuatorRefresh();\n  void testActuatorRefreshReloadDisabled();\n  private static void configWatcher(  Phase phase);\n  private void createConfigMap();\n  private void deleteConfigMap();\n  private String logs();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-configuration-watcher/src/test/java/org/springframework/cloud/kubernetes/configuration/watcher/ActuatorRefreshMultipleNamespacesIT.java",
        "name": "ActuatorRefreshMultipleNamespacesIT",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.ActuatorRefreshMultipleNamespacesIT",
        "extend": "",
        "implements": "",
        "raw": "class ActuatorRefreshMultipleNamespacesIT {\n  private static final String SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME\u003d\"spring-cloud-kubernetes-configuration-watcher\";\n  private static final String WIREMOCK_HOST\u003d\"localhost\";\n  private static final String WIREMOCK_PATH\u003d\"/\";\n  private static final int WIREMOCK_PORT\u003d80;\n  private static final String DEFAULT_NAMESPACE\u003d\"default\";\n  private static final String LEFT_NAMESPACE\u003d\"left\";\n  private static final String RIGHT_NAMESPACE\u003d\"right\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  @BeforeAll static void beforeAll() throws Exception {\n    K3S.start();\n    Commons.validateImage(SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME,K3S);\n    util\u003dnew Util(K3S);\n    util.createNamespace(LEFT_NAMESPACE);\n    util.createNamespace(RIGHT_NAMESPACE);\n    util.wiremock(DEFAULT_NAMESPACE,\"/\",Phase.CREATE);\n    util.setUpClusterWide(DEFAULT_NAMESPACE,Set.of(DEFAULT_NAMESPACE,LEFT_NAMESPACE,RIGHT_NAMESPACE));\n    configWatcher(Phase.CREATE);\n  }\n  @AfterAll static void afterAll() throws Exception {\n    configWatcher(Phase.DELETE);\n    util.wiremock(DEFAULT_NAMESPACE,\"/\",Phase.DELETE);\n    util.deleteClusterWide(DEFAULT_NAMESPACE,Set.of(DEFAULT_NAMESPACE,LEFT_NAMESPACE,RIGHT_NAMESPACE));\n    util.deleteNamespace(LEFT_NAMESPACE);\n    util.deleteNamespace(RIGHT_NAMESPACE);\n    Commons.cleanUp(SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME,K3S);\n    Commons.systemPrune();\n  }\n  /** \n * \u003cpre\u003e - deploy config-watcher in default namespace - deploy wiremock in default namespace (so that we could assert calls to the actuator path) - deploy configmap-left in left namespaces with proper label and \"service-wiremock\" name. Because of the label, this will trigger a reload; because of the name this will trigger a reload against that name. This is a http refresh against the actuator. - same as above for the configmap-right. \u003c/pre\u003e\n */\n  @Test void testConfigMapActuatorRefreshMultipleNamespaces(){\n    WireMock.configureFor(WIREMOCK_HOST,WIREMOCK_PORT);\n    await().timeout(Duration.ofSeconds(60)).until(() -\u003e WireMock.stubFor(WireMock.post(WireMock.urlEqualTo(\"/actuator/refresh\")).willReturn(WireMock.aResponse().withBody(\"{}\").withStatus(200))).getResponse().wasConfigured());\n    V1ConfigMap leftConfigMap\u003dnew V1ConfigMapBuilder().editOrNewMetadata().withLabels(Map.of(\"spring.cloud.kubernetes.config\",\"true\")).withName(\"service-wiremock\").withNamespace(LEFT_NAMESPACE).endMetadata().addToData(\"color\",\"purple\").build();\n    util.createAndWait(LEFT_NAMESPACE,leftConfigMap,null);\n    V1ConfigMap rightConfigMap\u003dnew V1ConfigMapBuilder().editOrNewMetadata().withLabels(Map.of(\"spring.cloud.kubernetes.config\",\"true\")).withName(\"service-wiremock\").withNamespace(RIGHT_NAMESPACE).endMetadata().addToData(\"color\",\"green\").build();\n    util.createAndWait(RIGHT_NAMESPACE,rightConfigMap,null);\n    Commons.assertReloadLogStatements(\"ConfigMap service-wiremock was added in namespace left\",\"\",\"spring-cloud-kubernetes-configuration-watcher\");\n    Commons.assertReloadLogStatements(\"ConfigMap service-wiremock was added in namespace right\",\"\",\"spring-cloud-kubernetes-configuration-watcher\");\n    await().atMost(Duration.ofSeconds(30)).until(() -\u003e !WireMock.findAll(WireMock.postRequestedFor(WireMock.urlEqualTo(\"/actuator/refresh\"))).isEmpty());\n    WireMock.verify(WireMock.exactly(2),WireMock.postRequestedFor(WireMock.urlEqualTo(\"/actuator/refresh\")));\n    testSecretActuatorRefreshMultipleNamespaces();\n  }\n  /** \n * \u003cpre\u003e - deploy config-watcher in default namespace - deploy wiremock in default namespace (so that we could assert calls to the actuator path) - deploy secret-left in left namespaces with proper label and \"service-wiremock\". Because of the label, this will trigger a reload; because of the name this will trigger a reload against that name. This is a http refresh against the actuator. - same as above for the secret-right. \u003c/pre\u003e\n */\n  void testSecretActuatorRefreshMultipleNamespaces(){\n    await().timeout(Duration.ofSeconds(60)).ignoreException(SocketTimeoutException.class).until(() -\u003e WireMock.stubFor(WireMock.post(WireMock.urlEqualTo(\"/actuator/refresh\")).willReturn(WireMock.aResponse().withBody(\"{}\").withStatus(200))).getResponse().wasConfigured());\n    V1Secret leftSecret\u003dnew V1SecretBuilder().editOrNewMetadata().withLabels(Map.of(\"spring.cloud.kubernetes.secret\",\"true\")).withName(\"service-wiremock\").withNamespace(LEFT_NAMESPACE).endMetadata().addToData(\"color\",Base64.getEncoder().encode(\"purple\".getBytes(StandardCharsets.UTF_8))).build();\n    util.createAndWait(LEFT_NAMESPACE,null,leftSecret);\n    V1Secret rightSecret\u003dnew V1SecretBuilder().editOrNewMetadata().withLabels(Map.of(\"spring.cloud.kubernetes.secret\",\"true\")).withName(\"service-wiremock\").withNamespace(RIGHT_NAMESPACE).endMetadata().addToData(\"color\",Base64.getEncoder().encode(\"green\".getBytes(StandardCharsets.UTF_8))).build();\n    util.createAndWait(RIGHT_NAMESPACE,null,rightSecret);\n    Commons.assertReloadLogStatements(\"Secret service-wiremock was added in namespace left\",\"\",\"spring-cloud-kubernetes-configuration-watcher\");\n    Commons.assertReloadLogStatements(\"Secret service-wiremock was added in namespace right\",\"\",\"spring-cloud-kubernetes-configuration-watcher\");\n    await().atMost(Duration.ofSeconds(30)).until(() -\u003e !WireMock.findAll(WireMock.postRequestedFor(WireMock.urlEqualTo(\"/actuator/refresh\"))).isEmpty());\n    WireMock.verify(WireMock.exactly(4),WireMock.postRequestedFor(WireMock.urlEqualTo(\"/actuator/refresh\")));\n  }\n  private static void configWatcher(  Phase phase){\n    V1ConfigMap configMap\u003d(V1ConfigMap)util.yaml(\"config-watcher/spring-cloud-kubernetes-configuration-watcher-configmap.yaml\");\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"config-watcher/spring-cloud-kubernetes-configuration-watcher-deployment.yaml\");\n    List\u003cV1EnvVar\u003e envVars\u003dList.of(new V1EnvVar().name(\"SPRING_CLOUD_KUBERNETES_RELOAD_NAMESPACES_0\").value(LEFT_NAMESPACE),new V1EnvVar().name(\"SPRING_CLOUD_KUBERNETES_RELOAD_NAMESPACES_1\").value(RIGHT_NAMESPACE),new V1EnvVar().name(\"LOGGING_LEVEL_ORG_SPRINGFRAMEWORK\").value(\"TRACE\"));\n    deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setEnv(envVars);\n    V1Service service\u003d(V1Service)util.yaml(\"config-watcher/spring-cloud-kubernetes-configuration-watcher-service.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(DEFAULT_NAMESPACE,configMap,null);\n      util.createAndWait(DEFAULT_NAMESPACE,null,deployment,service,null,true);\n    }\n else {\n      util.deleteAndWait(DEFAULT_NAMESPACE,configMap,null);\n      util.deleteAndWait(DEFAULT_NAMESPACE,deployment,service,null);\n    }\n  }\n}\n",
        "abstract": "class ActuatorRefreshMultipleNamespacesIT {\n  private static final String SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME\u003d\"spring-cloud-kubernetes-configuration-watcher\";\n  private static final String WIREMOCK_HOST\u003d\"localhost\";\n  private static final String WIREMOCK_PATH\u003d\"/\";\n  private static final int WIREMOCK_PORT\u003d80;\n  private static final String DEFAULT_NAMESPACE\u003d\"default\";\n  private static final String LEFT_NAMESPACE\u003d\"left\";\n  private static final String RIGHT_NAMESPACE\u003d\"right\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  @BeforeAll static void beforeAll() throws Exception;\n  @AfterAll static void afterAll() throws Exception;\n  /** \n * \u003cpre\u003e - deploy config-watcher in default namespace - deploy wiremock in default namespace (so that we could assert calls to the actuator path) - deploy configmap-left in left namespaces with proper label and \"service-wiremock\" name. Because of the label, this will trigger a reload; because of the name this will trigger a reload against that name. This is a http refresh against the actuator. - same as above for the configmap-right. \u003c/pre\u003e\n */\n  @Test void testConfigMapActuatorRefreshMultipleNamespaces();\n  /** \n * \u003cpre\u003e - deploy config-watcher in default namespace - deploy wiremock in default namespace (so that we could assert calls to the actuator path) - deploy secret-left in left namespaces with proper label and \"service-wiremock\". Because of the label, this will trigger a reload; because of the name this will trigger a reload against that name. This is a http refresh against the actuator. - same as above for the secret-right. \u003c/pre\u003e\n */\n  void testSecretActuatorRefreshMultipleNamespaces();\n  private static void configWatcher(  Phase phase);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/main/java/org/springframework/cloud/kubernetes/k8s/client/reload/RightProperties.java",
        "name": "RightProperties",
        "modifiers": "@ConfigurationProperties(\"right\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.RightProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"right\") public class RightProperties {\n  private String value;\n  public String getValue(){\n    return value;\n  }\n  public void setValue(  String value){\n    this.value\u003dvalue;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"right\") public class RightProperties {\n  private String value;\n  public String getValue();\n  public void setValue(  String value);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/main/java/org/springframework/cloud/kubernetes/k8s/client/reload/App.java",
        "name": "App",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({LeftProperties.class,RightProperties.class,RightWithLabelsProperties.class,ConfigMapProperties.class,SecretsProperties.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.App",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties({LeftProperties.class,RightProperties.class,RightWithLabelsProperties.class,ConfigMapProperties.class,SecretsProperties.class}) public class App {\n  public static void main(  String[] args){\n    SpringApplication.run(App.class,args);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties({LeftProperties.class,RightProperties.class,RightWithLabelsProperties.class,ConfigMapProperties.class,SecretsProperties.class}) public class App {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/main/java/org/springframework/cloud/kubernetes/k8s/client/reload/LeftProperties.java",
        "name": "LeftProperties",
        "modifiers": "@ConfigurationProperties(\"left\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.LeftProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"left\") public class LeftProperties {\n  private String value;\n  public String getValue(){\n    return value;\n  }\n  public void setValue(  String value){\n    this.value\u003dvalue;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"left\") public class LeftProperties {\n  private String value;\n  public String getValue();\n  public void setValue(  String value);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/main/java/org/springframework/cloud/kubernetes/k8s/client/reload/RightWithLabelsProperties.java",
        "name": "RightWithLabelsProperties",
        "modifiers": "@ConfigurationProperties(\"right.with.label\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.RightWithLabelsProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"right.with.label\") public class RightWithLabelsProperties {\n  private String value;\n  public String getValue(){\n    return value;\n  }\n  public void setValue(  String value){\n    this.value\u003dvalue;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"right.with.label\") public class RightWithLabelsProperties {\n  private String value;\n  public String getValue();\n  public void setValue(  String value);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/main/java/org/springframework/cloud/kubernetes/k8s/client/reload/SecretsController.java",
        "name": "SecretsController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.SecretsController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController public class SecretsController {\n  private final SecretsProperties properties;\n  public SecretsController(  SecretsProperties properties){\n    this.properties\u003dproperties;\n  }\n  @GetMapping(\"/key\") public String key(){\n    return properties.getKey();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController public class SecretsController {\n  private final SecretsProperties properties;\n  public SecretsController(  SecretsProperties properties);\n  @GetMapping(\"/key\") public String key();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/main/java/org/springframework/cloud/kubernetes/k8s/client/reload/SecretsProperties.java",
        "name": "SecretsProperties",
        "modifiers": "@ConfigurationProperties(\"from.properties\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.SecretsProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"from.properties\") public class SecretsProperties {\n  private String key;\n  public String getKey(){\n    return key;\n  }\n  public void setKey(  String key){\n    this.key\u003dkey;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"from.properties\") public class SecretsProperties {\n  private String key;\n  public String getKey();\n  public void setKey(  String key);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/main/java/org/springframework/cloud/kubernetes/k8s/client/reload/ConfigMapProperties.java",
        "name": "ConfigMapProperties",
        "modifiers": "@ConfigurationProperties(\"from.properties\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.ConfigMapProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"from.properties\") public class ConfigMapProperties {\n  private String key;\n  public String getKey(){\n    return key;\n  }\n  public void setKey(  String key1){\n    this.key\u003dkey1;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"from.properties\") public class ConfigMapProperties {\n  private String key;\n  public String getKey();\n  public void setKey(  String key1);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/main/java/org/springframework/cloud/kubernetes/k8s/client/reload/Controller.java",
        "name": "Controller",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.Controller",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController public class Controller {\n  private final LeftProperties leftProperties;\n  private final RightProperties rightProperties;\n  private final RightWithLabelsProperties rightWithLabelsProperties;\n  private final ConfigMapProperties configMapProperties;\n  public Controller(  LeftProperties leftProperties,  RightProperties rightProperties,  RightWithLabelsProperties rightWithLabelsProperties,  ConfigMapProperties configMapProperties){\n    this.leftProperties\u003dleftProperties;\n    this.rightProperties\u003drightProperties;\n    this.rightWithLabelsProperties\u003drightWithLabelsProperties;\n    this.configMapProperties\u003dconfigMapProperties;\n  }\n  @GetMapping(\"/left\") public String left(){\n    return leftProperties.getValue();\n  }\n  @GetMapping(\"/right\") public String right(){\n    return rightProperties.getValue();\n  }\n  @GetMapping(\"/with-label\") public String witLabel(){\n    return rightWithLabelsProperties.getValue();\n  }\n  @GetMapping(\"/mount\") public String key(){\n    return configMapProperties.getKey();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController public class Controller {\n  private final LeftProperties leftProperties;\n  private final RightProperties rightProperties;\n  private final RightWithLabelsProperties rightWithLabelsProperties;\n  private final ConfigMapProperties configMapProperties;\n  public Controller(  LeftProperties leftProperties,  RightProperties rightProperties,  RightWithLabelsProperties rightWithLabelsProperties,  ConfigMapProperties configMapProperties);\n  @GetMapping(\"/left\") public String left();\n  @GetMapping(\"/right\") public String right();\n  @GetMapping(\"/with-label\") public String witLabel();\n  @GetMapping(\"/mount\") public String key();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/test/java/org/springframework/cloud/kubernetes/k8s/client/reload/configmap/K8sClientConfigMapReloadIT.java",
        "name": "K8sClientConfigMapReloadIT",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.configmap.K8sClientConfigMapReloadIT",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass K8sClientConfigMapReloadIT {\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-k8s-client-reload\";\n  private static final String DEPLOYMENT_NAME\u003d\"spring-k8s-client-reload\";\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + IMAGE_NAME + \":\"+ Commons.pomVersion();\n  private static final String NAMESPACE\u003d\"default\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  private static CoreV1Api api;\n  @BeforeAll static void beforeAll() throws Exception {\n    K3S.start();\n    Commons.validateImage(IMAGE_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(IMAGE_NAME,K3S);\n    util\u003dnew Util(K3S);\n    util.createNamespace(\"left\");\n    util.createNamespace(\"right\");\n    util.setUpClusterWide(NAMESPACE,Set.of(\"left\",\"right\"));\n    util.setUp(NAMESPACE);\n    api\u003dnew CoreV1Api();\n  }\n  @AfterAll static void afterAll() throws Exception {\n    util.deleteClusterWide(NAMESPACE,Set.of(\"left\",\"right\"));\n    manifests(Phase.DELETE);\n    util.deleteNamespace(\"left\");\n    util.deleteNamespace(\"right\");\n    Commons.cleanUp(IMAGE_NAME,K3S);\n    Commons.systemPrune();\n  }\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right - each of the namespaces has one configmap - we watch the \"left\" namespace, but make a change in the configmap in the right namespace - as such, no event is triggered and \"left-configmap\" stays as-is \u003c/pre\u003e\n */\n  @Test void testInformFromOneNamespaceEventNotTriggered() throws Exception {\n    manifests(Phase.CREATE);\n    Commons.assertReloadLogStatements(\"added configmap informer for namespace\",\"added secret informer for namespace\",\"spring-k8s-client-reload\");\n    WebClient webClient\u003dbuilder().baseUrl(\"http://localhost/left\").build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(\"left-initial\",result);\n    webClient\u003dbuilder().baseUrl(\"http://localhost/right\").build();\n    result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(\"right-initial\",result);\n    V1ConfigMap rightConfigMapAfterChange\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMeta().namespace(\"right\").name(\"right-configmap\")).withData(Map.of(\"right.value\",\"right-after-change\")).build();\n    replaceConfigMap(rightConfigMapAfterChange,\"right-configmap\");\n    LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(5));\n    webClient\u003dbuilder().baseUrl(\"http://localhost/left\").build();\n    result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(\"left-initial\",result);\n    testAllOther();\n  }\n  private void testAllOther() throws Exception {\n    testInformFromOneNamespaceEventTriggered();\n    testInform();\n    testInformFromOneNamespaceEventTriggeredSecretsDisabled();\n    testSimple(DOCKER_IMAGE,DEPLOYMENT_NAME,K3S);\n    testPollingReloadConfigMapMount(DEPLOYMENT_NAME,K3S,util,DOCKER_IMAGE);\n    testBootstrapEnabledPollingReloadConfigMapMount(DEPLOYMENT_NAME,K3S,util,DOCKER_IMAGE);\n  }\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right - each of the namespaces has one configmap - we watch the \"right\" namespace and make a change in the configmap in the same namespace - as such, event is triggered and we see the updated value \u003c/pre\u003e\n */\n  void testInformFromOneNamespaceEventTriggered() throws Exception {\n    recreateConfigMaps();\n    patchOne(DEPLOYMENT_NAME,NAMESPACE,DOCKER_IMAGE);\n    Commons.assertReloadLogStatements(\"added configmap informer for namespace\",\"added secret informer for namespace\",DEPLOYMENT_NAME);\n    WebClient webClient\u003dbuilder().baseUrl(\"http://localhost/right\").build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(\"right-initial\",result);\n    V1ConfigMap rightConfigMapAfterChange\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMeta().namespace(\"right\").name(\"right-configmap\")).withData(Map.of(\"right.value\",\"right-after-change\")).build();\n    replaceConfigMap(rightConfigMapAfterChange,\"right-configmap\");\n    String[] resultAfterChange\u003dnew String[1];\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dbuilder().baseUrl(\"http://localhost/right\").build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n      resultAfterChange[0]\u003dinnerResult;\n      return innerResult !\u003d null;\n    }\n);\n    Assertions.assertEquals(\"right-after-change\",resultAfterChange[0]);\n  }\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right (though we do not care about the left one) - left has one configmap : left-configmap - right has two configmaps: right-configmap, right-configmap-with-label - we watch the \"right\" namespace, but enable tagging; which means that only right-configmap-with-label triggers changes. \u003c/pre\u003e\n */\n  void testInform() throws Exception {\n    recreateConfigMaps();\n    V1ConfigMap rightWithLabelConfigMap\u003d(V1ConfigMap)util.yaml(\"right-configmap-with-label.yaml\");\n    util.createAndWait(\"right\",rightWithLabelConfigMap,null);\n    patchTwo(DEPLOYMENT_NAME,NAMESPACE,DOCKER_IMAGE);\n    Commons.assertReloadLogStatements(\"added configmap informer for namespace\",\"added secret informer for namespace\",DEPLOYMENT_NAME);\n    WebClient rightWebClient\u003dbuilder().baseUrl(\"http://localhost/right\").build();\n    String rightResult\u003drightWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(\"right-initial\",rightResult);\n    WebClient rightWithLabelWebClient\u003dbuilder().baseUrl(\"http://localhost/with-label\").build();\n    String rightWithLabelResult\u003drightWithLabelWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(\"right-with-label-initial\",rightWithLabelResult);\n    V1ConfigMap rightConfigMapAfterChange\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMeta().namespace(\"right\").name(\"right-configmap\")).withData(Map.of(\"right.value\",\"right-after-change\")).build();\n    replaceConfigMap(rightConfigMapAfterChange,\"right-configmap\");\n    LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(5));\n    rightResult\u003drightWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(\"right-initial\",rightResult);\n    V1ConfigMap rightWithLabelConfigMapAfterChange\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMeta().namespace(\"right\").name(\"right-configmap-with-label\")).withData(Map.of(\"right.with.label.value\",\"right-with-label-after-change\")).build();\n    replaceConfigMap(rightWithLabelConfigMapAfterChange,\"right-configmap-with-label\");\n    String[] resultAfterChange\u003dnew String[1];\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dbuilder().baseUrl(\"http://localhost/with-label\").build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n      resultAfterChange[0]\u003dinnerResult;\n      return innerResult !\u003d null;\n    }\n);\n    Assertions.assertEquals(\"right-with-label-after-change\",resultAfterChange[0]);\n    rightResult\u003drightWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(\"right-after-change\",rightResult);\n    util.deleteAndWait(\"right\",rightWithLabelConfigMap,null);\n  }\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right - each of the namespaces has one configmap - we watch the \"right\" namespace and make a change in the configmap in the same namespace - as such, event is triggered and we see the updated value \u003c/pre\u003e\n */\n  void testInformFromOneNamespaceEventTriggeredSecretsDisabled() throws Exception {\n    recreateConfigMaps();\n    patchThree(DEPLOYMENT_NAME,NAMESPACE,DOCKER_IMAGE);\n    Commons.assertReloadLogStatements(\"added configmap informer for namespace\",\"added secret informer for namespace\",DEPLOYMENT_NAME);\n    WebClient webClient\u003dbuilder().baseUrl(\"http://localhost/right\").build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(\"right-initial\",result);\n    V1ConfigMap rightConfigMapAfterChange\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMeta().namespace(\"right\").name(\"right-configmap\")).withData(Map.of(\"right.value\",\"right-after-change\")).build();\n    replaceConfigMap(rightConfigMapAfterChange,\"right-configmap\");\n    String[] resultAfterChange\u003dnew String[1];\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dbuilder().baseUrl(\"http://localhost/right\").build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n      resultAfterChange[0]\u003dinnerResult;\n      return innerResult !\u003d null;\n    }\n);\n    Assertions.assertEquals(\"right-after-change\",resultAfterChange[0]);\n  }\n  private void recreateConfigMaps(){\n    V1ConfigMap leftConfigMap\u003d(V1ConfigMap)util.yaml(\"left-configmap.yaml\");\n    V1ConfigMap rightConfigMap\u003d(V1ConfigMap)util.yaml(\"right-configmap.yaml\");\n    util.deleteAndWait(\"left\",leftConfigMap,null);\n    util.deleteAndWait(\"right\",rightConfigMap,null);\n    util.createAndWait(\"left\",leftConfigMap,null);\n    util.createAndWait(\"right\",rightConfigMap,null);\n  }\n  private static void manifests(  Phase phase){\n    try {\n      V1ConfigMap leftConfigMap\u003d(V1ConfigMap)util.yaml(\"left-configmap.yaml\");\n      V1ConfigMap rightConfigMap\u003d(V1ConfigMap)util.yaml(\"right-configmap.yaml\");\n      V1ConfigMap mountConfigMap\u003d(V1ConfigMap)util.yaml(\"configmap-mount.yaml\");\n      V1Deployment deployment\u003d(V1Deployment)util.yaml(\"deployment.yaml\");\n      V1Service service\u003d(V1Service)util.yaml(\"service.yaml\");\n      V1Ingress ingress\u003d(V1Ingress)util.yaml(\"ingress.yaml\");\n      if (phase.equals(Phase.CREATE)) {\n        util.createAndWait(NAMESPACE,mountConfigMap,null);\n        util.createAndWait(\"left\",leftConfigMap,null);\n        util.createAndWait(\"right\",rightConfigMap,null);\n        util.createAndWait(NAMESPACE,null,deployment,service,ingress,true);\n      }\n      if (phase.equals(Phase.DELETE)) {\n        util.deleteAndWait(NAMESPACE,mountConfigMap,null);\n        util.deleteAndWait(\"left\",leftConfigMap,null);\n        util.deleteAndWait(\"right\",rightConfigMap,null);\n        util.deleteAndWait(NAMESPACE,deployment,service,ingress);\n      }\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  private static void replaceConfigMap(  V1ConfigMap configMap,  String name) throws ApiException {\n    api.replaceNamespacedConfigMap(name,\"right\",configMap,null,null,null,null);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass K8sClientConfigMapReloadIT {\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-k8s-client-reload\";\n  private static final String DEPLOYMENT_NAME\u003d\"spring-k8s-client-reload\";\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + IMAGE_NAME + \":\"+ Commons.pomVersion();\n  private static final String NAMESPACE\u003d\"default\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  private static CoreV1Api api;\n  @BeforeAll static void beforeAll() throws Exception;\n  @AfterAll static void afterAll() throws Exception;\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right - each of the namespaces has one configmap - we watch the \"left\" namespace, but make a change in the configmap in the right namespace - as such, no event is triggered and \"left-configmap\" stays as-is \u003c/pre\u003e\n */\n  @Test void testInformFromOneNamespaceEventNotTriggered() throws Exception;\n  private void testAllOther() throws Exception;\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right - each of the namespaces has one configmap - we watch the \"right\" namespace and make a change in the configmap in the same namespace - as such, event is triggered and we see the updated value \u003c/pre\u003e\n */\n  void testInformFromOneNamespaceEventTriggered() throws Exception;\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right (though we do not care about the left one) - left has one configmap : left-configmap - right has two configmaps: right-configmap, right-configmap-with-label - we watch the \"right\" namespace, but enable tagging; which means that only right-configmap-with-label triggers changes. \u003c/pre\u003e\n */\n  void testInform() throws Exception;\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right - each of the namespaces has one configmap - we watch the \"right\" namespace and make a change in the configmap in the same namespace - as such, event is triggered and we see the updated value \u003c/pre\u003e\n */\n  void testInformFromOneNamespaceEventTriggeredSecretsDisabled() throws Exception;\n  private void recreateConfigMaps();\n  private static void manifests(  Phase phase);\n  private static void replaceConfigMap(  V1ConfigMap configMap,  String name) throws ApiException;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/test/java/org/springframework/cloud/kubernetes/k8s/client/reload/configmap/K8sClientConfigMapReloadITUtil.java",
        "name": "K8sClientConfigMapReloadITUtil",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.configmap.K8sClientConfigMapReloadITUtil",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class K8sClientConfigMapReloadITUtil {\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-k8s-client-reload\");\n  private K8sClientConfigMapReloadITUtil(){\n  }\n  private static final String BODY_ONE\u003dnull;\n  private static final String BODY_TWO\u003dnull;\n  private static final String BODY_THREE\u003dnull;\n  private static final String BODY_FOUR\u003dnull;\n  private static final String BODY_FIVE\u003dnull;\n  private static final String BODY_SIX\u003dnull;\n  static void patchOne(  String deploymentName,  String namespace,  String imageName){\n    patchWithReplace(imageName,deploymentName,namespace,BODY_ONE,POD_LABELS);\n  }\n  static void patchTwo(  String deploymentName,  String namespace,  String imageName){\n    patchWithReplace(imageName,deploymentName,namespace,BODY_TWO,POD_LABELS);\n  }\n  static void patchThree(  String deploymentName,  String namespace,  String imageName){\n    patchWithReplace(imageName,deploymentName,namespace,BODY_THREE,POD_LABELS);\n  }\n  static void patchFour(  String deploymentName,  String namespace,  String imageName){\n    patchWithReplace(imageName,deploymentName,namespace,BODY_FOUR,POD_LABELS);\n  }\n  static void patchFive(  String deploymentName,  String namespace,  String imageName){\n    patchWithReplace(imageName,deploymentName,namespace,BODY_FIVE,POD_LABELS);\n  }\n  static void patchSix(  String deploymentName,  String namespace,  String imageName){\n    patchWithReplace(imageName,deploymentName,namespace,BODY_SIX,POD_LABELS);\n  }\n  static WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  static RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(120,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n  static String logs(  String appLabelValue,  K3sContainer k3sContainer){\n    try {\n      String appPodName\u003dk3sContainer.execInContainer(\"sh\",\"-c\",\"kubectl get pods -l app\u003d\" + appLabelValue + \" -o\u003dname --no-headers | tr -d \u0027\\n\u0027\").getStdout();\n      Container.ExecResult execResult\u003dk3sContainer.execInContainer(\"sh\",\"-c\",\"kubectl logs \" + appPodName.trim());\n      return execResult.getStdout();\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class K8sClientConfigMapReloadITUtil {\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-k8s-client-reload\");\n  private K8sClientConfigMapReloadITUtil();\n  private static final String BODY_ONE\u003dnull;\n  private static final String BODY_TWO\u003dnull;\n  private static final String BODY_THREE\u003dnull;\n  private static final String BODY_FOUR\u003dnull;\n  private static final String BODY_FIVE\u003dnull;\n  private static final String BODY_SIX\u003dnull;\n  static void patchOne(  String deploymentName,  String namespace,  String imageName);\n  static void patchTwo(  String deploymentName,  String namespace,  String imageName);\n  static void patchThree(  String deploymentName,  String namespace,  String imageName);\n  static void patchFour(  String deploymentName,  String namespace,  String imageName);\n  static void patchFive(  String deploymentName,  String namespace,  String imageName);\n  static void patchSix(  String deploymentName,  String namespace,  String imageName);\n  static WebClient.Builder builder();\n  static RetryBackoffSpec retrySpec();\n  static String logs(  String appLabelValue,  K3sContainer k3sContainer);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/test/java/org/springframework/cloud/kubernetes/k8s/client/reload/configmap/PollingReloadConfigMapMountDelegate.java",
        "name": "PollingReloadConfigMapMountDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.configmap.PollingReloadConfigMapMountDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class PollingReloadConfigMapMountDelegate {\n  private PollingReloadConfigMapMountDelegate(){\n  }\n  /** \n * \u003cpre\u003e - we have \"spring.config.import: kubernetes\", which means we will \u0027locate\u0027 property sources from config maps. - the property above means that at the moment we will be searching for config maps that only match the application name, in this specific test there is no such config map. - what we will also read, is \u0027spring.cloud.kubernetes.config.paths\u0027, which we have set to \u0027/tmp/application.properties\u0027 in this test. That is populated by the volumeMounts (see BODY_FIVE) - we first assert that we are actually reading the path based source via (1), (2) and (3). - we then change the config map content, wait for k8s to pick it up and replace them - our polling will then detect that change, and trigger a reload. \u003c/pre\u003e\n */\n  static void testPollingReloadConfigMapMount(  String deploymentName,  K3sContainer k3sContainer,  Util util,  String imageName) throws Exception {\n    K8sClientConfigMapReloadITUtil.patchFive(deploymentName,\"default\",imageName);\n    Commons.waitForLogStatement(\"paths property sources : [/tmp/application.properties]\",k3sContainer,deploymentName);\n    Commons.waitForLogStatement(\"will add file-based property source : /tmp/application.properties\",k3sContainer,deploymentName);\n    WebClient webClient\u003dK8sClientConfigMapReloadITUtil.builder().baseUrl(\"http://localhost/mount\").build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(K8sClientConfigMapReloadITUtil.retrySpec()).block();\n    Assertions.assertEquals(\"as-mount-initial\",result);\n    V1ConfigMap configMap\u003d(V1ConfigMap)util.yaml(\"configmap-mount.yaml\");\n    configMap.setData(Map.of(\"application.properties\",\"from.properties.key\u003das-mount-changed\"));\n    new CoreV1Api().replaceNamespacedConfigMap(\"poll-reload-as-mount\",\"default\",configMap,null,null,null,null);\n    await().timeout(Duration.ofSeconds(180)).until(() -\u003e webClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(K8sClientConfigMapReloadITUtil.retrySpec()).block().equals(\"as-mount-changed\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class PollingReloadConfigMapMountDelegate {\n  private PollingReloadConfigMapMountDelegate();\n  /** \n * \u003cpre\u003e - we have \"spring.config.import: kubernetes\", which means we will \u0027locate\u0027 property sources from config maps. - the property above means that at the moment we will be searching for config maps that only match the application name, in this specific test there is no such config map. - what we will also read, is \u0027spring.cloud.kubernetes.config.paths\u0027, which we have set to \u0027/tmp/application.properties\u0027 in this test. That is populated by the volumeMounts (see BODY_FIVE) - we first assert that we are actually reading the path based source via (1), (2) and (3). - we then change the config map content, wait for k8s to pick it up and replace them - our polling will then detect that change, and trigger a reload. \u003c/pre\u003e\n */\n  static void testPollingReloadConfigMapMount(  String deploymentName,  K3sContainer k3sContainer,  Util util,  String imageName) throws Exception;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/test/java/org/springframework/cloud/kubernetes/k8s/client/reload/configmap/BootstrapEnabledPollingReloadConfigMapMountDelegate.java",
        "name": "BootstrapEnabledPollingReloadConfigMapMountDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.configmap.BootstrapEnabledPollingReloadConfigMapMountDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class BootstrapEnabledPollingReloadConfigMapMountDelegate {\n  private static final String NAMESPACE\u003d\"default\";\n  /** \n * \u003cpre\u003e - we have bootstrap enabled, which means we will \u0027locate\u0027 property sources from config maps. - there are no explicit config maps to search for, but what we will also read, is \u0027spring.cloud.kubernetes.config.paths\u0027, which we have set to \u0027/tmp/application.properties\u0027 in this test. That is populated by the volumeMounts (see deployment-mount.yaml) - we first assert that we are actually reading the path based source via (1), (2) and (3). - we then change the config map content, wait for k8s to pick it up and replace them - our polling will then detect that change, and trigger a reload. \u003c/pre\u003e\n */\n  static void testBootstrapEnabledPollingReloadConfigMapMount(  String deploymentName,  K3sContainer k3sContainer,  Util util,  String imageName) throws Exception {\n    recreateMountConfigMap(util);\n    K8sClientConfigMapReloadITUtil.patchSix(deploymentName,\"default\",imageName);\n    Commons.waitForLogStatement(\"paths property sources : [/tmp/application.properties]\",k3sContainer,deploymentName);\n    Commons.waitForLogStatement(\"will add file-based property source : /tmp/application.properties\",k3sContainer,deploymentName);\n    WebClient webClient\u003dK8sClientConfigMapReloadITUtil.builder().baseUrl(\"http://localhost/mount\").build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(K8sClientConfigMapReloadITUtil.retrySpec()).block();\n    Assertions.assertEquals(\"as-mount-initial\",result);\n    V1ConfigMap configMap\u003d(V1ConfigMap)util.yaml(\"configmap-mount.yaml\");\n    configMap.setData(Map.of(\"application.properties\",\"from.properties.key\u003das-mount-changed\"));\n    new CoreV1Api().replaceNamespacedConfigMap(\"poll-reload-as-mount\",NAMESPACE,configMap,null,null,null,null);\n    await().timeout(Duration.ofSeconds(180)).until(() -\u003e webClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(K8sClientConfigMapReloadITUtil.retrySpec()).block().equals(\"as-mount-changed\"));\n  }\n  private static void recreateMountConfigMap(  Util util){\n    V1ConfigMap mountConfigMap\u003d(V1ConfigMap)util.yaml(\"configmap-mount.yaml\");\n    util.deleteAndWait(\"default\",mountConfigMap,null);\n    util.createAndWait(\"default\",mountConfigMap,null);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class BootstrapEnabledPollingReloadConfigMapMountDelegate {\n  private static final String NAMESPACE\u003d\"default\";\n  /** \n * \u003cpre\u003e - we have bootstrap enabled, which means we will \u0027locate\u0027 property sources from config maps. - there are no explicit config maps to search for, but what we will also read, is \u0027spring.cloud.kubernetes.config.paths\u0027, which we have set to \u0027/tmp/application.properties\u0027 in this test. That is populated by the volumeMounts (see deployment-mount.yaml) - we first assert that we are actually reading the path based source via (1), (2) and (3). - we then change the config map content, wait for k8s to pick it up and replace them - our polling will then detect that change, and trigger a reload. \u003c/pre\u003e\n */\n  static void testBootstrapEnabledPollingReloadConfigMapMount(  String deploymentName,  K3sContainer k3sContainer,  Util util,  String imageName) throws Exception;\n  private static void recreateMountConfigMap(  Util util);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/test/java/org/springframework/cloud/kubernetes/k8s/client/reload/configmap/DataChangesInConfigMapReloadDelegate.java",
        "name": "DataChangesInConfigMapReloadDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.configmap.DataChangesInConfigMapReloadDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class DataChangesInConfigMapReloadDelegate {\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String LEFT_NAMESPACE\u003d\"left\";\n  /** \n * \u003cpre\u003e - configMap with no labels and data: left.value \u003d left-initial exists in namespace left - we assert that we can read it correctly first, by invoking localhost/left - then we change the configmap by adding a label, this in turn does not change the result of localhost/left, because the data has not changed. - then we change data inside the config map, and we must see the updated value \u003c/pre\u003e\n */\n  static void testSimple(  String dockerImage,  String deploymentName,  K3sContainer k3sContainer){\n    K8sClientConfigMapReloadITUtil.patchFour(deploymentName,NAMESPACE,dockerImage);\n    Commons.assertReloadLogStatements(\"added configmap informer for namespace\",\"added secret informer for namespace\",deploymentName);\n    WebClient webClient\u003dK8sClientConfigMapReloadITUtil.builder().baseUrl(\"http://localhost/\" + LEFT_NAMESPACE).build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(K8sClientConfigMapReloadITUtil.retrySpec()).block();\n    Assertions.assertEquals(\"left-initial\",result);\n    V1ConfigMap configMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"new-label\",\"abc\")).withNamespace(\"left\").withName(\"left-configmap\").build()).withData(Map.of(\"left.value\",\"left-initial\")).build();\n    replaceConfigMap(configMap);\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dK8sClientConfigMapReloadITUtil.builder().baseUrl(\"http://localhost/\" + LEFT_NAMESPACE).build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(K8sClientConfigMapReloadITUtil.retrySpec()).block();\n      return \"left-initial\".equals(innerResult);\n    }\n);\n    String logs\u003dK8sClientConfigMapReloadITUtil.logs(deploymentName,k3sContainer);\n    Assertions.assertTrue(logs.contains(\"ConfigMap left-configmap was updated in namespace left\"));\n    Assertions.assertTrue(logs.contains(\"data in configmap has not changed, will not reload\"));\n    configMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"new-label\",\"abc\")).withNamespace(\"left\").withName(\"left-configmap\").build()).withData(Map.of(\"left.value\",\"left-after-change\")).build();\n    replaceConfigMap(configMap);\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dK8sClientConfigMapReloadITUtil.builder().baseUrl(\"http://localhost/\" + LEFT_NAMESPACE).build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(K8sClientConfigMapReloadITUtil.retrySpec()).block();\n      return \"left-after-change\".equals(innerResult);\n    }\n);\n  }\n  private static void replaceConfigMap(  V1ConfigMap configMap){\n    try {\n      new CoreV1Api().replaceNamespacedConfigMap(\"left-configmap\",LEFT_NAMESPACE,configMap,null,null,null,null);\n    }\n catch (    ApiException e) {\n      throw new RuntimeException(e);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class DataChangesInConfigMapReloadDelegate {\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String LEFT_NAMESPACE\u003d\"left\";\n  /** \n * \u003cpre\u003e - configMap with no labels and data: left.value \u003d left-initial exists in namespace left - we assert that we can read it correctly first, by invoking localhost/left - then we change the configmap by adding a label, this in turn does not change the result of localhost/left, because the data has not changed. - then we change data inside the config map, and we must see the updated value \u003c/pre\u003e\n */\n  static void testSimple(  String dockerImage,  String deploymentName,  K3sContainer k3sContainer);\n  private static void replaceConfigMap(  V1ConfigMap configMap);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/test/java/org/springframework/cloud/kubernetes/k8s/client/reload/secret/K8sClientSecretsReloadIT.java",
        "name": "K8sClientSecretsReloadIT",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.secret.K8sClientSecretsReloadIT",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass K8sClientSecretsReloadIT {\n  private static final String PROPERTY_URL\u003d\"http://localhost:80/key\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-k8s-client-reload\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String DEPLOYMENT_NAME\u003d\"spring-k8s-client-reload\";\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + IMAGE_NAME + \":\"+ Commons.pomVersion();\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  private static CoreV1Api coreV1Api;\n  @BeforeAll static void setup() throws Exception {\n    K3S.start();\n    Commons.validateImage(IMAGE_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(IMAGE_NAME,K3S);\n    util\u003dnew Util(K3S);\n    coreV1Api\u003dnew CoreV1Api();\n    util.setUp(NAMESPACE);\n    configK8sClientIt(Phase.CREATE);\n  }\n  @AfterAll static void afterAll() throws Exception {\n    configK8sClientIt(Phase.DELETE);\n    Commons.cleanUp(IMAGE_NAME,K3S);\n    Commons.systemPrune();\n  }\n  @Test void testSecretReload() throws Exception {\n    Commons.assertReloadLogStatements(\"added secret informer for namespace\",\"added configmap informer for namespace\",DEPLOYMENT_NAME);\n    testSecretEventReload();\n    testAllOther();\n  }\n  private void testAllOther() throws Exception {\n    recreateSecret();\n    patchOne(DEPLOYMENT_NAME,NAMESPACE,DOCKER_IMAGE);\n    testSecretReloadConfigDisabled();\n    recreateSecret();\n    patchOne(DEPLOYMENT_NAME,NAMESPACE,DOCKER_IMAGE);\n    testDataChangesInSecretsReload(K3S,DEPLOYMENT_NAME);\n  }\n  void testSecretReloadConfigDisabled() throws Exception {\n    Commons.assertReloadLogStatements(\"added secret informer for namespace\",\"added configmap informer for namespace\",DEPLOYMENT_NAME);\n    testSecretEventReload();\n  }\n  void testSecretEventReload() throws Exception {\n    WebClient.Builder builder\u003dbuilder();\n    WebClient secretClient\u003dbuilder.baseUrl(PROPERTY_URL).build();\n    await().timeout(Duration.ofSeconds(120)).pollInterval(Duration.ofSeconds(2)).until(() -\u003e secretClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block().equals(\"initial\"));\n    V1Secret v1Secret\u003d(V1Secret)util.yaml(\"secret.yaml\");\n    Map\u003cString,byte[]\u003e secretData\u003dv1Secret.getData();\n    secretData.replace(\"application.properties\",\"from.properties.key: after-change\".getBytes());\n    v1Secret.setData(secretData);\n    coreV1Api.replaceNamespacedSecret(\"event-reload\",NAMESPACE,v1Secret,null,null,null,null);\n    await().timeout(Duration.ofSeconds(120)).pollInterval(Duration.ofSeconds(2)).until(() -\u003e secretClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block().equals(\"after-change\"));\n  }\n  private void recreateSecret(){\n    V1Secret secret\u003d(V1Secret)util.yaml(\"secret.yaml\");\n    util.deleteAndWait(NAMESPACE,null,secret);\n    util.createAndWait(NAMESPACE,null,secret);\n  }\n  private static void configK8sClientIt(  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"deployment-with-secret.yaml\");\n    V1Service service\u003d(V1Service)util.yaml(\"service.yaml\");\n    V1Ingress ingress\u003d(V1Ingress)util.yaml(\"ingress.yaml\");\n    V1Secret secret\u003d(V1Secret)util.yaml(\"secret.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(NAMESPACE,null,deployment,service,ingress,true);\n      util.createAndWait(NAMESPACE,null,secret);\n    }\n else     if (phase.equals(Phase.DELETE)) {\n      util.deleteAndWait(NAMESPACE,deployment,service,ingress);\n      util.deleteAndWait(NAMESPACE,null,secret);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass K8sClientSecretsReloadIT {\n  private static final String PROPERTY_URL\u003d\"http://localhost:80/key\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-k8s-client-reload\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String DEPLOYMENT_NAME\u003d\"spring-k8s-client-reload\";\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + IMAGE_NAME + \":\"+ Commons.pomVersion();\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  private static CoreV1Api coreV1Api;\n  @BeforeAll static void setup() throws Exception;\n  @AfterAll static void afterAll() throws Exception;\n  @Test void testSecretReload() throws Exception;\n  private void testAllOther() throws Exception;\n  void testSecretReloadConfigDisabled() throws Exception;\n  void testSecretEventReload() throws Exception;\n  private void recreateSecret();\n  private static void configK8sClientIt(  Phase phase);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/test/java/org/springframework/cloud/kubernetes/k8s/client/reload/secret/K8sClientSecretsReloadITUtil.java",
        "name": "K8sClientSecretsReloadITUtil",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.secret.K8sClientSecretsReloadITUtil",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class K8sClientSecretsReloadITUtil {\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-k8s-client-reload\");\n  private static final String BODY_ONE\u003dnull;\n  private K8sClientSecretsReloadITUtil(){\n  }\n  static WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  static RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(60,Duration.ofSeconds(2)).filter(Objects::nonNull);\n  }\n  static void patchOne(  String deploymentName,  String namespace,  String imageName){\n    patchWithReplace(imageName,deploymentName,namespace,BODY_ONE,POD_LABELS);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class K8sClientSecretsReloadITUtil {\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-k8s-client-reload\");\n  private static final String BODY_ONE\u003dnull;\n  private K8sClientSecretsReloadITUtil();\n  static WebClient.Builder builder();\n  static RetryBackoffSpec retrySpec();\n  static void patchOne(  String deploymentName,  String namespace,  String imageName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-reload/src/test/java/org/springframework/cloud/kubernetes/k8s/client/reload/secret/DataChangesInSecretsReloadDelegate.java",
        "name": "DataChangesInSecretsReloadDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.reload.secret.DataChangesInSecretsReloadDelegate",
        "extend": "",
        "implements": "",
        "raw": "final class DataChangesInSecretsReloadDelegate {\n  private static final String NAMESPACE\u003d\"default\";\n  /** \n * \u003cpre\u003e - secret with no labels and data: from.properties.key \u003d initial exists in namespace default - we assert that we can read it correctly first, by invoking localhost/key. - then we change the secret by adding a label, this in turn does not change the result of localhost/key, because the data has not changed. - then we change data inside the secret, and we must see the updated value. \u003c/pre\u003e\n */\n  static void testDataChangesInSecretsReload(  K3sContainer k3sContainer,  String deploymentName){\n    Commons.assertReloadLogStatements(\"added secret informer for namespace\",\"added configmap informer for namespace\",deploymentName);\n    WebClient webClient\u003dbuilder().baseUrl(\"http://localhost/key\").build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(\"initial\",result);\n    V1Secret secret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"new-label\",\"abc\")).withNamespace(NAMESPACE).withName(\"event-reload\").build()).withData(Map.of(\"application.properties\",\"from.properties.key\u003dinitial\".getBytes())).build();\n    replaceSecret(secret,\"event-reload\");\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dbuilder().baseUrl(\"http://localhost/key\").build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n      return \"initial\".equals(innerResult);\n    }\n);\n    Commons.waitForLogStatement(\"Secret event-reload was updated in namespace default\",k3sContainer,deploymentName);\n    Commons.waitForLogStatement(\"data in secret has not changed, will not reload\",k3sContainer,deploymentName);\n    secret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"new-label\",\"abc\")).withNamespace(NAMESPACE).withName(\"event-reload\").build()).withData(Map.of(\"application.properties\",\"from.properties.key\u003dchange-initial\".getBytes())).build();\n    replaceSecret(secret,\"event-reload\");\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dbuilder().baseUrl(\"http://localhost/key\").build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n      return \"change-initial\".equals(innerResult);\n    }\n);\n  }\n  private static void replaceSecret(  V1Secret secret,  String name){\n    try {\n      new CoreV1Api().replaceNamespacedSecret(name,NAMESPACE,secret,null,null,null,null);\n    }\n catch (    ApiException e) {\n      throw new RuntimeException(e);\n    }\n  }\n}\n",
        "abstract": "final class DataChangesInSecretsReloadDelegate {\n  private static final String NAMESPACE\u003d\"default\";\n  /** \n * \u003cpre\u003e - secret with no labels and data: from.properties.key \u003d initial exists in namespace default - we assert that we can read it correctly first, by invoking localhost/key. - then we change the secret by adding a label, this in turn does not change the result of localhost/key, because the data has not changed. - then we change data inside the secret, and we must see the updated value. \u003c/pre\u003e\n */\n  static void testDataChangesInSecretsReload(  K3sContainer k3sContainer,  String deploymentName);\n  private static void replaceSecret(  V1Secret secret,  String name);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/discovery/Fabric8DiscoveryController.java",
        "name": "Fabric8DiscoveryController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.discovery.Fabric8DiscoveryController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController public class Fabric8DiscoveryController {\n  private final KubernetesDiscoveryClient discoveryClient;\n  public Fabric8DiscoveryController(  ObjectProvider\u003cKubernetesDiscoveryClient\u003e discoveryClient){\n    KubernetesDiscoveryClient[] local\u003dnew KubernetesDiscoveryClient[1];\n    discoveryClient.ifAvailable(x -\u003e local[0]\u003dx);\n    this.discoveryClient\u003dlocal[0];\n  }\n  @GetMapping(\"/services\") public List\u003cString\u003e allServices(){\n    return discoveryClient.getServices();\n  }\n  @GetMapping(\"/endpoints/{serviceId}\") public List\u003cEndpoints\u003e getEndPointsList(  @PathVariable(\"serviceId\") String serviceId){\n    return discoveryClient.getEndPointsList(serviceId);\n  }\n  @GetMapping(\"/service-instances/{serviceId}\") public List\u003cServiceInstance\u003e serviceInstances(  @PathVariable(\"serviceId\") String serviceId){\n    return discoveryClient.getInstances(serviceId);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController public class Fabric8DiscoveryController {\n  private final KubernetesDiscoveryClient discoveryClient;\n  public Fabric8DiscoveryController(  ObjectProvider\u003cKubernetesDiscoveryClient\u003e discoveryClient);\n  @GetMapping(\"/services\") public List\u003cString\u003e allServices();\n  @GetMapping(\"/endpoints/{serviceId}\") public List\u003cEndpoints\u003e getEndPointsList(  @PathVariable(\"serviceId\") String serviceId);\n  @GetMapping(\"/service-instances/{serviceId}\") public List\u003cServiceInstance\u003e serviceInstances(  @PathVariable(\"serviceId\") String serviceId);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/discovery/Fabric8DiscoveryApp.java",
        "name": "Fabric8DiscoveryApp",
        "modifiers": "@SpringBootApplication public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.discovery.Fabric8DiscoveryApp",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication public class Fabric8DiscoveryApp {\n  public static void main(  String[] args){\n    SpringApplication.run(Fabric8DiscoveryApp.class,args);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication public class Fabric8DiscoveryApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/discovery/Fabric8ReactiveDiscoveryController.java",
        "name": "Fabric8ReactiveDiscoveryController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.discovery.Fabric8ReactiveDiscoveryController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController public class Fabric8ReactiveDiscoveryController {\n  private final KubernetesReactiveDiscoveryClient reactiveDiscoveryClient;\n  public Fabric8ReactiveDiscoveryController(  ObjectProvider\u003cKubernetesReactiveDiscoveryClient\u003e reactiveDiscoveryClient){\n    KubernetesReactiveDiscoveryClient[] local\u003dnew KubernetesReactiveDiscoveryClient[1];\n    reactiveDiscoveryClient.ifAvailable(x -\u003e local[0]\u003dx);\n    this.reactiveDiscoveryClient\u003dlocal[0];\n  }\n  @GetMapping(\"/reactive/services\") public Mono\u003cList\u003cString\u003e\u003e allServices(){\n    return reactiveDiscoveryClient.getServices().collectList();\n  }\n  @GetMapping(\"/reactive/service-instances/{serviceId}\") public Mono\u003cList\u003cServiceInstance\u003e\u003e serviceInstances(  @PathVariable(\"serviceId\") String serviceId){\n    return reactiveDiscoveryClient.getInstances(serviceId).collectList();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController public class Fabric8ReactiveDiscoveryController {\n  private final KubernetesReactiveDiscoveryClient reactiveDiscoveryClient;\n  public Fabric8ReactiveDiscoveryController(  ObjectProvider\u003cKubernetesReactiveDiscoveryClient\u003e reactiveDiscoveryClient);\n  @GetMapping(\"/reactive/services\") public Mono\u003cList\u003cString\u003e\u003e allServices();\n  @GetMapping(\"/reactive/service-instances/{serviceId}\") public Mono\u003cList\u003cServiceInstance\u003e\u003e serviceInstances(  @PathVariable(\"serviceId\") String serviceId);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-discovery/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/discovery/Fabric8ApplicationDiscoveryListener.java",
        "name": "Fabric8ApplicationDiscoveryListener",
        "modifiers": "@Component public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.discovery.Fabric8ApplicationDiscoveryListener",
        "extend": "",
        "implements": "ApplicationListener\u003cInstanceRegisteredEvent\u003c?\u003e\u003e",
        "raw": "/** \n * @author wind57\n */\n@Component public class Fabric8ApplicationDiscoveryListener implements ApplicationListener\u003cInstanceRegisteredEvent\u003c?\u003e\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8ApplicationDiscoveryListener.class));\n  @Override public void onApplicationEvent(  InstanceRegisteredEvent\u003c?\u003e event){\n    Pod pod\u003d(Pod)((KubernetesDiscoveryClientHealthIndicatorInitializer.RegisteredEventSource)event.getSource()).pod();\n    LOG.info(() -\u003e \"received InstanceRegisteredEvent from pod with \u0027app\u0027 label value : \" + pod.getMetadata().getLabels().get(\"app\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@Component public class Fabric8ApplicationDiscoveryListener implements ApplicationListener\u003cInstanceRegisteredEvent\u003c?\u003e\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8ApplicationDiscoveryListener.class));\n  @Override public void onApplicationEvent(  InstanceRegisteredEvent\u003c?\u003e event);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/discovery/Fabric8DiscoveryFilterDelegate.java",
        "name": "Fabric8DiscoveryFilterDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.discovery.Fabric8DiscoveryFilterDelegate",
        "extend": "",
        "implements": "",
        "raw": "final class Fabric8DiscoveryFilterDelegate {\n  private Fabric8DiscoveryFilterDelegate(){\n  }\n  /** \n * \u003cpre\u003e - service \"wiremock\" is present in namespace \"a-uat\" - service \"wiremock\" is present in namespace \"b-uat\" - we search with a predicate : \"#root.metadata.namespace matches \u0027^uat.*$\u0027\" As such, both services are found via \u0027getInstances\u0027 call. \u003c/pre\u003e\n */\n  static void filterMatchesBothNamespacesViaThePredicate(){\n    WebClient clientServices\u003dbuilder().baseUrl(\"http://localhost/services\").build();\n    @SuppressWarnings(\"unchecked\") List\u003cString\u003e services\u003d(List\u003cString\u003e)clientServices.method(HttpMethod.GET).retrieve().bodyToMono(List.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(services.size(),1);\n    Assertions.assertTrue(services.contains(\"service-wiremock\"));\n    WebClient client\u003dbuilder().baseUrl(\"http://localhost/service-instances/service-wiremock\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e serviceInstances\u003dclient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(serviceInstances.size(),2);\n    List\u003cDefaultKubernetesServiceInstance\u003e sorted\u003dserviceInstances.stream().sorted(Comparator.comparing(DefaultKubernetesServiceInstance::getNamespace)).toList();\n    DefaultKubernetesServiceInstance first\u003dsorted.get(0);\n    Assertions.assertEquals(first.getServiceId(),\"service-wiremock\");\n    Assertions.assertNotNull(first.getInstanceId());\n    Assertions.assertEquals(first.getPort(),8080);\n    Assertions.assertEquals(first.getNamespace(),\"a-uat\");\n    Assertions.assertEquals(first.getMetadata(),Map.of(\"app\",\"service-wiremock\",\"port.http\",\"8080\",\"k8s_namespace\",\"a-uat\",\"type\",\"ClusterIP\"));\n    DefaultKubernetesServiceInstance second\u003dsorted.get(1);\n    Assertions.assertEquals(second.getServiceId(),\"service-wiremock\");\n    Assertions.assertNotNull(second.getInstanceId());\n    Assertions.assertEquals(second.getPort(),8080);\n    Assertions.assertEquals(second.getNamespace(),\"b-uat\");\n    Assertions.assertEquals(second.getMetadata(),Map.of(\"app\",\"service-wiremock\",\"port.http\",\"8080\",\"k8s_namespace\",\"b-uat\",\"type\",\"ClusterIP\"));\n  }\n  /** \n * \u003cpre\u003e - service \"wiremock\" is present in namespace \"a-uat\" - service \"wiremock\" is present in namespace \"b-uat\" - we search with a predicate : \"#root.metadata.namespace matches \u0027a-uat$\u0027\" As such, only service from \u0027a-uat\u0027 namespace matches. \u003c/pre\u003e\n */\n  static void filterMatchesOneNamespaceViaThePredicate(){\n    WebClient clientServices\u003dbuilder().baseUrl(\"http://localhost/services\").build();\n    @SuppressWarnings(\"unchecked\") List\u003cString\u003e services\u003d(List\u003cString\u003e)clientServices.method(HttpMethod.GET).retrieve().bodyToMono(List.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(services.size(),1);\n    Assertions.assertTrue(services.contains(\"service-wiremock\"));\n    WebClient client\u003dbuilder().baseUrl(\"http://localhost/service-instances/service-wiremock\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e serviceInstances\u003dclient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(serviceInstances.size(),1);\n    DefaultKubernetesServiceInstance first\u003dserviceInstances.get(0);\n    Assertions.assertEquals(first.getServiceId(),\"service-wiremock\");\n    Assertions.assertNotNull(first.getInstanceId());\n    Assertions.assertEquals(first.getPort(),8080);\n    Assertions.assertEquals(first.getNamespace(),\"a-uat\");\n    Assertions.assertEquals(first.getMetadata(),Map.of(\"app\",\"service-wiremock\",\"port.http\",\"8080\",\"k8s_namespace\",\"a-uat\",\"type\",\"ClusterIP\"));\n  }\n}\n",
        "abstract": "final class Fabric8DiscoveryFilterDelegate {\n  private Fabric8DiscoveryFilterDelegate();\n  /** \n * \u003cpre\u003e - service \"wiremock\" is present in namespace \"a-uat\" - service \"wiremock\" is present in namespace \"b-uat\" - we search with a predicate : \"#root.metadata.namespace matches \u0027^uat.*$\u0027\" As such, both services are found via \u0027getInstances\u0027 call. \u003c/pre\u003e\n */\n  static void filterMatchesBothNamespacesViaThePredicate();\n  /** \n * \u003cpre\u003e - service \"wiremock\" is present in namespace \"a-uat\" - service \"wiremock\" is present in namespace \"b-uat\" - we search with a predicate : \"#root.metadata.namespace matches \u0027a-uat$\u0027\" As such, only service from \u0027a-uat\u0027 namespace matches. \u003c/pre\u003e\n */\n  static void filterMatchesOneNamespaceViaThePredicate();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/discovery/Fabric8DiscoveryPodMetadataIT.java",
        "name": "Fabric8DiscoveryPodMetadataIT",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.discovery.Fabric8DiscoveryPodMetadataIT",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass Fabric8DiscoveryPodMetadataIT {\n  private static final String DEPLOYMENT_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-discovery-deployment\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String NAMESPACE_A_UAT\u003d\"a-uat\";\n  private static final String NAMESPACE_B_UAT\u003d\"b-uat\";\n  private static final String NAMESPACE_LEFT\u003d\"namespace-left\";\n  private static final String NAMESPACE_RIGHT\u003d\"namespace-right\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-discovery\";\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + IMAGE_NAME + \":\"+ pomVersion();\n  private static KubernetesClient client;\n  private static Util util;\n  private static final K3sContainer K3S\u003dCommons.container();\n  @BeforeAll static void beforeAll() throws Exception {\n    K3S.start();\n    Commons.validateImage(IMAGE_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(IMAGE_NAME,K3S);\n    Images.loadBusybox(K3S);\n    Images.loadWiremock(K3S);\n    util\u003dnew Util(K3S);\n    client\u003dutil.client();\n    util.setUp(NAMESPACE);\n    manifests(Phase.CREATE);\n    util.wiremock(NAMESPACE,\"/wiremock\",Phase.CREATE,false);\n    util.busybox(NAMESPACE,Phase.CREATE);\n    util.createNamespace(NAMESPACE_A_UAT);\n    util.createNamespace(NAMESPACE_B_UAT);\n    util.wiremock(NAMESPACE_A_UAT,\"/wiremock\",Phase.CREATE,false);\n    util.wiremock(NAMESPACE_B_UAT,\"/wiremock\",Phase.CREATE,false);\n    util.createNamespace(NAMESPACE_LEFT);\n    util.createNamespace(NAMESPACE_RIGHT);\n    util.wiremock(NAMESPACE_LEFT,\"/wiremock\",Phase.CREATE,false);\n    util.wiremock(NAMESPACE_RIGHT,\"/wiremock\",Phase.CREATE,false);\n  }\n  @AfterAll static void after() throws Exception {\n    util.wiremock(NAMESPACE,\"/wiremock\",Phase.DELETE,false);\n    util.busybox(NAMESPACE,Phase.DELETE);\n    util.wiremock(NAMESPACE_A_UAT,\"/wiremock\",Phase.DELETE,false);\n    util.wiremock(NAMESPACE_B_UAT,\"/wiremock\",Phase.DELETE,false);\n    util.deleteNamespace(NAMESPACE_A_UAT);\n    util.deleteNamespace(NAMESPACE_B_UAT);\n    util.wiremock(NAMESPACE_LEFT,\"/wiremock\",Phase.DELETE,false);\n    util.wiremock(NAMESPACE_RIGHT,\"/wiremock\",Phase.DELETE,false);\n    util.deleteNamespace(NAMESPACE_LEFT);\n    util.deleteNamespace(NAMESPACE_RIGHT);\n    manifests(Phase.DELETE);\n    Commons.cleanUp(IMAGE_NAME,K3S);\n    Commons.systemPrune();\n  }\n  @Test void testPodMetadata() throws Exception {\n    String[] both\u003dK3S.execInContainer(\"sh\",\"-c\",\"kubectl get pods -l app\u003dbusybox -o\u003dname --no-headers\").getStdout().split(\"\\n\");\n    K3S.execInContainer(\"sh\",\"-c\",\"kubectl label pods \" + both[0].split(\"/\")[1] + \" custom-label\u003dcustom-label-value\");\n    K3S.execInContainer(\"sh\",\"-c\",\"kubectl annotate pods \" + both[1].split(\"/\")[1] + \" custom-annotation\u003dcustom-annotation-value\");\n    WebClient client\u003dbuilder().baseUrl(\"http://localhost/service-instances/busybox-service\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e serviceInstances\u003dclient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    DefaultKubernetesServiceInstance withCustomLabel\u003dserviceInstances.stream().filter(x -\u003e x.podMetadata().getOrDefault(\"annotations\",Map.of()).isEmpty()).toList().get(0);\n    Assertions.assertEquals(withCustomLabel.getServiceId(),\"busybox-service\");\n    Assertions.assertNotNull(withCustomLabel.getInstanceId());\n    Assertions.assertNotNull(withCustomLabel.getHost());\n    Assertions.assertEquals(withCustomLabel.getMetadata(),Map.of(\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\",\"port.busybox-port\",\"80\"));\n    Assertions.assertTrue(withCustomLabel.podMetadata().get(\"labels\").entrySet().stream().anyMatch(x -\u003e x.getKey().equals(\"custom-label\") \u0026\u0026 x.getValue().equals(\"custom-label-value\")));\n    DefaultKubernetesServiceInstance withCustomAnnotation\u003dserviceInstances.stream().filter(x -\u003e !x.podMetadata().getOrDefault(\"annotations\",Map.of()).isEmpty()).toList().get(0);\n    Assertions.assertEquals(withCustomAnnotation.getServiceId(),\"busybox-service\");\n    Assertions.assertNotNull(withCustomAnnotation.getInstanceId());\n    Assertions.assertNotNull(withCustomAnnotation.getHost());\n    Assertions.assertEquals(withCustomAnnotation.getMetadata(),Map.of(\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\",\"port.busybox-port\",\"80\"));\n    Assertions.assertTrue(withCustomAnnotation.podMetadata().get(\"annotations\").entrySet().stream().anyMatch(x -\u003e x.getKey().equals(\"custom-annotation\") \u0026\u0026 x.getValue().equals(\"custom-annotation-value\")));\n    testAllOther();\n  }\n  private void testAllOther(){\n    testAllServices();\n    testAllServicesWithBootstrap();\n    testExternalNameServiceInstance();\n    testBlockingConfiguration();\n    testDefaultConfiguration();\n    testReactiveConfiguration();\n    filterMatchesBothNamespacesViaThePredicate();\n    filterMatchesOneNamespaceViaThePredicate();\n    namespaceFilter();\n  }\n  private void testAllServices(){\n    util.patchWithReplace(DOCKER_IMAGE,DEPLOYMENT_NAME,NAMESPACE,BODY_ONE,Map.of(\"app\",IMAGE_NAME));\n    Fabric8DiscoveryDelegate.testAllServices();\n  }\n  private void testAllServicesWithBootstrap(){\n    util.patchWithReplace(DOCKER_IMAGE,DEPLOYMENT_NAME,NAMESPACE,BODY_ONE_WITH_BOOTSTRAP,Map.of(\"app\",IMAGE_NAME));\n    Fabric8DiscoveryBoostrapDelegate.testAllServicesWithBootstrap();\n  }\n  private void testExternalNameServiceInstance(){\n    Fabric8DiscoveryDelegate.testExternalNameServiceInstance();\n  }\n  private void testBlockingConfiguration(){\n    util.patchWithReplace(DOCKER_IMAGE,DEPLOYMENT_NAME,NAMESPACE,BODY_TWO,Map.of(\"app\",IMAGE_NAME));\n    Fabric8DiscoveryClientHealthDelegate.testBlockingConfiguration(K3S,IMAGE_NAME);\n  }\n  private void testDefaultConfiguration(){\n    util.patchWithReplace(DOCKER_IMAGE,DEPLOYMENT_NAME,NAMESPACE,BODY_THREE,Map.of(\"app\",IMAGE_NAME));\n    Fabric8DiscoveryClientHealthDelegate.testDefaultConfiguration(K3S,IMAGE_NAME);\n  }\n  private void testReactiveConfiguration(){\n    util.patchWithReplace(DOCKER_IMAGE,DEPLOYMENT_NAME,NAMESPACE,BODY_FOUR,Map.of(\"app\",IMAGE_NAME));\n    Fabric8DiscoveryClientHealthDelegate.testReactiveConfiguration(K3S,IMAGE_NAME);\n  }\n  private void filterMatchesBothNamespacesViaThePredicate(){\n    util.patchWithReplace(DOCKER_IMAGE,DEPLOYMENT_NAME,NAMESPACE,BODY_FIVE,Map.of(\"app\",IMAGE_NAME));\n    Fabric8DiscoveryFilterDelegate.filterMatchesBothNamespacesViaThePredicate();\n  }\n  private void filterMatchesOneNamespaceViaThePredicate(){\n    util.patchWithReplace(DOCKER_IMAGE,DEPLOYMENT_NAME,NAMESPACE,BODY_SIX,Map.of(\"app\",IMAGE_NAME));\n    Fabric8DiscoveryFilterDelegate.filterMatchesOneNamespaceViaThePredicate();\n  }\n  private void namespaceFilter(){\n    util.patchWithReplace(DOCKER_IMAGE,DEPLOYMENT_NAME,NAMESPACE,BODY_SEVEN,Map.of(\"app\",IMAGE_NAME));\n    Fabric8DiscoveryNamespaceDelegate.namespaceFilter();\n  }\n  private static void manifests(  Phase phase){\n    InputStream deploymentStream\u003dutil.inputStream(\"fabric8-discovery-deployment.yaml\");\n    InputStream externalNameServiceStream\u003dutil.inputStream(\"external-name-service.yaml\");\n    InputStream discoveryServiceStream\u003dutil.inputStream(\"fabric8-discovery-service.yaml\");\n    InputStream ingressStream\u003dutil.inputStream(\"fabric8-discovery-ingress.yaml\");\n    Deployment deployment\u003dSerialization.unmarshal(deploymentStream,Deployment.class);\n    List\u003cEnvVar\u003e existing\u003dnew ArrayList\u003c\u003e(deployment.getSpec().getTemplate().getSpec().getContainers().get(0).getEnv());\n    existing.add(new EnvVarBuilder().withName(\"SPRING_CLOUD_KUBERNETES_DISCOVERY_METADATA_ADDPODLABELS\").withValue(\"true\").build());\n    existing.add(new EnvVarBuilder().withName(\"SPRING_CLOUD_KUBERNETES_DISCOVERY_METADATA_ADDPODANNOTATIONS\").withValue(\"true\").build());\n    existing.add(new EnvVarBuilder().withName(\"LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_CLOUD_KUBERNETES_FABRIC8_DISCOVERY\").withValue(\"DEBUG\").build());\n    deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setEnv(existing);\n    Service externalServiceName\u003dSerialization.unmarshal(externalNameServiceStream,Service.class);\n    Service discoveryService\u003dSerialization.unmarshal(discoveryServiceStream,Service.class);\n    Ingress ingress\u003dSerialization.unmarshal(ingressStream,Ingress.class);\n    ClusterRoleBinding clusterRoleBinding\u003dSerialization.unmarshal(getAdminRole(),ClusterRoleBinding.class);\n    if (phase.equals(Phase.CREATE)) {\n      client.rbac().clusterRoleBindings().resource(clusterRoleBinding).create();\n      util.createAndWait(NAMESPACE,IMAGE_NAME,deployment,discoveryService,ingress,true);\n      util.createAndWait(NAMESPACE,null,null,externalServiceName,null,true);\n    }\n else {\n      client.rbac().clusterRoleBindings().resource(clusterRoleBinding).delete();\n      util.deleteAndWait(NAMESPACE,deployment,discoveryService,ingress);\n      util.deleteAndWait(NAMESPACE,null,externalServiceName,null);\n    }\n  }\n  private static InputStream getAdminRole(){\n    return util.inputStream(\"namespace-filter/fabric8-cluster-admin-serviceaccount-role.yaml\");\n  }\n  private WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass Fabric8DiscoveryPodMetadataIT {\n  private static final String DEPLOYMENT_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-discovery-deployment\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String NAMESPACE_A_UAT\u003d\"a-uat\";\n  private static final String NAMESPACE_B_UAT\u003d\"b-uat\";\n  private static final String NAMESPACE_LEFT\u003d\"namespace-left\";\n  private static final String NAMESPACE_RIGHT\u003d\"namespace-right\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-discovery\";\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + IMAGE_NAME + \":\"+ pomVersion();\n  private static KubernetesClient client;\n  private static Util util;\n  private static final K3sContainer K3S\u003dCommons.container();\n  @BeforeAll static void beforeAll() throws Exception;\n  @AfterAll static void after() throws Exception;\n  @Test void testPodMetadata() throws Exception;\n  private void testAllOther();\n  private void testAllServices();\n  private void testAllServicesWithBootstrap();\n  private void testExternalNameServiceInstance();\n  private void testBlockingConfiguration();\n  private void testDefaultConfiguration();\n  private void testReactiveConfiguration();\n  private void filterMatchesBothNamespacesViaThePredicate();\n  private void filterMatchesOneNamespaceViaThePredicate();\n  private void namespaceFilter();\n  private static void manifests(  Phase phase);\n  private static InputStream getAdminRole();\n  private WebClient.Builder builder();\n  private RetryBackoffSpec retrySpec();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/discovery/Fabric8DiscoveryClientUtil.java",
        "name": "Fabric8DiscoveryClientUtil",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.discovery.Fabric8DiscoveryClientUtil",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class Fabric8DiscoveryClientUtil {\n  private Fabric8DiscoveryClientUtil(){\n  }\n  static final String BODY_ONE\u003dnull;\n  static final String BODY_ONE_WITH_BOOTSTRAP\u003dnull;\n  static final String BODY_TWO\u003dnull;\n  static final String BODY_THREE\u003dnull;\n  static final String BODY_FOUR\u003dnull;\n  static final String BODY_FIVE\u003dnull;\n  static final String BODY_SIX\u003dnull;\n  static final String BODY_SEVEN\u003dnull;\n  static WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  static RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class Fabric8DiscoveryClientUtil {\n  private Fabric8DiscoveryClientUtil();\n  static final String BODY_ONE\u003dnull;\n  static final String BODY_ONE_WITH_BOOTSTRAP\u003dnull;\n  static final String BODY_TWO\u003dnull;\n  static final String BODY_THREE\u003dnull;\n  static final String BODY_FOUR\u003dnull;\n  static final String BODY_FIVE\u003dnull;\n  static final String BODY_SIX\u003dnull;\n  static final String BODY_SEVEN\u003dnull;\n  static WebClient.Builder builder();\n  static RetryBackoffSpec retrySpec();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/discovery/Fabric8DiscoveryBoostrapDelegate.java",
        "name": "Fabric8DiscoveryBoostrapDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.discovery.Fabric8DiscoveryBoostrapDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class Fabric8DiscoveryBoostrapDelegate {\n  /** \n * KubernetesDiscoveryClient::getServices call must include the external-name-service also.\n */\n  static void testAllServicesWithBootstrap(){\n    WebClient client\u003dbuilder().baseUrl(\"http://localhost/services\").build();\n    List\u003cString\u003e result\u003dclient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cString\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(result.size(),5);\n    Assertions.assertTrue(result.contains(\"kubernetes\"));\n    Assertions.assertTrue(result.contains(\"spring-cloud-kubernetes-fabric8-client-discovery\"));\n    Assertions.assertTrue(result.contains(\"service-wiremock\"));\n    Assertions.assertTrue(result.contains(\"busybox-service\"));\n    Assertions.assertTrue(result.contains(\"external-name-service\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class Fabric8DiscoveryBoostrapDelegate {\n  /** \n * KubernetesDiscoveryClient::getServices call must include the external-name-service also.\n */\n  static void testAllServicesWithBootstrap();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/discovery/Fabric8DiscoveryClientHealthDelegate.java",
        "name": "Fabric8DiscoveryClientHealthDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.discovery.Fabric8DiscoveryClientHealthDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class Fabric8DiscoveryClientHealthDelegate {\n  private Fabric8DiscoveryClientHealthDelegate(){\n  }\n  private static final String REACTIVE_STATUS\u003d\"$.components.reactiveDiscoveryClients.components.[\u0027Fabric8 Kubernetes Reactive Discovery Client\u0027].status\";\n  private static final String BLOCKING_STATUS\u003d\"$.components.discoveryComposite.components.discoveryClient.status\";\n  private static final BasicJsonTester BASIC_JSON_TESTER\u003dnew BasicJsonTester(Fabric8DiscoveryClientHealthDelegate.class);\n  /** \n * Reactive is disabled, only blocking is active. As such, KubernetesInformerDiscoveryClientAutoConfiguration::indicatorInitializer will post an InstanceRegisteredEvent. We assert for logs and call \u0027/health\u0027 endpoint to see that blocking discovery client was initialized.\n */\n  static void testBlockingConfiguration(  K3sContainer k3sContainer,  String imageName){\n    waitForLogStatement(\"Will publish InstanceRegisteredEvent from blocking implementation\",k3sContainer,imageName);\n    waitForLogStatement(\"publishing InstanceRegisteredEvent\",k3sContainer,imageName);\n    waitForLogStatement(\"Discovery Client has been initialized\",k3sContainer,imageName);\n    waitForLogStatement(\"received InstanceRegisteredEvent from pod with \u0027app\u0027 label value : spring-cloud-kubernetes-fabric8-client-discovery\",k3sContainer,imageName);\n    WebClient healthClient\u003dbuilder().baseUrl(\"http://localhost/actuator/health\").build();\n    String healthResult\u003dhealthClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.discoveryComposite.status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(BLOCKING_STATUS).isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathArrayValue(\"$.components.discoveryComposite.components.discoveryClient.details.services\").containsExactlyInAnyOrder(\"spring-cloud-kubernetes-fabric8-client-discovery\",\"kubernetes\",\"busybox-service\",\"external-name-service\",\"service-wiremock\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).doesNotHaveJsonPath(REACTIVE_STATUS);\n  }\n  /** \n * Both blocking and reactive are enabled.\n */\n  static void testDefaultConfiguration(  K3sContainer k3sContainer,  String imageName){\n    waitForLogStatement(\"Will publish InstanceRegisteredEvent from blocking implementation\",k3sContainer,imageName);\n    waitForLogStatement(\"publishing InstanceRegisteredEvent\",k3sContainer,imageName);\n    waitForLogStatement(\"Discovery Client has been initialized\",k3sContainer,imageName);\n    waitForLogStatement(\"received InstanceRegisteredEvent from pod with \u0027app\u0027 label value : \" + \"spring-cloud-kubernetes-fabric8-client-discovery\",k3sContainer,imageName);\n    WebClient healthClient\u003dbuilder().baseUrl(\"http://localhost/actuator/health\").build();\n    String healthResult\u003dhealthClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.discoveryComposite.status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.discoveryComposite.components.discoveryClient.status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathArrayValue(\"$.components.discoveryComposite.components.discoveryClient.details.services\").containsExactlyInAnyOrder(\"spring-cloud-kubernetes-fabric8-client-discovery\",\"kubernetes\",\"external-name-service\",\"service-wiremock\",\"busybox-service\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.reactiveDiscoveryClients.status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.reactiveDiscoveryClients.components.[\u0027Fabric8 Kubernetes Reactive Discovery Client\u0027].status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathArrayValue(\"$.components.reactiveDiscoveryClients.components.[\u0027Fabric8 Kubernetes Reactive Discovery Client\u0027].details.services\").containsExactlyInAnyOrder(\"spring-cloud-kubernetes-fabric8-client-discovery\",\"kubernetes\",\"external-name-service\",\"service-wiremock\",\"busybox-service\");\n  }\n  /** \n * Reactive is enabled, blocking is disabled. As such, KubernetesInformerDiscoveryClientAutoConfiguration::indicatorInitializer will post an InstanceRegisteredEvent. We assert for logs and call \u0027/health\u0027 endpoint to see that blocking discovery client was initialized.\n */\n  static void testReactiveConfiguration(  K3sContainer k3sContainer,  String imageName){\n    waitForLogStatement(\"Will publish InstanceRegisteredEvent from reactive implementation\",k3sContainer,imageName);\n    waitForLogStatement(\"publishing InstanceRegisteredEvent\",k3sContainer,imageName);\n    waitForLogStatement(\"Discovery Client has been initialized\",k3sContainer,imageName);\n    waitForLogStatement(\"received InstanceRegisteredEvent from pod with \u0027app\u0027 label value : spring-cloud-kubernetes-fabric8-client-discovery\",k3sContainer,imageName);\n    WebClient healthClient\u003dbuilder().baseUrl(\"http://localhost/actuator/health\").build();\n    String healthResult\u003dhealthClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.reactiveDiscoveryClients.status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(REACTIVE_STATUS).isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathArrayValue(\"$.components.reactiveDiscoveryClients.components.[\u0027Fabric8 Kubernetes Reactive Discovery Client\u0027].details.services\").containsExactlyInAnyOrder(\"spring-cloud-kubernetes-fabric8-client-discovery\",\"kubernetes\",\"external-name-service\",\"service-wiremock\",\"busybox-service\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).doesNotHaveJsonPath(BLOCKING_STATUS);\n    WebClient servicesClient\u003dbuilder().baseUrl(\"http://localhost/reactive/services\").build();\n    List\u003cString\u003e servicesResult\u003dservicesClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cString\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertThat(servicesResult).contains(\"spring-cloud-kubernetes-fabric8-client-discovery\");\n    Assertions.assertThat(servicesResult).contains(\"kubernetes\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class Fabric8DiscoveryClientHealthDelegate {\n  private Fabric8DiscoveryClientHealthDelegate();\n  private static final String REACTIVE_STATUS\u003d\"$.components.reactiveDiscoveryClients.components.[\u0027Fabric8 Kubernetes Reactive Discovery Client\u0027].status\";\n  private static final String BLOCKING_STATUS\u003d\"$.components.discoveryComposite.components.discoveryClient.status\";\n  private static final BasicJsonTester BASIC_JSON_TESTER\u003dnew BasicJsonTester(Fabric8DiscoveryClientHealthDelegate.class);\n  /** \n * Reactive is disabled, only blocking is active. As such, KubernetesInformerDiscoveryClientAutoConfiguration::indicatorInitializer will post an InstanceRegisteredEvent. We assert for logs and call \u0027/health\u0027 endpoint to see that blocking discovery client was initialized.\n */\n  static void testBlockingConfiguration(  K3sContainer k3sContainer,  String imageName);\n  /** \n * Both blocking and reactive are enabled.\n */\n  static void testDefaultConfiguration(  K3sContainer k3sContainer,  String imageName);\n  /** \n * Reactive is enabled, blocking is disabled. As such, KubernetesInformerDiscoveryClientAutoConfiguration::indicatorInitializer will post an InstanceRegisteredEvent. We assert for logs and call \u0027/health\u0027 endpoint to see that blocking discovery client was initialized.\n */\n  static void testReactiveConfiguration(  K3sContainer k3sContainer,  String imageName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/discovery/Fabric8DiscoveryNamespaceDelegate.java",
        "name": "Fabric8DiscoveryNamespaceDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.discovery.Fabric8DiscoveryNamespaceDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author mbialkowski1\n */\nfinal class Fabric8DiscoveryNamespaceDelegate {\n  private Fabric8DiscoveryNamespaceDelegate(){\n  }\n  static void namespaceFilter(){\n    WebClient clientServices\u003dbuilder().baseUrl(\"http://localhost/services\").build();\n    @SuppressWarnings(\"unchecked\") List\u003cString\u003e services\u003d(List\u003cString\u003e)clientServices.method(HttpMethod.GET).retrieve().bodyToMono(List.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(services.size(),1);\n    Assertions.assertTrue(services.contains(\"service-wiremock\"));\n    WebClient clientEndpoints\u003dbuilder().baseUrl(\"http://localhost/endpoints/service-wiremock\").build();\n    List\u003cEndpoints\u003e endpoints\u003dclientEndpoints.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cEndpoints\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(endpoints.size(),1);\n    Assertions.assertEquals(endpoints.get(0).getMetadata().getNamespace(),\"namespace-left\");\n  }\n}\n",
        "abstract": "/** \n * @author mbialkowski1\n */\nfinal class Fabric8DiscoveryNamespaceDelegate {\n  private Fabric8DiscoveryNamespaceDelegate();\n  static void namespaceFilter();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-discovery/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/discovery/Fabric8DiscoveryDelegate.java",
        "name": "Fabric8DiscoveryDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.discovery.Fabric8DiscoveryDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class Fabric8DiscoveryDelegate {\n  private Fabric8DiscoveryDelegate(){\n  }\n  /** \n * KubernetesDiscoveryClient::getServices call must include the external-name-service also.\n */\n  static void testAllServices(){\n    WebClient client\u003dbuilder().baseUrl(\"http://localhost/services\").build();\n    List\u003cString\u003e result\u003dclient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cString\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(result.size(),5);\n    Assertions.assertTrue(result.contains(\"kubernetes\"));\n    Assertions.assertTrue(result.contains(\"spring-cloud-kubernetes-fabric8-client-discovery\"));\n    Assertions.assertTrue(result.contains(\"service-wiremock\"));\n    Assertions.assertTrue(result.contains(\"busybox-service\"));\n    Assertions.assertTrue(result.contains(\"external-name-service\"));\n  }\n  static void testExternalNameServiceInstance(){\n    WebClient client\u003dbuilder().baseUrl(\"http://localhost/service-instances/external-name-service\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e serviceInstances\u003dclient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    DefaultKubernetesServiceInstance result\u003dserviceInstances.get(0);\n    Assertions.assertEquals(serviceInstances.size(),1);\n    Assertions.assertEquals(result.getServiceId(),\"external-name-service\");\n    Assertions.assertNotNull(result.getInstanceId());\n    Assertions.assertEquals(result.getHost(),\"spring.io\");\n    Assertions.assertEquals(result.getPort(),-1);\n    Assertions.assertEquals(result.getMetadata(),Map.of(\"k8s_namespace\",\"default\",\"type\",\"ExternalName\"));\n    Assertions.assertFalse(result.isSecure());\n    Assertions.assertEquals(result.getUri().toASCIIString(),\"spring.io\");\n    Assertions.assertEquals(result.getScheme(),\"http\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class Fabric8DiscoveryDelegate {\n  private Fabric8DiscoveryDelegate();\n  /** \n * KubernetesDiscoveryClient::getServices call must include the external-name-service also.\n */\n  static void testAllServices();\n  static void testExternalNameServiceInstance();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-istio/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/istio/IstioApp.java",
        "name": "IstioApp",
        "modifiers": "@SpringBootApplication public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.istio.IstioApp",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication public class IstioApp {\n  public static void main(  String[] args){\n    SpringApplication.run(IstioApp.class,args);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication public class IstioApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-istio/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/istio/IstioController.java",
        "name": "IstioController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.istio.IstioController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController public class IstioController {\n  private final Environment environment;\n  private final IstioClient istioClient;\n  public IstioController(  Environment environment,  IstioClient istioClient){\n    this.environment\u003denvironment;\n    this.istioClient\u003distioClient;\n  }\n  @GetMapping(\"/profiles\") public List\u003cString\u003e profiles(){\n    return Arrays.asList(environment.getActiveProfiles());\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController public class IstioController {\n  private final Environment environment;\n  private final IstioClient istioClient;\n  public IstioController(  Environment environment,  IstioClient istioClient);\n  @GetMapping(\"/profiles\") public List\u003cString\u003e profiles();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-istio/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/istio/Fabric8IstioIT.java",
        "name": "Fabric8IstioIT",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.istio.Fabric8IstioIT",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass Fabric8IstioIT {\n  private static final String NAMESPACE\u003d\"istio-test\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-istio\";\n  private static Util util;\n  private static K3sContainer K3S;\n  @BeforeAll static void beforeAll() throws Exception {\n    K3S\u003dCommons.container();\n    K3S.start();\n    util\u003dnew Util(K3S);\n    Commons.validateImage(IMAGE_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(IMAGE_NAME,K3S);\n    Images.loadIstioctl(K3S);\n    processExecResult(K3S.execInContainer(\"sh\",\"-c\",\"kubectl create namespace istio-test\"));\n    processExecResult(K3S.execInContainer(\"sh\",\"-c\",\"kubectl label namespace istio-test istio-injection\u003denabled\"));\n    util.setUpIstioctl(NAMESPACE,Phase.CREATE);\n    String istioctlPodName\u003distioctlPodName();\n    K3S.execInContainer(\"sh\",\"-c\",\"kubectl cp istio-test/\" + istioctlPodName + \":/usr/local/bin/istioctl /tmp/istioctl\");\n    K3S.execInContainer(\"sh\",\"-c\",\"chmod +x /tmp/istioctl\");\n    processExecResult(K3S.execInContainer(\"sh\",\"-c\",\"/tmp/istioctl\" + \" --kubeconfig\u003d/etc/rancher/k3s/k3s.yaml install --set profile\u003dminimal -y\"));\n    util.setUpIstio(NAMESPACE);\n    appManifests(Phase.CREATE);\n  }\n  @AfterAll static void afterAll() throws Exception {\n    util.deleteNamespace(\"istio-system\");\n    Commons.cleanUp(IMAGE_NAME,K3S);\n    Commons.systemPrune();\n  }\n  @AfterAll static void after(){\n    appManifests(Phase.DELETE);\n    util.setUpIstioctl(NAMESPACE,Phase.DELETE);\n  }\n  @Test void test(){\n    WebClient client\u003dbuilder().baseUrl(\"http://localhost/profiles\").build();\n    @SuppressWarnings(\"unchecked\") List\u003cString\u003e result\u003dclient.method(HttpMethod.GET).retrieve().bodyToMono(List.class).retryWhen(retrySpec()).block();\n    Assertions.assertTrue(result.contains(\"istio\"));\n  }\n  private static void appManifests(  Phase phase){\n    InputStream deploymentStream\u003dutil.inputStream(\"istio-deployment.yaml\");\n    InputStream serviceStream\u003dutil.inputStream(\"istio-service.yaml\");\n    InputStream ingressStream\u003dutil.inputStream(\"istio-ingress.yaml\");\n    Deployment deployment\u003dSerialization.unmarshal(deploymentStream,Deployment.class);\n    Service service\u003dSerialization.unmarshal(serviceStream,Service.class);\n    Ingress ingress\u003dSerialization.unmarshal(ingressStream,Ingress.class);\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(NAMESPACE,null,deployment,service,ingress,true);\n    }\n else {\n      util.deleteAndWait(NAMESPACE,deployment,service,ingress);\n    }\n  }\n  private WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n  private static String istioctlPodName(){\n    try {\n      return K3S.execInContainer(\"sh\",\"-c\",\"kubectl get pods -n istio-test -l app\u003distio-ctl -o\u003dname --no-headers | tr -d \u0027\\n\u0027\").getStdout().split(\"/\")[1];\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass Fabric8IstioIT {\n  private static final String NAMESPACE\u003d\"istio-test\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-istio\";\n  private static Util util;\n  private static K3sContainer K3S;\n  @BeforeAll static void beforeAll() throws Exception;\n  @AfterAll static void afterAll() throws Exception;\n  @AfterAll static void after();\n  @Test void test();\n  private static void appManifests(  Phase phase);\n  private WebClient.Builder builder();\n  private RetryBackoffSpec retrySpec();\n  private static String istioctlPodName();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery/src/main/java/org/springframework/cloud/kubernetes/k8s/client/discovery/DiscoveryController.java",
        "name": "DiscoveryController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.discovery.DiscoveryController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController public class DiscoveryController {\n  private final KubernetesInformerDiscoveryClient discoveryClient;\n  public DiscoveryController(  ObjectProvider\u003cKubernetesInformerDiscoveryClient\u003e discoveryClient){\n    KubernetesInformerDiscoveryClient[] local\u003dnew KubernetesInformerDiscoveryClient[1];\n    discoveryClient.ifAvailable(x -\u003e local[0]\u003dx);\n    this.discoveryClient\u003dlocal[0];\n  }\n  @GetMapping(\"/services\") public List\u003cString\u003e allServices(){\n    return discoveryClient.getServices();\n  }\n  @GetMapping(\"/service-instances/{serviceId}\") public List\u003cServiceInstance\u003e serviceInstances(  @PathVariable(\"serviceId\") String serviceId){\n    return discoveryClient.getInstances(serviceId);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController public class DiscoveryController {\n  private final KubernetesInformerDiscoveryClient discoveryClient;\n  public DiscoveryController(  ObjectProvider\u003cKubernetesInformerDiscoveryClient\u003e discoveryClient);\n  @GetMapping(\"/services\") public List\u003cString\u003e allServices();\n  @GetMapping(\"/service-instances/{serviceId}\") public List\u003cServiceInstance\u003e serviceInstances(  @PathVariable(\"serviceId\") String serviceId);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery/src/main/java/org/springframework/cloud/kubernetes/k8s/client/discovery/DiscoveryApplicationListener.java",
        "name": "DiscoveryApplicationListener",
        "modifiers": "@Component public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.discovery.DiscoveryApplicationListener",
        "extend": "",
        "implements": "ApplicationListener\u003cInstanceRegisteredEvent\u003c?\u003e\u003e",
        "raw": "/** \n * @author wind57\n */\n@Component public class DiscoveryApplicationListener implements ApplicationListener\u003cInstanceRegisteredEvent\u003c?\u003e\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(DiscoveryApplicationListener.class));\n  @Override public void onApplicationEvent(  InstanceRegisteredEvent\u003c?\u003e event){\n    V1Pod pod\u003d(V1Pod)((RegisteredEventSource)event.getSource()).pod();\n    LOG.info(() -\u003e \"received InstanceRegisteredEvent from pod with \u0027app\u0027 label value : \" + pod.getMetadata().getLabels().get(\"app\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@Component public class DiscoveryApplicationListener implements ApplicationListener\u003cInstanceRegisteredEvent\u003c?\u003e\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(DiscoveryApplicationListener.class));\n  @Override public void onApplicationEvent(  InstanceRegisteredEvent\u003c?\u003e event);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery/src/main/java/org/springframework/cloud/kubernetes/k8s/client/discovery/DiscoveryApp.java",
        "name": "DiscoveryApp",
        "modifiers": "@SpringBootApplication public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.discovery.DiscoveryApp",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication public class DiscoveryApp {\n  public static void main(  String[] args){\n    SpringApplication.run(DiscoveryApp.class,args);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication public class DiscoveryApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery/src/main/java/org/springframework/cloud/kubernetes/k8s/client/discovery/ReactiveDiscoveryController.java",
        "name": "ReactiveDiscoveryController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.discovery.ReactiveDiscoveryController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController public class ReactiveDiscoveryController {\n  private final KubernetesInformerReactiveDiscoveryClient reactiveDiscoveryClient;\n  public ReactiveDiscoveryController(  ObjectProvider\u003cKubernetesInformerReactiveDiscoveryClient\u003e reactiveDiscoveryClient){\n    KubernetesInformerReactiveDiscoveryClient[] local\u003dnew KubernetesInformerReactiveDiscoveryClient[1];\n    reactiveDiscoveryClient.ifAvailable(x -\u003e local[0]\u003dx);\n    this.reactiveDiscoveryClient\u003dlocal[0];\n  }\n  @GetMapping(\"/reactive/services\") public Mono\u003cList\u003cString\u003e\u003e allServices(){\n    return reactiveDiscoveryClient.getServices().collectList();\n  }\n  @GetMapping(\"reactive/service-instances/{serviceId}\") public Mono\u003cList\u003cServiceInstance\u003e\u003e serviceInstances(  @PathVariable(\"serviceId\") String serviceId){\n    return reactiveDiscoveryClient.getInstances(serviceId).collectList();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController public class ReactiveDiscoveryController {\n  private final KubernetesInformerReactiveDiscoveryClient reactiveDiscoveryClient;\n  public ReactiveDiscoveryController(  ObjectProvider\u003cKubernetesInformerReactiveDiscoveryClient\u003e reactiveDiscoveryClient);\n  @GetMapping(\"/reactive/services\") public Mono\u003cList\u003cString\u003e\u003e allServices();\n  @GetMapping(\"reactive/service-instances/{serviceId}\") public Mono\u003cList\u003cServiceInstance\u003e\u003e serviceInstances(  @PathVariable(\"serviceId\") String serviceId);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery/src/test/java/org/springframework/cloud/kubernetes/k8s/client/discovery/KubernetesClientDiscoveryHealthITDelegate.java",
        "name": "KubernetesClientDiscoveryHealthITDelegate",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.discovery.KubernetesClientDiscoveryHealthITDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesClientDiscoveryHealthITDelegate {\n  KubernetesClientDiscoveryHealthITDelegate(){\n  }\n  private static final String REACTIVE_STATUS\u003d\"$.components.reactiveDiscoveryClients.components.[\u0027Kubernetes Reactive Discovery Client\u0027].status\";\n  private static final String BLOCKING_STATUS\u003d\"$.components.discoveryComposite.components.discoveryClient.status\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String DEPLOYMENT_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  private static final BasicJsonTester BASIC_JSON_TESTER\u003dnew BasicJsonTester(KubernetesClientDiscoveryHealthITDelegate.class);\n  /** \n * Reactive is disabled, only blocking is active. As such, KubernetesInformerDiscoveryClientAutoConfiguration::indicatorInitializer will post an InstanceRegisteredEvent. We assert for logs and call \u0027/health\u0027 endpoint to see that blocking discovery client was initialized.\n */\n  void testBlockingConfiguration(  K3sContainer container){\n    assertLogStatement(container,\"Will publish InstanceRegisteredEvent from blocking implementation\");\n    assertLogStatement(container,\"publishing InstanceRegisteredEvent\");\n    assertLogStatement(container,\"Discovery Client has been initialized\");\n    assertLogStatement(container,\"received InstanceRegisteredEvent from pod with \u0027app\u0027 label value : spring-cloud-kubernetes-k8s-client-discovery\");\n    WebClient healthClient\u003dbuilder().baseUrl(\"http://localhost/actuator/health\").build();\n    String healthResult\u003dhealthClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.discoveryComposite.status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(BLOCKING_STATUS).isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathArrayValue(\"$.components.discoveryComposite.components.discoveryClient.details.services\").containsExactlyInAnyOrder(\"spring-cloud-kubernetes-k8s-client-discovery\",\"kubernetes\",\"external-name-service\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).doesNotHaveJsonPath(REACTIVE_STATUS);\n  }\n  /** \n * Reactive is enabled, blocking is disabled. As such, KubernetesInformerDiscoveryClientAutoConfiguration::indicatorInitializer will post an InstanceRegisteredEvent. We assert for logs and call \u0027/health\u0027 endpoint to see that blocking discovery client was initialized.\n */\n  void testReactiveConfiguration(  K3sContainer container){\n    KubernetesClientDiscoveryClientUtils.patchForReactiveHealth(DEPLOYMENT_NAME,NAMESPACE);\n    assertLogStatement(container,\"Will publish InstanceRegisteredEvent from reactive implementation\");\n    assertLogStatement(container,\"publishing InstanceRegisteredEvent\");\n    assertLogStatement(container,\"Discovery Client has been initialized\");\n    assertLogStatement(container,\"received InstanceRegisteredEvent from pod with \u0027app\u0027 label value : spring-cloud-kubernetes-k8s-client-discovery\");\n    WebClient healthClient\u003dbuilder().baseUrl(\"http://localhost/actuator/health\").build();\n    String healthResult\u003dhealthClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.reactiveDiscoveryClients.status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(REACTIVE_STATUS).isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathArrayValue(\"$.components.reactiveDiscoveryClients.components.[\u0027Kubernetes Reactive Discovery Client\u0027].details.services\").containsExactlyInAnyOrder(\"spring-cloud-kubernetes-k8s-client-discovery\",\"kubernetes\",\"external-name-service\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).doesNotHaveJsonPath(BLOCKING_STATUS);\n    WebClient servicesClient\u003dbuilder().baseUrl(\"http://localhost/reactive/services\").build();\n    List\u003cString\u003e servicesResult\u003dservicesClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cString\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertThat(servicesResult).contains(\"spring-cloud-kubernetes-k8s-client-discovery\");\n    Assertions.assertThat(servicesResult).contains(\"kubernetes\");\n  }\n  /** \n * Both blocking and reactive are enabled.\n */\n  void testDefaultConfiguration(  K3sContainer container){\n    KubernetesClientDiscoveryClientUtils.patchForBlockingAndReactiveHealth(DEPLOYMENT_NAME,NAMESPACE);\n    assertLogStatement(container,\"Will publish InstanceRegisteredEvent from blocking implementation\");\n    assertLogStatement(container,\"publishing InstanceRegisteredEvent\");\n    assertLogStatement(container,\"Discovery Client has been initialized\");\n    assertLogStatement(container,\"received InstanceRegisteredEvent from pod with \u0027app\u0027 label value : spring-cloud-kubernetes-k8s-client-discovery\");\n    WebClient healthClient\u003dbuilder().baseUrl(\"http://localhost/actuator/health\").build();\n    WebClient infoClient\u003dbuilder().baseUrl(\"http://localhost/actuator/info\").build();\n    String healthResult\u003dhealthClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    String infoResult\u003dinfoClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.discoveryComposite.status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.discoveryComposite.components.discoveryClient.status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathArrayValue(\"$.components.discoveryComposite.components.discoveryClient.details.services\").containsExactlyInAnyOrder(\"spring-cloud-kubernetes-k8s-client-discovery\",\"kubernetes\",\"external-name-service\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.reactiveDiscoveryClients.status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.reactiveDiscoveryClients.components.[\u0027Kubernetes Reactive Discovery Client\u0027].status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathArrayValue(\"$.components.reactiveDiscoveryClients.components.[\u0027Kubernetes Reactive Discovery Client\u0027].details.services\").containsExactlyInAnyOrder(\"spring-cloud-kubernetes-k8s-client-discovery\",\"kubernetes\",\"external-name-service\");\n    assertHealth(healthResult);\n    assertInfo(infoResult);\n  }\n  private void assertHealth(  String healthResult){\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.kubernetes.status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.kubernetes.details.hostIp\").isNotEmpty();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathBooleanValue(\"$.components.kubernetes.details.inside\").isEqualTo(true);\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.kubernetes.details.labels.app\").isEqualTo(\"spring-cloud-kubernetes-k8s-client-discovery\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.kubernetes.details.namespace\").isNotEmpty();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.kubernetes.details.nodeName\").isNotEmpty();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.kubernetes.details.podIp\").isNotEmpty();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.kubernetes.details.podName\").isNotEmpty();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(healthResult)).extractingJsonPathStringValue(\"$.components.kubernetes.details.serviceAccount\").isNotEmpty();\n  }\n  private void assertInfo(  String infoResult){\n    Assertions.assertThat(BASIC_JSON_TESTER.from(infoResult)).extractingJsonPathStringValue(\"$.kubernetes.hostIp\").isNotEmpty();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(infoResult)).extractingJsonPathBooleanValue(\"$.kubernetes.inside\").isEqualTo(true);\n    Assertions.assertThat(BASIC_JSON_TESTER.from(infoResult)).extractingJsonPathStringValue(\"$.kubernetes.namespace\").isNotEmpty();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(infoResult)).extractingJsonPathStringValue(\"$.kubernetes.nodeName\").isNotEmpty();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(infoResult)).extractingJsonPathStringValue(\"$.kubernetes.podIp\").isNotEmpty();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(infoResult)).extractingJsonPathStringValue(\"$.kubernetes.podName\").isNotEmpty();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(infoResult)).extractingJsonPathStringValue(\"$.kubernetes.serviceAccount\").isNotEmpty();\n  }\n  private WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n  private void assertLogStatement(  K3sContainer container,  String message){\n    try {\n      String appPodName\u003dcontainer.execInContainer(\"sh\",\"-c\",\"kubectl get pods -l app\u003d\" + DEPLOYMENT_NAME + \" -o\u003dname --no-headers | tr -d \u0027\\n\u0027\").getStdout();\n      await().pollDelay(Duration.ofSeconds(4)).pollInterval(Duration.ofSeconds(1)).atMost(20,TimeUnit.SECONDS).until(() -\u003e {\n        Container.ExecResult execResult\u003dcontainer.execInContainer(\"sh\",\"-c\",\"kubectl logs \" + appPodName.trim());\n        String ok\u003dexecResult.getStdout();\n        return ok.contains(message);\n      }\n);\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesClientDiscoveryHealthITDelegate {\n  KubernetesClientDiscoveryHealthITDelegate();\n  private static final String REACTIVE_STATUS\u003d\"$.components.reactiveDiscoveryClients.components.[\u0027Kubernetes Reactive Discovery Client\u0027].status\";\n  private static final String BLOCKING_STATUS\u003d\"$.components.discoveryComposite.components.discoveryClient.status\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String DEPLOYMENT_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  private static final BasicJsonTester BASIC_JSON_TESTER\u003dnew BasicJsonTester(KubernetesClientDiscoveryHealthITDelegate.class);\n  /** \n * Reactive is disabled, only blocking is active. As such, KubernetesInformerDiscoveryClientAutoConfiguration::indicatorInitializer will post an InstanceRegisteredEvent. We assert for logs and call \u0027/health\u0027 endpoint to see that blocking discovery client was initialized.\n */\n  void testBlockingConfiguration(  K3sContainer container);\n  /** \n * Reactive is enabled, blocking is disabled. As such, KubernetesInformerDiscoveryClientAutoConfiguration::indicatorInitializer will post an InstanceRegisteredEvent. We assert for logs and call \u0027/health\u0027 endpoint to see that blocking discovery client was initialized.\n */\n  void testReactiveConfiguration(  K3sContainer container);\n  /** \n * Both blocking and reactive are enabled.\n */\n  void testDefaultConfiguration(  K3sContainer container);\n  private void assertHealth(  String healthResult);\n  private void assertInfo(  String infoResult);\n  private WebClient.Builder builder();\n  private RetryBackoffSpec retrySpec();\n  private void assertLogStatement(  K3sContainer container,  String message);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery/src/test/java/org/springframework/cloud/kubernetes/k8s/client/discovery/KubernetesClientDiscoveryFilterITDelegate.java",
        "name": "KubernetesClientDiscoveryFilterITDelegate",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.discovery.KubernetesClientDiscoveryFilterITDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesClientDiscoveryFilterITDelegate {\n  private static final String NAMESPACE_A_UAT\u003d\"a-uat\";\n  private static final String NAMESPACE_B_UAT\u003d\"b-uat\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String DEPLOYMENT_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  void filterMatchesOneNamespaceViaThePredicate(  Util util){\n    util.createNamespace(NAMESPACE_A_UAT);\n    util.createNamespace(NAMESPACE_B_UAT);\n    util.setUpClusterWide(NAMESPACE,Set.of(NAMESPACE,NAMESPACE_A_UAT,NAMESPACE_B_UAT));\n    util.wiremock(NAMESPACE_A_UAT,\"/wiremock\",Phase.CREATE,false);\n    util.wiremock(NAMESPACE_B_UAT,\"/wiremock\",Phase.CREATE,false);\n    WebClient clientServices\u003dbuilder().baseUrl(\"http://localhost/services\").build();\n    @SuppressWarnings(\"unchecked\") List\u003cString\u003e services\u003d(List\u003cString\u003e)clientServices.method(HttpMethod.GET).retrieve().bodyToMono(List.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(services.size(),1);\n    Assertions.assertTrue(services.contains(\"service-wiremock\"));\n    WebClient client\u003dbuilder().baseUrl(\"http://localhost/service-instances/service-wiremock\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e serviceInstances\u003dclient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(serviceInstances.size(),1);\n    DefaultKubernetesServiceInstance first\u003dserviceInstances.get(0);\n    Assertions.assertEquals(first.getServiceId(),\"service-wiremock\");\n    Assertions.assertNotNull(first.getInstanceId());\n    Assertions.assertEquals(first.getPort(),8080);\n    Assertions.assertEquals(first.getNamespace(),\"a-uat\");\n    Assertions.assertEquals(first.getMetadata(),Map.of(\"app\",\"service-wiremock\",\"port.http\",\"8080\",\"k8s_namespace\",\"a-uat\",\"type\",\"ClusterIP\"));\n  }\n  /** \n * \u003cpre\u003e - service \"wiremock\" is present in namespace \"a-uat\" - service \"wiremock\" is present in namespace \"b-uat\" - we search with a predicate : \"#root.metadata.namespace matches \u0027^uat.*$\u0027\" As such, both services are found via \u0027getInstances\u0027 call. \u003c/pre\u003e\n */\n  void filterMatchesBothNamespacesViaThePredicate(){\n    KubernetesClientDiscoveryClientUtils.patchForTwoNamespacesMatchViaThePredicate(DEPLOYMENT_NAME,NAMESPACE);\n    WebClient clientServices\u003dbuilder().baseUrl(\"http://localhost/services\").build();\n    @SuppressWarnings(\"unchecked\") List\u003cString\u003e services\u003d(List\u003cString\u003e)clientServices.method(HttpMethod.GET).retrieve().bodyToMono(List.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(services.size(),1);\n    Assertions.assertTrue(services.contains(\"service-wiremock\"));\n    WebClient client\u003dbuilder().baseUrl(\"http://localhost/service-instances/service-wiremock\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e serviceInstances\u003dclient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(serviceInstances.size(),2);\n    List\u003cDefaultKubernetesServiceInstance\u003e sorted\u003dserviceInstances.stream().sorted(Comparator.comparing(DefaultKubernetesServiceInstance::getNamespace)).toList();\n    DefaultKubernetesServiceInstance first\u003dsorted.get(0);\n    Assertions.assertEquals(first.getServiceId(),\"service-wiremock\");\n    Assertions.assertNotNull(first.getInstanceId());\n    Assertions.assertEquals(first.getPort(),8080);\n    Assertions.assertEquals(first.getNamespace(),\"a-uat\");\n    Assertions.assertEquals(first.getMetadata(),Map.of(\"app\",\"service-wiremock\",\"port.http\",\"8080\",\"k8s_namespace\",\"a-uat\",\"type\",\"ClusterIP\"));\n    DefaultKubernetesServiceInstance second\u003dsorted.get(1);\n    Assertions.assertEquals(second.getServiceId(),\"service-wiremock\");\n    Assertions.assertNotNull(second.getInstanceId());\n    Assertions.assertEquals(second.getPort(),8080);\n    Assertions.assertEquals(second.getNamespace(),\"b-uat\");\n    Assertions.assertEquals(second.getMetadata(),Map.of(\"app\",\"service-wiremock\",\"port.http\",\"8080\",\"k8s_namespace\",\"b-uat\",\"type\",\"ClusterIP\"));\n  }\n  private WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(2)).filter(Objects::nonNull);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesClientDiscoveryFilterITDelegate {\n  private static final String NAMESPACE_A_UAT\u003d\"a-uat\";\n  private static final String NAMESPACE_B_UAT\u003d\"b-uat\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String DEPLOYMENT_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  void filterMatchesOneNamespaceViaThePredicate(  Util util);\n  /** \n * \u003cpre\u003e - service \"wiremock\" is present in namespace \"a-uat\" - service \"wiremock\" is present in namespace \"b-uat\" - we search with a predicate : \"#root.metadata.namespace matches \u0027^uat.*$\u0027\" As such, both services are found via \u0027getInstances\u0027 call. \u003c/pre\u003e\n */\n  void filterMatchesBothNamespacesViaThePredicate();\n  private WebClient.Builder builder();\n  private RetryBackoffSpec retrySpec();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery/src/test/java/org/springframework/cloud/kubernetes/k8s/client/discovery/KubernetesClientDiscoveryClientIT.java",
        "name": "KubernetesClientDiscoveryClientIT",
        "modifiers": "@TestMethodOrder(MethodOrderer.OrderAnnotation.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.discovery.KubernetesClientDiscoveryClientIT",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class) class KubernetesClientDiscoveryClientIT {\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String NAMESPACE_A\u003d\"a\";\n  private static final String NAMESPACE_B\u003d\"b\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  private static final String DEPLOYMENT_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  private static final String NAMESPACE_A_UAT\u003d\"a-uat\";\n  private static final String NAMESPACE_B_UAT\u003d\"b-uat\";\n  private static Util util;\n  private static final K3sContainer K3S\u003dCommons.container();\n  @BeforeAll static void beforeAll() throws Exception {\n    K3S.start();\n    Commons.validateImage(IMAGE_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(IMAGE_NAME,K3S);\n    Images.loadWiremock(K3S);\n    Images.loadBusybox(K3S);\n    util\u003dnew Util(K3S);\n    util.setUp(NAMESPACE);\n    manifests(Phase.CREATE);\n  }\n  @AfterAll static void afterAll() throws Exception {\n    manifests(Phase.DELETE);\n    Commons.cleanUp(IMAGE_NAME,K3S);\n    Commons.systemPrune();\n  }\n  /** \n * Three services are deployed in the default namespace. We do not configure any explicit namespace and \u0027default\u0027 must be picked-up.\n */\n  @Test @Order(1) void testSimple() throws Exception {\n    util.busybox(NAMESPACE,Phase.CREATE);\n    String[] both\u003dK3S.execInContainer(\"sh\",\"-c\",\"kubectl get pods -l app\u003dbusybox -o\u003dname --no-headers\").getStdout().split(\"\\n\");\n    K3S.execInContainer(\"sh\",\"-c\",\"kubectl label pods \" + both[0].split(\"/\")[1] + \" custom-label\u003dcustom-label-value\");\n    K3S.execInContainer(\"sh\",\"-c\",\"kubectl annotate pods \" + both[1].split(\"/\")[1] + \" custom-annotation\u003dcustom-annotation-value\");\n    Commons.waitForLogStatement(\"serviceSharedInformer will use namespace : default\",K3S,IMAGE_NAME);\n    WebClient servicesClient\u003dbuilder().baseUrl(\"http://localhost/services\").build();\n    List\u003cString\u003e servicesResult\u003dservicesClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cString\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(servicesResult.size(),4);\n    Assertions.assertTrue(servicesResult.contains(\"kubernetes\"));\n    Assertions.assertTrue(servicesResult.contains(\"spring-cloud-kubernetes-k8s-client-discovery\"));\n    Assertions.assertTrue(servicesResult.contains(\"busybox-service\"));\n    Assertions.assertTrue(servicesResult.contains(\"external-name-service\"));\n    WebClient ourServiceClient\u003dbuilder().baseUrl(\"http://localhost/service-instances/spring-cloud-kubernetes-k8s-client-discovery\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e ourServiceInstances\u003dourServiceClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(ourServiceInstances.size(),1);\n    DefaultKubernetesServiceInstance serviceInstance\u003dourServiceInstances.get(0);\n    Assertions.assertNotNull(serviceInstance.getInstanceId());\n    Assertions.assertEquals(serviceInstance.getServiceId(),\"spring-cloud-kubernetes-k8s-client-discovery\");\n    Assertions.assertNotNull(serviceInstance.getHost());\n    Assertions.assertEquals(serviceInstance.getMetadata(),Map.of(\"app\",\"spring-cloud-kubernetes-k8s-client-discovery\",\"custom-spring-k8s\",\"spring-k8s\",\"port.http\",\"8080\",\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\"));\n    Assertions.assertEquals(serviceInstance.getPort(),8080);\n    Assertions.assertEquals(serviceInstance.getNamespace(),\"default\");\n    WebClient busyBoxServiceClient\u003dbuilder().baseUrl(\"http://localhost/service-instances/busybox-service\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e busyBoxServiceInstances\u003dbusyBoxServiceClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(busyBoxServiceInstances.size(),2);\n    DefaultKubernetesServiceInstance withCustomLabel\u003dbusyBoxServiceInstances.stream().filter(x -\u003e x.podMetadata().getOrDefault(\"annotations\",Map.of()).isEmpty()).toList().get(0);\n    Assertions.assertEquals(withCustomLabel.getServiceId(),\"busybox-service\");\n    Assertions.assertNotNull(withCustomLabel.getInstanceId());\n    Assertions.assertNotNull(withCustomLabel.getHost());\n    Assertions.assertEquals(withCustomLabel.getMetadata(),Map.of(\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\",\"port.busybox-port\",\"80\"));\n    Assertions.assertTrue(withCustomLabel.podMetadata().get(\"labels\").entrySet().stream().anyMatch(x -\u003e x.getKey().equals(\"custom-label\") \u0026\u0026 x.getValue().equals(\"custom-label-value\")));\n    DefaultKubernetesServiceInstance withCustomAnnotation\u003dbusyBoxServiceInstances.stream().filter(x -\u003e !x.podMetadata().getOrDefault(\"annotations\",Map.of()).isEmpty()).toList().get(0);\n    Assertions.assertEquals(withCustomAnnotation.getServiceId(),\"busybox-service\");\n    Assertions.assertNotNull(withCustomAnnotation.getInstanceId());\n    Assertions.assertNotNull(withCustomAnnotation.getHost());\n    Assertions.assertEquals(withCustomAnnotation.getMetadata(),Map.of(\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\",\"port.busybox-port\",\"80\"));\n    Assertions.assertTrue(withCustomAnnotation.podMetadata().get(\"annotations\").entrySet().stream().anyMatch(x -\u003e x.getKey().equals(\"custom-annotation\") \u0026\u0026 x.getValue().equals(\"custom-annotation-value\")));\n    WebClient clientForNonExistentService\u003dbuilder().baseUrl(\"http://localhost/service-instances/non-existent\").build();\n    List\u003cServiceInstance\u003e resultForNonExistentService\u003dclientForNonExistentService.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(resultForNonExistentService.size(),0);\n    util.busybox(NAMESPACE,Phase.DELETE);\n  }\n  /** \n * \u003cpre\u003e - config server is enabled for all namespaces - wiremock service is deployed in namespace-a - busybox service is deployed in namespace-b - external-name-service is deployed in namespace \"default\" and such a service type is requested, thus found also. Our discovery searches in all namespaces, thus finds them both. \u003c/pre\u003e\n */\n  @Test @Order(2) void testAllNamespaces(){\n    util.createNamespace(NAMESPACE_A);\n    util.createNamespace(NAMESPACE_B);\n    util.setUpClusterWideClusterRoleBinding(NAMESPACE);\n    util.wiremock(NAMESPACE_A,\"/wiremock\",Phase.CREATE,false);\n    util.busybox(NAMESPACE_B,Phase.CREATE);\n    KubernetesClientDiscoveryClientUtils.patchForAllNamespaces(DEPLOYMENT_NAME,NAMESPACE);\n    Commons.waitForLogStatement(\"serviceSharedInformer will use all-namespaces\",K3S,IMAGE_NAME);\n    WebClient servicesClient\u003dbuilder().baseUrl(\"http://localhost/services\").build();\n    List\u003cString\u003e servicesResult\u003dservicesClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cString\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(servicesResult.size(),8);\n    Assertions.assertTrue(servicesResult.contains(\"kubernetes\"));\n    Assertions.assertTrue(servicesResult.contains(\"spring-cloud-kubernetes-k8s-client-discovery\"));\n    Assertions.assertTrue(servicesResult.contains(\"busybox-service\"));\n    Assertions.assertTrue(servicesResult.contains(\"service-wiremock\"));\n    Assertions.assertTrue(servicesResult.contains(\"external-name-service\"));\n    WebClient clientForNonExistentService\u003dbuilder().baseUrl(\"http://localhost/service-instances/non-existent\").build();\n    List\u003cServiceInstance\u003e resultForNonExistentService\u003dclientForNonExistentService.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(resultForNonExistentService.size(),0);\n    WebClient externalNameClient\u003dbuilder().baseUrl(\"http://localhost/service-instances/external-name-service\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e externalNameServices\u003dexternalNameClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    DefaultKubernetesServiceInstance externalNameService\u003dexternalNameServices.get(0);\n    Assertions.assertNotNull(externalNameService.getInstanceId());\n    Assertions.assertEquals(externalNameService.getHost(),\"spring.io\");\n    Assertions.assertEquals(externalNameService.getPort(),-1);\n    Assertions.assertEquals(externalNameService.getMetadata(),Map.of(\"k8s_namespace\",\"default\",\"type\",\"ExternalName\"));\n    Assertions.assertFalse(externalNameService.isSecure());\n    Assertions.assertEquals(externalNameService.getUri().toASCIIString(),\"spring.io\");\n    Assertions.assertEquals(externalNameService.getScheme(),\"http\");\n    util.busybox(NAMESPACE_B,Phase.DELETE);\n    util.deleteClusterWideClusterRoleBinding(NAMESPACE);\n  }\n  /** \n * \u003cpre\u003e - config server is enabled for namespace-a - wiremock service is deployed in namespace-a - wiremock service is deployed in namespace-b Only service in namespace-a is found. \u003c/pre\u003e\n */\n  @Test @Order(3) void testSpecificNamespace(){\n    util.setUpClusterWide(NAMESPACE,Set.of(NAMESPACE,NAMESPACE_A));\n    util.wiremock(NAMESPACE_B,\"/wiremock\",Phase.CREATE,false);\n    KubernetesClientDiscoveryClientUtils.patchForSingleNamespace(DEPLOYMENT_NAME,NAMESPACE);\n    assertServicePresentInNamespaces(List.of(\"a\",\"b\"),\"service-wiremock\",\"service-wiremock\");\n    Commons.waitForLogStatement(\"using selective namespaces : [a]\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"reading pod in namespace : default\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for services) in namespace : a\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for endpoints) in namespace : a\",K3S,IMAGE_NAME);\n    WebClient servicesClient\u003dbuilder().baseUrl(\"http://localhost/services\").build();\n    List\u003cString\u003e servicesResult\u003dservicesClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cString\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(servicesResult.size(),1);\n    Assertions.assertTrue(servicesResult.contains(\"service-wiremock\"));\n    WebClient wiremockInNamespaceAClient\u003dbuilder().baseUrl(\"http://localhost/service-instances/service-wiremock\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e wiremockInNamespaceA\u003dwiremockInNamespaceAClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(wiremockInNamespaceA.size(),1);\n    DefaultKubernetesServiceInstance serviceInstance\u003dwiremockInNamespaceA.get(0);\n    Assertions.assertEquals(serviceInstance.getNamespace(),\"a\");\n    WebClient clientForNonExistentService\u003dbuilder().baseUrl(\"http://localhost/service-instances/non-existent\").build();\n    List\u003cServiceInstance\u003e resultForNonExistentService\u003dclientForNonExistentService.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(resultForNonExistentService.size(),0);\n    util.wiremock(NAMESPACE_A,\"/wiremock\",Phase.DELETE,false);\n    util.wiremock(NAMESPACE_B,\"/wiremock\",Phase.DELETE,false);\n    util.deleteClusterWide(NAMESPACE,Set.of(NAMESPACE,NAMESPACE_A));\n    util.deleteNamespace(NAMESPACE_A);\n    util.deleteNamespace(NAMESPACE_B);\n  }\n  @Test @Order(4) void testSimplePodMetadata(){\n    util.setUp(NAMESPACE);\n    String imageName\u003d\"docker.io/springcloud/spring-cloud-kubernetes-k8s-client-discovery:\" + Commons.pomVersion();\n    KubernetesClientDiscoveryClientUtils.patchForPodMetadata(imageName,DEPLOYMENT_NAME,NAMESPACE);\n    new KubernetesClientDiscoveryPodMetadataITDelegate().testSimple();\n  }\n  @Test @Order(5) void filterMatchesOneNamespaceViaThePredicate(){\n    String imageName\u003d\"docker.io/springcloud/spring-cloud-kubernetes-k8s-client-discovery:\" + Commons.pomVersion();\n    KubernetesClientDiscoveryClientUtils.patchForUATNamespacesTests(imageName,DEPLOYMENT_NAME,NAMESPACE);\n    new KubernetesClientDiscoveryFilterITDelegate().filterMatchesOneNamespaceViaThePredicate(util);\n  }\n  /** \n * \u003cpre\u003e - service \"wiremock\" is present in namespace \"a-uat\" - service \"wiremock\" is present in namespace \"b-uat\" - we search with a predicate : \"#root.metadata.namespace matches \u0027^uat.*$\u0027\" As such, both services are found via \u0027getInstances\u0027 call. \u003c/pre\u003e\n */\n  @Test @Order(6) void filterMatchesBothNamespacesViaThePredicate(){\n    KubernetesClientDiscoveryClientUtils.patchForTwoNamespacesMatchViaThePredicate(DEPLOYMENT_NAME,NAMESPACE);\n    new KubernetesClientDiscoveryFilterITDelegate().filterMatchesBothNamespacesViaThePredicate();\n  }\n  @Test @Order(7) void testBlockingConfiguration(){\n    deleteNamespacesAndWiremock();\n    String imageName\u003d\"docker.io/springcloud/spring-cloud-kubernetes-k8s-client-discovery:\" + Commons.pomVersion();\n    KubernetesClientDiscoveryClientUtils.patchForBlockingHealth(imageName,DEPLOYMENT_NAME,NAMESPACE);\n    new KubernetesClientDiscoveryHealthITDelegate().testBlockingConfiguration(K3S);\n  }\n  @Test @Order(8) void testReactiveConfiguration(){\n    KubernetesClientDiscoveryClientUtils.patchForReactiveHealth(DEPLOYMENT_NAME,NAMESPACE);\n    new KubernetesClientDiscoveryHealthITDelegate().testReactiveConfiguration(K3S);\n  }\n  @Test @Order(9) void testDefaultConfiguration(){\n    KubernetesClientDiscoveryClientUtils.patchForBlockingAndReactiveHealth(DEPLOYMENT_NAME,NAMESPACE);\n    new KubernetesClientDiscoveryHealthITDelegate().testDefaultConfiguration(K3S);\n  }\n  private void deleteNamespacesAndWiremock(){\n    util.wiremock(NAMESPACE_A_UAT,\"/wiremock\",Phase.DELETE,false);\n    util.wiremock(NAMESPACE_B_UAT,\"/wiremock\",Phase.DELETE,false);\n    util.deleteNamespace(NAMESPACE_A_UAT);\n    util.deleteNamespace(NAMESPACE_B_UAT);\n  }\n  private static void manifests(  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"kubernetes-discovery-deployment.yaml\");\n    V1Service service\u003d(V1Service)util.yaml(\"kubernetes-discovery-service.yaml\");\n    V1Service externalNameService\u003d(V1Service)util.yaml(\"external-name-service.yaml\");\n    V1Ingress ingress\u003d(V1Ingress)util.yaml(\"kubernetes-discovery-ingress.yaml\");\n    if (phase.equals(Phase.DELETE)) {\n      util.deleteAndWait(NAMESPACE,deployment,service,ingress);\n      util.deleteAndWait(NAMESPACE,null,externalNameService,null);\n      return;\n    }\n    if (phase.equals(Phase.CREATE)) {\n      List\u003cV1EnvVar\u003e envVars\u003dnew ArrayList\u003c\u003e(Optional.ofNullable(deployment.getSpec().getTemplate().getSpec().getContainers().get(0).getEnv()).orElse(List.of()));\n      V1EnvVar debugLevel\u003dnew V1EnvVar().name(\"LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_CLOUD_KUBERNETES_CLIENT_DISCOVERY\").value(\"DEBUG\");\n      V1EnvVar commonsLevel\u003dnew V1EnvVar().name(\"LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_CLOUD_KUBERNETES_COMMONS_DISCOVERY\").value(\"DEBUG\");\n      V1EnvVar debugLevelForClient\u003dnew V1EnvVar().name(\"LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_CLOUD_KUBERNETES_CLIENT\").value(\"DEBUG\");\n      V1EnvVar addLabels\u003dnew V1EnvVar().name(\"SPRING_CLOUD_KUBERNETES_DISCOVERY_METADATA_ADDPODLABELS\").value(\"TRUE\");\n      V1EnvVar addAnnotations\u003dnew V1EnvVar().name(\"SPRING_CLOUD_KUBERNETES_DISCOVERY_METADATA_ADDPODANNOTATIONS\").value(\"TRUE\");\n      envVars.add(debugLevel);\n      envVars.add(debugLevelForClient);\n      envVars.add(addLabels);\n      envVars.add(addAnnotations);\n      envVars.add(commonsLevel);\n      deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setEnv(envVars);\n      util.createAndWait(NAMESPACE,null,deployment,service,ingress,true);\n      util.createAndWait(NAMESPACE,null,null,externalNameService,null,true);\n    }\n  }\n  private WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n  private void assertServicePresentInNamespaces(  List\u003cString\u003e namespaces,  String value,  String serviceName){\n    namespaces.forEach(x -\u003e {\n      try {\n        String service\u003dK3S.execInContainer(\"sh\",\"-c\",\"kubectl get services -n \" + x + \" -l app\u003d\"+ value+ \" -o\u003dname --no-headers | tr -d \u0027\\n\u0027\").getStdout();\n        Assertions.assertEquals(service,\"service/\" + serviceName);\n      }\n catch (      Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class) class KubernetesClientDiscoveryClientIT {\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String NAMESPACE_A\u003d\"a\";\n  private static final String NAMESPACE_B\u003d\"b\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  private static final String DEPLOYMENT_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  private static final String NAMESPACE_A_UAT\u003d\"a-uat\";\n  private static final String NAMESPACE_B_UAT\u003d\"b-uat\";\n  private static Util util;\n  private static final K3sContainer K3S\u003dCommons.container();\n  @BeforeAll static void beforeAll() throws Exception;\n  @AfterAll static void afterAll() throws Exception;\n  /** \n * Three services are deployed in the default namespace. We do not configure any explicit namespace and \u0027default\u0027 must be picked-up.\n */\n  @Test @Order(1) void testSimple() throws Exception;\n  /** \n * \u003cpre\u003e - config server is enabled for all namespaces - wiremock service is deployed in namespace-a - busybox service is deployed in namespace-b - external-name-service is deployed in namespace \"default\" and such a service type is requested, thus found also. Our discovery searches in all namespaces, thus finds them both. \u003c/pre\u003e\n */\n  @Test @Order(2) void testAllNamespaces();\n  /** \n * \u003cpre\u003e - config server is enabled for namespace-a - wiremock service is deployed in namespace-a - wiremock service is deployed in namespace-b Only service in namespace-a is found. \u003c/pre\u003e\n */\n  @Test @Order(3) void testSpecificNamespace();\n  @Test @Order(4) void testSimplePodMetadata();\n  @Test @Order(5) void filterMatchesOneNamespaceViaThePredicate();\n  /** \n * \u003cpre\u003e - service \"wiremock\" is present in namespace \"a-uat\" - service \"wiremock\" is present in namespace \"b-uat\" - we search with a predicate : \"#root.metadata.namespace matches \u0027^uat.*$\u0027\" As such, both services are found via \u0027getInstances\u0027 call. \u003c/pre\u003e\n */\n  @Test @Order(6) void filterMatchesBothNamespacesViaThePredicate();\n  @Test @Order(7) void testBlockingConfiguration();\n  @Test @Order(8) void testReactiveConfiguration();\n  @Test @Order(9) void testDefaultConfiguration();\n  private void deleteNamespacesAndWiremock();\n  private static void manifests(  Phase phase);\n  private WebClient.Builder builder();\n  private RetryBackoffSpec retrySpec();\n  private void assertServicePresentInNamespaces(  List\u003cString\u003e namespaces,  String value,  String serviceName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery/src/test/java/org/springframework/cloud/kubernetes/k8s/client/discovery/KubernetesClientDiscoveryClientUtils.java",
        "name": "KubernetesClientDiscoveryClientUtils",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.discovery.KubernetesClientDiscoveryClientUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class KubernetesClientDiscoveryClientUtils {\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-cloud-kubernetes-k8s-client-discovery\");\n  private static final String BODY_ONE\u003dnull;\n  private static final String BODY_TWO\u003dnull;\n  private static final String BODY_THREE\u003dnull;\n  private static final String BODY_FOUR\u003dnull;\n  private static final String BODY_FIVE\u003dnull;\n  private static final String BODY_SIX\u003dnull;\n  private static final String BODY_SEVEN\u003dnull;\n  private static final String BODY_EIGHT\u003dnull;\n  private static final String BODY_NINE\u003dnull;\n  private static final String BODY_TEN\u003dnull;\n  private static final String BODY_ELEVEN\u003dnull;\n  private static final String BODY_TWELVE\u003dnull;\n  private KubernetesClientDiscoveryClientUtils(){\n  }\n  static void patchForTwoNamespacesMatchViaThePredicate(  String deploymentName,  String namespace){\n    patchWithMerge(deploymentName,namespace,BODY_ONE,POD_LABELS);\n  }\n  static void patchForReactiveHealth(  String deploymentName,  String namespace){\n    patchWithMerge(deploymentName,namespace,BODY_TWO,POD_LABELS);\n  }\n  static void patchForBlockingAndReactiveHealth(  String deploymentName,  String namespace){\n    patchWithMerge(deploymentName,namespace,BODY_THREE,POD_LABELS);\n  }\n  static void patchForBlockingHealth(  String image,  String deploymentName,  String namespace){\n    patchWithReplace(image,deploymentName,namespace,BODY_FOUR,POD_LABELS);\n  }\n  static void patchForAllNamespaces(  String deploymentName,  String namespace){\n    patchWithMerge(deploymentName,namespace,BODY_FIVE,POD_LABELS);\n  }\n  static void patchForSingleNamespace(  String deploymentName,  String namespace){\n    patchWithMerge(deploymentName,namespace,BODY_SIX,POD_LABELS);\n  }\n  static void patchForPodMetadata(  String imageName,  String deploymentName,  String namespace){\n    patchWithReplace(imageName,deploymentName,namespace,BODY_SEVEN,POD_LABELS);\n  }\n  static void patchForReactiveOnly(  String deploymentName,  String namespace){\n    patchWithMerge(deploymentName,namespace,BODY_EIGHT,POD_LABELS);\n  }\n  static void patchForBlockingAndReactive(  String deploymentName,  String namespace){\n    patchWithMerge(deploymentName,namespace,BODY_NINE,POD_LABELS);\n  }\n  static void patchForTwoNamespacesBlockingOnly(  String deploymentName,  String namespace){\n    patchWithMerge(deploymentName,namespace,BODY_TEN,POD_LABELS);\n  }\n  static void patchToAddBlockingSupport(  String deploymentName,  String namespace){\n    patchWithMerge(deploymentName,namespace,BODY_ELEVEN,POD_LABELS);\n  }\n  static void patchForUATNamespacesTests(  String image,  String deploymentName,  String namespace){\n    patchWithReplace(image,deploymentName,namespace,BODY_TWELVE,POD_LABELS);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class KubernetesClientDiscoveryClientUtils {\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-cloud-kubernetes-k8s-client-discovery\");\n  private static final String BODY_ONE\u003dnull;\n  private static final String BODY_TWO\u003dnull;\n  private static final String BODY_THREE\u003dnull;\n  private static final String BODY_FOUR\u003dnull;\n  private static final String BODY_FIVE\u003dnull;\n  private static final String BODY_SIX\u003dnull;\n  private static final String BODY_SEVEN\u003dnull;\n  private static final String BODY_EIGHT\u003dnull;\n  private static final String BODY_NINE\u003dnull;\n  private static final String BODY_TEN\u003dnull;\n  private static final String BODY_ELEVEN\u003dnull;\n  private static final String BODY_TWELVE\u003dnull;\n  private KubernetesClientDiscoveryClientUtils();\n  static void patchForTwoNamespacesMatchViaThePredicate(  String deploymentName,  String namespace);\n  static void patchForReactiveHealth(  String deploymentName,  String namespace);\n  static void patchForBlockingAndReactiveHealth(  String deploymentName,  String namespace);\n  static void patchForBlockingHealth(  String image,  String deploymentName,  String namespace);\n  static void patchForAllNamespaces(  String deploymentName,  String namespace);\n  static void patchForSingleNamespace(  String deploymentName,  String namespace);\n  static void patchForPodMetadata(  String imageName,  String deploymentName,  String namespace);\n  static void patchForReactiveOnly(  String deploymentName,  String namespace);\n  static void patchForBlockingAndReactive(  String deploymentName,  String namespace);\n  static void patchForTwoNamespacesBlockingOnly(  String deploymentName,  String namespace);\n  static void patchToAddBlockingSupport(  String deploymentName,  String namespace);\n  static void patchForUATNamespacesTests(  String image,  String deploymentName,  String namespace);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery/src/test/java/org/springframework/cloud/kubernetes/k8s/client/discovery/KubernetesClientDiscoverySelectiveNamespacesIT.java",
        "name": "KubernetesClientDiscoverySelectiveNamespacesIT",
        "modifiers": "@TestMethodOrder(MethodOrderer.OrderAnnotation.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.discovery.KubernetesClientDiscoverySelectiveNamespacesIT",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class) class KubernetesClientDiscoverySelectiveNamespacesIT {\n  private static final String BLOCKING_PUBLISH\u003d\"Will publish InstanceRegisteredEvent from blocking implementation\";\n  private static final String REACTIVE_PUBLISH\u003d\"Will publish InstanceRegisteredEvent from reactive implementation\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String NAMESPACE_A\u003d\"a\";\n  private static final String NAMESPACE_B\u003d\"b\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  private static final String DEPLOYMENT_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  private static Util util;\n  private static final K3sContainer K3S\u003dCommons.container();\n  @BeforeAll static void beforeAll() throws Exception {\n    K3S.start();\n    Commons.validateImage(IMAGE_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(IMAGE_NAME,K3S);\n    Images.loadWiremock(K3S);\n    util\u003dnew Util(K3S);\n    util.createNamespace(NAMESPACE_A);\n    util.createNamespace(NAMESPACE_B);\n    util.setUpClusterWide(NAMESPACE,Set.of(NAMESPACE,NAMESPACE_A,NAMESPACE_B));\n    util.wiremock(NAMESPACE,\"/wiremock\",Phase.CREATE,false);\n    util.wiremock(NAMESPACE_A,\"/wiremock\",Phase.CREATE,false);\n    util.wiremock(NAMESPACE_B,\"/wiremock\",Phase.CREATE,false);\n    manifests(Phase.CREATE);\n  }\n  @AfterAll static void afterAll() throws Exception {\n    Commons.cleanUp(IMAGE_NAME,K3S);\n    util.wiremock(NAMESPACE,\"/wiremock\",Phase.DELETE,false);\n    util.wiremock(NAMESPACE_A,\"/wiremock\",Phase.DELETE,false);\n    util.wiremock(NAMESPACE_B,\"/wiremock\",Phase.DELETE,false);\n    util.deleteClusterWide(NAMESPACE,Set.of(NAMESPACE,NAMESPACE_A,NAMESPACE_B));\n    util.deleteNamespace(NAMESPACE_A);\n    util.deleteNamespace(NAMESPACE_B);\n    manifests(Phase.DELETE);\n    Commons.systemPrune();\n  }\n  /** \n * Deploy wiremock in 3 namespaces: default, a, b. Search only in selective namespace \u0027a\u0027 with blocking enabled and reactive disabled, as such find a single service and its service instance.\n */\n  @Test @Order(1) void testOneNamespaceBlockingOnly(){\n    Commons.waitForLogStatement(\"using selective namespaces : [a]\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"ConditionalOnSelectiveNamespacesMissing : found selective namespaces : [a]\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"ConditionalOnSelectiveNamespacesPresent : found selective namespaces : [a]\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for services) in namespace : a\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for endpoints) in namespace : a\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(BLOCKING_PUBLISH,K3S,IMAGE_NAME);\n    Assertions.assertFalse(logs().contains(REACTIVE_PUBLISH));\n    blockingCheck();\n  }\n  /** \n * Deploy wiremock in 3 namespaces: default, a, b. Search only in selective namespace \u0027a\u0027 with blocking disabled and reactive enabled, as such find a single service and its service instance.\n */\n  @Test @Order(2) void testOneNamespaceReactiveOnly(){\n    KubernetesClientDiscoveryClientUtils.patchForReactiveOnly(DEPLOYMENT_NAME,NAMESPACE);\n    Commons.waitForLogStatement(\"using selective namespaces : [a]\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"ConditionalOnSelectiveNamespacesMissing : found selective namespaces : [a]\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for services) in namespace : a\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for endpoints) in namespace : a\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(REACTIVE_PUBLISH,K3S,IMAGE_NAME);\n    Assertions.assertFalse(logs().contains(BLOCKING_PUBLISH));\n    reactiveCheck();\n  }\n  /** \n * Deploy wiremock in 3 namespaces: default, a, b. Search only in selective namespace \u0027a\u0027 with blocking enabled and reactive enabled, as such find a single service and its service instance.\n */\n  @Test @Order(3) void testOneNamespaceBothBlockingAndReactive(){\n    KubernetesClientDiscoveryClientUtils.patchForBlockingAndReactive(DEPLOYMENT_NAME,NAMESPACE);\n    Commons.waitForLogStatement(\"using selective namespaces : [a]\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"ConditionalOnSelectiveNamespacesMissing : found selective namespaces : [a]\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"ConditionalOnSelectiveNamespacesPresent : found selective namespaces : [a]\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for services) in namespace : a\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for endpoints) in namespace : a\",K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(BLOCKING_PUBLISH,K3S,IMAGE_NAME);\n    Commons.waitForLogStatement(REACTIVE_PUBLISH,K3S,IMAGE_NAME);\n    blockingCheck();\n    reactiveCheck();\n  }\n  /** \n * previous test already has: \u003cpre\u003e - SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_0 \u003d a - SPRING_CLOUD_DISCOVERY_REACTIVE_ENABLED \u003d TRUE - SPRING_CLOUD_DISCOVERY_BLOCKING_ENABLED \u003d TRUE All we need to patch for is: -  add one more namespace to track, via SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_1 \u003d b - disable reactive, via SPRING_CLOUD_DISCOVERY_REACTIVE_ENABLED \u003d FALSE As such, two namespaces + blocking only, is achieved. \u003c/pre\u003e\n */\n  @Test @Order(4) void testTwoNamespacesBlockingOnly(){\n    KubernetesClientDiscoveryClientUtils.patchForTwoNamespacesBlockingOnly(DEPLOYMENT_NAME,NAMESPACE);\n    new KubernetesClientDiscoveryMultipleSelectiveNamespacesITDelegate().testTwoNamespacesBlockingOnly(K3S);\n  }\n  /** \n * previous test already has: \u003cpre\u003e - SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_0 \u003d a - SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_1 \u003d b - SPRING_CLOUD_DISCOVERY_REACTIVE_ENABLED \u003d FALSE - SPRING_CLOUD_DISCOVERY_BLOCKING_ENABLED \u003d TRUE We invert the reactive and blocking in this test via patching. As such, two namespaces + reactive only, is achieved. \u003c/pre\u003e\n */\n  @Test @Order(5) void testTwoNamespacesReactiveOnly(){\n    KubernetesClientDiscoveryClientUtils.patchForReactiveOnly(DEPLOYMENT_NAME,NAMESPACE);\n    new KubernetesClientDiscoveryMultipleSelectiveNamespacesITDelegate().testTwoNamespaceReactiveOnly(K3S);\n  }\n  /** \n * previous test already has: \u003cpre\u003e - SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_0 \u003d a - SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_1 \u003d b - SPRING_CLOUD_DISCOVERY_REACTIVE_ENABLED \u003d TRUE - SPRING_CLOUD_DISCOVERY_BLOCKING_ENABLED \u003d FALSE We invert the blocking support. As such, two namespaces + blocking and reactive, is achieved. \u003c/pre\u003e\n */\n  @Test @Order(6) void testTwoNamespacesBothBlockingAndReactive(){\n    KubernetesClientDiscoveryClientUtils.patchToAddBlockingSupport(DEPLOYMENT_NAME,NAMESPACE);\n    new KubernetesClientDiscoveryMultipleSelectiveNamespacesITDelegate().testTwoNamespacesBothBlockingAndReactive(K3S);\n  }\n  private static void manifests(  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"kubernetes-discovery-deployment.yaml\");\n    V1Service service\u003d(V1Service)util.yaml(\"kubernetes-discovery-service.yaml\");\n    V1Ingress ingress\u003d(V1Ingress)util.yaml(\"kubernetes-discovery-ingress.yaml\");\n    if (phase.equals(Phase.DELETE)) {\n      util.deleteAndWait(NAMESPACE,deployment,service,ingress);\n      return;\n    }\n    if (phase.equals(Phase.CREATE)) {\n      List\u003cV1EnvVar\u003e envVars\u003dnew ArrayList\u003c\u003e(Optional.ofNullable(deployment.getSpec().getTemplate().getSpec().getContainers().get(0).getEnv()).orElse(List.of()));\n      V1EnvVar debugLevel\u003dnew V1EnvVar().name(\"LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_CLOUD_KUBERNETES_CLIENT_DISCOVERY\").value(\"DEBUG\");\n      V1EnvVar selectiveNamespaceA\u003dnew V1EnvVar().name(\"SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_0\").value(NAMESPACE_A);\n      V1EnvVar disableReactiveEnvVar\u003dnew V1EnvVar().name(\"SPRING_CLOUD_DISCOVERY_REACTIVE_ENABLED\").value(\"FALSE\");\n      envVars.add(disableReactiveEnvVar);\n      envVars.add(debugLevel);\n      envVars.add(selectiveNamespaceA);\n      deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setEnv(envVars);\n      util.createAndWait(NAMESPACE,null,deployment,service,ingress,true);\n    }\n  }\n  private void reactiveCheck(){\n    WebClient servicesClient\u003dbuilder().baseUrl(\"http://localhost/reactive/services\").build();\n    List\u003cString\u003e servicesResult\u003dservicesClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cString\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(servicesResult.size(),1);\n    Assertions.assertTrue(servicesResult.contains(\"service-wiremock\"));\n    WebClient ourServiceClient\u003dbuilder().baseUrl(\"http://localhost/reactive/service-instances/service-wiremock\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e ourServiceInstances\u003dourServiceClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(ourServiceInstances.size(),1);\n    DefaultKubernetesServiceInstance serviceInstance\u003dourServiceInstances.get(0);\n    Assertions.assertEquals(serviceInstance.getNamespace(),\"a\");\n  }\n  private void blockingCheck(){\n    WebClient servicesClient\u003dbuilder().baseUrl(\"http://localhost/services\").build();\n    List\u003cString\u003e servicesResult\u003dservicesClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cString\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(servicesResult.size(),1);\n    Assertions.assertTrue(servicesResult.contains(\"service-wiremock\"));\n    WebClient ourServiceClient\u003dbuilder().baseUrl(\"http://localhost/service-instances/service-wiremock\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e ourServiceInstances\u003dourServiceClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(ourServiceInstances.size(),1);\n    DefaultKubernetesServiceInstance serviceInstance\u003dourServiceInstances.get(0);\n    Assertions.assertEquals(serviceInstance.getNamespace(),\"a\");\n  }\n  private String logs(){\n    try {\n      String appPodName\u003dK3S.execInContainer(\"sh\",\"-c\",\"kubectl get pods -l app\u003d\" + IMAGE_NAME + \" -o\u003dname --no-headers | tr -d \u0027\\n\u0027\").getStdout();\n      Container.ExecResult execResult\u003dK3S.execInContainer(\"sh\",\"-c\",\"kubectl logs \" + appPodName.trim());\n      return execResult.getStdout();\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n  private WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class) class KubernetesClientDiscoverySelectiveNamespacesIT {\n  private static final String BLOCKING_PUBLISH\u003d\"Will publish InstanceRegisteredEvent from blocking implementation\";\n  private static final String REACTIVE_PUBLISH\u003d\"Will publish InstanceRegisteredEvent from reactive implementation\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String NAMESPACE_A\u003d\"a\";\n  private static final String NAMESPACE_B\u003d\"b\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  private static final String DEPLOYMENT_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  private static Util util;\n  private static final K3sContainer K3S\u003dCommons.container();\n  @BeforeAll static void beforeAll() throws Exception;\n  @AfterAll static void afterAll() throws Exception;\n  /** \n * Deploy wiremock in 3 namespaces: default, a, b. Search only in selective namespace \u0027a\u0027 with blocking enabled and reactive disabled, as such find a single service and its service instance.\n */\n  @Test @Order(1) void testOneNamespaceBlockingOnly();\n  /** \n * Deploy wiremock in 3 namespaces: default, a, b. Search only in selective namespace \u0027a\u0027 with blocking disabled and reactive enabled, as such find a single service and its service instance.\n */\n  @Test @Order(2) void testOneNamespaceReactiveOnly();\n  /** \n * Deploy wiremock in 3 namespaces: default, a, b. Search only in selective namespace \u0027a\u0027 with blocking enabled and reactive enabled, as such find a single service and its service instance.\n */\n  @Test @Order(3) void testOneNamespaceBothBlockingAndReactive();\n  /** \n * previous test already has: \u003cpre\u003e - SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_0 \u003d a - SPRING_CLOUD_DISCOVERY_REACTIVE_ENABLED \u003d TRUE - SPRING_CLOUD_DISCOVERY_BLOCKING_ENABLED \u003d TRUE All we need to patch for is: -  add one more namespace to track, via SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_1 \u003d b - disable reactive, via SPRING_CLOUD_DISCOVERY_REACTIVE_ENABLED \u003d FALSE As such, two namespaces + blocking only, is achieved. \u003c/pre\u003e\n */\n  @Test @Order(4) void testTwoNamespacesBlockingOnly();\n  /** \n * previous test already has: \u003cpre\u003e - SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_0 \u003d a - SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_1 \u003d b - SPRING_CLOUD_DISCOVERY_REACTIVE_ENABLED \u003d FALSE - SPRING_CLOUD_DISCOVERY_BLOCKING_ENABLED \u003d TRUE We invert the reactive and blocking in this test via patching. As such, two namespaces + reactive only, is achieved. \u003c/pre\u003e\n */\n  @Test @Order(5) void testTwoNamespacesReactiveOnly();\n  /** \n * previous test already has: \u003cpre\u003e - SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_0 \u003d a - SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_1 \u003d b - SPRING_CLOUD_DISCOVERY_REACTIVE_ENABLED \u003d TRUE - SPRING_CLOUD_DISCOVERY_BLOCKING_ENABLED \u003d FALSE We invert the blocking support. As such, two namespaces + blocking and reactive, is achieved. \u003c/pre\u003e\n */\n  @Test @Order(6) void testTwoNamespacesBothBlockingAndReactive();\n  private static void manifests(  Phase phase);\n  private void reactiveCheck();\n  private void blockingCheck();\n  private String logs();\n  private WebClient.Builder builder();\n  private RetryBackoffSpec retrySpec();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery/src/test/java/org/springframework/cloud/kubernetes/k8s/client/discovery/KubernetesClientDiscoveryMultipleSelectiveNamespacesITDelegate.java",
        "name": "KubernetesClientDiscoveryMultipleSelectiveNamespacesITDelegate",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.discovery.KubernetesClientDiscoveryMultipleSelectiveNamespacesITDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesClientDiscoveryMultipleSelectiveNamespacesITDelegate {\n  private static final String BLOCKING_PUBLISH\u003d\"Will publish InstanceRegisteredEvent from blocking implementation\";\n  private static final String REACTIVE_PUBLISH\u003d\"Will publish InstanceRegisteredEvent from reactive implementation\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  /** \n * Deploy wiremock in 3 namespaces: default, a, b. Search in selective namespaces \u0027a\u0027 and \u0027b\u0027 with blocking enabled and reactive disabled, as such find services and it\u0027s instances.\n */\n  void testTwoNamespacesBlockingOnly(  K3sContainer container){\n    Commons.waitForLogStatement(\"using selective namespaces : [a, b]\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"ConditionalOnSelectiveNamespacesMissing : found selective namespaces : [a, b]\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"ConditionalOnSelectiveNamespacesMissing : found selective namespaces : [a, b]\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"ConditionalOnSelectiveNamespacesPresent : found selective namespaces : [a, b]\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for services) in namespace : a\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for services) in namespace : b\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for endpoints) in namespace : a\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for endpoints) in namespace : b\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(BLOCKING_PUBLISH,container,IMAGE_NAME);\n    Assertions.assertFalse(logs(container).contains(REACTIVE_PUBLISH));\n    blockingCheck();\n  }\n  /** \n * Deploy wiremock in 3 namespaces: default, a, b. Search in selective namespaces \u0027a\u0027 and \u0027b\u0027 with blocking disabled and reactive enabled, as such find services and it\u0027s instances.\n */\n  void testTwoNamespaceReactiveOnly(  K3sContainer container){\n    Commons.waitForLogStatement(\"using selective namespaces : [a, b]\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"ConditionalOnSelectiveNamespacesMissing : found selective namespaces : [a, b]\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"ConditionalOnSelectiveNamespacesPresent : found selective namespaces : [a, b]\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for services) in namespace : a\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for services) in namespace : b\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for endpoints) in namespace : a\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for endpoints) in namespace : b\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(REACTIVE_PUBLISH,container,IMAGE_NAME);\n    Assertions.assertFalse(logs(container).contains(BLOCKING_PUBLISH));\n    reactiveCheck();\n  }\n  /** \n * Deploy wiremock in 3 namespaces: default, a, b. Search in selective namespaces \u0027a\u0027 and \u0027b\u0027 with blocking enabled and reactive enabled, as such find services and its service instances.\n */\n  void testTwoNamespacesBothBlockingAndReactive(  K3sContainer container){\n    Commons.waitForLogStatement(\"using selective namespaces : [a, b]\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"ConditionalOnSelectiveNamespacesMissing : found selective namespaces : [a, b]\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"ConditionalOnSelectiveNamespacesPresent : found selective namespaces : [a, b]\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for services) in namespace : a\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for services) in namespace : b\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for endpoints) in namespace : a\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(\"registering lister (for endpoints) in namespace : b\",container,IMAGE_NAME);\n    Commons.waitForLogStatement(BLOCKING_PUBLISH,container,IMAGE_NAME);\n    Assertions.assertTrue(logs(container).contains(REACTIVE_PUBLISH));\n    blockingCheck();\n    reactiveCheck();\n  }\n  private String logs(  K3sContainer container){\n    try {\n      String appPodName\u003dcontainer.execInContainer(\"sh\",\"-c\",\"kubectl get pods -l app\u003d\" + IMAGE_NAME + \" -o\u003dname --no-headers | tr -d \u0027\\n\u0027\").getStdout();\n      Container.ExecResult execResult\u003dcontainer.execInContainer(\"sh\",\"-c\",\"kubectl logs \" + appPodName.trim());\n      return execResult.getStdout();\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n  private void reactiveCheck(){\n    WebClient servicesClient\u003dbuilder().baseUrl(\"http://localhost/reactive/services\").build();\n    List\u003cString\u003e servicesResult\u003dservicesClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cString\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(servicesResult.size(),1);\n    Assertions.assertTrue(servicesResult.contains(\"service-wiremock\"));\n    WebClient ourServiceClient\u003dbuilder().baseUrl(\"http://localhost/reactive/service-instances/service-wiremock\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e ourServiceInstances\u003dourServiceClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(ourServiceInstances.size(),2);\n    ourServiceInstances\u003dourServiceInstances.stream().sorted(Comparator.comparing(DefaultKubernetesServiceInstance::namespace)).toList();\n    DefaultKubernetesServiceInstance serviceInstanceA\u003dourServiceInstances.get(0);\n    Assertions.assertEquals(serviceInstanceA.getNamespace(),\"a\");\n    DefaultKubernetesServiceInstance serviceInstanceB\u003dourServiceInstances.get(1);\n    Assertions.assertEquals(serviceInstanceB.getNamespace(),\"b\");\n  }\n  private void blockingCheck(){\n    WebClient servicesClient\u003dbuilder().baseUrl(\"http://localhost/services\").build();\n    List\u003cString\u003e servicesResult\u003dservicesClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cString\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(servicesResult.size(),1);\n    Assertions.assertTrue(servicesResult.contains(\"service-wiremock\"));\n    WebClient ourServiceClient\u003dbuilder().baseUrl(\"http://localhost/service-instances/service-wiremock\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e ourServiceInstances\u003dourServiceClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(ourServiceInstances.size(),2);\n    ourServiceInstances\u003dourServiceInstances.stream().sorted(Comparator.comparing(DefaultKubernetesServiceInstance::namespace)).toList();\n    DefaultKubernetesServiceInstance serviceInstanceA\u003dourServiceInstances.get(0);\n    Assertions.assertEquals(serviceInstanceA.getNamespace(),\"a\");\n    DefaultKubernetesServiceInstance serviceInstanceB\u003dourServiceInstances.get(1);\n    Assertions.assertEquals(serviceInstanceB.getNamespace(),\"b\");\n  }\n  private WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesClientDiscoveryMultipleSelectiveNamespacesITDelegate {\n  private static final String BLOCKING_PUBLISH\u003d\"Will publish InstanceRegisteredEvent from blocking implementation\";\n  private static final String REACTIVE_PUBLISH\u003d\"Will publish InstanceRegisteredEvent from reactive implementation\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery\";\n  /** \n * Deploy wiremock in 3 namespaces: default, a, b. Search in selective namespaces \u0027a\u0027 and \u0027b\u0027 with blocking enabled and reactive disabled, as such find services and it\u0027s instances.\n */\n  void testTwoNamespacesBlockingOnly(  K3sContainer container);\n  /** \n * Deploy wiremock in 3 namespaces: default, a, b. Search in selective namespaces \u0027a\u0027 and \u0027b\u0027 with blocking disabled and reactive enabled, as such find services and it\u0027s instances.\n */\n  void testTwoNamespaceReactiveOnly(  K3sContainer container);\n  /** \n * Deploy wiremock in 3 namespaces: default, a, b. Search in selective namespaces \u0027a\u0027 and \u0027b\u0027 with blocking enabled and reactive enabled, as such find services and its service instances.\n */\n  void testTwoNamespacesBothBlockingAndReactive(  K3sContainer container);\n  private String logs(  K3sContainer container);\n  private void reactiveCheck();\n  private void blockingCheck();\n  private WebClient.Builder builder();\n  private RetryBackoffSpec retrySpec();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery/src/test/java/org/springframework/cloud/kubernetes/k8s/client/discovery/KubernetesClientDiscoveryPodMetadataITDelegate.java",
        "name": "KubernetesClientDiscoveryPodMetadataITDelegate",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.k8s.client.discovery.KubernetesClientDiscoveryPodMetadataITDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesClientDiscoveryPodMetadataITDelegate {\n  /** \n * Three services are deployed in the default namespace. We do not configure any explicit namespace and \u0027default\u0027 must be picked-up.\n */\n  void testSimple(){\n    WebClient servicesClient\u003dbuilder().baseUrl(\"http://localhost/services\").build();\n    List\u003cString\u003e servicesResult\u003dservicesClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cString\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(servicesResult.size(),3);\n    Assertions.assertTrue(servicesResult.contains(\"kubernetes\"));\n    Assertions.assertTrue(servicesResult.contains(\"spring-cloud-kubernetes-k8s-client-discovery\"));\n    Assertions.assertTrue(servicesResult.contains(\"external-name-service\"));\n    WebClient ourServiceClient\u003dbuilder().baseUrl(\"http://localhost//service-instances/spring-cloud-kubernetes-k8s-client-discovery\").build();\n    List\u003cDefaultKubernetesServiceInstance\u003e ourServiceInstances\u003dourServiceClient.method(HttpMethod.GET).retrieve().bodyToMono(new ParameterizedTypeReference\u003cList\u003cDefaultKubernetesServiceInstance\u003e\u003e(){\n    }\n).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(ourServiceInstances.size(),1);\n    DefaultKubernetesServiceInstance serviceInstance\u003dourServiceInstances.get(0);\n    Assertions.assertNotNull(serviceInstance.getInstanceId());\n    Assertions.assertEquals(serviceInstance.getServiceId(),\"spring-cloud-kubernetes-k8s-client-discovery\");\n    Assertions.assertNotNull(serviceInstance.getHost());\n    Assertions.assertEquals(serviceInstance.getMetadata(),Map.of(\"port.http\",\"8080\",\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\",\"label-app\",\"spring-cloud-kubernetes-k8s-client-discovery\",\"annotation-custom-spring-k8s\",\"spring-k8s\"));\n    Assertions.assertEquals(serviceInstance.getPort(),8080);\n    Assertions.assertEquals(serviceInstance.getNamespace(),\"default\");\n  }\n  private WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesClientDiscoveryPodMetadataITDelegate {\n  /** \n * Three services are deployed in the default namespace. We do not configure any explicit namespace and \u0027default\u0027 must be picked-up.\n */\n  void testSimple();\n  private WebClient.Builder builder();\n  private RetryBackoffSpec retrySpec();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery-server/src/main/java/org/springframework/cloud/kubernetes/discoveryclient/it/KubernetesDiscoveryClientApplicationIt.java",
        "name": "KubernetesDiscoveryClientApplicationIt",
        "modifiers": "@SpringBootApplication @EnableScheduling @RestController",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryclient.it.KubernetesDiscoveryClientApplicationIt",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootApplication @EnableScheduling @RestController class KubernetesDiscoveryClientApplicationIt {\n  private final DiscoveryClient discoveryClient;\n  private final HeartbeatListener heartbeatListener;\n  KubernetesDiscoveryClientApplicationIt(  DiscoveryClient discoveryClient,  HeartbeatListener heartbeatListener){\n    this.discoveryClient\u003ddiscoveryClient;\n    this.heartbeatListener\u003dheartbeatListener;\n  }\n  public static void main(  String[] args){\n    SpringApplication.run(KubernetesDiscoveryClientApplicationIt.class,args);\n  }\n  @GetMapping(\"/services\") List\u003cString\u003e services(){\n    return discoveryClient.getServices();\n  }\n  @GetMapping(\"/service/{serviceId}\") List\u003cServiceInstance\u003e service(  @PathVariable String serviceId){\n    return discoveryClient.getInstances(serviceId);\n  }\n  @GetMapping(\"/state\") List\u003cEndpointNameAndNamespace\u003e state(){\n    return heartbeatListener.state.get();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootApplication @EnableScheduling @RestController class KubernetesDiscoveryClientApplicationIt {\n  private final DiscoveryClient discoveryClient;\n  private final HeartbeatListener heartbeatListener;\n  KubernetesDiscoveryClientApplicationIt(  DiscoveryClient discoveryClient,  HeartbeatListener heartbeatListener);\n  public static void main(  String[] args);\n  @GetMapping(\"/services\") List\u003cString\u003e services();\n  @GetMapping(\"/service/{serviceId}\") List\u003cServiceInstance\u003e service(  @PathVariable String serviceId);\n  @GetMapping(\"/state\") List\u003cEndpointNameAndNamespace\u003e state();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery-server/src/main/java/org/springframework/cloud/kubernetes/discoveryclient/it/HeartbeatListener.java",
        "name": "HeartbeatListener",
        "modifiers": "@Component",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryclient.it.HeartbeatListener",
        "extend": "",
        "implements": "ApplicationListener\u003cHeartbeatEvent\u003e",
        "raw": "/** \n * @author wind57\n */\n@Component class HeartbeatListener implements ApplicationListener\u003cHeartbeatEvent\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(HeartbeatListener.class));\n  AtomicReference\u003cList\u003cEndpointNameAndNamespace\u003e\u003e state\u003dnew AtomicReference\u003c\u003e(List.of());\n  @Override @SuppressWarnings(\"unchecked\") public void onApplicationEvent(  HeartbeatEvent event){\n    LOG.info(\"received heartbeat event\");\n    List\u003cEndpointNameAndNamespace\u003e state\u003d(List\u003cEndpointNameAndNamespace\u003e)event.getValue();\n    this.state.set(state);\n    LOG.info(\"state received : \" + state);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@Component class HeartbeatListener implements ApplicationListener\u003cHeartbeatEvent\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(HeartbeatListener.class));\n  AtomicReference\u003cList\u003cEndpointNameAndNamespace\u003e\u003e state\u003dnew AtomicReference\u003c\u003e(List.of());\n  @Override @SuppressWarnings(\"unchecked\") public void onApplicationEvent(  HeartbeatEvent event);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery-server/src/test/java/org/springframework/cloud/kubernetes/discoveryclient/it/DiscoveryClientFilterNamespaceDelegate.java",
        "name": "DiscoveryClientFilterNamespaceDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryclient.it.DiscoveryClientFilterNamespaceDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author mbialkowski1\n */\nfinal class DiscoveryClientFilterNamespaceDelegate {\n  private DiscoveryClientFilterNamespaceDelegate(){\n  }\n  private static final BasicJsonTester BASIC_JSON_TESTER\u003dnew BasicJsonTester(DiscoveryClientFilterNamespaceDelegate.class);\n  static void testNamespaceDiscoveryClient(  K3sContainer container){\n    testLoadBalancer();\n    testHealth();\n    testForHeartbeat(container);\n  }\n  private static void testLoadBalancer(){\n    WebClient.Builder builder\u003dbuilder();\n    WebClient serviceClient\u003dbuilder.baseUrl(\"http://localhost:80/discoveryclient-it/services\").build();\n    String result\u003dserviceClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(result)).extractingJsonPathArrayValue(\"$\").contains(\"service-wiremock\");\n    WebClient serviceInstanceClient\u003dbuilder.baseUrl(\"http://localhost:80/discoveryclient-it/service/service-wiremock\").build();\n    String serviceInstances\u003dserviceInstanceClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(serviceInstances)).extractingJsonPathStringValue(\"$.[0].serviceId\").isEqualTo(\"service-wiremock\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(serviceInstances)).extractingJsonPathStringValue(\"$.[0].namespace\").isEqualTo(\"left\");\n  }\n  private static void testHealth(){\n    WebClient.Builder builder\u003dbuilder();\n    WebClient serviceClient\u003dbuilder.baseUrl(\"http://localhost:80/discoveryclient-it/actuator/health\").build();\n    String health\u003dserviceClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(health)).extractingJsonPathStringValue(\"$.components.discoveryComposite.status\").isEqualTo(\"UP\");\n  }\n  private static void testForHeartbeat(  K3sContainer container){\n    Commons.waitForLogStatement(\"using delay : 3000\",container,\"spring-cloud-kubernetes-discoveryserver\");\n    Commons.waitForLogStatement(\"received heartbeat event\",container,\"spring-cloud-kubernetes-discoveryserver\");\n    Commons.waitForLogStatement(\"state received :\",container,\"spring-cloud-kubernetes-discoveryserver\");\n    Commons.waitForLogStatement(\"using delay : 3000\",container,\"spring-cloud-kubernetes-k8s-client-discovery-server\");\n    Commons.waitForLogStatement(\"state received : \",container,\"spring-cloud-kubernetes-k8s-client-discovery-server\");\n    WebClient.Builder builder\u003dbuilder();\n    WebClient client\u003dbuilder.baseUrl(\"http://localhost:80/discoveryclient-it/state\").build();\n    String result\u003dclient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Condition\u003cLinkedHashMap\u003cString,String\u003e\u003e wireMockService\u003dnew Condition\u003c\u003e(map -\u003e map.entrySet().stream().anyMatch(en -\u003e en.getValue().contains(\"service-wiremock-deployment\")),\"\");\n    Condition\u003cLinkedHashMap\u003cString,String\u003e\u003e discoveryServerService\u003dnew Condition\u003c\u003e(map -\u003e map.entrySet().stream().anyMatch(en -\u003e en.getValue().contains(\"spring-cloud-kubernetes-k8s-client-discovery-server\")),\"\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(result)).\u003cLinkedHashMap\u003cString,String\u003e\u003eextractingJsonPathArrayValue(\"$.[*]\").areAtLeastOne(wireMockService);\n    Assertions.assertThat(BASIC_JSON_TESTER.from(result)).\u003cLinkedHashMap\u003cString,String\u003e\u003eextractingJsonPathArrayValue(\"$.[*]\").areAtLeastOne(discoveryServerService);\n  }\n  private static WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private static RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n}\n",
        "abstract": "/** \n * @author mbialkowski1\n */\nfinal class DiscoveryClientFilterNamespaceDelegate {\n  private DiscoveryClientFilterNamespaceDelegate();\n  private static final BasicJsonTester BASIC_JSON_TESTER\u003dnew BasicJsonTester(DiscoveryClientFilterNamespaceDelegate.class);\n  static void testNamespaceDiscoveryClient(  K3sContainer container);\n  private static void testLoadBalancer();\n  private static void testHealth();\n  private static void testForHeartbeat(  K3sContainer container);\n  private static WebClient.Builder builder();\n  private static RetryBackoffSpec retrySpec();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-discovery-server/src/test/java/org/springframework/cloud/kubernetes/discoveryclient/it/DiscoveryClientIT.java",
        "name": "DiscoveryClientIT",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.discoveryclient.it.DiscoveryClientIT",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass DiscoveryClientIT {\n  private static final String BODY_ONE\u003dnull;\n  private static final String BODY_TWO\u003dnull;\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-cloud-kubernetes-k8s-client-discovery-server\");\n  private static final Map\u003cString,String\u003e POD_LABELS_DISCOVERY\u003dMap.of(\"app\",\"spring-cloud-kubernetes-discoveryserver\");\n  private static final BasicJsonTester BASIC_JSON_TESTER\u003dnew BasicJsonTester(DiscoveryClientIT.class);\n  private static final String DISCOVERY_SERVER_APP_NAME\u003d\"spring-cloud-kubernetes-discoveryserver\";\n  private static final String SPRING_CLOUD_K8S_DISCOVERY_CLIENT_APP_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery-server\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String NAMESPACE_LEFT\u003d\"left\";\n  private static final String NAMESPACE_RIGHT\u003d\"right\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  private static RbacAuthorizationV1Api rbacApi;\n  private static V1ClusterRoleBinding clusterRoleBinding;\n  @BeforeAll static void beforeAll() throws Exception {\n    K3S.start();\n    Commons.validateImage(DISCOVERY_SERVER_APP_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(DISCOVERY_SERVER_APP_NAME,K3S);\n    Commons.validateImage(SPRING_CLOUD_K8S_DISCOVERY_CLIENT_APP_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(SPRING_CLOUD_K8S_DISCOVERY_CLIENT_APP_NAME,K3S);\n    Images.loadWiremock(K3S);\n    util\u003dnew Util(K3S);\n    rbacApi\u003dnew RbacAuthorizationV1Api();\n    util.setUp(NAMESPACE);\n    util.createNamespace(NAMESPACE_LEFT);\n    util.createNamespace(NAMESPACE_RIGHT);\n    clusterRoleBinding\u003d(V1ClusterRoleBinding)util.yaml(\"namespace-filter/cluster-admin-serviceaccount-role.yaml\");\n    rbacApi.createClusterRoleBinding(clusterRoleBinding,null,null,null,null);\n    util.wiremock(NAMESPACE_LEFT,\"/wiremock-\" + NAMESPACE_LEFT,Phase.CREATE,false);\n    util.wiremock(NAMESPACE_RIGHT,\"/wiremock-\" + NAMESPACE_RIGHT,Phase.CREATE,false);\n    discoveryServer(Phase.CREATE);\n  }\n  @AfterAll static void afterAll() throws Exception {\n    rbacApi.deleteClusterRoleBinding(clusterRoleBinding.getMetadata().getName(),null,null,null,null,null,null);\n    Commons.cleanUp(DISCOVERY_SERVER_APP_NAME,K3S);\n    Commons.cleanUp(SPRING_CLOUD_K8S_DISCOVERY_CLIENT_APP_NAME,K3S);\n    util.wiremock(NAMESPACE_LEFT,\"/wiremock-\" + NAMESPACE_LEFT,Phase.DELETE,false);\n    util.wiremock(NAMESPACE_RIGHT,\"/wiremock-\" + NAMESPACE_RIGHT,Phase.DELETE,false);\n    util.deleteNamespace(NAMESPACE_LEFT);\n    util.deleteNamespace(NAMESPACE_RIGHT);\n    discoveryServer(Phase.DELETE);\n    discoveryClient(Phase.DELETE);\n    Commons.systemPrune();\n  }\n  @Test void testDiscoveryClient(){\n    discoveryClient(Phase.CREATE);\n    testLoadBalancer();\n    testHealth();\n    patchForAllNamespaces(\"docker.io/springcloud/spring-cloud-kubernetes-discoveryserver:\" + Commons.pomVersion(),\"spring-cloud-kubernetes-discoveryserver-deployment\",NAMESPACE);\n    patchForNamespaceFilter(\"docker.io/springcloud/spring-cloud-kubernetes-k8s-client-discovery-server:\" + Commons.pomVersion(),\"spring-cloud-kubernetes-k8s-client-discovery-server-deployment\",NAMESPACE);\n    testNamespaceDiscoveryClient(K3S);\n  }\n  private void testLoadBalancer(){\n    WebClient.Builder builder\u003dbuilder();\n    WebClient serviceClient\u003dbuilder.baseUrl(\"http://localhost:80/discoveryclient-it/services\").build();\n    String result\u003dserviceClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(result)).extractingJsonPathArrayValue(\"$\").contains(\"spring-cloud-kubernetes-discoveryserver\");\n    WebClient.Builder stateBuilder\u003dbuilder();\n    WebClient client\u003dstateBuilder.baseUrl(\"http://localhost:80/discoveryclient-it/state\").build();\n    String stateResult\u003dclient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(stateResult)).isEqualTo(\"[]\");\n    try {\n      Thread.sleep(TimeUnit.SECONDS.toMillis(10));\n    }\n catch (    InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n    String stateResultAfter10Seconds\u003dclient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(stateResultAfter10Seconds)).isEqualTo(\"[]\");\n  }\n  void testHealth(){\n    WebClient.Builder clientBuilder\u003dbuilder();\n    WebClient.Builder serverBuilder\u003dbuilder();\n    WebClient client\u003dclientBuilder.baseUrl(\"http://localhost:80/discoveryclient-it/actuator/health\").build();\n    WebClient server\u003dserverBuilder.baseUrl(\"http://localhost:80/actuator/health\").build();\n    String clientHealth\u003dclient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    String serverHealth\u003dserver.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertThat(BASIC_JSON_TESTER.from(clientHealth)).extractingJsonPathStringValue(\"$.components.discoveryComposite.status\").isEqualTo(\"UP\");\n    Assertions.assertThat(BASIC_JSON_TESTER.from(serverHealth)).extractingJsonPathStringValue(\"$.components.kubernetes.status\").isEqualTo(\"UP\");\n  }\n  private static void discoveryClient(  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"client/spring-cloud-kubernetes-discoveryclient-it-deployment.yaml\");\n    V1Service service\u003d(V1Service)util.yaml(\"client/spring-cloud-kubernetes-discoveryclient-it-service.yaml\");\n    V1Ingress ingress\u003d(V1Ingress)util.yaml(\"ingress.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(NAMESPACE,null,deployment,service,ingress,true);\n    }\n else {\n      util.deleteAndWait(NAMESPACE,deployment,service,ingress);\n    }\n  }\n  private static void discoveryServer(  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"server/spring-cloud-kubernetes-discoveryserver-deployment.yaml\");\n    V1Service service\u003d(V1Service)util.yaml(\"server/spring-cloud-kubernetes-discoveryserver-service.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(NAMESPACE,null,deployment,service,null,true);\n    }\n else {\n      util.deleteAndWait(NAMESPACE,deployment,service,null);\n    }\n  }\n  private WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n  static void patchForNamespaceFilter(  String image,  String deploymentName,  String namespace){\n    patchWithReplace(image,deploymentName,namespace,BODY_ONE,POD_LABELS);\n  }\n  static void patchForAllNamespaces(  String image,  String deploymentName,  String namespace){\n    patchWithReplace(image,deploymentName,namespace,BODY_TWO,POD_LABELS_DISCOVERY);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass DiscoveryClientIT {\n  private static final String BODY_ONE\u003dnull;\n  private static final String BODY_TWO\u003dnull;\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-cloud-kubernetes-k8s-client-discovery-server\");\n  private static final Map\u003cString,String\u003e POD_LABELS_DISCOVERY\u003dMap.of(\"app\",\"spring-cloud-kubernetes-discoveryserver\");\n  private static final BasicJsonTester BASIC_JSON_TESTER\u003dnew BasicJsonTester(DiscoveryClientIT.class);\n  private static final String DISCOVERY_SERVER_APP_NAME\u003d\"spring-cloud-kubernetes-discoveryserver\";\n  private static final String SPRING_CLOUD_K8S_DISCOVERY_CLIENT_APP_NAME\u003d\"spring-cloud-kubernetes-k8s-client-discovery-server\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String NAMESPACE_LEFT\u003d\"left\";\n  private static final String NAMESPACE_RIGHT\u003d\"right\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  private static RbacAuthorizationV1Api rbacApi;\n  private static V1ClusterRoleBinding clusterRoleBinding;\n  @BeforeAll static void beforeAll() throws Exception;\n  @AfterAll static void afterAll() throws Exception;\n  @Test void testDiscoveryClient();\n  private void testLoadBalancer();\n  void testHealth();\n  private static void discoveryClient(  Phase phase);\n  private static void discoveryServer(  Phase phase);\n  private WebClient.Builder builder();\n  private RetryBackoffSpec retrySpec();\n  static void patchForNamespaceFilter(  String image,  String deploymentName,  String namespace);\n  static void patchForAllNamespaces(  String image,  String deploymentName,  String namespace);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-rabbitmq-secret-reload-multiple-apps/rabbitmq-secret-test-app/src/test/java/org/springframework/cloud/kubernetes/configuration/watcher/multiple/apps/ConfigurationWatcherMultipleAppIT.java",
        "name": "ConfigurationWatcherMultipleAppIT",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.multiple.apps.ConfigurationWatcherMultipleAppIT",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass ConfigurationWatcherMultipleAppIT {\n  private static final String CONFIG_WATCHER_APP_A_IMAGE\u003d\"rabbitmq-secret-app-a\";\n  private static final String CONFIG_WATCHER_APP_B_IMAGE\u003d\"rabbitmq-secret-app-b\";\n  private static final String SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME\u003d\"spring-cloud-kubernetes-configuration-watcher\";\n  private static final String SECRET_NAME\u003d\"multiple-apps\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  @BeforeAll static void beforeAll() throws Exception {\n    K3S.start();\n    Commons.validateImage(SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME,K3S);\n    Commons.validateImage(CONFIG_WATCHER_APP_A_IMAGE,K3S);\n    Commons.loadSpringCloudKubernetesImage(CONFIG_WATCHER_APP_A_IMAGE,K3S);\n    Commons.validateImage(CONFIG_WATCHER_APP_B_IMAGE,K3S);\n    Commons.loadSpringCloudKubernetesImage(CONFIG_WATCHER_APP_B_IMAGE,K3S);\n    Images.loadRabbitmq(K3S);\n    util\u003dnew Util(K3S);\n    util.setUp(NAMESPACE);\n  }\n  @AfterAll static void afterAll() throws Exception {\n    Commons.cleanUp(SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME,K3S);\n    Commons.cleanUp(CONFIG_WATCHER_APP_A_IMAGE,K3S);\n    Commons.cleanUp(CONFIG_WATCHER_APP_B_IMAGE,K3S);\n    Commons.systemPrune();\n  }\n  @BeforeEach void setup(){\n    util.rabbitMq(NAMESPACE,Phase.CREATE);\n    appA(Phase.CREATE);\n    appB(Phase.CREATE);\n    configWatcher(Phase.CREATE);\n  }\n  @AfterEach void after(){\n    util.rabbitMq(NAMESPACE,Phase.DELETE);\n    appA(Phase.DELETE);\n    appB(Phase.DELETE);\n    configWatcher(Phase.DELETE);\n  }\n  @Test void testRefresh(){\n    V1Secret secret\u003dnew V1SecretBuilder().editOrNewMetadata().withName(SECRET_NAME).addToLabels(\"spring.cloud.kubernetes.secret\",\"true\").addToAnnotations(\"spring.cloud.kubernetes.secret.apps\",\"spring-cloud-kubernetes-client-configuration-watcher-secret-app-a, \" + \"spring-cloud-kubernetes-client-configuration-watcher-secret-app-b\").endMetadata().build();\n    util.createAndWait(NAMESPACE,null,secret);\n    WebClient.Builder builderA\u003dbuilder();\n    WebClient serviceClientA\u003dbuilderA.baseUrl(\"http://localhost:80/app-a\").build();\n    WebClient.Builder builderB\u003dbuilder();\n    WebClient serviceClientB\u003dbuilderB.baseUrl(\"http://localhost:80/app-b\").build();\n    Boolean[] valueA\u003dnew Boolean[1];\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(240)).until(() -\u003e {\n      valueA[0]\u003dserviceClientA.method(HttpMethod.GET).retrieve().bodyToMono(Boolean.class).retryWhen(retrySpec()).block();\n      return valueA[0];\n    }\n);\n    Assertions.assertTrue(valueA[0]);\n    Boolean[] valueB\u003dnew Boolean[1];\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(240)).until(() -\u003e {\n      valueB[0]\u003dserviceClientB.method(HttpMethod.GET).retrieve().bodyToMono(Boolean.class).retryWhen(retrySpec()).block();\n      return valueB[0];\n    }\n);\n    Assertions.assertTrue(valueB[0]);\n    util.deleteAndWait(NAMESPACE,null,secret);\n  }\n  private void appA(  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"app-a/app-a-deployment.yaml\");\n    V1Service service\u003d(V1Service)util.yaml(\"app-a/app-a-service.yaml\");\n    V1Ingress ingress\u003d(V1Ingress)util.yaml(\"ingress/spring-cloud-kubernetes-configuration-watcher-multiple-apps-ingress.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(NAMESPACE,null,deployment,service,ingress,true);\n    }\n else     if (phase.equals(Phase.DELETE)) {\n      util.deleteAndWait(NAMESPACE,deployment,service,ingress);\n    }\n  }\n  private void appB(  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"app-b/app-b-deployment.yaml\");\n    V1Service service\u003d(V1Service)util.yaml(\"app-b/app-b-service.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(NAMESPACE,null,deployment,service,null,true);\n    }\n else     if (phase.equals(Phase.DELETE)) {\n      util.deleteAndWait(NAMESPACE,deployment,service,null);\n    }\n  }\n  private void configWatcher(  Phase phase){\n    V1Deployment deployment\u003d(V1Deployment)util.yaml(\"config-watcher/spring-cloud-kubernetes-configuration-watcher-it-bus-amqp-deployment.yaml\");\n    V1Service service\u003d(V1Service)util.yaml(\"config-watcher/spring-cloud-kubernetes-configuration-watcher-service.yaml\");\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(NAMESPACE,null,deployment,service,null,true);\n    }\n else     if (phase.equals(Phase.DELETE)) {\n      util.deleteAndWait(NAMESPACE,deployment,service,null);\n    }\n  }\n  private WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  private RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(240,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass ConfigurationWatcherMultipleAppIT {\n  private static final String CONFIG_WATCHER_APP_A_IMAGE\u003d\"rabbitmq-secret-app-a\";\n  private static final String CONFIG_WATCHER_APP_B_IMAGE\u003d\"rabbitmq-secret-app-b\";\n  private static final String SPRING_CLOUD_K8S_CONFIG_WATCHER_APP_NAME\u003d\"spring-cloud-kubernetes-configuration-watcher\";\n  private static final String SECRET_NAME\u003d\"multiple-apps\";\n  private static final String NAMESPACE\u003d\"default\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  @BeforeAll static void beforeAll() throws Exception;\n  @AfterAll static void afterAll() throws Exception;\n  @BeforeEach void setup();\n  @AfterEach void after();\n  @Test void testRefresh();\n  private void appA(  Phase phase);\n  private void appB(  Phase phase);\n  private void configWatcher(  Phase phase);\n  private WebClient.Builder builder();\n  private RetryBackoffSpec retrySpec();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-rabbitmq-secret-reload-multiple-apps/rabbitmq-secret-app-a/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/appA/AppATestApplication.java",
        "name": "AppATestApplication",
        "modifiers": "@SpringBootApplication @RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.appA.AppATestApplication",
        "extend": "",
        "implements": "ApplicationListener\u003cRefreshRemoteApplicationEvent\u003e",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication @RestController public class AppATestApplication implements ApplicationListener\u003cRefreshRemoteApplicationEvent\u003e {\n  private final Log LOG\u003dLogFactory.getLog(getClass());\n  private boolean value\u003dfalse;\n  public static void main(  String[] args){\n    SpringApplication.run(AppATestApplication.class,args);\n  }\n  @GetMapping(\"/app-a\") public boolean index(){\n    LOG.info(\"Current value: \" + value);\n    return value;\n  }\n  @Override public void onApplicationEvent(  RefreshRemoteApplicationEvent refreshRemoteApplicationEvent){\n    LOG.info(\"Received remote refresh event from origin: \" + refreshRemoteApplicationEvent.getOriginService() + \" to destination : \"+ refreshRemoteApplicationEvent.getDestinationService());\n    this.value\u003dtrue;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication @RestController public class AppATestApplication implements ApplicationListener\u003cRefreshRemoteApplicationEvent\u003e {\n  private final Log LOG\u003dLogFactory.getLog(getClass());\n  private boolean value\u003dfalse;\n  public static void main(  String[] args);\n  @GetMapping(\"/app-a\") public boolean index();\n  @Override public void onApplicationEvent(  RefreshRemoteApplicationEvent refreshRemoteApplicationEvent);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-k8s-client-rabbitmq-secret-reload-multiple-apps/rabbitmq-secret-app-b/src/main/java/org/springframework/cloud/kubernetes/configuration/watcher/appB/AppBTestApplication.java",
        "name": "AppBTestApplication",
        "modifiers": "@SpringBootApplication @RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.configuration.watcher.appB.AppBTestApplication",
        "extend": "",
        "implements": "ApplicationListener\u003cRefreshRemoteApplicationEvent\u003e",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication @RestController public class AppBTestApplication implements ApplicationListener\u003cRefreshRemoteApplicationEvent\u003e {\n  private final Log LOG\u003dLogFactory.getLog(getClass());\n  private boolean value\u003dfalse;\n  public static void main(  String[] args){\n    SpringApplication.run(AppBTestApplication.class,args);\n  }\n  @GetMapping(\"/app-b\") public boolean index(){\n    LOG.info(\"Current value: \" + value);\n    return value;\n  }\n  @Override public void onApplicationEvent(  RefreshRemoteApplicationEvent refreshRemoteApplicationEvent){\n    LOG.info(\"Received remote refresh event from origin: \" + refreshRemoteApplicationEvent.getOriginService() + \" to destination : \"+ refreshRemoteApplicationEvent.getDestinationService());\n    this.value\u003dtrue;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication @RestController public class AppBTestApplication implements ApplicationListener\u003cRefreshRemoteApplicationEvent\u003e {\n  private final Log LOG\u003dLogFactory.getLog(getClass());\n  private boolean value\u003dfalse;\n  public static void main(  String[] args);\n  @GetMapping(\"/app-b\") public boolean index();\n  @Override public void onApplicationEvent(  RefreshRemoteApplicationEvent refreshRemoteApplicationEvent);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-catalog-watcher/src/main/java/org/springframework/cloud/kubernetes/fabric8/catalog/watch/Application.java",
        "name": "Application",
        "modifiers": "@SpringBootApplication @EnableScheduling public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.catalog.watch.Application",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableScheduling public class Application {\n  public static void main(  String[] args){\n    SpringApplication.run(Application.class,args);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableScheduling public class Application {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-catalog-watcher/src/main/java/org/springframework/cloud/kubernetes/fabric8/catalog/watch/EndpointNameAndNamespaceService.java",
        "name": "EndpointNameAndNamespaceService",
        "modifiers": "@Service public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.catalog.watch.EndpointNameAndNamespaceService",
        "extend": "",
        "implements": "",
        "raw": "/** \n * holds an EndpointNameAndNamespace object, needed so that the controller can poll to see if anything has changed. And we call the controller from our tests.\n * @author wind57\n */\n@Service public class EndpointNameAndNamespaceService {\n  private List\u003cEndpointNameAndNamespace\u003e result;\n  public List\u003cEndpointNameAndNamespace\u003e result(){\n    return result;\n  }\n  public void setResult(  List\u003cEndpointNameAndNamespace\u003e result){\n    this.result\u003dresult;\n  }\n}\n",
        "abstract": "/** \n * holds an EndpointNameAndNamespace object, needed so that the controller can poll to see if anything has changed. And we call the controller from our tests.\n * @author wind57\n */\n@Service public class EndpointNameAndNamespaceService {\n  private List\u003cEndpointNameAndNamespace\u003e result;\n  public List\u003cEndpointNameAndNamespace\u003e result();\n  public void setResult(  List\u003cEndpointNameAndNamespace\u003e result);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-catalog-watcher/src/main/java/org/springframework/cloud/kubernetes/fabric8/catalog/watch/HeartBeatListener.java",
        "name": "HeartBeatListener",
        "modifiers": "@Component public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.catalog.watch.HeartBeatListener",
        "extend": "",
        "implements": "ApplicationListener\u003cApplicationEvent\u003e",
        "raw": "/** \n * Listener that will catch events from {@link org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesCatalogWatch}\n * @author wind57\n */\n@Component public class HeartBeatListener implements ApplicationListener\u003cApplicationEvent\u003e {\n  private final EndpointNameAndNamespaceService service;\n  public HeartBeatListener(  EndpointNameAndNamespaceService service){\n    this.service\u003dservice;\n  }\n  @SuppressWarnings(\"unchecked\") @Override public void onApplicationEvent(  ApplicationEvent event){\n    if (event instanceof HeartbeatEvent) {\n      List\u003cEndpointNameAndNamespace\u003e result\u003d(List\u003cEndpointNameAndNamespace\u003e)heartbeatEvent.getValue();\n      service.setResult(result);\n    }\n  }\n}\n",
        "abstract": "/** \n * Listener that will catch events from {@link org.springframework.cloud.kubernetes.fabric8.discovery.KubernetesCatalogWatch}\n * @author wind57\n */\n@Component public class HeartBeatListener implements ApplicationListener\u003cApplicationEvent\u003e {\n  private final EndpointNameAndNamespaceService service;\n  public HeartBeatListener(  EndpointNameAndNamespaceService service);\n  @SuppressWarnings(\"unchecked\") @Override public void onApplicationEvent(  ApplicationEvent event);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-catalog-watcher/src/main/java/org/springframework/cloud/kubernetes/fabric8/catalog/watch/HeartbeatController.java",
        "name": "HeartbeatController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.catalog.watch.HeartbeatController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class HeartbeatController {\n  private final EndpointNameAndNamespaceService service;\n  public HeartbeatController(  EndpointNameAndNamespaceService service){\n    this.service\u003dservice;\n  }\n  @GetMapping(\"/result\") public List\u003cEndpointNameAndNamespace\u003e result(){\n    return service.result();\n  }\n}\n",
        "abstract": "@RestController public class HeartbeatController {\n  private final EndpointNameAndNamespaceService service;\n  public HeartbeatController(  EndpointNameAndNamespaceService service);\n  @GetMapping(\"/result\") public List\u003cEndpointNameAndNamespace\u003e result();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-catalog-watcher/src/test/java/org/springframework/cloud/kubernetes/fabric8/catalog/watch/Fabric8CatalogWatchIT.java",
        "name": "Fabric8CatalogWatchIT",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.catalog.watch.Fabric8CatalogWatchIT",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass Fabric8CatalogWatchIT {\n  private static final String NAMESPACE\u003d\"default\";\n  public static final String NAMESPACE_A\u003d\"namespacea\";\n  public static final String NAMESPACE_B\u003d\"namespaceb\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-catalog-watcher\";\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + IMAGE_NAME + \":\"+ pomVersion();\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  @BeforeAll static void beforeAll() throws Exception {\n    K3S.start();\n    Commons.validateImage(IMAGE_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(IMAGE_NAME,K3S);\n    Images.loadBusybox(K3S);\n    util\u003dnew Util(K3S);\n    util.createNamespace(NAMESPACE_A);\n    util.createNamespace(NAMESPACE_B);\n    util.setUp(NAMESPACE);\n    util.setUpClusterWide(NAMESPACE,Set.of(NAMESPACE,NAMESPACE_A,NAMESPACE_B));\n    util.busybox(NAMESPACE,Phase.CREATE);\n    app(Phase.CREATE);\n  }\n  @AfterAll static void afterAll(){\n    util.deleteNamespace(NAMESPACE_A);\n    util.deleteNamespace(NAMESPACE_B);\n    app(Phase.DELETE);\n    Commons.systemPrune();\n  }\n  /** \n * \u003cpre\u003e - we deploy a busybox service with 2 replica pods - we receive an event from KubernetesCatalogWatcher, assert what is inside it - delete the busybox service - assert that we receive only spring-cloud-kubernetes-fabric8-client-catalog-watcher pod \u003c/pre\u003e\n */\n  @Test void testCatalogWatchWithEndpoints() throws Exception {\n    assertLogStatement();\n    test();\n    testCatalogWatchWithEndpointSlices();\n    testCatalogWatchWithNamespaceFilterAndEndpoints();\n    testCatalogWatchWithNamespaceFilterAndEndpointSlices();\n  }\n  void testCatalogWatchWithEndpointSlices(){\n    util.busybox(NAMESPACE,Phase.CREATE);\n    patchForEndpointSlices(util,DOCKER_IMAGE,IMAGE_NAME,NAMESPACE);\n    Commons.waitForLogStatement(\"stateGenerator is of type: Fabric8EndpointSliceV1CatalogWatch\",K3S,IMAGE_NAME);\n    test();\n  }\n  void testCatalogWatchWithNamespaceFilterAndEndpoints(){\n    util.busybox(NAMESPACE_A,Phase.CREATE);\n    util.busybox(NAMESPACE_B,Phase.CREATE);\n    patchForNamespaceFilterAndEndpoints(util,DOCKER_IMAGE,IMAGE_NAME,NAMESPACE);\n    Fabric8CatalogWatchWithNamespacesDelegate.testCatalogWatchWithNamespaceFilterAndEndpoints(K3S,IMAGE_NAME,util);\n  }\n  void testCatalogWatchWithNamespaceFilterAndEndpointSlices(){\n    util.busybox(NAMESPACE_A,Phase.CREATE);\n    util.busybox(NAMESPACE_B,Phase.CREATE);\n    patchForNamespaceFilterAndEndpointSlices(util,DOCKER_IMAGE,IMAGE_NAME,NAMESPACE);\n    Fabric8CatalogWatchWithNamespacesDelegate.testCatalogWatchWithNamespaceFilterAndEndpointSlices(K3S,IMAGE_NAME,util);\n  }\n  /** \n * we log in debug mode the type of the StateGenerator we use, be that Endpoints or EndpointSlices. Here we make sure that in the test we actually use the correct type.\n */\n  private void assertLogStatement() throws Exception {\n    String appPodName\u003dK3S.execInContainer(\"kubectl\",\"get\",\"pods\",\"-l\",\"app\u003dspring-cloud-kubernetes-fabric8-client-catalog-watcher\",\"-o\u003dname\",\"--no-headers\").getStdout();\n    String allLogs\u003dK3S.execInContainer(\"kubectl\",\"logs\",appPodName.trim()).getStdout();\n    Assertions.assertTrue(allLogs.contains(\"stateGenerator is of type: Fabric8EndpointsCatalogWatch\"));\n  }\n  /** \n * the test is the same for both endpoints and endpoint slices, the set-up for them is different.\n */\n  @SuppressWarnings(\"unchecked\") private void test(){\n    WebClient client\u003dbuilder().baseUrl(\"http://localhost/result\").build();\n    EndpointNameAndNamespace[] holder\u003dnew EndpointNameAndNamespace[2];\n    ResolvableType resolvableType\u003dResolvableType.forClassWithGenerics(List.class,EndpointNameAndNamespace.class);\n    await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(240)).until(() -\u003e {\n      List\u003cEndpointNameAndNamespace\u003e result\u003d(List\u003cEndpointNameAndNamespace\u003e)client.method(HttpMethod.GET).retrieve().bodyToMono(ParameterizedTypeReference.forType(resolvableType.getType())).retryWhen(retrySpec()).block();\n      if (result !\u003d null) {\n        if (result.size() !\u003d 3) {\n          return false;\n        }\n        holder[0]\u003dresult.get(0);\n        holder[1]\u003dresult.get(1);\n        return true;\n      }\n      return false;\n    }\n);\n    EndpointNameAndNamespace resultOne\u003dholder[0];\n    EndpointNameAndNamespace resultTwo\u003dholder[1];\n    Assertions.assertNotNull(resultOne);\n    Assertions.assertNotNull(resultTwo);\n    Assertions.assertTrue(resultOne.endpointName().contains(\"busybox\"));\n    Assertions.assertTrue(resultTwo.endpointName().contains(\"busybox\"));\n    Assertions.assertEquals(\"default\",resultOne.namespace());\n    Assertions.assertEquals(\"default\",resultTwo.namespace());\n    util.busybox(NAMESPACE,Phase.DELETE);\n    EndpointNameAndNamespace[] afterDelete\u003dnew EndpointNameAndNamespace[1];\n    await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(240)).until(() -\u003e {\n      List\u003cEndpointNameAndNamespace\u003e result\u003d(List\u003cEndpointNameAndNamespace\u003e)client.method(HttpMethod.GET).retrieve().bodyToMono(ParameterizedTypeReference.forType(resolvableType.getType())).retryWhen(retrySpec()).block();\n      if (result !\u003d null \u0026\u0026 result.size() !\u003d 1) {\n        return false;\n      }\n      if (result !\u003d null) {\n        afterDelete[0]\u003dresult.get(0);\n        return true;\n      }\n      return false;\n    }\n);\n    Assertions.assertTrue(afterDelete[0].endpointName().contains(IMAGE_NAME));\n    Assertions.assertEquals(\"default\",afterDelete[0].namespace());\n  }\n  private static void app(  Phase phase){\n    InputStream endpointsDeploymentStream\u003dutil.inputStream(\"app/watcher-endpoints-deployment.yaml\");\n    InputStream serviceStream\u003dutil.inputStream(\"app/watcher-service.yaml\");\n    InputStream ingressStream\u003dutil.inputStream(\"app/watcher-ingress.yaml\");\n    Deployment deployment\u003dSerialization.unmarshal(endpointsDeploymentStream,Deployment.class);\n    Service service\u003dSerialization.unmarshal(serviceStream,Service.class);\n    Ingress ingress\u003dSerialization.unmarshal(ingressStream,Ingress.class);\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(Fabric8CatalogWatchIT.NAMESPACE,null,deployment,service,ingress,true);\n    }\n else {\n      util.deleteAndWait(Fabric8CatalogWatchIT.NAMESPACE,deployment,service,ingress);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass Fabric8CatalogWatchIT {\n  private static final String NAMESPACE\u003d\"default\";\n  public static final String NAMESPACE_A\u003d\"namespacea\";\n  public static final String NAMESPACE_B\u003d\"namespaceb\";\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-catalog-watcher\";\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + IMAGE_NAME + \":\"+ pomVersion();\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  @BeforeAll static void beforeAll() throws Exception;\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e - we deploy a busybox service with 2 replica pods - we receive an event from KubernetesCatalogWatcher, assert what is inside it - delete the busybox service - assert that we receive only spring-cloud-kubernetes-fabric8-client-catalog-watcher pod \u003c/pre\u003e\n */\n  @Test void testCatalogWatchWithEndpoints() throws Exception;\n  void testCatalogWatchWithEndpointSlices();\n  void testCatalogWatchWithNamespaceFilterAndEndpoints();\n  void testCatalogWatchWithNamespaceFilterAndEndpointSlices();\n  /** \n * we log in debug mode the type of the StateGenerator we use, be that Endpoints or EndpointSlices. Here we make sure that in the test we actually use the correct type.\n */\n  private void assertLogStatement() throws Exception;\n  /** \n * the test is the same for both endpoints and endpoint slices, the set-up for them is different.\n */\n  @SuppressWarnings(\"unchecked\") private void test();\n  private static void app(  Phase phase);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-catalog-watcher/src/test/java/org/springframework/cloud/kubernetes/fabric8/catalog/watch/Fabric8CatalogWatchWithNamespacesDelegate.java",
        "name": "Fabric8CatalogWatchWithNamespacesDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.catalog.watch.Fabric8CatalogWatchWithNamespacesDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class Fabric8CatalogWatchWithNamespacesDelegate {\n  private Fabric8CatalogWatchWithNamespacesDelegate(){\n  }\n  private static final String APP_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-catalog-watcher\";\n  /** \n * \u003cpre\u003e - we deploy one busybox service with 2 replica pods in namespace namespacea - we deploy one busybox service with 2 replica pods in namespace namespaceb - we enable the search to be made in namespacea and default ones - we receive an event from KubernetesCatalogWatcher, assert what is inside it - delete both busybox services in namespacea and namespaceb - assert that we receive only spring-cloud-kubernetes-fabric8-client-catalog-watcher pod \u003c/pre\u003e\n */\n  static void testCatalogWatchWithNamespaceFilterAndEndpoints(  K3sContainer container,  String imageName,  Util util){\n    Commons.waitForLogStatement(\"stateGenerator is of type: Fabric8EndpointsCatalogWatch\",container,imageName);\n    test(util);\n  }\n  static void testCatalogWatchWithNamespaceFilterAndEndpointSlices(  K3sContainer container,  String imageName,  Util util){\n    Commons.waitForLogStatement(\"stateGenerator is of type: Fabric8EndpointSliceV1CatalogWatch\",container,imageName);\n    test(util);\n  }\n  /** \n * the test is the same for both endpoints and endpoint slices, the set-up for them is different.\n */\n  @SuppressWarnings(\"unchecked\") private static void test(  Util util){\n    WebClient client\u003dbuilder().baseUrl(\"http://localhost/result\").build();\n    EndpointNameAndNamespace[] holder\u003dnew EndpointNameAndNamespace[2];\n    ResolvableType resolvableType\u003dResolvableType.forClassWithGenerics(List.class,EndpointNameAndNamespace.class);\n    await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(240)).until(() -\u003e {\n      List\u003cEndpointNameAndNamespace\u003e result\u003d(List\u003cEndpointNameAndNamespace\u003e)client.method(HttpMethod.GET).retrieve().bodyToMono(ParameterizedTypeReference.forType(resolvableType.getType())).retryWhen(retrySpec()).block();\n      if (result !\u003d null) {\n        holder[0]\u003dresult.get(0);\n        holder[1]\u003dresult.get(1);\n        return true;\n      }\n      return false;\n    }\n);\n    EndpointNameAndNamespace resultOne\u003dholder[0];\n    EndpointNameAndNamespace resultTwo\u003dholder[1];\n    Assertions.assertNotNull(resultOne);\n    Assertions.assertNotNull(resultTwo);\n    Assertions.assertTrue(resultOne.endpointName().contains(\"busybox\"));\n    Assertions.assertTrue(resultTwo.endpointName().contains(\"busybox\"));\n    Assertions.assertEquals(NAMESPACE_A,resultOne.namespace());\n    Assertions.assertEquals(NAMESPACE_A,resultTwo.namespace());\n    util.busybox(NAMESPACE_A,Phase.DELETE);\n    util.busybox(NAMESPACE_B,Phase.DELETE);\n    EndpointNameAndNamespace[] afterDelete\u003dnew EndpointNameAndNamespace[1];\n    await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(240)).until(() -\u003e {\n      List\u003cEndpointNameAndNamespace\u003e result\u003d(List\u003cEndpointNameAndNamespace\u003e)client.method(HttpMethod.GET).retrieve().bodyToMono(ParameterizedTypeReference.forType(resolvableType.getType())).retryWhen(retrySpec()).block();\n      if (result !\u003d null \u0026\u0026 result.size() !\u003d 1) {\n        return false;\n      }\n      if (result !\u003d null) {\n        afterDelete[0]\u003dresult.get(0);\n        return true;\n      }\n      return false;\n    }\n);\n    Assertions.assertTrue(afterDelete[0].endpointName().contains(APP_NAME));\n    Assertions.assertEquals(\"default\",afterDelete[0].namespace());\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class Fabric8CatalogWatchWithNamespacesDelegate {\n  private Fabric8CatalogWatchWithNamespacesDelegate();\n  private static final String APP_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-catalog-watcher\";\n  /** \n * \u003cpre\u003e - we deploy one busybox service with 2 replica pods in namespace namespacea - we deploy one busybox service with 2 replica pods in namespace namespaceb - we enable the search to be made in namespacea and default ones - we receive an event from KubernetesCatalogWatcher, assert what is inside it - delete both busybox services in namespacea and namespaceb - assert that we receive only spring-cloud-kubernetes-fabric8-client-catalog-watcher pod \u003c/pre\u003e\n */\n  static void testCatalogWatchWithNamespaceFilterAndEndpoints(  K3sContainer container,  String imageName,  Util util);\n  static void testCatalogWatchWithNamespaceFilterAndEndpointSlices(  K3sContainer container,  String imageName,  Util util);\n  /** \n * the test is the same for both endpoints and endpoint slices, the set-up for them is different.\n */\n  @SuppressWarnings(\"unchecked\") private static void test(  Util util);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-catalog-watcher/src/test/java/org/springframework/cloud/kubernetes/fabric8/catalog/watch/Fabric8CatalogWatchUtil.java",
        "name": "Fabric8CatalogWatchUtil",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.catalog.watch.Fabric8CatalogWatchUtil",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class Fabric8CatalogWatchUtil {\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-cloud-kubernetes-fabric8-client-catalog-watcher\");\n  private Fabric8CatalogWatchUtil(){\n  }\n  static final String BODY_ONE\u003dnull;\n  static final String BODY_TWO\u003dnull;\n  static final String BODY_THREE\u003dnull;\n  static void patchForEndpointSlices(  Util util,  String dockerImage,  String deploymentName,  String namespace){\n    util.patchWithReplace(dockerImage,deploymentName,namespace,BODY_ONE,POD_LABELS);\n  }\n  static void patchForNamespaceFilterAndEndpoints(  Util util,  String dockerImage,  String deploymentName,  String namespace){\n    util.patchWithReplace(dockerImage,deploymentName,namespace,BODY_TWO,POD_LABELS);\n  }\n  static void patchForNamespaceFilterAndEndpointSlices(  Util util,  String dockerImage,  String deploymentName,  String namespace){\n    util.patchWithReplace(dockerImage,deploymentName,namespace,BODY_THREE,POD_LABELS);\n  }\n  static WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  static RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(15,Duration.ofSeconds(1)).filter(Objects::nonNull);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class Fabric8CatalogWatchUtil {\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-cloud-kubernetes-fabric8-client-catalog-watcher\");\n  private Fabric8CatalogWatchUtil();\n  static final String BODY_ONE\u003dnull;\n  static final String BODY_TWO\u003dnull;\n  static final String BODY_THREE\u003dnull;\n  static void patchForEndpointSlices(  Util util,  String dockerImage,  String deploymentName,  String namespace);\n  static void patchForNamespaceFilterAndEndpoints(  Util util,  String dockerImage,  String deploymentName,  String namespace);\n  static void patchForNamespaceFilterAndEndpointSlices(  Util util,  String dockerImage,  String deploymentName,  String namespace);\n  static WebClient.Builder builder();\n  static RetryBackoffSpec retrySpec();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-reload/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/reload/RightProperties.java",
        "name": "RightProperties",
        "modifiers": "@ConfigurationProperties(\"right\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.reload.RightProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"right\") public class RightProperties {\n  private String value;\n  public String getValue(){\n    return value;\n  }\n  public void setValue(  String value){\n    this.value\u003dvalue;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"right\") public class RightProperties {\n  private String value;\n  public String getValue();\n  public void setValue(  String value);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-reload/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/reload/App.java",
        "name": "App",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({LeftProperties.class,RightProperties.class,RightWithLabelsProperties.class,ConfigMapProperties.class,SecretProperties.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.reload.App",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties({LeftProperties.class,RightProperties.class,RightWithLabelsProperties.class,ConfigMapProperties.class,SecretProperties.class}) public class App {\n  public static void main(  String[] args){\n    SpringApplication.run(App.class,args);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties({LeftProperties.class,RightProperties.class,RightWithLabelsProperties.class,ConfigMapProperties.class,SecretProperties.class}) public class App {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-reload/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/reload/LeftProperties.java",
        "name": "LeftProperties",
        "modifiers": "@ConfigurationProperties(\"left\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.reload.LeftProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"left\") public class LeftProperties {\n  private String value;\n  public String getValue(){\n    return value;\n  }\n  public void setValue(  String value){\n    this.value\u003dvalue;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"left\") public class LeftProperties {\n  private String value;\n  public String getValue();\n  public void setValue(  String value);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-reload/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/reload/RightWithLabelsProperties.java",
        "name": "RightWithLabelsProperties",
        "modifiers": "@ConfigurationProperties(\"right.with.label\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.reload.RightWithLabelsProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"right.with.label\") public class RightWithLabelsProperties {\n  private String value;\n  public String getValue(){\n    return value;\n  }\n  public void setValue(  String value){\n    this.value\u003dvalue;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"right.with.label\") public class RightWithLabelsProperties {\n  private String value;\n  public String getValue();\n  public void setValue(  String value);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-reload/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/reload/SecretProperties.java",
        "name": "SecretProperties",
        "modifiers": "@ConfigurationProperties(\"from.secret.properties\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.reload.SecretProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"from.secret.properties\") public class SecretProperties {\n  private String key;\n  public String getKey(){\n    return key;\n  }\n  public void setKey(  String key){\n    this.key\u003dkey;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"from.secret.properties\") public class SecretProperties {\n  private String key;\n  public String getKey();\n  public void setKey(  String key);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-reload/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/reload/ConfigMapProperties.java",
        "name": "ConfigMapProperties",
        "modifiers": "@ConfigurationProperties(\"from.properties\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.reload.ConfigMapProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"from.properties\") public class ConfigMapProperties {\n  private String key;\n  public String getKey(){\n    return key;\n  }\n  public void setKey(  String key1){\n    this.key\u003dkey1;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"from.properties\") public class ConfigMapProperties {\n  private String key;\n  public String getKey();\n  public void setKey(  String key1);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-reload/src/main/java/org/springframework/cloud/kubernetes/fabric8/client/reload/Controller.java",
        "name": "Controller",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.reload.Controller",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController public class Controller {\n  private final LeftProperties leftProperties;\n  private final RightProperties rightProperties;\n  private final RightWithLabelsProperties rightWithLabelsProperties;\n  private final ConfigMapProperties configMapProperties;\n  private final SecretProperties secretProperties;\n  public Controller(  LeftProperties leftProperties,  RightProperties rightProperties,  RightWithLabelsProperties rightWithLabelsProperties,  ConfigMapProperties configMapProperties,  SecretProperties secretProperties){\n    this.leftProperties\u003dleftProperties;\n    this.rightProperties\u003drightProperties;\n    this.rightWithLabelsProperties\u003drightWithLabelsProperties;\n    this.configMapProperties\u003dconfigMapProperties;\n    this.secretProperties\u003dsecretProperties;\n  }\n  @GetMapping(\"/left\") public String left(){\n    return leftProperties.getValue();\n  }\n  @GetMapping(\"/right\") public String right(){\n    return rightProperties.getValue();\n  }\n  @GetMapping(\"/with-label\") public String witLabel(){\n    return rightWithLabelsProperties.getValue();\n  }\n  @GetMapping(\"/key\") public String key(){\n    return configMapProperties.getKey();\n  }\n  @GetMapping(\"/key-from-secret\") public String keyFromSecret(){\n    return secretProperties.getKey();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController public class Controller {\n  private final LeftProperties leftProperties;\n  private final RightProperties rightProperties;\n  private final RightWithLabelsProperties rightWithLabelsProperties;\n  private final ConfigMapProperties configMapProperties;\n  private final SecretProperties secretProperties;\n  public Controller(  LeftProperties leftProperties,  RightProperties rightProperties,  RightWithLabelsProperties rightWithLabelsProperties,  ConfigMapProperties configMapProperties,  SecretProperties secretProperties);\n  @GetMapping(\"/left\") public String left();\n  @GetMapping(\"/right\") public String right();\n  @GetMapping(\"/with-label\") public String witLabel();\n  @GetMapping(\"/key\") public String key();\n  @GetMapping(\"/key-from-secret\") public String keyFromSecret();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-reload/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/reload/ConfigMapMountPollingReloadDelegate.java",
        "name": "ConfigMapMountPollingReloadDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.reload.ConfigMapMountPollingReloadDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class ConfigMapMountPollingReloadDelegate {\n  /** \n * \u003cpre\u003e - we have \"spring.config.import: kubernetes\", which means we will \u0027locate\u0027 property sources from config maps. - the property above means that at the moment we will be searching for config maps that only match the application name, in this specific test there is no such config map. - what we will also read, is \u0027spring.cloud.kubernetes.config.paths\u0027, which we have set to \u0027/tmp/application.properties\u0027 in this test. That is populated by the volumeMounts (see deployment-mount.yaml) - we first assert that we are actually reading the path based source via (1), (2) and (3). - we then change the config map content, wait for k8s to pick it up and replace them - our polling will then detect that change, and trigger a reload. \u003c/pre\u003e\n */\n  static void testConfigMapMountPollingReload(  KubernetesClient client,  Util util,  K3sContainer container,  String appLabelValue){\n    Commons.waitForLogStatement(\"paths property sources : [/tmp/application.properties]\",container,appLabelValue);\n    Commons.waitForLogStatement(\"will add file-based property source : /tmp/application.properties\",container,appLabelValue);\n    WebClient webClient\u003dTestUtil.builder().baseUrl(\"http://localhost/key\").build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n    Assertions.assertEquals(\"as-mount-initial\",result);\n    InputStream configMapStream\u003dutil.inputStream(\"configmap.yaml\");\n    ConfigMap configMap\u003dSerialization.unmarshal(configMapStream,ConfigMap.class);\n    configMap.setData(Map.of(\"application.properties\",\"from.properties.key\u003das-mount-changed\"));\n    client.configMaps().inNamespace(\"default\").resource(configMap).createOrReplace();\n    await().timeout(Duration.ofSeconds(360)).until(() -\u003e webClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block().equals(\"as-mount-changed\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class ConfigMapMountPollingReloadDelegate {\n  /** \n * \u003cpre\u003e - we have \"spring.config.import: kubernetes\", which means we will \u0027locate\u0027 property sources from config maps. - the property above means that at the moment we will be searching for config maps that only match the application name, in this specific test there is no such config map. - what we will also read, is \u0027spring.cloud.kubernetes.config.paths\u0027, which we have set to \u0027/tmp/application.properties\u0027 in this test. That is populated by the volumeMounts (see deployment-mount.yaml) - we first assert that we are actually reading the path based source via (1), (2) and (3). - we then change the config map content, wait for k8s to pick it up and replace them - our polling will then detect that change, and trigger a reload. \u003c/pre\u003e\n */\n  static void testConfigMapMountPollingReload(  KubernetesClient client,  Util util,  K3sContainer container,  String appLabelValue);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-reload/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/reload/TestUtil.java",
        "name": "TestUtil",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.reload.TestUtil",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class TestUtil {\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-cloud-kubernetes-fabric8-client-reload\");\n  private static final String BODY_ONE\u003dnull;\n  private static final String BODY_TWO\u003dnull;\n  private static final String BODY_THREE\u003dnull;\n  private static final String BODY_FOUR\u003dnull;\n  private static final String BODY_FIVE\u003dnull;\n  private static final String BODY_SIX\u003dnull;\n  private static final String BODY_SEVEN\u003dnull;\n  private TestUtil(){\n  }\n  static void reCreateSources(  Util util,  KubernetesClient client){\n    InputStream leftConfigMapStream\u003dutil.inputStream(\"left-configmap.yaml\");\n    InputStream rightConfigMapStream\u003dutil.inputStream(\"right-configmap.yaml\");\n    InputStream configMapStream\u003dutil.inputStream(\"configmap.yaml\");\n    ConfigMap leftConfigMap\u003dSerialization.unmarshal(leftConfigMapStream,ConfigMap.class);\n    ConfigMap rightConfigMap\u003dSerialization.unmarshal(rightConfigMapStream,ConfigMap.class);\n    ConfigMap configMap\u003dSerialization.unmarshal(configMapStream,ConfigMap.class);\n    replaceConfigMap(client,leftConfigMap,\"left\");\n    replaceConfigMap(client,rightConfigMap,\"right\");\n    replaceConfigMap(client,configMap,\"default\");\n  }\n  static void replaceConfigMap(  KubernetesClient client,  ConfigMap configMap,  String namespace){\n    client.configMaps().inNamespace(namespace).resource(configMap).createOrReplace();\n  }\n  static void patchOne(  Util util,  String dockerImage,  String deploymentName,  String namespace){\n    util.patchWithReplace(dockerImage,deploymentName,namespace,BODY_ONE,POD_LABELS);\n  }\n  static void patchTwo(  Util util,  String dockerImage,  String deploymentName,  String namespace){\n    util.patchWithReplace(dockerImage,deploymentName,namespace,BODY_TWO,POD_LABELS);\n  }\n  static void patchThree(  Util util,  String dockerImage,  String deploymentName,  String namespace){\n    util.patchWithReplace(dockerImage,deploymentName,namespace,BODY_THREE,POD_LABELS);\n  }\n  static void patchFour(  Util util,  String dockerImage,  String deploymentName,  String namespace){\n    util.patchWithReplace(dockerImage,deploymentName,namespace,BODY_FOUR,POD_LABELS);\n  }\n  static void patchFive(  Util util,  String dockerImage,  String deploymentName,  String namespace){\n    util.patchWithReplace(dockerImage,deploymentName,namespace,BODY_FIVE,POD_LABELS);\n  }\n  static void patchSix(  Util util,  String dockerImage,  String deploymentName,  String namespace){\n    util.patchWithReplace(dockerImage,deploymentName,namespace,BODY_SIX,POD_LABELS);\n  }\n  static void patchSeven(  Util util,  String dockerImage,  String deploymentName,  String namespace){\n    util.patchWithReplace(dockerImage,deploymentName,namespace,BODY_SEVEN,POD_LABELS);\n  }\n  static WebClient.Builder builder(){\n    return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create()));\n  }\n  static RetryBackoffSpec retrySpec(){\n    return Retry.fixedDelay(120,Duration.ofSeconds(2)).filter(Objects::nonNull);\n  }\n  static String logs(  K3sContainer container,  String appLabelValue){\n    try {\n      String appPodName\u003dcontainer.execInContainer(\"sh\",\"-c\",\"kubectl get pods -l app\u003d\" + appLabelValue + \" -o\u003dname --no-headers | tr -d \u0027\\n\u0027\").getStdout();\n      Container.ExecResult execResult\u003dcontainer.execInContainer(\"sh\",\"-c\",\"kubectl logs \" + appPodName.trim());\n      return execResult.getStdout();\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class TestUtil {\n  private static final Map\u003cString,String\u003e POD_LABELS\u003dMap.of(\"app\",\"spring-cloud-kubernetes-fabric8-client-reload\");\n  private static final String BODY_ONE\u003dnull;\n  private static final String BODY_TWO\u003dnull;\n  private static final String BODY_THREE\u003dnull;\n  private static final String BODY_FOUR\u003dnull;\n  private static final String BODY_FIVE\u003dnull;\n  private static final String BODY_SIX\u003dnull;\n  private static final String BODY_SEVEN\u003dnull;\n  private TestUtil();\n  static void reCreateSources(  Util util,  KubernetesClient client);\n  static void replaceConfigMap(  KubernetesClient client,  ConfigMap configMap,  String namespace);\n  static void patchOne(  Util util,  String dockerImage,  String deploymentName,  String namespace);\n  static void patchTwo(  Util util,  String dockerImage,  String deploymentName,  String namespace);\n  static void patchThree(  Util util,  String dockerImage,  String deploymentName,  String namespace);\n  static void patchFour(  Util util,  String dockerImage,  String deploymentName,  String namespace);\n  static void patchFive(  Util util,  String dockerImage,  String deploymentName,  String namespace);\n  static void patchSix(  Util util,  String dockerImage,  String deploymentName,  String namespace);\n  static void patchSeven(  Util util,  String dockerImage,  String deploymentName,  String namespace);\n  static WebClient.Builder builder();\n  static RetryBackoffSpec retrySpec();\n  static String logs(  K3sContainer container,  String appLabelValue);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-reload/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/reload/BootstrapEnabledPollingReloadConfigMapMountDelegate.java",
        "name": "BootstrapEnabledPollingReloadConfigMapMountDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.reload.BootstrapEnabledPollingReloadConfigMapMountDelegate",
        "extend": "",
        "implements": "",
        "raw": "final class BootstrapEnabledPollingReloadConfigMapMountDelegate {\n  /** \n * \u003cpre\u003e - we have bootstrap enabled, which means we will \u0027locate\u0027 property sources from config maps. - there are no explicit config maps to search for, but what we will also read, is \u0027spring.cloud.kubernetes.config.paths\u0027, which we have set to \u0027/tmp/application.properties\u0027 in this test. That is populated by the volumeMounts (see deployment-mount.yaml) - we first assert that we are actually reading the path based source via (1), (2) and (3). - we then change the config map content, wait for k8s to pick it up and replace them - our polling will then detect that change, and trigger a reload. \u003c/pre\u003e\n */\n  static void testPollingReloadConfigMapWithBootstrap(  KubernetesClient client,  Util util,  K3sContainer container,  String appLabelValue){\n    Commons.waitForLogStatement(\"paths property sources : [/tmp/application.properties]\",container,appLabelValue);\n    Commons.waitForLogStatement(\"will add file-based property source : /tmp/application.properties\",container,appLabelValue);\n    WebClient webClient\u003dTestUtil.builder().baseUrl(\"http://localhost/key\").build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n    Assertions.assertEquals(\"as-mount-initial\",result);\n    InputStream configMapStream\u003dutil.inputStream(\"configmap.yaml\");\n    ConfigMap configMap\u003dSerialization.unmarshal(configMapStream,ConfigMap.class);\n    configMap.setData(Map.of(\"application.properties\",\"from.properties.key\u003das-mount-changed\"));\n    client.configMaps().inNamespace(\"default\").resource(configMap).createOrReplace();\n    await().timeout(Duration.ofSeconds(360)).until(() -\u003e webClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block().equals(\"as-mount-changed\"));\n  }\n}\n",
        "abstract": "final class BootstrapEnabledPollingReloadConfigMapMountDelegate {\n  /** \n * \u003cpre\u003e - we have bootstrap enabled, which means we will \u0027locate\u0027 property sources from config maps. - there are no explicit config maps to search for, but what we will also read, is \u0027spring.cloud.kubernetes.config.paths\u0027, which we have set to \u0027/tmp/application.properties\u0027 in this test. That is populated by the volumeMounts (see deployment-mount.yaml) - we first assert that we are actually reading the path based source via (1), (2) and (3). - we then change the config map content, wait for k8s to pick it up and replace them - our polling will then detect that change, and trigger a reload. \u003c/pre\u003e\n */\n  static void testPollingReloadConfigMapWithBootstrap(  KubernetesClient client,  Util util,  K3sContainer container,  String appLabelValue);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-reload/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/reload/Fabric8EventReloadIT.java",
        "name": "Fabric8EventReloadIT",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.reload.Fabric8EventReloadIT",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass Fabric8EventReloadIT {\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-reload\";\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + IMAGE_NAME + \":\"+ pomVersion();\n  private static final String NAMESPACE\u003d\"default\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  private static KubernetesClient client;\n  @BeforeAll static void beforeAll() throws Exception {\n    K3S.start();\n    Commons.validateImage(IMAGE_NAME,K3S);\n    Commons.loadSpringCloudKubernetesImage(IMAGE_NAME,K3S);\n    util\u003dnew Util(K3S);\n    client\u003dutil.client();\n    util.createNamespace(\"left\");\n    util.createNamespace(\"right\");\n    util.setUpClusterWide(NAMESPACE,Set.of(\"left\",\"right\"));\n    util.setUp(NAMESPACE);\n    manifests(Phase.CREATE);\n  }\n  @AfterAll static void afterAll() throws Exception {\n    util.deleteNamespace(\"left\");\n    util.deleteNamespace(\"right\");\n    Commons.cleanUp(IMAGE_NAME,K3S);\n    Commons.systemPrune();\n    manifests(Phase.DELETE);\n  }\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right - each of the namespaces has one configmap - we watch the \"left\" namespace, but make a change in the configmap in the right namespace - as such, no event is triggered and \"left-configmap\" stays as-is \u003c/pre\u003e\n */\n  @Test void testInformFromOneNamespaceEventNotTriggered(){\n    Commons.assertReloadLogStatements(\"added configmap informer for namespace\",\"added secret informer for namespace\",IMAGE_NAME);\n    WebClient webClient\u003dTestUtil.builder().baseUrl(\"http://localhost/left\").build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n    Assertions.assertEquals(\"left-initial\",result);\n    webClient\u003dTestUtil.builder().baseUrl(\"http://localhost/right\").build();\n    result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n    Assertions.assertEquals(\"right-initial\",result);\n    ConfigMap rightConfigMapAfterChange\u003dnew ConfigMapBuilder().withMetadata(new ObjectMetaBuilder().withNamespace(\"right\").withName(\"right-configmap\").build()).withData(Map.of(\"right.value\",\"right-after-change\")).build();\n    TestUtil.replaceConfigMap(client,rightConfigMapAfterChange,\"right\");\n    webClient\u003dTestUtil.builder().baseUrl(\"http://localhost/left\").build();\n    WebClient finalWebClient\u003dwebClient;\n    await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(30)).until(() -\u003e {\n      String innerResult\u003dfinalWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n      return \"left-initial\".equals(innerResult);\n    }\n);\n    testInformFromOneNamespaceEventTriggered();\n    testInform();\n    testInformFromOneNamespaceEventTriggeredSecretsDisabled();\n    testDataChangesInConfigMap();\n    testConfigMapMountPollingReload();\n    testPollingReloadConfigMapWithBootstrap();\n    testSecretReload();\n  }\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right - each of the namespaces has one configmap - we watch the \"right\" namespace and make a change in the configmap in the same namespace - as such, event is triggered and we see the updated value \u003c/pre\u003e\n */\n  void testInformFromOneNamespaceEventTriggered(){\n    TestUtil.reCreateSources(util,client);\n    TestUtil.patchOne(util,DOCKER_IMAGE,IMAGE_NAME,NAMESPACE);\n    Commons.assertReloadLogStatements(\"added configmap informer for namespace\",\"added secret informer for namespace\",IMAGE_NAME);\n    WebClient webClient\u003dTestUtil.builder().baseUrl(\"http://localhost/right\").build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n    Assertions.assertEquals(\"right-initial\",result);\n    ConfigMap rightConfigMapAfterChange\u003dnew ConfigMapBuilder().withMetadata(new ObjectMetaBuilder().withNamespace(\"right\").withName(\"right-configmap\").build()).withData(Map.of(\"right.value\",\"right-after-change\")).build();\n    TestUtil.replaceConfigMap(client,rightConfigMapAfterChange,\"right\");\n    String[] resultAfterChange\u003dnew String[1];\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dTestUtil.builder().baseUrl(\"http://localhost/right\").build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n      resultAfterChange[0]\u003dinnerResult;\n      return innerResult !\u003d null;\n    }\n);\n    Assertions.assertEquals(\"right-after-change\",resultAfterChange[0]);\n  }\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right (though we do not care about the left one) - left has one configmap : left-configmap - right has two configmaps: right-configmap, right-configmap-with-label - we watch the \"right\" namespace, but enable tagging; which means that only right-configmap-with-label triggers changes. \u003c/pre\u003e\n */\n  void testInform(){\n    TestUtil.reCreateSources(util,client);\n    TestUtil.patchTwo(util,DOCKER_IMAGE,IMAGE_NAME,NAMESPACE);\n    Commons.assertReloadLogStatements(\"added configmap informer for namespace\",\"added secret informer for namespace\",IMAGE_NAME);\n    WebClient rightWebClient\u003dTestUtil.builder().baseUrl(\"http://localhost/right\").build();\n    String rightResult\u003drightWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n    Assertions.assertEquals(\"right-initial\",rightResult);\n    WebClient rightWithLabelWebClient\u003dTestUtil.builder().baseUrl(\"http://localhost/with-label\").build();\n    String rightWithLabelResult\u003drightWithLabelWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n    Assertions.assertEquals(\"right-with-label-initial\",rightWithLabelResult);\n    ConfigMap rightConfigMapAfterChange\u003dnew ConfigMapBuilder().withMetadata(new ObjectMetaBuilder().withNamespace(\"right\").withName(\"right-configmap\").build()).withData(Map.of(\"right.value\",\"right-after-change\")).build();\n    TestUtil.replaceConfigMap(client,rightConfigMapAfterChange,\"right\");\n    await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(30)).until(() -\u003e {\n      String innerRightResult\u003drightWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n      return \"right-initial\".equals(innerRightResult);\n    }\n);\n    ConfigMap rightWithLabelConfigMapAfterChange\u003dnew ConfigMapBuilder().withMetadata(new ObjectMetaBuilder().withNamespace(\"right\").withName(\"right-configmap-with-label\").build()).withData(Map.of(\"right.with.label.value\",\"right-with-label-after-change\")).build();\n    TestUtil.replaceConfigMap(client,rightWithLabelConfigMapAfterChange,\"right\");\n    String[] resultAfterChange\u003dnew String[1];\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dTestUtil.builder().baseUrl(\"http://localhost/with-label\").build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n      resultAfterChange[0]\u003dinnerResult;\n      return innerResult !\u003d null;\n    }\n);\n    Assertions.assertEquals(\"right-with-label-after-change\",resultAfterChange[0]);\n    rightResult\u003drightWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n    Assertions.assertEquals(\"right-after-change\",rightResult);\n  }\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right - each of the namespaces has one configmap - secrets are disabled - we watch the \"right\" namespace and make a change in the configmap in the same namespace - as such, event is triggered and we see the updated value \u003c/pre\u003e\n */\n  void testInformFromOneNamespaceEventTriggeredSecretsDisabled(){\n    TestUtil.reCreateSources(util,client);\n    TestUtil.patchThree(util,DOCKER_IMAGE,IMAGE_NAME,NAMESPACE);\n    Commons.assertReloadLogStatements(\"added configmap informer for namespace\",\"added secret informer for namespace\",IMAGE_NAME);\n    WebClient webClient\u003dTestUtil.builder().baseUrl(\"http://localhost/right\").build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n    Assertions.assertEquals(\"right-initial\",result);\n    ConfigMap rightConfigMapAfterChange\u003dnew ConfigMapBuilder().withMetadata(new ObjectMetaBuilder().withNamespace(\"right\").withName(\"right-configmap\").build()).withData(Map.of(\"right.value\",\"right-after-change\")).build();\n    TestUtil.replaceConfigMap(client,rightConfigMapAfterChange,\"right\");\n    String[] resultAfterChange\u003dnew String[1];\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dTestUtil.builder().baseUrl(\"http://localhost/right\").build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(TestUtil.retrySpec()).block();\n      resultAfterChange[0]\u003dinnerResult;\n      return innerResult !\u003d null;\n    }\n);\n    Assertions.assertEquals(\"right-after-change\",resultAfterChange[0]);\n  }\n  void testDataChangesInConfigMap(){\n    TestUtil.reCreateSources(util,client);\n    TestUtil.patchFour(util,DOCKER_IMAGE,IMAGE_NAME,NAMESPACE);\n    DataChangesInConfigMapReloadDelegate.testDataChangesInConfigMap(client,K3S,IMAGE_NAME);\n  }\n  void testConfigMapMountPollingReload(){\n    TestUtil.reCreateSources(util,client);\n    TestUtil.patchFive(util,DOCKER_IMAGE,IMAGE_NAME,NAMESPACE);\n    ConfigMapMountPollingReloadDelegate.testConfigMapMountPollingReload(client,util,K3S,IMAGE_NAME);\n  }\n  void testPollingReloadConfigMapWithBootstrap(){\n    TestUtil.reCreateSources(util,client);\n    TestUtil.patchSix(util,DOCKER_IMAGE,IMAGE_NAME,NAMESPACE);\n    BootstrapEnabledPollingReloadConfigMapMountDelegate.testPollingReloadConfigMapWithBootstrap(client,util,K3S,IMAGE_NAME);\n  }\n  void testSecretReload(){\n    TestUtil.patchSeven(util,DOCKER_IMAGE,IMAGE_NAME,NAMESPACE);\n    SecretsEventsReloadDelegate.testSecretReload(client,K3S,IMAGE_NAME);\n  }\n  private static void manifests(  Phase phase){\n    InputStream deploymentStream\u003dutil.inputStream(\"deployment.yaml\");\n    InputStream serviceStream\u003dutil.inputStream(\"service.yaml\");\n    InputStream ingressStream\u003dutil.inputStream(\"ingress.yaml\");\n    InputStream leftConfigMapStream\u003dutil.inputStream(\"left-configmap.yaml\");\n    InputStream rightConfigMapStream\u003dutil.inputStream(\"right-configmap.yaml\");\n    InputStream rightWithLabelConfigMapStream\u003dutil.inputStream(\"right-configmap-with-label.yaml\");\n    InputStream configMapAsStream\u003dutil.inputStream(\"configmap.yaml\");\n    InputStream secretAsStream\u003dutil.inputStream(\"secret.yaml\");\n    Deployment deployment\u003dSerialization.unmarshal(deploymentStream,Deployment.class);\n    Service service\u003dSerialization.unmarshal(serviceStream,Service.class);\n    Ingress ingress\u003dSerialization.unmarshal(ingressStream,Ingress.class);\n    ConfigMap leftConfigMap\u003dSerialization.unmarshal(leftConfigMapStream,ConfigMap.class);\n    ConfigMap rightConfigMap\u003dSerialization.unmarshal(rightConfigMapStream,ConfigMap.class);\n    ConfigMap rightWithLabelConfigMap\u003dSerialization.unmarshal(rightWithLabelConfigMapStream,ConfigMap.class);\n    ConfigMap configMap\u003dSerialization.unmarshal(configMapAsStream,ConfigMap.class);\n    Secret secret\u003dSerialization.unmarshal(secretAsStream,Secret.class);\n    if (phase.equals(Phase.CREATE)) {\n      util.createAndWait(\"left\",leftConfigMap,null);\n      util.createAndWait(\"right\",rightConfigMap,null);\n      util.createAndWait(\"right\",rightWithLabelConfigMap,null);\n      util.createAndWait(NAMESPACE,configMap,secret);\n      util.createAndWait(NAMESPACE,null,deployment,service,ingress,true);\n    }\n else {\n      util.deleteAndWait(\"left\",leftConfigMap,null);\n      util.deleteAndWait(\"right\",rightConfigMap,null);\n      util.deleteAndWait(\"right\",rightWithLabelConfigMap,null);\n      util.deleteAndWait(NAMESPACE,configMap,secret);\n      util.deleteAndWait(NAMESPACE,deployment,service,ingress);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass Fabric8EventReloadIT {\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-reload\";\n  private static final String DOCKER_IMAGE\u003d\"docker.io/springcloud/\" + IMAGE_NAME + \":\"+ pomVersion();\n  private static final String NAMESPACE\u003d\"default\";\n  private static final K3sContainer K3S\u003dCommons.container();\n  private static Util util;\n  private static KubernetesClient client;\n  @BeforeAll static void beforeAll() throws Exception;\n  @AfterAll static void afterAll() throws Exception;\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right - each of the namespaces has one configmap - we watch the \"left\" namespace, but make a change in the configmap in the right namespace - as such, no event is triggered and \"left-configmap\" stays as-is \u003c/pre\u003e\n */\n  @Test void testInformFromOneNamespaceEventNotTriggered();\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right - each of the namespaces has one configmap - we watch the \"right\" namespace and make a change in the configmap in the same namespace - as such, event is triggered and we see the updated value \u003c/pre\u003e\n */\n  void testInformFromOneNamespaceEventTriggered();\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right (though we do not care about the left one) - left has one configmap : left-configmap - right has two configmaps: right-configmap, right-configmap-with-label - we watch the \"right\" namespace, but enable tagging; which means that only right-configmap-with-label triggers changes. \u003c/pre\u003e\n */\n  void testInform();\n  /** \n * \u003cpre\u003e - there are two namespaces : left and right - each of the namespaces has one configmap - secrets are disabled - we watch the \"right\" namespace and make a change in the configmap in the same namespace - as such, event is triggered and we see the updated value \u003c/pre\u003e\n */\n  void testInformFromOneNamespaceEventTriggeredSecretsDisabled();\n  void testDataChangesInConfigMap();\n  void testConfigMapMountPollingReload();\n  void testPollingReloadConfigMapWithBootstrap();\n  void testSecretReload();\n  private static void manifests(  Phase phase);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-reload/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/reload/DataChangesInConfigMapReloadDelegate.java",
        "name": "DataChangesInConfigMapReloadDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.reload.DataChangesInConfigMapReloadDelegate",
        "extend": "",
        "implements": "",
        "raw": "final class DataChangesInConfigMapReloadDelegate {\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-reload\";\n  private static final String LEFT_NAMESPACE\u003d\"left\";\n  /** \n * \u003cpre\u003e - configMap with no labels and data: left.value \u003d left-initial exists in namespace left - we assert that we can read it correctly first, by invoking localhost/left - then we change the configmap by adding a label, this in turn does not change the result of localhost/left, because the data has not changed. - then we change data inside the config map, and we must see the updated value \u003c/pre\u003e\n */\n  static void testDataChangesInConfigMap(  KubernetesClient client,  K3sContainer container,  String appLabelValue){\n    Commons.assertReloadLogStatements(\"added configmap informer for namespace\",\"added secret informer for namespace\",IMAGE_NAME);\n    WebClient webClient\u003dbuilder().baseUrl(\"http://localhost/\" + LEFT_NAMESPACE).build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(\"left-initial\",result);\n    ConfigMap configMap\u003dnew ConfigMapBuilder().withMetadata(new ObjectMetaBuilder().withLabels(Map.of(\"new-label\",\"abc\")).withNamespace(\"left\").withName(\"left-configmap\").build()).withData(Map.of(\"left.value\",\"left-initial\")).build();\n    replaceConfigMap(client,configMap,\"left\");\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dbuilder().baseUrl(\"http://localhost/\" + LEFT_NAMESPACE).build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n      return \"left-initial\".equals(innerResult);\n    }\n);\n    String logs\u003dlogs(container,appLabelValue);\n    Assertions.assertTrue(logs.contains(\"ConfigMap left-configmap was updated in namespace left\"));\n    Assertions.assertTrue(logs.contains(\"data in configmap has not changed, will not reload\"));\n    configMap\u003dnew ConfigMapBuilder().withMetadata(new ObjectMetaBuilder().withLabels(Map.of(\"new-label\",\"abc\")).withNamespace(\"left\").withName(\"left-configmap\").build()).withData(Map.of(\"left.value\",\"left-after-change\")).build();\n    replaceConfigMap(client,configMap,\"left\");\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dbuilder().baseUrl(\"http://localhost/\" + LEFT_NAMESPACE).build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n      return \"left-after-change\".equals(innerResult);\n    }\n);\n  }\n}\n",
        "abstract": "final class DataChangesInConfigMapReloadDelegate {\n  private static final String IMAGE_NAME\u003d\"spring-cloud-kubernetes-fabric8-client-reload\";\n  private static final String LEFT_NAMESPACE\u003d\"left\";\n  /** \n * \u003cpre\u003e - configMap with no labels and data: left.value \u003d left-initial exists in namespace left - we assert that we can read it correctly first, by invoking localhost/left - then we change the configmap by adding a label, this in turn does not change the result of localhost/left, because the data has not changed. - then we change data inside the config map, and we must see the updated value \u003c/pre\u003e\n */\n  static void testDataChangesInConfigMap(  KubernetesClient client,  K3sContainer container,  String appLabelValue);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-integration-tests/spring-cloud-kubernetes-fabric8-client-reload/src/test/java/org/springframework/cloud/kubernetes/fabric8/client/reload/SecretsEventsReloadDelegate.java",
        "name": "SecretsEventsReloadDelegate",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.client.reload.SecretsEventsReloadDelegate",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class SecretsEventsReloadDelegate {\n  /** \n * \u003cpre\u003e - secret with no labels and data: from.secret.properties.key \u003d secret-initial exists in namespace default - we assert that we can read it correctly first, by invoking localhost/key. - then we change the secret by adding a label, this in turn does not change the result of localhost/key, because the data has not changed. - then we change data inside the secret, and we must see the updated value. \u003c/pre\u003e\n */\n  static void testSecretReload(  KubernetesClient client,  K3sContainer container,  String appLabelValue){\n    Commons.assertReloadLogStatements(\"added secret informer for namespace\",\"added configmap informer for namespace\",appLabelValue);\n    WebClient webClient\u003dbuilder().baseUrl(\"http://localhost/key-from-secret\").build();\n    String result\u003dwebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n    Assertions.assertEquals(\"secret-initial\",result);\n    Secret secret\u003dnew SecretBuilder().withMetadata(new ObjectMetaBuilder().withLabels(Map.of(\"letter\",\"a\")).withNamespace(\"default\").withName(\"event-reload\").build()).withData(Map.of(\"application.properties\",Base64.getEncoder().encodeToString(\"from.secret.properties.key\u003dsecret-initial\".getBytes()))).build();\n    client.secrets().inNamespace(\"default\").resource(secret).createOrReplace();\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dbuilder().baseUrl(\"http://localhost/key-from-secret\").build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n      return \"secret-initial\".equals(innerResult);\n    }\n);\n    Commons.waitForLogStatement(\"Secret event-reload was updated in namespace default\",container,appLabelValue);\n    Commons.waitForLogStatement(\"data in secret has not changed, will not reload\",container,appLabelValue);\n    secret\u003dnew SecretBuilder().withMetadata(new ObjectMetaBuilder().withNamespace(\"default\").withName(\"event-reload\").build()).withData(Map.of(\"application.properties\",Base64.getEncoder().encodeToString(\"from.secret.properties.key\u003dsecret-initial-changed\".getBytes()))).build();\n    client.secrets().inNamespace(\"default\").resource(secret).createOrReplace();\n    await().pollInterval(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(90)).until(() -\u003e {\n      WebClient innerWebClient\u003dbuilder().baseUrl(\"http://localhost/key-from-secret\").build();\n      String innerResult\u003dinnerWebClient.method(HttpMethod.GET).retrieve().bodyToMono(String.class).retryWhen(retrySpec()).block();\n      return \"secret-initial-changed\".equals(innerResult);\n    }\n);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class SecretsEventsReloadDelegate {\n  /** \n * \u003cpre\u003e - secret with no labels and data: from.secret.properties.key \u003d secret-initial exists in namespace default - we assert that we can read it correctly first, by invoking localhost/key. - then we change the secret by adding a label, this in turn does not change the result of localhost/key, because the data has not changed. - then we change data inside the secret, and we must see the updated value. \u003c/pre\u003e\n */\n  static void testSecretReload(  KubernetesClient client,  K3sContainer container,  String appLabelValue);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientConfigMapPropertySource.java",
        "name": "KubernetesClientConfigMapPropertySource",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientConfigMapPropertySource",
        "extend": "SourceDataEntriesProcessor",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\npublic class KubernetesClientConfigMapPropertySource extends SourceDataEntriesProcessor {\n  private static final EnumMap\u003cNormalizedSourceType,KubernetesClientContextToSourceData\u003e STRATEGIES\u003dnew EnumMap\u003c\u003e(NormalizedSourceType.class);\nstatic {\n    STRATEGIES.put(NormalizedSourceType.NAMED_CONFIG_MAP,namedConfigMap());\n    STRATEGIES.put(NormalizedSourceType.LABELED_CONFIG_MAP,labeledConfigMap());\n  }\n  public KubernetesClientConfigMapPropertySource(  KubernetesClientConfigContext context){\n    super(getSourceData(context));\n  }\n  private static SourceData getSourceData(  KubernetesClientConfigContext context){\n    NormalizedSourceType type\u003dcontext.normalizedSource().type();\n    return Optional.ofNullable(STRATEGIES.get(type)).map(x -\u003e x.apply(context)).orElseThrow(() -\u003e new IllegalArgumentException(\"no strategy found for : \" + type));\n  }\n  private static KubernetesClientContextToSourceData namedConfigMap(){\n    return new NamedConfigMapContextToSourceDataProvider().get();\n  }\n  private static KubernetesClientContextToSourceData labeledConfigMap(){\n    return new LabeledConfigMapContextToSourceDataProvider().get();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\npublic class KubernetesClientConfigMapPropertySource extends SourceDataEntriesProcessor {\n  private static final EnumMap\u003cNormalizedSourceType,KubernetesClientContextToSourceData\u003e STRATEGIES\u003dnew EnumMap\u003c\u003e(NormalizedSourceType.class);\nstatic {\n    STRATEGIES.put(NormalizedSourceType.NAMED_CONFIG_MAP,namedConfigMap());\n    STRATEGIES.put(NormalizedSourceType.LABELED_CONFIG_MAP,labeledConfigMap());\n  }\n  public KubernetesClientConfigMapPropertySource(  KubernetesClientConfigContext context);\n  private static SourceData getSourceData(  KubernetesClientConfigContext context);\n  private static KubernetesClientContextToSourceData namedConfigMap();\n  private static KubernetesClientContextToSourceData labeledConfigMap();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientConfigDataLocationResolver.java",
        "name": "KubernetesClientConfigDataLocationResolver",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientConfigDataLocationResolver",
        "extend": "KubernetesConfigDataLocationResolver",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientConfigDataLocationResolver extends KubernetesConfigDataLocationResolver {\n  public KubernetesClientConfigDataLocationResolver(  DeferredLogFactory factory){\n    super(factory);\n  }\n  @Override protected void registerBeans(  ConfigDataLocationResolverContext resolverContext,  ConfigDataLocation location,  Profiles profiles,  KubernetesConfigDataLocationResolver.PropertyHolder propertyHolder,  KubernetesNamespaceProvider namespaceProvider){\n    KubernetesClientProperties kubernetesClientProperties\u003dpropertyHolder.kubernetesClientProperties();\n    ConfigMapConfigProperties configMapProperties\u003dpropertyHolder.configMapConfigProperties();\n    SecretsConfigProperties secretsProperties\u003dpropertyHolder.secretsProperties();\n    ConfigurableBootstrapContext bootstrapContext\u003dresolverContext.getBootstrapContext();\n    CoreV1Api coreV1Api\u003dregisterClientAndCoreV1Api(bootstrapContext,kubernetesClientProperties);\n    if (configMapProperties !\u003d null \u0026\u0026 configMapProperties.enabled()) {\n      ConfigMapPropertySourceLocator configMapPropertySourceLocator\u003dnew KubernetesClientConfigMapPropertySourceLocator(coreV1Api,configMapProperties,namespaceProvider);\n      if (isRetryEnabledForConfigMap(configMapProperties)) {\n        configMapPropertySourceLocator\u003dnew ConfigDataRetryableConfigMapPropertySourceLocator(configMapPropertySourceLocator,configMapProperties,new KubernetesClientConfigMapsCache());\n      }\n      registerSingle(bootstrapContext,ConfigMapPropertySourceLocator.class,configMapPropertySourceLocator,\"configDataConfigMapPropertySourceLocator\");\n    }\n    if (secretsProperties !\u003d null \u0026\u0026 secretsProperties.enabled()) {\n      SecretsPropertySourceLocator secretsPropertySourceLocator\u003dnew KubernetesClientSecretsPropertySourceLocator(coreV1Api,namespaceProvider,secretsProperties);\n      if (isRetryEnabledForSecrets(secretsProperties)) {\n        secretsPropertySourceLocator\u003dnew ConfigDataRetryableSecretsPropertySourceLocator(secretsPropertySourceLocator,secretsProperties,new KubernetesClientSecretsCache());\n      }\n      registerSingle(bootstrapContext,SecretsPropertySourceLocator.class,secretsPropertySourceLocator,\"configDataSecretsPropertySourceLocator\");\n    }\n  }\n  private CoreV1Api registerClientAndCoreV1Api(  ConfigurableBootstrapContext bootstrapContext,  KubernetesClientProperties kubernetesClientProperties){\n    ApiClient apiClient\u003dkubernetesApiClient();\n    apiClient.setUserAgent(kubernetesClientProperties.userAgent());\n    registerSingle(bootstrapContext,ApiClient.class,apiClient,\"configDataApiClient\");\n    CoreV1Api coreV1Api\u003dnew CoreV1Api(apiClient);\n    bootstrapContext.registerIfAbsent(CoreV1Api.class,BootstrapRegistry.InstanceSupplier.of(coreV1Api));\n    return coreV1Api;\n  }\n  protected KubernetesNamespaceProvider kubernetesNamespaceProvider(  Environment environment){\n    return new KubernetesNamespaceProvider(environment);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientConfigDataLocationResolver extends KubernetesConfigDataLocationResolver {\n  public KubernetesClientConfigDataLocationResolver(  DeferredLogFactory factory);\n  @Override protected void registerBeans(  ConfigDataLocationResolverContext resolverContext,  ConfigDataLocation location,  Profiles profiles,  KubernetesConfigDataLocationResolver.PropertyHolder propertyHolder,  KubernetesNamespaceProvider namespaceProvider);\n  private CoreV1Api registerClientAndCoreV1Api(  ConfigurableBootstrapContext bootstrapContext,  KubernetesClientProperties kubernetesClientProperties);\n  protected KubernetesNamespaceProvider kubernetesNamespaceProvider(  Environment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientBootstrapConfiguration.java",
        "name": "KubernetesClientBootstrapConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @AutoConfigureAfter(KubernetesBootstrapConfiguration.class) @Import({KubernetesCommonsAutoConfiguration.class,KubernetesClientAutoConfiguration.class}) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientBootstrapConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @AutoConfigureAfter(KubernetesBootstrapConfiguration.class) @Import({KubernetesCommonsAutoConfiguration.class,KubernetesClientAutoConfiguration.class}) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public class KubernetesClientBootstrapConfiguration {\n  @Bean @ConditionalOnKubernetesConfigEnabled @ConditionalOnKubernetesConfigRetryDisabled public KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator(  ConfigMapConfigProperties properties,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    return new KubernetesClientConfigMapPropertySourceLocator(coreV1Api,properties,kubernetesNamespaceProvider);\n  }\n  @Bean @ConditionalOnKubernetesSecretsEnabled @ConditionalOnKubernetesSecretsRetryDisabled public KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator(  SecretsConfigProperties properties,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    return new KubernetesClientSecretsPropertySourceLocator(coreV1Api,kubernetesNamespaceProvider,properties);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @AutoConfigureAfter(KubernetesBootstrapConfiguration.class) @Import({KubernetesCommonsAutoConfiguration.class,KubernetesClientAutoConfiguration.class}) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public class KubernetesClientBootstrapConfiguration {\n  @Bean @ConditionalOnKubernetesConfigEnabled @ConditionalOnKubernetesConfigRetryDisabled public KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator(  ConfigMapConfigProperties properties,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n  @Bean @ConditionalOnKubernetesSecretsEnabled @ConditionalOnKubernetesSecretsRetryDisabled public KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator(  SecretsConfigProperties properties,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientConfigUtils.java",
        "name": "KubernetesClientConfigUtils",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientConfigUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic final class KubernetesClientConfigUtils {\n  private static final Log LOG\u003dLogFactory.getLog(KubernetesClientConfigUtils.class);\n  private static final boolean DECODE\u003dBoolean.FALSE;\n  private KubernetesClientConfigUtils(){\n  }\n  /** \n * finds namespaces to be used for the event based reloading.\n */\n  public static Set\u003cString\u003e namespaces(  KubernetesNamespaceProvider provider,  ConfigReloadProperties properties,  String target){\n    Set\u003cString\u003e namespaces\u003dproperties.namespaces();\n    if (namespaces.isEmpty()) {\n      namespaces\u003dSet.of(getApplicationNamespace(null,target,provider));\n    }\n    LOG.debug(\"informer namespaces : \" + namespaces);\n    return namespaces;\n  }\n  /** \n * \u003cpre\u003e 1. read all secrets in the provided namespace 2. from the above, filter the ones that we care about (filter by labels) 3. with secret names from (2), find out if there are any profile based secrets (if profiles is not empty) 4. concat (2) and (3) and these are the secrets we are interested in 5. see if any of the secrets from (4) has a single yaml/properties file 6. gather all the names of the secrets (from 4) + data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer secretsDataByLabels(  CoreV1Api coreV1Api,  String namespace,  Map\u003cString,String\u003e labels,  Environment environment,  Set\u003cString\u003e profiles){\n    List\u003cStrippedSourceContainer\u003e strippedSecrets\u003dstrippedSecrets(coreV1Api,namespace);\n    if (strippedSecrets.isEmpty()) {\n      return MultipleSourcesContainer.empty();\n    }\n    return ConfigUtils.processLabeledData(strippedSecrets,environment,labels,namespace,profiles,DECODE);\n  }\n  /** \n * \u003cpre\u003e 1. read all config maps in the provided namespace 2. from the above, filter the ones that we care about (filter by labels) 3. with config maps names from (2), find out if there are any profile based ones (if profiles is not empty) 4. concat (2) and (3) and these are the config maps we are interested in 5. see if any from (4) has a single yaml/properties file 6. gather all the names of the config maps (from 4) + data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer configMapsDataByLabels(  CoreV1Api coreV1Api,  String namespace,  Map\u003cString,String\u003e labels,  Environment environment,  Set\u003cString\u003e profiles){\n    List\u003cStrippedSourceContainer\u003e strippedConfigMaps\u003dstrippedConfigMaps(coreV1Api,namespace);\n    if (strippedConfigMaps.isEmpty()) {\n      return MultipleSourcesContainer.empty();\n    }\n    return ConfigUtils.processLabeledData(strippedConfigMaps,environment,labels,namespace,profiles,DECODE);\n  }\n  /** \n * \u003cpre\u003e 1. read all secrets in the provided namespace 2. from the above, filter the ones that we care about (by name) 3. see if any of the secrets has a single yaml/properties file 4. gather all the names of the secrets + decoded data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer secretsDataByName(  CoreV1Api coreV1Api,  String namespace,  LinkedHashSet\u003cString\u003e sourceNames,  Environment environment,  boolean includeDefaultProfileData){\n    List\u003cStrippedSourceContainer\u003e strippedSecrets\u003dstrippedSecrets(coreV1Api,namespace);\n    if (strippedSecrets.isEmpty()) {\n      return MultipleSourcesContainer.empty();\n    }\n    return ConfigUtils.processNamedData(strippedSecrets,environment,sourceNames,namespace,DECODE,includeDefaultProfileData);\n  }\n  /** \n * \u003cpre\u003e 1. read all config maps in the provided namespace 2. from the above, filter the ones that we care about (by name) 3. see if any of the config maps has a single yaml/properties file 4. gather all the names of the config maps + data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer configMapsDataByName(  CoreV1Api coreV1Api,  String namespace,  LinkedHashSet\u003cString\u003e sourceNames,  Environment environment,  boolean includeDefaultProfileData){\n    List\u003cStrippedSourceContainer\u003e strippedConfigMaps\u003dstrippedConfigMaps(coreV1Api,namespace);\n    if (strippedConfigMaps.isEmpty()) {\n      return MultipleSourcesContainer.empty();\n    }\n    return ConfigUtils.processNamedData(strippedConfigMaps,environment,sourceNames,namespace,DECODE,includeDefaultProfileData);\n  }\n  private static List\u003cStrippedSourceContainer\u003e strippedConfigMaps(  CoreV1Api coreV1Api,  String namespace){\n    List\u003cStrippedSourceContainer\u003e strippedConfigMaps\u003dKubernetesClientConfigMapsCache.byNamespace(coreV1Api,namespace);\n    if (strippedConfigMaps.isEmpty()) {\n      LOG.debug(\"No configmaps in namespace \u0027\" + namespace + \"\u0027\");\n    }\n    return strippedConfigMaps;\n  }\n  private static List\u003cStrippedSourceContainer\u003e strippedSecrets(  CoreV1Api coreV1Api,  String namespace){\n    List\u003cStrippedSourceContainer\u003e strippedSecrets\u003dKubernetesClientSecretsCache.byNamespace(coreV1Api,namespace);\n    if (strippedSecrets.isEmpty()) {\n      LOG.debug(\"No configmaps in namespace \u0027\" + namespace + \"\u0027\");\n    }\n    return strippedSecrets;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic final class KubernetesClientConfigUtils {\n  private static final Log LOG\u003dLogFactory.getLog(KubernetesClientConfigUtils.class);\n  private static final boolean DECODE\u003dBoolean.FALSE;\n  private KubernetesClientConfigUtils();\n  /** \n * finds namespaces to be used for the event based reloading.\n */\n  public static Set\u003cString\u003e namespaces(  KubernetesNamespaceProvider provider,  ConfigReloadProperties properties,  String target);\n  /** \n * \u003cpre\u003e 1. read all secrets in the provided namespace 2. from the above, filter the ones that we care about (filter by labels) 3. with secret names from (2), find out if there are any profile based secrets (if profiles is not empty) 4. concat (2) and (3) and these are the secrets we are interested in 5. see if any of the secrets from (4) has a single yaml/properties file 6. gather all the names of the secrets (from 4) + data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer secretsDataByLabels(  CoreV1Api coreV1Api,  String namespace,  Map\u003cString,String\u003e labels,  Environment environment,  Set\u003cString\u003e profiles);\n  /** \n * \u003cpre\u003e 1. read all config maps in the provided namespace 2. from the above, filter the ones that we care about (filter by labels) 3. with config maps names from (2), find out if there are any profile based ones (if profiles is not empty) 4. concat (2) and (3) and these are the config maps we are interested in 5. see if any from (4) has a single yaml/properties file 6. gather all the names of the config maps (from 4) + data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer configMapsDataByLabels(  CoreV1Api coreV1Api,  String namespace,  Map\u003cString,String\u003e labels,  Environment environment,  Set\u003cString\u003e profiles);\n  /** \n * \u003cpre\u003e 1. read all secrets in the provided namespace 2. from the above, filter the ones that we care about (by name) 3. see if any of the secrets has a single yaml/properties file 4. gather all the names of the secrets + decoded data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer secretsDataByName(  CoreV1Api coreV1Api,  String namespace,  LinkedHashSet\u003cString\u003e sourceNames,  Environment environment,  boolean includeDefaultProfileData);\n  /** \n * \u003cpre\u003e 1. read all config maps in the provided namespace 2. from the above, filter the ones that we care about (by name) 3. see if any of the config maps has a single yaml/properties file 4. gather all the names of the config maps + data they hold \u003c/pre\u003e\n */\n  static MultipleSourcesContainer configMapsDataByName(  CoreV1Api coreV1Api,  String namespace,  LinkedHashSet\u003cString\u003e sourceNames,  Environment environment,  boolean includeDefaultProfileData);\n  private static List\u003cStrippedSourceContainer\u003e strippedConfigMaps(  CoreV1Api coreV1Api,  String namespace);\n  private static List\u003cStrippedSourceContainer\u003e strippedSecrets(  CoreV1Api coreV1Api,  String namespace);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientSecretsPropertySource.java",
        "name": "KubernetesClientSecretsPropertySource",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientSecretsPropertySource",
        "extend": "SecretsPropertySource",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\npublic class KubernetesClientSecretsPropertySource extends SecretsPropertySource {\n  @Deprecated(forRemoval\u003dtrue) public KubernetesClientSecretsPropertySource(  SourceData sourceData){\n    super(sourceData);\n  }\n  private static final EnumMap\u003cNormalizedSourceType,KubernetesClientContextToSourceData\u003e STRATEGIES\u003dnew EnumMap\u003c\u003e(NormalizedSourceType.class);\nstatic {\n    STRATEGIES.put(NormalizedSourceType.NAMED_SECRET,namedSecret());\n    STRATEGIES.put(NormalizedSourceType.LABELED_SECRET,labeledSecret());\n  }\n  public KubernetesClientSecretsPropertySource(  KubernetesClientConfigContext context){\n    super(getSourceData(context));\n  }\n  private static SourceData getSourceData(  KubernetesClientConfigContext context){\n    NormalizedSourceType type\u003dcontext.normalizedSource().type();\n    return Optional.ofNullable(STRATEGIES.get(type)).map(x -\u003e x.apply(context)).orElseThrow(() -\u003e new IllegalArgumentException(\"no strategy found for : \" + type));\n  }\n  private static KubernetesClientContextToSourceData namedSecret(){\n    return new NamedSecretContextToSourceDataProvider().get();\n  }\n  private static KubernetesClientContextToSourceData labeledSecret(){\n    return new LabeledSecretContextToSourceDataProvider().get();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\npublic class KubernetesClientSecretsPropertySource extends SecretsPropertySource {\n  @Deprecated(forRemoval\u003dtrue) public KubernetesClientSecretsPropertySource(  SourceData sourceData);\n  private static final EnumMap\u003cNormalizedSourceType,KubernetesClientContextToSourceData\u003e STRATEGIES\u003dnew EnumMap\u003c\u003e(NormalizedSourceType.class);\nstatic {\n    STRATEGIES.put(NormalizedSourceType.NAMED_SECRET,namedSecret());\n    STRATEGIES.put(NormalizedSourceType.LABELED_SECRET,labeledSecret());\n  }\n  public KubernetesClientSecretsPropertySource(  KubernetesClientConfigContext context);\n  private static SourceData getSourceData(  KubernetesClientConfigContext context);\n  private static KubernetesClientContextToSourceData namedSecret();\n  private static KubernetesClientContextToSourceData labeledSecret();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/RetryableKubernetesClientSecretsPropertySourceLocator.java",
        "name": "RetryableKubernetesClientSecretsPropertySourceLocator",
        "modifiers": "@Order(1)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.RetryableKubernetesClientSecretsPropertySourceLocator",
        "extend": "KubernetesClientSecretsPropertySourceLocator",
        "implements": "",
        "raw": "/** \n * SecretsPropertySourceLocator for when retry is enabled.\n * @author Ryan Baxter\n */\n@Order(1) class RetryableKubernetesClientSecretsPropertySourceLocator extends KubernetesClientSecretsPropertySourceLocator {\n  RetryableKubernetesClientSecretsPropertySourceLocator(  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  SecretsConfigProperties secretsConfigProperties){\n    super(coreV1Api,kubernetesNamespaceProvider,secretsConfigProperties);\n  }\n  @Override @Retryable(interceptor\u003d\"kubernetesSecretsRetryInterceptor\") public PropertySource\u003c?\u003e locate(  Environment environment){\n    return super.locate(environment);\n  }\n  @Override @Retryable(interceptor\u003d\"kubernetesSecretsRetryInterceptor\") public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment){\n    return super.locateCollection(environment);\n  }\n}\n",
        "abstract": "/** \n * SecretsPropertySourceLocator for when retry is enabled.\n * @author Ryan Baxter\n */\n@Order(1) class RetryableKubernetesClientSecretsPropertySourceLocator extends KubernetesClientSecretsPropertySourceLocator {\n  RetryableKubernetesClientSecretsPropertySourceLocator(  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  SecretsConfigProperties secretsConfigProperties);\n  @Override @Retryable(interceptor\u003d\"kubernetesSecretsRetryInterceptor\") public PropertySource\u003c?\u003e locate(  Environment environment);\n  @Override @Retryable(interceptor\u003d\"kubernetesSecretsRetryInterceptor\") public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientSecretsPropertySourceLocator.java",
        "name": "KubernetesClientSecretsPropertySourceLocator",
        "modifiers": "@Order(1) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientSecretsPropertySourceLocator",
        "extend": "SecretsPropertySourceLocator",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\n@Order(1) public class KubernetesClientSecretsPropertySourceLocator extends SecretsPropertySourceLocator {\n  private final CoreV1Api coreV1Api;\n  private final KubernetesNamespaceProvider kubernetesNamespaceProvider;\n  public KubernetesClientSecretsPropertySourceLocator(  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  SecretsConfigProperties secretsConfigProperties){\n    super(secretsConfigProperties,new KubernetesClientSecretsCache());\n    this.coreV1Api\u003dcoreV1Api;\n    this.kubernetesNamespaceProvider\u003dkubernetesNamespaceProvider;\n  }\n  @Override protected SecretsPropertySource getPropertySource(  ConfigurableEnvironment environment,  NormalizedSource source){\n    String normalizedNamespace\u003dsource.namespace().orElse(null);\n    String namespace\u003dgetApplicationNamespace(normalizedNamespace,source.target(),kubernetesNamespaceProvider);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(coreV1Api,source,namespace,environment);\n    return new KubernetesClientSecretsPropertySource(context);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\n@Order(1) public class KubernetesClientSecretsPropertySourceLocator extends SecretsPropertySourceLocator {\n  private final CoreV1Api coreV1Api;\n  private final KubernetesNamespaceProvider kubernetesNamespaceProvider;\n  public KubernetesClientSecretsPropertySourceLocator(  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider,  SecretsConfigProperties secretsConfigProperties);\n  @Override protected SecretsPropertySource getPropertySource(  ConfigurableEnvironment environment,  NormalizedSource source);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientConfigMapsCache.java",
        "name": "KubernetesClientConfigMapsCache",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientConfigMapsCache",
        "extend": "",
        "implements": "ConfigMapCache",
        "raw": "/** \n * A cache of V1ConfigMap(s) per namespace. Makes sure we read config maps only once from a namespace.\n * @author wind57\n */\npublic final class KubernetesClientConfigMapsCache implements ConfigMapCache {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientConfigMapsCache.class));\n  /** \n * at the moment our loading of config maps is using a single thread, but might change in the future, thus a thread safe structure.\n */\n  private static final ConcurrentHashMap\u003cString,List\u003cStrippedSourceContainer\u003e\u003e CACHE\u003dnew ConcurrentHashMap\u003c\u003e();\n  @Override public void discardAll(){\n    CACHE.clear();\n  }\n  static List\u003cStrippedSourceContainer\u003e byNamespace(  CoreV1Api coreV1Api,  String namespace){\n    boolean[] b\u003dnew boolean[1];\n    List\u003cStrippedSourceContainer\u003e result\u003dCACHE.computeIfAbsent(namespace,x -\u003e {\n      try {\n        b[0]\u003dtrue;\n        return strippedConfigMaps(coreV1Api.listNamespacedConfigMap(namespace,null,null,null,null,null,null,null,null,null,null,null).getItems());\n      }\n catch (      ApiException apiException) {\n        throw new RuntimeException(apiException.getResponseBody(),apiException);\n      }\n    }\n);\n    if (b[0]) {\n      LOG.debug(() -\u003e \"Loaded all config maps in namespace \u0027\" + namespace + \"\u0027\");\n    }\n else {\n      LOG.debug(() -\u003e \"Loaded (from cache) all config maps in namespace \u0027\" + namespace + \"\u0027\");\n    }\n    return result;\n  }\n  private static List\u003cStrippedSourceContainer\u003e strippedConfigMaps(  List\u003cV1ConfigMap\u003e configMaps){\n    return configMaps.stream().map(configMap -\u003e new StrippedSourceContainer(configMap.getMetadata().getLabels(),configMap.getMetadata().getName(),configMap.getData())).collect(Collectors.toList());\n  }\n}\n",
        "abstract": "/** \n * A cache of V1ConfigMap(s) per namespace. Makes sure we read config maps only once from a namespace.\n * @author wind57\n */\npublic final class KubernetesClientConfigMapsCache implements ConfigMapCache {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientConfigMapsCache.class));\n  /** \n * at the moment our loading of config maps is using a single thread, but might change in the future, thus a thread safe structure.\n */\n  private static final ConcurrentHashMap\u003cString,List\u003cStrippedSourceContainer\u003e\u003e CACHE\u003dnew ConcurrentHashMap\u003c\u003e();\n  @Override public void discardAll();\n  static List\u003cStrippedSourceContainer\u003e byNamespace(  CoreV1Api coreV1Api,  String namespace);\n  private static List\u003cStrippedSourceContainer\u003e strippedConfigMaps(  List\u003cV1ConfigMap\u003e configMaps);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/RetryableKubernetesClientConfigMapPropertySourceLocator.java",
        "name": "RetryableKubernetesClientConfigMapPropertySourceLocator",
        "modifiers": "@Order(0)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.RetryableKubernetesClientConfigMapPropertySourceLocator",
        "extend": "KubernetesClientConfigMapPropertySourceLocator",
        "implements": "",
        "raw": "/** \n * ConfigMapPropertySourceLocator for when retry is enabled.\n * @author Ryan Baxter\n */\n@Order(0) class RetryableKubernetesClientConfigMapPropertySourceLocator extends KubernetesClientConfigMapPropertySourceLocator {\n  RetryableKubernetesClientConfigMapPropertySourceLocator(  CoreV1Api coreV1Api,  ConfigMapConfigProperties properties,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    super(coreV1Api,properties,kubernetesNamespaceProvider);\n  }\n  @Override @Retryable(interceptor\u003d\"kubernetesConfigRetryInterceptor\") public PropertySource\u003c?\u003e locate(  Environment environment){\n    return super.locate(environment);\n  }\n  @Override @Retryable(interceptor\u003d\"kubernetesConfigRetryInterceptor\") public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment){\n    return super.locateCollection(environment);\n  }\n}\n",
        "abstract": "/** \n * ConfigMapPropertySourceLocator for when retry is enabled.\n * @author Ryan Baxter\n */\n@Order(0) class RetryableKubernetesClientConfigMapPropertySourceLocator extends KubernetesClientConfigMapPropertySourceLocator {\n  RetryableKubernetesClientConfigMapPropertySourceLocator(  CoreV1Api coreV1Api,  ConfigMapConfigProperties properties,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n  @Override @Retryable(interceptor\u003d\"kubernetesConfigRetryInterceptor\") public PropertySource\u003c?\u003e locate(  Environment environment);\n  @Override @Retryable(interceptor\u003d\"kubernetesConfigRetryInterceptor\") public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientRetryBootstrapConfiguration.java",
        "name": "KubernetesClientRetryBootstrapConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @AutoConfigureAfter(KubernetesBootstrapConfiguration.class) @AutoConfigureBefore(KubernetesClientBootstrapConfiguration.class) @Import({KubernetesCommonsAutoConfiguration.class,KubernetesClientAutoConfiguration.class}) @ConditionalOnKubernetesConfigOrSecretsRetryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientRetryBootstrapConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @AutoConfigureAfter(KubernetesBootstrapConfiguration.class) @AutoConfigureBefore(KubernetesClientBootstrapConfiguration.class) @Import({KubernetesCommonsAutoConfiguration.class,KubernetesClientAutoConfiguration.class}) @ConditionalOnKubernetesConfigOrSecretsRetryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public class KubernetesClientRetryBootstrapConfiguration {\n  @Bean @ConditionalOnKubernetesConfigRetryEnabled public KubernetesClientConfigMapPropertySourceLocator retryableConfigMapPropertySourceLocator(  ConfigMapConfigProperties properties,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    return new RetryableKubernetesClientConfigMapPropertySourceLocator(coreV1Api,properties,kubernetesNamespaceProvider);\n  }\n  @Bean @ConditionalOnKubernetesSecretsRetryEnabled public KubernetesClientSecretsPropertySourceLocator retryableSecretsPropertySourceLocator(  SecretsConfigProperties properties,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    return new RetryableKubernetesClientSecretsPropertySourceLocator(coreV1Api,kubernetesNamespaceProvider,properties);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @AutoConfigureAfter(KubernetesBootstrapConfiguration.class) @AutoConfigureBefore(KubernetesClientBootstrapConfiguration.class) @Import({KubernetesCommonsAutoConfiguration.class,KubernetesClientAutoConfiguration.class}) @ConditionalOnKubernetesConfigOrSecretsRetryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public class KubernetesClientRetryBootstrapConfiguration {\n  @Bean @ConditionalOnKubernetesConfigRetryEnabled public KubernetesClientConfigMapPropertySourceLocator retryableConfigMapPropertySourceLocator(  ConfigMapConfigProperties properties,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n  @Bean @ConditionalOnKubernetesSecretsRetryEnabled public KubernetesClientSecretsPropertySourceLocator retryableSecretsPropertySourceLocator(  SecretsConfigProperties properties,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/LabeledSecretContextToSourceDataProvider.java",
        "name": "LabeledSecretContextToSourceDataProvider",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.LabeledSecretContextToSourceDataProvider",
        "extend": "",
        "implements": "Supplier\u003cKubernetesClientContextToSourceData\u003e",
        "raw": "/** \n * Provides an implementation of  {@link KubernetesClientContextToSourceData} for a labeledsecret.\n * @author wind57\n */\nfinal class LabeledSecretContextToSourceDataProvider implements Supplier\u003cKubernetesClientContextToSourceData\u003e {\n  LabeledSecretContextToSourceDataProvider(){\n  }\n  @Override public KubernetesClientContextToSourceData get(){\n    return context -\u003e {\n      LabeledSecretNormalizedSource source\u003d(LabeledSecretNormalizedSource)context.normalizedSource();\n      return new LabeledSourceData(){\n        @Override public MultipleSourcesContainer dataSupplier(        Map\u003cString,String\u003e labels,        Set\u003cString\u003e profiles){\n          return KubernetesClientConfigUtils.secretsDataByLabels(context.client(),context.namespace(),labels,context.environment(),profiles);\n        }\n      }\n.compute(source.labels(),source.prefix(),source.target(),source.profileSpecificSources(),source.failFast(),context.namespace(),context.environment().getActiveProfiles());\n    }\n;\n  }\n}\n",
        "abstract": "/** \n * Provides an implementation of  {@link KubernetesClientContextToSourceData} for a labeledsecret.\n * @author wind57\n */\nfinal class LabeledSecretContextToSourceDataProvider implements Supplier\u003cKubernetesClientContextToSourceData\u003e {\n  LabeledSecretContextToSourceDataProvider();\n  @Override public KubernetesClientContextToSourceData get();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/NamedConfigMapContextToSourceDataProvider.java",
        "name": "NamedConfigMapContextToSourceDataProvider",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.NamedConfigMapContextToSourceDataProvider",
        "extend": "",
        "implements": "Supplier\u003cKubernetesClientContextToSourceData\u003e",
        "raw": "/** \n * Provides an implementation of  {@link KubernetesClientContextToSourceData} for a namedconfig map.\n * @author wind57\n */\nfinal class NamedConfigMapContextToSourceDataProvider implements Supplier\u003cKubernetesClientContextToSourceData\u003e {\n  NamedConfigMapContextToSourceDataProvider(){\n  }\n  @Override public KubernetesClientContextToSourceData get(){\n    return context -\u003e {\n      NamedConfigMapNormalizedSource source\u003d(NamedConfigMapNormalizedSource)context.normalizedSource();\n      return new NamedSourceData(){\n        @Override protected String generateSourceName(        String target,        String sourceName,        String namespace,        String[] activeProfiles){\n          if (source.appendProfileToName()) {\n            return ConfigUtils.sourceName(target,sourceName,namespace,activeProfiles);\n          }\n          return super.generateSourceName(target,sourceName,namespace,activeProfiles);\n        }\n        @Override public MultipleSourcesContainer dataSupplier(        LinkedHashSet\u003cString\u003e sourceNames){\n          return KubernetesClientConfigUtils.configMapsDataByName(context.client(),context.namespace(),sourceNames,context.environment(),context.includeDefaultProfileData());\n        }\n      }\n.compute(source.name().orElseThrow(),source.prefix(),source.target(),source.profileSpecificSources(),source.failFast(),context.namespace(),context.environment().getActiveProfiles());\n    }\n;\n  }\n}\n",
        "abstract": "/** \n * Provides an implementation of  {@link KubernetesClientContextToSourceData} for a namedconfig map.\n * @author wind57\n */\nfinal class NamedConfigMapContextToSourceDataProvider implements Supplier\u003cKubernetesClientContextToSourceData\u003e {\n  NamedConfigMapContextToSourceDataProvider();\n  @Override public KubernetesClientContextToSourceData get();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/NamedSecretContextToSourceDataProvider.java",
        "name": "NamedSecretContextToSourceDataProvider",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.NamedSecretContextToSourceDataProvider",
        "extend": "",
        "implements": "Supplier\u003cKubernetesClientContextToSourceData\u003e",
        "raw": "/** \n * Provides an implementation of  {@link KubernetesClientContextToSourceData} for a namedsecret.\n * @author wind57\n */\nfinal class NamedSecretContextToSourceDataProvider implements Supplier\u003cKubernetesClientContextToSourceData\u003e {\n  NamedSecretContextToSourceDataProvider(){\n  }\n  @Override public KubernetesClientContextToSourceData get(){\n    return context -\u003e {\n      NamedSecretNormalizedSource source\u003d(NamedSecretNormalizedSource)context.normalizedSource();\n      return new NamedSourceData(){\n        @Override protected String generateSourceName(        String target,        String sourceName,        String namespace,        String[] activeProfiles){\n          if (source.appendProfileToName()) {\n            return ConfigUtils.sourceName(target,sourceName,namespace,activeProfiles);\n          }\n          return super.generateSourceName(target,sourceName,namespace,activeProfiles);\n        }\n        @Override public MultipleSourcesContainer dataSupplier(        LinkedHashSet\u003cString\u003e sourceNames){\n          return KubernetesClientConfigUtils.secretsDataByName(context.client(),context.namespace(),sourceNames,context.environment(),context.includeDefaultProfileData());\n        }\n      }\n.compute(source.name().orElseThrow(),source.prefix(),source.target(),source.profileSpecificSources(),source.failFast(),context.namespace(),context.environment().getActiveProfiles());\n    }\n;\n  }\n}\n",
        "abstract": "/** \n * Provides an implementation of  {@link KubernetesClientContextToSourceData} for a namedsecret.\n * @author wind57\n */\nfinal class NamedSecretContextToSourceDataProvider implements Supplier\u003cKubernetesClientContextToSourceData\u003e {\n  NamedSecretContextToSourceDataProvider();\n  @Override public KubernetesClientContextToSourceData get();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientContextToSourceData.java",
        "name": "KubernetesClientContextToSourceData",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientContextToSourceData",
        "extend": "",
        "implements": "Function\u003cKubernetesClientConfigContext,SourceData\u003e",
        "raw": "/** \n * A more succinct way to define a Function from KubernetesClientConfigContext to SourceData.\n * @author wind57\n */\ninterface KubernetesClientContextToSourceData extends Function\u003cKubernetesClientConfigContext,SourceData\u003e {\n}\n",
        "abstract": "/** \n * A more succinct way to define a Function from KubernetesClientConfigContext to SourceData.\n * @author wind57\n */\ninterface KubernetesClientContextToSourceData extends Function\u003cKubernetesClientConfigContext,SourceData\u003e {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/LabeledConfigMapContextToSourceDataProvider.java",
        "name": "LabeledConfigMapContextToSourceDataProvider",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.LabeledConfigMapContextToSourceDataProvider",
        "extend": "",
        "implements": "Supplier\u003cKubernetesClientContextToSourceData\u003e",
        "raw": "class LabeledConfigMapContextToSourceDataProvider implements Supplier\u003cKubernetesClientContextToSourceData\u003e {\n  LabeledConfigMapContextToSourceDataProvider(){\n  }\n  @Override public KubernetesClientContextToSourceData get(){\n    return context -\u003e {\n      LabeledConfigMapNormalizedSource source\u003d(LabeledConfigMapNormalizedSource)context.normalizedSource();\n      return new LabeledSourceData(){\n        @Override public MultipleSourcesContainer dataSupplier(        Map\u003cString,String\u003e labels,        Set\u003cString\u003e profiles){\n          return KubernetesClientConfigUtils.configMapsDataByLabels(context.client(),context.namespace(),labels,context.environment(),profiles);\n        }\n      }\n.compute(source.labels(),source.prefix(),source.target(),source.profileSpecificSources(),source.failFast(),context.namespace(),context.environment().getActiveProfiles());\n    }\n;\n  }\n}\n",
        "abstract": "class LabeledConfigMapContextToSourceDataProvider implements Supplier\u003cKubernetesClientContextToSourceData\u003e {\n  LabeledConfigMapContextToSourceDataProvider();\n  @Override public KubernetesClientContextToSourceData get();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/reload/KubernetesClientEventBasedConfigMapChangeDetector.java",
        "name": "KubernetesClientEventBasedConfigMapChangeDetector",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.reload.KubernetesClientEventBasedConfigMapChangeDetector",
        "extend": "ConfigurationChangeDetector",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientEventBasedConfigMapChangeDetector extends ConfigurationChangeDetector {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientEventBasedConfigMapChangeDetector.class));\n  private final CoreV1Api coreV1Api;\n  private final KubernetesClientConfigMapPropertySourceLocator propertySourceLocator;\n  private final ApiClient apiClient;\n  private final List\u003cSharedIndexInformer\u003cV1ConfigMap\u003e\u003e informers\u003dnew ArrayList\u003c\u003e();\n  private final List\u003cSharedInformerFactory\u003e factories\u003dnew ArrayList\u003c\u003e();\n  private final Set\u003cString\u003e namespaces;\n  private final boolean enableReloadFiltering;\n  private final ResourceEventHandler\u003cV1ConfigMap\u003e handler\u003dnew ResourceEventHandler\u003c\u003e(){\n    @Override public void onAdd(    V1ConfigMap configMap){\n      LOG.debug(() -\u003e \"ConfigMap \" + configMap.getMetadata().getName() + \" was added in namespace \"+ configMap.getMetadata().getNamespace());\n      onEvent(configMap);\n    }\n    @Override public void onUpdate(    V1ConfigMap oldConfigMap,    V1ConfigMap newConfigMap){\n      LOG.debug(() -\u003e \"ConfigMap \" + newConfigMap.getMetadata().getName() + \" was updated in namespace \"+ newConfigMap.getMetadata().getNamespace());\n      if (Objects.equals(oldConfigMap.getData(),newConfigMap.getData())) {\n        LOG.debug(() -\u003e \"data in configmap has not changed, will not reload\");\n      }\n else {\n        onEvent(newConfigMap);\n      }\n    }\n    @Override public void onDelete(    V1ConfigMap configMap,    boolean deletedFinalStateUnknown){\n      LOG.debug(() -\u003e \"ConfigMap \" + configMap.getMetadata().getName() + \" was deleted in namespace \"+ configMap.getMetadata().getNamespace());\n      onEvent(configMap);\n    }\n  }\n;\n  public KubernetesClientEventBasedConfigMapChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientConfigMapPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    super(environment,properties,strategy);\n    this.propertySourceLocator\u003dpropertySourceLocator;\n    this.coreV1Api\u003dcoreV1Api;\n    this.apiClient\u003dcreateApiClientForInformerClient();\n    this.enableReloadFiltering\u003dproperties.enableReloadFiltering();\n    namespaces\u003dnamespaces(kubernetesNamespaceProvider,properties,\"configmap\");\n  }\n  @PostConstruct void inform(){\n    LOG.info(() -\u003e \"Kubernetes event-based configMap change detector activated\");\n    namespaces.forEach(namespace -\u003e {\n      SharedIndexInformer\u003cV1ConfigMap\u003e informer;\n      String[] filter\u003dnew String[1];\n      if (enableReloadFiltering) {\n        filter[0]\u003dConfigReloadProperties.RELOAD_LABEL_FILTER + \"\u003dtrue\";\n      }\n      SharedInformerFactory factory\u003dnew SharedInformerFactory(apiClient);\n      factories.add(factory);\n      informer\u003dfactory.sharedIndexInformerFor((      CallGeneratorParams params) -\u003e coreV1Api.listNamespacedConfigMapCall(namespace,null,null,null,null,filter[0],null,params.resourceVersion,null,null,params.timeoutSeconds,params.watch,null),V1ConfigMap.class,V1ConfigMapList.class);\n      LOG.debug(() -\u003e \"added configmap informer for namespace : \" + namespace + \" with filter : \"+ filter[0]);\n      informer.addEventHandler(handler);\n      informers.add(informer);\n      factory.startAllRegisteredInformers();\n    }\n);\n  }\n  @PreDestroy void shutdown(){\n    informers.forEach(SharedIndexInformer::stop);\n    factories.forEach(SharedInformerFactory::stopAllRegisteredInformers);\n  }\n  protected void onEvent(  KubernetesObject configMap){\n    boolean reload\u003dConfigReloadUtil.reload(\"config-map\",configMap.toString(),propertySourceLocator,environment,KubernetesClientConfigMapPropertySource.class);\n    if (reload) {\n      reloadProperties();\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientEventBasedConfigMapChangeDetector extends ConfigurationChangeDetector {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientEventBasedConfigMapChangeDetector.class));\n  private final CoreV1Api coreV1Api;\n  private final KubernetesClientConfigMapPropertySourceLocator propertySourceLocator;\n  private final ApiClient apiClient;\n  private final List\u003cSharedIndexInformer\u003cV1ConfigMap\u003e\u003e informers\u003dnew ArrayList\u003c\u003e();\n  private final List\u003cSharedInformerFactory\u003e factories\u003dnew ArrayList\u003c\u003e();\n  private final Set\u003cString\u003e namespaces;\n  private final boolean enableReloadFiltering;\n  private final ResourceEventHandler\u003cV1ConfigMap\u003e handler\u003dnew ResourceEventHandler\u003c\u003e(){\n    @Override public void onAdd(    V1ConfigMap configMap);\n    @Override public void onUpdate(    V1ConfigMap oldConfigMap,    V1ConfigMap newConfigMap);\n    @Override public void onDelete(    V1ConfigMap configMap,    boolean deletedFinalStateUnknown);\n  }\n;\n  public KubernetesClientEventBasedConfigMapChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientConfigMapPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n  @PostConstruct void inform();\n  @PreDestroy void shutdown();\n  protected void onEvent(  KubernetesObject configMap);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/reload/KubernetesClientConfigReloadAutoConfiguration.java",
        "name": "KubernetesClientConfigReloadAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesReloadEnabled @ConditionalOnClass({EndpointAutoConfiguration.class,RestartEndpoint.class,ContextRefresher.class}) @AutoConfigureAfter({InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,RefreshAutoConfiguration.class,ConfigReloadPropertiesAutoConfiguration.class}) @Import(ConfigReloadAutoConfiguration.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.reload.KubernetesClientConfigReloadAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesReloadEnabled @ConditionalOnClass({EndpointAutoConfiguration.class,RestartEndpoint.class,ContextRefresher.class}) @AutoConfigureAfter({InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,RefreshAutoConfiguration.class,ConfigReloadPropertiesAutoConfiguration.class}) @Import(ConfigReloadAutoConfiguration.class) public class KubernetesClientConfigReloadAutoConfiguration {\n  /** \n * Polling configMap ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param configMapPropertySourceLocator configMap property source locator\n * @return a bean that listen to configuration changes and fire a reload.\n */\n  @Bean @ConditionalOnConfigMapsReloadEnabled @ConditionalOnBean(KubernetesClientConfigMapPropertySourceLocator.class) @Conditional(PollingReloadDetectionMode.class) public ConfigurationChangeDetector configMapPropertyChangePollingWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator,  AbstractEnvironment environment,  TaskSchedulerWrapper\u003cTaskScheduler\u003e taskScheduler){\n    return new PollingConfigMapChangeDetector(environment,properties,strategy,KubernetesClientConfigMapPropertySource.class,configMapPropertySourceLocator,taskScheduler.getTaskScheduler());\n  }\n  /** \n * Polling secrets ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param secretsPropertySourceLocator secrets property source locator\n * @return a bean that listen to configuration changes and fire a reload.\n */\n  @Bean @ConditionalOnSecretsReloadEnabled @ConditionalOnBean(KubernetesClientSecretsPropertySourceLocator.class) @Conditional(PollingReloadDetectionMode.class) public ConfigurationChangeDetector secretsPropertyChangePollingWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator,  AbstractEnvironment environment,  TaskSchedulerWrapper\u003cTaskScheduler\u003e taskScheduler){\n    return new PollingSecretsChangeDetector(environment,properties,strategy,KubernetesClientSecretsPropertySource.class,secretsPropertySourceLocator,taskScheduler.getTaskScheduler());\n  }\n  /** \n * Event Based configMap ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param configMapPropertySourceLocator configMap property source locator\n * @return a bean that listen to configMap change events and fire a reload.\n */\n  @Bean @ConditionalOnConfigMapsReloadEnabled @ConditionalOnBean(KubernetesClientConfigMapPropertySourceLocator.class) @Conditional(EventReloadDetectionMode.class) public ConfigurationChangeDetector configMapPropertyChangeEventWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator,  AbstractEnvironment environment,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    return new KubernetesClientEventBasedConfigMapChangeDetector(coreV1Api,environment,properties,strategy,configMapPropertySourceLocator,kubernetesNamespaceProvider);\n  }\n  /** \n * Event Based secrets ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param secretsPropertySourceLocator secrets property source locator\n * @return a bean that listen to secrets change events and fire a reload.\n */\n  @Bean @ConditionalOnSecretsReloadEnabled @ConditionalOnBean(KubernetesClientSecretsPropertySourceLocator.class) @Conditional(EventReloadDetectionMode.class) public ConfigurationChangeDetector secretsPropertyChangeEventWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator,  AbstractEnvironment environment,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    return new KubernetesClientEventBasedSecretsChangeDetector(coreV1Api,environment,properties,strategy,secretsPropertySourceLocator,kubernetesNamespaceProvider);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesReloadEnabled @ConditionalOnClass({EndpointAutoConfiguration.class,RestartEndpoint.class,ContextRefresher.class}) @AutoConfigureAfter({InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,RefreshAutoConfiguration.class,ConfigReloadPropertiesAutoConfiguration.class}) @Import(ConfigReloadAutoConfiguration.class) public class KubernetesClientConfigReloadAutoConfiguration {\n  /** \n * Polling configMap ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param configMapPropertySourceLocator configMap property source locator\n * @return a bean that listen to configuration changes and fire a reload.\n */\n  @Bean @ConditionalOnConfigMapsReloadEnabled @ConditionalOnBean(KubernetesClientConfigMapPropertySourceLocator.class) @Conditional(PollingReloadDetectionMode.class) public ConfigurationChangeDetector configMapPropertyChangePollingWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator,  AbstractEnvironment environment,  TaskSchedulerWrapper\u003cTaskScheduler\u003e taskScheduler);\n  /** \n * Polling secrets ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param secretsPropertySourceLocator secrets property source locator\n * @return a bean that listen to configuration changes and fire a reload.\n */\n  @Bean @ConditionalOnSecretsReloadEnabled @ConditionalOnBean(KubernetesClientSecretsPropertySourceLocator.class) @Conditional(PollingReloadDetectionMode.class) public ConfigurationChangeDetector secretsPropertyChangePollingWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator,  AbstractEnvironment environment,  TaskSchedulerWrapper\u003cTaskScheduler\u003e taskScheduler);\n  /** \n * Event Based configMap ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param configMapPropertySourceLocator configMap property source locator\n * @return a bean that listen to configMap change events and fire a reload.\n */\n  @Bean @ConditionalOnConfigMapsReloadEnabled @ConditionalOnBean(KubernetesClientConfigMapPropertySourceLocator.class) @Conditional(EventReloadDetectionMode.class) public ConfigurationChangeDetector configMapPropertyChangeEventWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientConfigMapPropertySourceLocator configMapPropertySourceLocator,  AbstractEnvironment environment,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n  /** \n * Event Based secrets ConfigurationChangeDetector.\n * @param properties config reload properties\n * @param strategy configuration update strategy\n * @param secretsPropertySourceLocator secrets property source locator\n * @return a bean that listen to secrets change events and fire a reload.\n */\n  @Bean @ConditionalOnSecretsReloadEnabled @ConditionalOnBean(KubernetesClientSecretsPropertySourceLocator.class) @Conditional(EventReloadDetectionMode.class) public ConfigurationChangeDetector secretsPropertyChangeEventWatcher(  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientSecretsPropertySourceLocator secretsPropertySourceLocator,  AbstractEnvironment environment,  CoreV1Api coreV1Api,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/reload/KubernetesClientEventBasedSecretsChangeDetector.java",
        "name": "KubernetesClientEventBasedSecretsChangeDetector",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.reload.KubernetesClientEventBasedSecretsChangeDetector",
        "extend": "ConfigurationChangeDetector",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientEventBasedSecretsChangeDetector extends ConfigurationChangeDetector {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientEventBasedSecretsChangeDetector.class));\n  private final CoreV1Api coreV1Api;\n  private final KubernetesClientSecretsPropertySourceLocator propertySourceLocator;\n  private final ApiClient apiClient;\n  private final List\u003cSharedIndexInformer\u003cV1Secret\u003e\u003e informers\u003dnew ArrayList\u003c\u003e();\n  private final List\u003cSharedInformerFactory\u003e factories\u003dnew ArrayList\u003c\u003e();\n  private final Set\u003cString\u003e namespaces;\n  private final boolean enableReloadFiltering;\n  private final ResourceEventHandler\u003cV1Secret\u003e handler\u003dnew ResourceEventHandler\u003c\u003e(){\n    @Override public void onAdd(    V1Secret secret){\n      LOG.debug(() -\u003e \"Secret \" + secret.getMetadata().getName() + \" was added in namespace \"+ secret.getMetadata().getNamespace());\n      onEvent(secret);\n    }\n    @Override public void onUpdate(    V1Secret oldSecret,    V1Secret newSecret){\n      LOG.debug(() -\u003e \"Secret \" + newSecret.getMetadata().getName() + \" was updated in namespace \"+ newSecret.getMetadata().getNamespace());\n      if (KubernetesClientEventBasedSecretsChangeDetector.equals(oldSecret.getData(),newSecret.getData())) {\n        LOG.debug(() -\u003e \"data in secret has not changed, will not reload\");\n      }\n else {\n        onEvent(newSecret);\n      }\n    }\n    @Override public void onDelete(    V1Secret secret,    boolean deletedFinalStateUnknown){\n      LOG.debug(() -\u003e \"Secret \" + secret.getMetadata().getName() + \" was deleted in namespace \"+ secret.getMetadata().getNamespace());\n      onEvent(secret);\n    }\n  }\n;\n  public KubernetesClientEventBasedSecretsChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientSecretsPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    super(environment,properties,strategy);\n    this.propertySourceLocator\u003dpropertySourceLocator;\n    this.coreV1Api\u003dcoreV1Api;\n    this.apiClient\u003dcreateApiClientForInformerClient();\n    this.enableReloadFiltering\u003dproperties.enableReloadFiltering();\n    namespaces\u003dnamespaces(kubernetesNamespaceProvider,properties,\"secret\");\n  }\n  @PostConstruct void inform(){\n    LOG.info(() -\u003e \"Kubernetes event-based secrets change detector activated\");\n    namespaces.forEach(namespace -\u003e {\n      SharedIndexInformer\u003cV1Secret\u003e informer;\n      String[] filter\u003dnew String[1];\n      if (enableReloadFiltering) {\n        filter[0]\u003dConfigReloadProperties.RELOAD_LABEL_FILTER + \"\u003dtrue\";\n      }\n      SharedInformerFactory factory\u003dnew SharedInformerFactory(apiClient);\n      factories.add(factory);\n      informer\u003dfactory.sharedIndexInformerFor((      CallGeneratorParams params) -\u003e coreV1Api.listNamespacedSecretCall(namespace,null,null,null,null,filter[0],null,params.resourceVersion,null,null,params.timeoutSeconds,params.watch,null),V1Secret.class,V1SecretList.class);\n      LOG.debug(() -\u003e \"added secret informer for namespace : \" + namespace + \" with filter : \"+ filter[0]);\n      informer.addEventHandler(handler);\n      informers.add(informer);\n      factory.startAllRegisteredInformers();\n    }\n);\n  }\n  @PreDestroy void shutdown(){\n    informers.forEach(SharedIndexInformer::stop);\n    factories.forEach(SharedInformerFactory::stopAllRegisteredInformers);\n  }\n  protected void onEvent(  KubernetesObject secret){\n    boolean reload\u003dConfigReloadUtil.reload(\"secrets\",secret.toString(),propertySourceLocator,environment,KubernetesClientSecretsPropertySource.class);\n    if (reload) {\n      reloadProperties();\n    }\n  }\n  static boolean equals(  Map\u003cString,byte[]\u003e left,  Map\u003cString,byte[]\u003e right){\n    Map\u003cString,byte[]\u003e innerLeft\u003dOptional.ofNullable(left).orElse(Map.of());\n    Map\u003cString,byte[]\u003e innerRight\u003dOptional.ofNullable(right).orElse(Map.of());\n    if (innerLeft.size() !\u003d innerRight.size()) {\n      return false;\n    }\n    for (    Map.Entry\u003cString,byte[]\u003e entry : innerLeft.entrySet()) {\n      String key\u003dentry.getKey();\n      byte[] value\u003dentry.getValue();\n      if (!Arrays.equals(value,innerRight.get(key))) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesClientEventBasedSecretsChangeDetector extends ConfigurationChangeDetector {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientEventBasedSecretsChangeDetector.class));\n  private final CoreV1Api coreV1Api;\n  private final KubernetesClientSecretsPropertySourceLocator propertySourceLocator;\n  private final ApiClient apiClient;\n  private final List\u003cSharedIndexInformer\u003cV1Secret\u003e\u003e informers\u003dnew ArrayList\u003c\u003e();\n  private final List\u003cSharedInformerFactory\u003e factories\u003dnew ArrayList\u003c\u003e();\n  private final Set\u003cString\u003e namespaces;\n  private final boolean enableReloadFiltering;\n  private final ResourceEventHandler\u003cV1Secret\u003e handler\u003dnew ResourceEventHandler\u003c\u003e(){\n    @Override public void onAdd(    V1Secret secret);\n    @Override public void onUpdate(    V1Secret oldSecret,    V1Secret newSecret);\n    @Override public void onDelete(    V1Secret secret,    boolean deletedFinalStateUnknown);\n  }\n;\n  public KubernetesClientEventBasedSecretsChangeDetector(  CoreV1Api coreV1Api,  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  KubernetesClientSecretsPropertySourceLocator propertySourceLocator,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n  @PostConstruct void inform();\n  @PreDestroy void shutdown();\n  protected void onEvent(  KubernetesObject secret);\n  static boolean equals(  Map\u003cString,byte[]\u003e left,  Map\u003cString,byte[]\u003e right);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientConfigMapPropertySourceLocator.java",
        "name": "KubernetesClientConfigMapPropertySourceLocator",
        "modifiers": "@Order(0) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientConfigMapPropertySourceLocator",
        "extend": "ConfigMapPropertySourceLocator",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\n@Order(0) public class KubernetesClientConfigMapPropertySourceLocator extends ConfigMapPropertySourceLocator {\n  private final CoreV1Api coreV1Api;\n  private final KubernetesNamespaceProvider kubernetesNamespaceProvider;\n  public KubernetesClientConfigMapPropertySourceLocator(  CoreV1Api coreV1Api,  ConfigMapConfigProperties properties,  KubernetesNamespaceProvider kubernetesNamespaceProvider){\n    super(properties,new KubernetesClientConfigMapsCache());\n    this.coreV1Api\u003dcoreV1Api;\n    this.kubernetesNamespaceProvider\u003dkubernetesNamespaceProvider;\n  }\n  @Override protected MapPropertySource getMapPropertySource(  NormalizedSource source,  ConfigurableEnvironment environment){\n    String normalizedNamespace\u003dsource.namespace().orElse(null);\n    String namespace\u003dgetApplicationNamespace(normalizedNamespace,source.target(),kubernetesNamespaceProvider);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(coreV1Api,source,namespace,environment);\n    return new KubernetesClientConfigMapPropertySource(context);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\n@Order(0) public class KubernetesClientConfigMapPropertySourceLocator extends ConfigMapPropertySourceLocator {\n  private final CoreV1Api coreV1Api;\n  private final KubernetesNamespaceProvider kubernetesNamespaceProvider;\n  public KubernetesClientConfigMapPropertySourceLocator(  CoreV1Api coreV1Api,  ConfigMapConfigProperties properties,  KubernetesNamespaceProvider kubernetesNamespaceProvider);\n  @Override protected MapPropertySource getMapPropertySource(  NormalizedSource source,  ConfigurableEnvironment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/main/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientSecretsCache.java",
        "name": "KubernetesClientSecretsCache",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientSecretsCache",
        "extend": "",
        "implements": "SecretsCache",
        "raw": "/** \n * A cache of V1ConfigMap(s) per namespace. Makes sure we read config maps only once from a namespace.\n * @author wind57\n */\npublic class KubernetesClientSecretsCache implements SecretsCache {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientConfigMapsCache.class));\n  /** \n * at the moment our loading of config maps is using a single thread, but might change in the future, thus a thread safe structure.\n */\n  private static final ConcurrentHashMap\u003cString,List\u003cStrippedSourceContainer\u003e\u003e CACHE\u003dnew ConcurrentHashMap\u003c\u003e();\n  @Override public void discardAll(){\n    CACHE.clear();\n  }\n  static List\u003cStrippedSourceContainer\u003e byNamespace(  CoreV1Api coreV1Api,  String namespace){\n    boolean[] b\u003dnew boolean[1];\n    List\u003cStrippedSourceContainer\u003e result\u003dCACHE.computeIfAbsent(namespace,x -\u003e {\n      try {\n        b[0]\u003dtrue;\n        return strippedSecrets(coreV1Api.listNamespacedSecret(namespace,null,null,null,null,null,null,null,null,null,null,null).getItems());\n      }\n catch (      ApiException apiException) {\n        throw new RuntimeException(apiException.getResponseBody(),apiException);\n      }\n    }\n);\n    if (b[0]) {\n      LOG.debug(() -\u003e \"Loaded all secrets in namespace \u0027\" + namespace + \"\u0027\");\n    }\n else {\n      LOG.debug(() -\u003e \"Loaded (from cache) all secrets in namespace \u0027\" + namespace + \"\u0027\");\n    }\n    return result;\n  }\n  private static List\u003cStrippedSourceContainer\u003e strippedSecrets(  List\u003cV1Secret\u003e secrets){\n    return secrets.stream().map(secret -\u003e new StrippedSourceContainer(secret.getMetadata().getLabels(),secret.getMetadata().getName(),transform(secret.getData()))).collect(Collectors.toList());\n  }\n  private static Map\u003cString,String\u003e transform(  Map\u003cString,byte[]\u003e in){\n    return ObjectUtils.isEmpty(in) ? Map.of() : in.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey,en -\u003e new String(en.getValue())));\n  }\n}\n",
        "abstract": "/** \n * A cache of V1ConfigMap(s) per namespace. Makes sure we read config maps only once from a namespace.\n * @author wind57\n */\npublic class KubernetesClientSecretsCache implements SecretsCache {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesClientConfigMapsCache.class));\n  /** \n * at the moment our loading of config maps is using a single thread, but might change in the future, thus a thread safe structure.\n */\n  private static final ConcurrentHashMap\u003cString,List\u003cStrippedSourceContainer\u003e\u003e CACHE\u003dnew ConcurrentHashMap\u003c\u003e();\n  @Override public void discardAll();\n  static List\u003cStrippedSourceContainer\u003e byNamespace(  CoreV1Api coreV1Api,  String namespace);\n  private static List\u003cStrippedSourceContainer\u003e strippedSecrets(  List\u003cV1Secret\u003e secrets);\n  private static Map\u003cString,String\u003e transform(  Map\u003cString,byte[]\u003e in);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/Application.java",
        "name": "Application",
        "modifiers": "@SpringBootApplication public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.Application",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication public class Application {\n}\n",
        "abstract": "@SpringBootApplication public class Application {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/NamedSecretContextToSourceDataProviderTests.java",
        "name": "NamedSecretContextToSourceDataProviderTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.NamedSecretContextToSourceDataProviderTests",
        "extend": "",
        "implements": "",
        "raw": "@ExtendWith(OutputCaptureExtension.class) class NamedSecretContextToSourceDataProviderTests {\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"some\",false,false,\"irrelevant\");\n  private static final String NAMESPACE\u003d\"default\";\n  private static final Map\u003cString,byte[]\u003e COLOR_REALLY_RED\u003dMap.of(\"color\",\"really-red\".getBytes());\n  @BeforeAll static void setup(){\n    WireMockServer wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    client.setDebugging(true);\n    Configuration.setDefaultApiClient(client);\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n    new KubernetesClientSecretsCache().discardAll();\n  }\n  /** \n * we have a single secret deployed. it matched the name in our queries\n */\n  @Test void singleSecretMatchAgainstLabels(){\n    V1Secret red\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withNamespace(NAMESPACE).withName(\"red\").build()).addToData(COLOR_REALLY_RED).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(red);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew NamedSecretNormalizedSource(\"red\",NAMESPACE,false,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.red.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Map.of(\"color\",\"really-red\"));\n  }\n  /** \n * we have three secrets deployed. one of them has a name that matches (red), the other two have different names, thus no match.\n */\n  @Test void twoSecretMatchAgainstLabels(){\n    V1Secret red\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withNamespace(NAMESPACE).withName(\"red\").build()).addToData(COLOR_REALLY_RED).build();\n    V1Secret blue\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withNamespace(NAMESPACE).withName(\"blue\").build()).addToData(COLOR_REALLY_RED).build();\n    V1Secret pink\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withNamespace(NAMESPACE).withName(\"pink\").build()).addToData(COLOR_REALLY_RED).build();\n    V1SecretList secretList\u003dnew V1SecretListBuilder().addToItems(red).addToItems(blue).addToItems(pink).build();\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew NamedSecretNormalizedSource(\"red\",NAMESPACE,false,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.red.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),1);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color\"),\"really-red\");\n  }\n  /** \n * one secret deployed (pink), does not match our query (blue).\n */\n  @Test void testSecretNoMatch(){\n    V1Secret secret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withNamespace(NAMESPACE).withName(\"red\").build()).addToData(COLOR_REALLY_RED).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(secret);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew NamedSecretNormalizedSource(\"blue\",NAMESPACE,false,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.blue.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Collections.emptyMap());\n  }\n  /** \n * \u003cpre\u003e - LabeledSecretContextToSourceDataProvider gets as input a KubernetesClientConfigContext. - This context has a namespace as well as a NormalizedSource, that has a namespace too. - This test makes sure that we use the proper one. \u003c/pre\u003e\n */\n  @Test void namespaceMatch(){\n    V1Secret secret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withNamespace(NAMESPACE).withName(\"red\").build()).addToData(COLOR_REALLY_RED).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(secret);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    String wrongNamespace\u003dNAMESPACE + \"nope\";\n    NormalizedSource source\u003dnew NamedSecretNormalizedSource(\"red\",wrongNamespace,false,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.red.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Map.of(\"color\",\"really-red\"));\n  }\n  /** \n * we have two secrets deployed. one matches the query name. the other matches the active profile + name, thus is taken also.\n */\n  @Test void matchIncludeSingleProfile(){\n    V1Secret red\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withNamespace(NAMESPACE).withName(\"red\").build()).addToData(COLOR_REALLY_RED).build();\n    V1Secret mango\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withNamespace(NAMESPACE).withName(\"red-with-profile\").build()).addToData(\"taste\",\"mango\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(red).addItemsItem(mango);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew NamedSecretNormalizedSource(\"red\",NAMESPACE,false,ConfigUtils.Prefix.DEFAULT,true,true);\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.addActiveProfile(\"with-profile\");\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,environment,false);\n    KubernetesClientContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.red.red-with-profile.default.with-profile\");\n    Assertions.assertEquals(sourceData.sourceData().size(),1);\n    Assertions.assertEquals(sourceData.sourceData().get(\"taste\"),\"mango\");\n  }\n  /** \n * we have two secrets deployed. one matches the query name. the other matches the active profile + name, thus is taken also. This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based secrets as well.\n */\n  @Test void matchIncludeSingleProfileWithPrefix(){\n    V1Secret red\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withNamespace(NAMESPACE).withName(\"red\").build()).addToData(COLOR_REALLY_RED).build();\n    V1Secret mango\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withNamespace(NAMESPACE).withName(\"red-with-taste\").build()).addToData(\"taste\",\"mango\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(red).addItemsItem(mango);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew NamedSecretNormalizedSource(\"red\",NAMESPACE,true,PREFIX,true);\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.addActiveProfile(\"with-taste\");\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,environment);\n    KubernetesClientContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.red.red-with-taste.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.color\"),\"really-red\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.taste\"),\"mango\");\n  }\n  /** \n * we have three secrets deployed. one matches the query name. the other two match the active profile + name, thus are taken also. This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based config maps as well.\n */\n  @Test void matchIncludeTwoProfilesWithPrefix(){\n    V1Secret red\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withNamespace(NAMESPACE).withName(\"red\").build()).addToData(COLOR_REALLY_RED).build();\n    V1Secret mango\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withNamespace(NAMESPACE).withName(\"red-with-taste\").build()).addToData(\"taste\",\"mango\".getBytes()).build();\n    V1Secret shape\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withNamespace(NAMESPACE).withName(\"red-with-shape\").build()).addToData(\"shape\",\"round\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(red).addItemsItem(mango).addItemsItem(shape);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew NamedSecretNormalizedSource(\"red\",NAMESPACE,true,PREFIX,true);\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"with-taste\",\"with-shape\");\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,environment);\n    KubernetesClientContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.red.red-with-shape.red-with-taste.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),3);\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.color\"),\"really-red\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.taste\"),\"mango\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.shape\"),\"round\");\n  }\n  /** \n * \u003cpre\u003e - proves that single yaml file gets special treatment \u003c/pre\u003e\n */\n  @Test void testSingleYaml(){\n    V1Secret singleYaml\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"single-yaml\").withNamespace(NAMESPACE).build()).addToData(\"single.yaml\",\"key: value\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(singleYaml);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew NamedSecretNormalizedSource(\"single-yaml\",NAMESPACE,true,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.single-yaml.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Map.of(\"key\",\"value\"));\n  }\n  /** \n * \u003cpre\u003e - one secret is deployed with name \"red\" - one secret is deployed with name \"green\" - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output){\n    V1Secret red\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"red\").withNamespace(NAMESPACE).build()).addToData(\"color\",\"red\".getBytes()).build();\n    V1Secret green\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"green\").withNamespace(NAMESPACE).build()).addToData(\"color\",\"green\".getBytes()).build();\n    V1SecretList configMapList\u003dnew V1SecretList().addItemsItem(red).addItemsItem(green);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    NormalizedSource redSource\u003dnew NamedSecretNormalizedSource(\"red\",NAMESPACE,true,false);\n    KubernetesClientConfigContext redContext\u003dnew KubernetesClientConfigContext(api,redSource,NAMESPACE,environment);\n    KubernetesClientContextToSourceData redData\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData redSourceData\u003dredData.apply(redContext);\n    Assertions.assertEquals(redSourceData.sourceName(),\"secret.red.default\");\n    Assertions.assertEquals(redSourceData.sourceData(),Map.of(\"color\",\"red\"));\n    Assertions.assertTrue(output.getAll().contains(\"Loaded all secrets in namespace \u0027\" + NAMESPACE + \"\u0027\"));\n    NormalizedSource greenSource\u003dnew NamedSecretNormalizedSource(\"green\",NAMESPACE,true,true);\n    KubernetesClientConfigContext greenContext\u003dnew KubernetesClientConfigContext(api,greenSource,NAMESPACE,environment);\n    KubernetesClientContextToSourceData greenData\u003dnew NamedSecretContextToSourceDataProvider().get();\n    SourceData greenSourceData\u003dgreenData.apply(greenContext);\n    Assertions.assertEquals(greenSourceData.sourceName(),\"secret.green.default\");\n    Assertions.assertEquals(greenSourceData.sourceData(),Map.of(\"color\",\"green\"));\n    String[] out\u003doutput.getAll().split(\"Loaded all secrets in namespace\");\n    Assertions.assertEquals(out.length,2);\n    out\u003doutput.getAll().split(\"Loaded \\\\(from cache\\\\) all secrets in namespace\");\n    Assertions.assertEquals(out.length,2);\n  }\n  private void stubCall(  V1SecretList list){\n    stubFor(get(\"/api/v1/namespaces/default/secrets\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(list))));\n  }\n}\n",
        "abstract": "@ExtendWith(OutputCaptureExtension.class) class NamedSecretContextToSourceDataProviderTests {\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"some\",false,false,\"irrelevant\");\n  private static final String NAMESPACE\u003d\"default\";\n  private static final Map\u003cString,byte[]\u003e COLOR_REALLY_RED\u003dMap.of(\"color\",\"really-red\".getBytes());\n  @BeforeAll static void setup();\n  @AfterEach void afterEach();\n  /** \n * we have a single secret deployed. it matched the name in our queries\n */\n  @Test void singleSecretMatchAgainstLabels();\n  /** \n * we have three secrets deployed. one of them has a name that matches (red), the other two have different names, thus no match.\n */\n  @Test void twoSecretMatchAgainstLabels();\n  /** \n * one secret deployed (pink), does not match our query (blue).\n */\n  @Test void testSecretNoMatch();\n  /** \n * \u003cpre\u003e - LabeledSecretContextToSourceDataProvider gets as input a KubernetesClientConfigContext. - This context has a namespace as well as a NormalizedSource, that has a namespace too. - This test makes sure that we use the proper one. \u003c/pre\u003e\n */\n  @Test void namespaceMatch();\n  /** \n * we have two secrets deployed. one matches the query name. the other matches the active profile + name, thus is taken also.\n */\n  @Test void matchIncludeSingleProfile();\n  /** \n * we have two secrets deployed. one matches the query name. the other matches the active profile + name, thus is taken also. This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based secrets as well.\n */\n  @Test void matchIncludeSingleProfileWithPrefix();\n  /** \n * we have three secrets deployed. one matches the query name. the other two match the active profile + name, thus are taken also. This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based config maps as well.\n */\n  @Test void matchIncludeTwoProfilesWithPrefix();\n  /** \n * \u003cpre\u003e - proves that single yaml file gets special treatment \u003c/pre\u003e\n */\n  @Test void testSingleYaml();\n  /** \n * \u003cpre\u003e - one secret is deployed with name \"red\" - one secret is deployed with name \"green\" - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output);\n  private void stubCall(  V1SecretList list);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientSecretsPropertySourceTests.java",
        "name": "KubernetesClientSecretsPropertySourceTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientSecretsPropertySourceTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\nclass KubernetesClientSecretsPropertySourceTests {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final V1SecretList SECRET_LIST\u003dnew V1SecretListBuilder().addToItems(new V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"db-secret\").withResourceVersion(\"0\").withNamespace(\"default\").build()).addToData(\"password\",\"p455w0rd\".getBytes()).addToData(\"username\",\"user\".getBytes()).build()).build();\n  private static final V1SecretList EMPTY_DATA_SECRET_LIST\u003dnew V1SecretListBuilder().addToItems(new V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"db-secret\").withResourceVersion(\"0\").withNamespace(\"default\").build()).build()).build();\n  private static final String LIST_API_WITH_LABEL\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final String LIST_BODY\u003d\"{\\n\" + \"\\t\\\"kind\\\": \\\"SecretList\\\",\\n\" + \"\\t\\\"apiVersion\\\": \\\"v1\\\",\\n\"+ \"\\t\\\"metadata\\\": {\\n\"+ \"\\t\\t\\\"selfLink\\\": \\\"/api/v1/secrets\\\",\\n\"+ \"\\t\\t\\\"resourceVersion\\\": \\\"163035\\\"\\n\"+ \"\\t},\\n\"+ \"\\t\\\"items\\\": [{\\n\"+ \"\\t\\t\\t\\\"metadata\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"name\\\": \\\"db-secret\\\",\\n\"+ \"\\t\\t\\t\\t\\\"namespace\\\": \\\"default\\\",\\n\"+ \"\\t\\t\\t\\t\\\"selfLink\\\": \\\"/api/v1/namespaces/default/secrets/db-secret\\\",\\n\"+ \"\\t\\t\\t\\t\\\"uid\\\": \\\"59ba8e6a-a2d4-416c-b016-22597c193f23\\\",\\n\"+ \"\\t\\t\\t\\t\\\"resourceVersion\\\": \\\"1462\\\",\\n\"+ \"\\t\\t\\t\\t\\\"creationTimestamp\\\": \\\"2020-10-28T14:45:02Z\\\",\\n\"+ \"\\t\\t\\t\\t\\\"labels\\\": {\\n\"+ \"\\t\\t\\t\\t\\t\\\"spring.cloud.kubernetes.secret\\\": \\\"true\\\"\\n\"+ \"\\t\\t\\t\\t}\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"data\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"password\\\": \\\"cDQ1NXcwcmQ\u003d\\\",\\n\"+ \"\\t\\t\\t\\t\\\"username\\\": \\\"dXNlcg\u003d\u003d\\\"\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"type\\\": \\\"Opaque\\\"\\n\"+ \"\\t\\t},\\n\"+ \"\\t\\t{\\n\"+ \"\\t\\t\\t\\\"metadata\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"name\\\": \\\"rabbit-password\\\",\\n\"+ \"\\t\\t\\t\\t\\\"namespace\\\": \\\"default\\\",\\n\"+ \"\\t\\t\\t\\t\\\"selfLink\\\": \\\"/api/v1/namespaces/default/secrets/rabbit-password\\\",\\n\"+ \"\\t\\t\\t\\t\\\"uid\\\": \\\"bc211cb4-e7ff-4556-b26e-c54911301740\\\",\\n\"+ \"\\t\\t\\t\\t\\\"resourceVersion\\\": \\\"162708\\\",\\n\"+ \"\\t\\t\\t\\t\\\"creationTimestamp\\\": \\\"2020-10-29T19:47:36Z\\\",\\n\"+ \"\\t\\t\\t\\t\\\"labels\\\": {\\n\"+ \"\\t\\t\\t\\t\\t\\\"spring.cloud.kubernetes.secret\\\": \\\"true\\\"\\n\"+ \"\\t\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\t\\\"annotations\\\": {\\n\"+ \"\\t\\t\\t\\t\\t\\\"kubectl.kubernetes.io/last-applied-configuration\\\": \\\"{\\\\\\\"apiVersion\\\\\\\":\\\\\\\"v1\\\\\\\",\\\\\\\"data\\\\\\\":{\\\\\\\"spring.rabbitmq.password\\\\\\\":\\\\\\\"password\\\\\\\"},\\\\\\\"kind\\\\\\\":\\\\\\\"Secret\\\\\\\",\\\\\\\"metadata\\\\\\\":{\\\\\\\"annotations\\\\\\\":{},\\\\\\\"labels\\\\\\\":{\\\\\\\"spring.cloud.kubernetes.secret\\\\\\\":\\\\\\\"true\\\\\\\"},\\\\\\\"name\\\\\\\":\\\\\\\"rabbit-password\\\\\\\",\\\\\\\"namespace\\\\\\\":\\\\\\\"default\\\\\\\"},\\\\\\\"type\\\\\\\":\\\\\\\"Opaque\\\\\\\"}\\\\n\\\"\\n\"+ \"\\t\\t\\t\\t}\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"data\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"spring.rabbitmq.password\\\": \\\"cGFzc3dvcmQ\u003d\\\"\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"type\\\": \\\"Opaque\\\"\\n\"+ \"\\t\\t}\\n\"+ \"\\t]\\n\"+ \"}\";\n  private static WireMockServer wireMockServer;\n  @BeforeAll static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    client.setDebugging(true);\n    Configuration.setDefaultApiClient(client);\n  }\n  @AfterAll static void after(){\n    WireMock.shutdownServer();\n    wireMockServer.stop();\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n    new KubernetesClientSecretsCache().discardAll();\n  }\n  @Test void emptyDataSecretTest(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(EMPTY_DATA_SECRET_LIST))));\n    NormalizedSource source\u003dnew NamedSecretNormalizedSource(\"db-secret\",\"default\",false,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,\"default\",new MockEnvironment());\n    KubernetesClientSecretsPropertySource propertySource\u003dnew KubernetesClientSecretsPropertySource(context);\n    assertThat(propertySource.getName()).isEqualTo(\"secret.db-secret.default\");\n    assertThat(propertySource.getPropertyNames()).isEmpty();\n  }\n  @Test void secretsTest(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(SECRET_LIST))));\n    NormalizedSource source\u003dnew NamedSecretNormalizedSource(\"db-secret\",\"default\",false,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,\"default\",new MockEnvironment());\n    KubernetesClientSecretsPropertySource propertySource\u003dnew KubernetesClientSecretsPropertySource(context);\n    assertThat(propertySource.containsProperty(\"password\")).isTrue();\n    assertThat(propertySource.getProperty(\"password\")).isEqualTo(\"p455w0rd\");\n    assertThat(propertySource.containsProperty(\"username\")).isTrue();\n    assertThat(propertySource.getProperty(\"username\")).isEqualTo(\"user\");\n  }\n  @Test void secretLabelsTest(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(LIST_API_WITH_LABEL).willReturn(aResponse().withStatus(200).withBody(LIST_BODY)));\n    Map\u003cString,String\u003e labels\u003dnew HashMap\u003c\u003e();\n    labels.put(\"spring.cloud.kubernetes.secret\",\"true\");\n    NormalizedSource source\u003dnew LabeledSecretNormalizedSource(\"default\",labels,false,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,\"default\",new MockEnvironment());\n    KubernetesClientSecretsPropertySource propertySource\u003dnew KubernetesClientSecretsPropertySource(context);\n    assertThat(propertySource.containsProperty(\"spring.rabbitmq.password\")).isTrue();\n    assertThat(propertySource.getProperty(\"spring.rabbitmq.password\")).isEqualTo(\"password\");\n  }\n  @Test void constructorShouldThrowExceptionOnFailureWhenFailFastIsEnabled(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    NormalizedSource source\u003dnew NamedSecretNormalizedSource(\"secret\",\"default\",true,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,\"default\",new MockEnvironment());\n    assertThatThrownBy(() -\u003e new KubernetesClientSecretsPropertySource(context)).isInstanceOf(IllegalStateException.class).hasMessage(\"Internal Server Error\");\n    verify(getRequestedFor(urlEqualTo(API)));\n  }\n  @Test void constructorShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    NormalizedSource source\u003dnew NamedSecretNormalizedSource(\"secret\",\"db-secret\",false,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,\"default\",new MockEnvironment());\n    assertThatNoException().isThrownBy((() -\u003e new KubernetesClientSecretsPropertySource(context)));\n    verify(getRequestedFor(urlEqualTo(API)));\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\nclass KubernetesClientSecretsPropertySourceTests {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final V1SecretList SECRET_LIST\u003dnew V1SecretListBuilder().addToItems(new V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"db-secret\").withResourceVersion(\"0\").withNamespace(\"default\").build()).addToData(\"password\",\"p455w0rd\".getBytes()).addToData(\"username\",\"user\".getBytes()).build()).build();\n  private static final V1SecretList EMPTY_DATA_SECRET_LIST\u003dnew V1SecretListBuilder().addToItems(new V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"db-secret\").withResourceVersion(\"0\").withNamespace(\"default\").build()).build()).build();\n  private static final String LIST_API_WITH_LABEL\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final String LIST_BODY\u003d\"{\\n\" + \"\\t\\\"kind\\\": \\\"SecretList\\\",\\n\" + \"\\t\\\"apiVersion\\\": \\\"v1\\\",\\n\"+ \"\\t\\\"metadata\\\": {\\n\"+ \"\\t\\t\\\"selfLink\\\": \\\"/api/v1/secrets\\\",\\n\"+ \"\\t\\t\\\"resourceVersion\\\": \\\"163035\\\"\\n\"+ \"\\t},\\n\"+ \"\\t\\\"items\\\": [{\\n\"+ \"\\t\\t\\t\\\"metadata\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"name\\\": \\\"db-secret\\\",\\n\"+ \"\\t\\t\\t\\t\\\"namespace\\\": \\\"default\\\",\\n\"+ \"\\t\\t\\t\\t\\\"selfLink\\\": \\\"/api/v1/namespaces/default/secrets/db-secret\\\",\\n\"+ \"\\t\\t\\t\\t\\\"uid\\\": \\\"59ba8e6a-a2d4-416c-b016-22597c193f23\\\",\\n\"+ \"\\t\\t\\t\\t\\\"resourceVersion\\\": \\\"1462\\\",\\n\"+ \"\\t\\t\\t\\t\\\"creationTimestamp\\\": \\\"2020-10-28T14:45:02Z\\\",\\n\"+ \"\\t\\t\\t\\t\\\"labels\\\": {\\n\"+ \"\\t\\t\\t\\t\\t\\\"spring.cloud.kubernetes.secret\\\": \\\"true\\\"\\n\"+ \"\\t\\t\\t\\t}\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"data\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"password\\\": \\\"cDQ1NXcwcmQ\u003d\\\",\\n\"+ \"\\t\\t\\t\\t\\\"username\\\": \\\"dXNlcg\u003d\u003d\\\"\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"type\\\": \\\"Opaque\\\"\\n\"+ \"\\t\\t},\\n\"+ \"\\t\\t{\\n\"+ \"\\t\\t\\t\\\"metadata\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"name\\\": \\\"rabbit-password\\\",\\n\"+ \"\\t\\t\\t\\t\\\"namespace\\\": \\\"default\\\",\\n\"+ \"\\t\\t\\t\\t\\\"selfLink\\\": \\\"/api/v1/namespaces/default/secrets/rabbit-password\\\",\\n\"+ \"\\t\\t\\t\\t\\\"uid\\\": \\\"bc211cb4-e7ff-4556-b26e-c54911301740\\\",\\n\"+ \"\\t\\t\\t\\t\\\"resourceVersion\\\": \\\"162708\\\",\\n\"+ \"\\t\\t\\t\\t\\\"creationTimestamp\\\": \\\"2020-10-29T19:47:36Z\\\",\\n\"+ \"\\t\\t\\t\\t\\\"labels\\\": {\\n\"+ \"\\t\\t\\t\\t\\t\\\"spring.cloud.kubernetes.secret\\\": \\\"true\\\"\\n\"+ \"\\t\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\t\\\"annotations\\\": {\\n\"+ \"\\t\\t\\t\\t\\t\\\"kubectl.kubernetes.io/last-applied-configuration\\\": \\\"{\\\\\\\"apiVersion\\\\\\\":\\\\\\\"v1\\\\\\\",\\\\\\\"data\\\\\\\":{\\\\\\\"spring.rabbitmq.password\\\\\\\":\\\\\\\"password\\\\\\\"},\\\\\\\"kind\\\\\\\":\\\\\\\"Secret\\\\\\\",\\\\\\\"metadata\\\\\\\":{\\\\\\\"annotations\\\\\\\":{},\\\\\\\"labels\\\\\\\":{\\\\\\\"spring.cloud.kubernetes.secret\\\\\\\":\\\\\\\"true\\\\\\\"},\\\\\\\"name\\\\\\\":\\\\\\\"rabbit-password\\\\\\\",\\\\\\\"namespace\\\\\\\":\\\\\\\"default\\\\\\\"},\\\\\\\"type\\\\\\\":\\\\\\\"Opaque\\\\\\\"}\\\\n\\\"\\n\"+ \"\\t\\t\\t\\t}\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"data\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"spring.rabbitmq.password\\\": \\\"cGFzc3dvcmQ\u003d\\\"\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"type\\\": \\\"Opaque\\\"\\n\"+ \"\\t\\t}\\n\"+ \"\\t]\\n\"+ \"}\";\n  private static WireMockServer wireMockServer;\n  @BeforeAll static void setup();\n  @AfterAll static void after();\n  @AfterEach void afterEach();\n  @Test void emptyDataSecretTest();\n  @Test void secretsTest();\n  @Test void secretLabelsTest();\n  @Test void constructorShouldThrowExceptionOnFailureWhenFailFastIsEnabled();\n  @Test void constructorShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientSecretsPropertySourceLocatorTests.java",
        "name": "KubernetesClientSecretsPropertySourceLocatorTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientSecretsPropertySourceLocatorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\nclass KubernetesClientSecretsPropertySourceLocatorTests {\n  private static final String LIST_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final String LIST_BODY\u003d\"{\\n\" + \"\\t\\\"kind\\\": \\\"SecretList\\\",\\n\" + \"\\t\\\"apiVersion\\\": \\\"v1\\\",\\n\"+ \"\\t\\\"metadata\\\": {\\n\"+ \"\\t\\t\\\"selfLink\\\": \\\"/api/v1/secrets\\\",\\n\"+ \"\\t\\t\\\"resourceVersion\\\": \\\"163035\\\"\\n\"+ \"\\t},\\n\"+ \"\\t\\\"items\\\": [{\\n\"+ \"\\t\\t\\t\\\"metadata\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"name\\\": \\\"db-secret\\\",\\n\"+ \"\\t\\t\\t\\t\\\"namespace\\\": \\\"default\\\",\\n\"+ \"\\t\\t\\t\\t\\\"selfLink\\\": \\\"/api/v1/namespaces/default/secrets/db-secret\\\",\\n\"+ \"\\t\\t\\t\\t\\\"uid\\\": \\\"59ba8e6a-a2d4-416c-b016-22597c193f23\\\",\\n\"+ \"\\t\\t\\t\\t\\\"resourceVersion\\\": \\\"1462\\\",\\n\"+ \"\\t\\t\\t\\t\\\"creationTimestamp\\\": \\\"2020-10-28T14:45:02Z\\\",\\n\"+ \"\\t\\t\\t\\t\\\"labels\\\": {\\n\"+ \"\\t\\t\\t\\t\\t\\\"spring.cloud.kubernetes.secret\\\": \\\"true\\\"\\n\"+ \"\\t\\t\\t\\t}\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"data\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"password\\\": \\\"cDQ1NXcwcmQ\u003d\\\",\\n\"+ \"\\t\\t\\t\\t\\\"username\\\": \\\"dXNlcg\u003d\u003d\\\"\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"type\\\": \\\"Opaque\\\"\\n\"+ \"\\t\\t},\\n\"+ \"\\t\\t{\\n\"+ \"\\t\\t\\t\\\"metadata\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"name\\\": \\\"rabbit-password\\\",\\n\"+ \"\\t\\t\\t\\t\\\"namespace\\\": \\\"default\\\",\\n\"+ \"\\t\\t\\t\\t\\\"selfLink\\\": \\\"/api/v1/namespaces/default/secrets/rabbit-password\\\",\\n\"+ \"\\t\\t\\t\\t\\\"uid\\\": \\\"bc211cb4-e7ff-4556-b26e-c54911301740\\\",\\n\"+ \"\\t\\t\\t\\t\\\"resourceVersion\\\": \\\"162708\\\",\\n\"+ \"\\t\\t\\t\\t\\\"creationTimestamp\\\": \\\"2020-10-29T19:47:36Z\\\",\\n\"+ \"\\t\\t\\t\\t\\\"labels\\\": {\\n\"+ \"\\t\\t\\t\\t\\t\\\"spring.cloud.kubernetes.secret\\\": \\\"true\\\"\\n\"+ \"\\t\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\t\\\"annotations\\\": {\\n\"+ \"\\t\\t\\t\\t\\t\\\"kubectl.kubernetes.io/last-applied-configuration\\\": \\\"{\\\\\\\"apiVersion\\\\\\\":\\\\\\\"v1\\\\\\\",\\\\\\\"data\\\\\\\":{\\\\\\\"spring.rabbitmq.password\\\\\\\":\\\\\\\"password\\\\\\\"},\\\\\\\"kind\\\\\\\":\\\\\\\"Secret\\\\\\\",\\\\\\\"metadata\\\\\\\":{\\\\\\\"annotations\\\\\\\":{},\\\\\\\"labels\\\\\\\":{\\\\\\\"spring.cloud.kubernetes.secret\\\\\\\":\\\\\\\"true\\\\\\\"},\\\\\\\"name\\\\\\\":\\\\\\\"rabbit-password\\\\\\\",\\\\\\\"namespace\\\\\\\":\\\\\\\"default\\\\\\\"},\\\\\\\"type\\\\\\\":\\\\\\\"Opaque\\\\\\\"}\\\\n\\\"\\n\"+ \"\\t\\t\\t\\t}\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"data\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"spring.rabbitmq.password\\\": \\\"cGFzc3dvcmQ\u003d\\\"\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"type\\\": \\\"Opaque\\\"\\n\"+ \"\\t\\t}\\n\"+ \"\\t]\\n\"+ \"}\";\n  private static WireMockServer wireMockServer;\n  private static final MockEnvironment ENV\u003dnew MockEnvironment();\n  @BeforeAll static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    client.setDebugging(true);\n    Configuration.setDefaultApiClient(client);\n  }\n  @AfterAll static void after(){\n    wireMockServer.stop();\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n  }\n  @Test void getLocateWithSources(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(LIST_API).willReturn(aResponse().withStatus(200).withBody(LIST_BODY)));\n    SecretsConfigProperties.Source source1\u003dnew SecretsConfigProperties.Source(\"db-secret\",\"\",Collections.emptyMap(),null,null,null);\n    SecretsConfigProperties.Source source2\u003dnew SecretsConfigProperties.Source(\"rabbit-password\",\"\",Collections.emptyMap(),null,null,null);\n    SecretsConfigProperties secretsConfigProperties\u003dnew SecretsConfigProperties(true,Map.of(),List.of(),List.of(source1,source2),true,\"app\",\"default\",false,true,false,RetryProperties.DEFAULT);\n    PropertySource\u003c?\u003e propertySource\u003dnew KubernetesClientSecretsPropertySourceLocator(api,new KubernetesNamespaceProvider(new MockEnvironment()),secretsConfigProperties).locate(ENV);\n    assertThat(propertySource.containsProperty(\"password\")).isTrue();\n    assertThat(propertySource.getProperty(\"password\")).isEqualTo(\"p455w0rd\");\n  }\n  @Test void getLocateWithOutSources(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(LIST_API).willReturn(aResponse().withStatus(200).withBody(LIST_BODY)));\n    SecretsConfigProperties secretsConfigProperties\u003dnew SecretsConfigProperties(true,Map.of(),List.of(),List.of(),true,\"db-secret\",\"default\",false,true,false,RetryProperties.DEFAULT);\n    PropertySource\u003c?\u003e propertySource\u003dnew KubernetesClientSecretsPropertySourceLocator(api,new KubernetesNamespaceProvider(new MockEnvironment()),secretsConfigProperties).locate(ENV);\n    assertThat(propertySource.containsProperty(\"password\")).isTrue();\n    assertThat(propertySource.getProperty(\"password\")).isEqualTo(\"p455w0rd\");\n  }\n  /** \n * \u003cpre\u003e 1. not providing the namespace \u003c/pre\u003e will result in an Exception\n */\n  @Test void testLocateWithoutNamespaceConstructor(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(LIST_API).willReturn(aResponse().withStatus(200).withBody(LIST_BODY)));\n    SecretsConfigProperties secretsConfigProperties\u003dnew SecretsConfigProperties(true,Map.of(),List.of(),List.of(),true,\"db-secret\",\"\",false,true,false,RetryProperties.DEFAULT);\n    assertThatThrownBy(() -\u003e new KubernetesClientSecretsPropertySourceLocator(api,new KubernetesNamespaceProvider(new MockEnvironment()),secretsConfigProperties).locate(ENV)).isInstanceOf(NamespaceResolutionFailedException.class);\n  }\n  @Test void locateShouldThrowExceptionOnFailureWhenFailFastIsEnabled(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(LIST_API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    SecretsConfigProperties secretsConfigProperties\u003dnew SecretsConfigProperties(true,Map.of(),List.of(),List.of(),true,\"db-secret\",\"default\",false,true,true,RetryProperties.DEFAULT);\n    KubernetesClientSecretsPropertySourceLocator locator\u003dnew KubernetesClientSecretsPropertySourceLocator(api,new KubernetesNamespaceProvider(new MockEnvironment()),secretsConfigProperties);\n    assertThatThrownBy(() -\u003e locator.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessage(\"Internal Server Error\");\n  }\n  @Test void locateShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(LIST_API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    SecretsConfigProperties secretsConfigProperties\u003dnew SecretsConfigProperties(true,Map.of(),List.of(),List.of(),true,\"db-secret\",\"default\",false,true,false,RetryProperties.DEFAULT);\n    KubernetesClientSecretsPropertySourceLocator locator\u003dnew KubernetesClientSecretsPropertySourceLocator(api,new KubernetesNamespaceProvider(new MockEnvironment()),secretsConfigProperties);\n    assertThatNoException().isThrownBy(() -\u003e locator.locate(new MockEnvironment()));\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\nclass KubernetesClientSecretsPropertySourceLocatorTests {\n  private static final String LIST_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final String LIST_BODY\u003d\"{\\n\" + \"\\t\\\"kind\\\": \\\"SecretList\\\",\\n\" + \"\\t\\\"apiVersion\\\": \\\"v1\\\",\\n\"+ \"\\t\\\"metadata\\\": {\\n\"+ \"\\t\\t\\\"selfLink\\\": \\\"/api/v1/secrets\\\",\\n\"+ \"\\t\\t\\\"resourceVersion\\\": \\\"163035\\\"\\n\"+ \"\\t},\\n\"+ \"\\t\\\"items\\\": [{\\n\"+ \"\\t\\t\\t\\\"metadata\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"name\\\": \\\"db-secret\\\",\\n\"+ \"\\t\\t\\t\\t\\\"namespace\\\": \\\"default\\\",\\n\"+ \"\\t\\t\\t\\t\\\"selfLink\\\": \\\"/api/v1/namespaces/default/secrets/db-secret\\\",\\n\"+ \"\\t\\t\\t\\t\\\"uid\\\": \\\"59ba8e6a-a2d4-416c-b016-22597c193f23\\\",\\n\"+ \"\\t\\t\\t\\t\\\"resourceVersion\\\": \\\"1462\\\",\\n\"+ \"\\t\\t\\t\\t\\\"creationTimestamp\\\": \\\"2020-10-28T14:45:02Z\\\",\\n\"+ \"\\t\\t\\t\\t\\\"labels\\\": {\\n\"+ \"\\t\\t\\t\\t\\t\\\"spring.cloud.kubernetes.secret\\\": \\\"true\\\"\\n\"+ \"\\t\\t\\t\\t}\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"data\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"password\\\": \\\"cDQ1NXcwcmQ\u003d\\\",\\n\"+ \"\\t\\t\\t\\t\\\"username\\\": \\\"dXNlcg\u003d\u003d\\\"\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"type\\\": \\\"Opaque\\\"\\n\"+ \"\\t\\t},\\n\"+ \"\\t\\t{\\n\"+ \"\\t\\t\\t\\\"metadata\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"name\\\": \\\"rabbit-password\\\",\\n\"+ \"\\t\\t\\t\\t\\\"namespace\\\": \\\"default\\\",\\n\"+ \"\\t\\t\\t\\t\\\"selfLink\\\": \\\"/api/v1/namespaces/default/secrets/rabbit-password\\\",\\n\"+ \"\\t\\t\\t\\t\\\"uid\\\": \\\"bc211cb4-e7ff-4556-b26e-c54911301740\\\",\\n\"+ \"\\t\\t\\t\\t\\\"resourceVersion\\\": \\\"162708\\\",\\n\"+ \"\\t\\t\\t\\t\\\"creationTimestamp\\\": \\\"2020-10-29T19:47:36Z\\\",\\n\"+ \"\\t\\t\\t\\t\\\"labels\\\": {\\n\"+ \"\\t\\t\\t\\t\\t\\\"spring.cloud.kubernetes.secret\\\": \\\"true\\\"\\n\"+ \"\\t\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\t\\\"annotations\\\": {\\n\"+ \"\\t\\t\\t\\t\\t\\\"kubectl.kubernetes.io/last-applied-configuration\\\": \\\"{\\\\\\\"apiVersion\\\\\\\":\\\\\\\"v1\\\\\\\",\\\\\\\"data\\\\\\\":{\\\\\\\"spring.rabbitmq.password\\\\\\\":\\\\\\\"password\\\\\\\"},\\\\\\\"kind\\\\\\\":\\\\\\\"Secret\\\\\\\",\\\\\\\"metadata\\\\\\\":{\\\\\\\"annotations\\\\\\\":{},\\\\\\\"labels\\\\\\\":{\\\\\\\"spring.cloud.kubernetes.secret\\\\\\\":\\\\\\\"true\\\\\\\"},\\\\\\\"name\\\\\\\":\\\\\\\"rabbit-password\\\\\\\",\\\\\\\"namespace\\\\\\\":\\\\\\\"default\\\\\\\"},\\\\\\\"type\\\\\\\":\\\\\\\"Opaque\\\\\\\"}\\\\n\\\"\\n\"+ \"\\t\\t\\t\\t}\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"data\\\": {\\n\"+ \"\\t\\t\\t\\t\\\"spring.rabbitmq.password\\\": \\\"cGFzc3dvcmQ\u003d\\\"\\n\"+ \"\\t\\t\\t},\\n\"+ \"\\t\\t\\t\\\"type\\\": \\\"Opaque\\\"\\n\"+ \"\\t\\t}\\n\"+ \"\\t]\\n\"+ \"}\";\n  private static WireMockServer wireMockServer;\n  private static final MockEnvironment ENV\u003dnew MockEnvironment();\n  @BeforeAll static void setup();\n  @AfterAll static void after();\n  @AfterEach void afterEach();\n  @Test void getLocateWithSources();\n  @Test void getLocateWithOutSources();\n  /** \n * \u003cpre\u003e 1. not providing the namespace \u003c/pre\u003e will result in an Exception\n */\n  @Test void testLocateWithoutNamespaceConstructor();\n  @Test void locateShouldThrowExceptionOnFailureWhenFailFastIsEnabled();\n  @Test void locateShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientConfigMapPropertySourceTests.java",
        "name": "KubernetesClientConfigMapPropertySourceTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientConfigMapPropertySourceTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\nclass KubernetesClientConfigMapPropertySourceTests {\n  private static final V1ConfigMapList PROPERTIES_CONFIGMAP_LIST\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"bootstrap-640\").withNamespace(\"default\").withResourceVersion(\"1\").build()).addToData(\"application.properties\",\"spring.cloud.kubernetes.configuration.watcher.refreshDelay\u003d0\\n\" + \"logging.level.org.springframework.cloud.kubernetes\u003dTRACE\").build());\n  private static final V1ConfigMapList YAML_CONFIGMAP_LIST\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"bootstrap-641\").withNamespace(\"default\").withResourceVersion(\"1\").build()).addToData(\"application.yaml\",\"dummy:\\n  property:\\n    string2: \\\"a\\\"\\n    int2: 1\\n    bool2: true\\n\").build());\n  private static WireMockServer wireMockServer;\n  @BeforeAll public static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    client.setDebugging(true);\n    Configuration.setDefaultApiClient(client);\n  }\n  @AfterAll public static void after(){\n    wireMockServer.stop();\n  }\n  @AfterEach public void afterEach(){\n    WireMock.reset();\n    new KubernetesClientConfigMapsCache().discardAll();\n  }\n  @Test public void propertiesFile(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(\"/api/v1/namespaces/default/configmaps\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(PROPERTIES_CONFIGMAP_LIST))));\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(\"bootstrap-640\",\"default\",false,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,\"default\",new MockEnvironment());\n    KubernetesClientConfigMapPropertySource propertySource\u003dnew KubernetesClientConfigMapPropertySource(context);\n    verify(getRequestedFor(urlEqualTo(\"/api/v1/namespaces/default/configmaps\")));\n    assertThat(propertySource.containsProperty(\"spring.cloud.kubernetes.configuration.watcher.refreshDelay\")).isTrue();\n    assertThat(propertySource.getProperty(\"spring.cloud.kubernetes.configuration.watcher.refreshDelay\")).isEqualTo(\"0\");\n    assertThat(propertySource.containsProperty(\"logging.level.org.springframework.cloud.kubernetes\")).isTrue();\n    assertThat(propertySource.getProperty(\"logging.level.org.springframework.cloud.kubernetes\")).isEqualTo(\"TRACE\");\n  }\n  @Test public void yamlFile(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(\"/api/v1/namespaces/default/configmaps\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(YAML_CONFIGMAP_LIST))));\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(\"bootstrap-641\",\"default\",false,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,\"default\",new MockEnvironment());\n    KubernetesClientConfigMapPropertySource propertySource\u003dnew KubernetesClientConfigMapPropertySource(context);\n    verify(getRequestedFor(urlEqualTo(\"/api/v1/namespaces/default/configmaps\")));\n    assertThat(propertySource.containsProperty(\"dummy.property.string2\")).isTrue();\n    assertThat(propertySource.getProperty(\"dummy.property.string2\")).isEqualTo(\"a\");\n    assertThat(propertySource.containsProperty(\"dummy.property.int2\")).isTrue();\n    assertThat(propertySource.getProperty(\"dummy.property.int2\")).isEqualTo(1);\n    assertThat(propertySource.containsProperty(\"dummy.property.bool2\")).isTrue();\n    assertThat(propertySource.getProperty(\"dummy.property.bool2\")).isEqualTo(true);\n  }\n  @Test public void propertiesFileWithPrefix(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(\"/api/v1/namespaces/default/configmaps\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(PROPERTIES_CONFIGMAP_LIST))));\n    ConfigUtils.Prefix prefix\u003dConfigUtils.findPrefix(\"prefix\",false,false,null);\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(\"bootstrap-640\",\"default\",false,prefix,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,\"default\",new MockEnvironment());\n    KubernetesClientConfigMapPropertySource propertySource\u003dnew KubernetesClientConfigMapPropertySource(context);\n    verify(getRequestedFor(urlEqualTo(\"/api/v1/namespaces/default/configmaps\")));\n    assertThat(propertySource.containsProperty(\"prefix.spring.cloud.kubernetes.configuration.watcher.refreshDelay\")).isTrue();\n    assertThat(propertySource.getProperty(\"prefix.spring.cloud.kubernetes.configuration.watcher.refreshDelay\")).isEqualTo(\"0\");\n    assertThat(propertySource.containsProperty(\"prefix.logging.level.org.springframework.cloud.kubernetes\")).isTrue();\n    assertThat(propertySource.getProperty(\"prefix.logging.level.org.springframework.cloud.kubernetes\")).isEqualTo(\"TRACE\");\n  }\n  @Test void constructorWithNamespaceMustNotFail(){\n    ConfigUtils.Prefix prefix\u003dConfigUtils.findPrefix(\"prefix\",false,false,null);\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(\"bootstrap-640\",\"default\",false,prefix,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(new CoreV1Api(),source,\"default\",new MockEnvironment());\n    assertThat(new KubernetesClientConfigMapPropertySource(context)).isNotNull();\n  }\n  @Test public void constructorShouldThrowExceptionOnFailureWhenFailFastIsEnabled(){\n    stubFor(get(\"/api/v1/namespaces/default/configmaps\").willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    ConfigUtils.Prefix prefix\u003dConfigUtils.findPrefix(\"prefix\",false,false,null);\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(\"my-config\",\"default\",true,prefix,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(new CoreV1Api(),source,\"default\",new MockEnvironment());\n    assertThatThrownBy(() -\u003e new KubernetesClientConfigMapPropertySource(context)).isInstanceOf(IllegalStateException.class).hasMessage(\"Internal Server Error\");\n    verify(getRequestedFor(urlEqualTo(\"/api/v1/namespaces/default/configmaps\")));\n  }\n  @Test public void constructorShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled(){\n    stubFor(get(\"/api/v1/namespaces/default/configmaps\").willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    ConfigUtils.Prefix prefix\u003dConfigUtils.findPrefix(\"prefix\",false,false,null);\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(\"my-config\",\"default\",false,prefix,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(new CoreV1Api(),source,\"default\",new MockEnvironment());\n    assertThatNoException().isThrownBy((() -\u003e new KubernetesClientConfigMapPropertySource(context)));\n    verify(getRequestedFor(urlEqualTo(\"/api/v1/namespaces/default/configmaps\")));\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\nclass KubernetesClientConfigMapPropertySourceTests {\n  private static final V1ConfigMapList PROPERTIES_CONFIGMAP_LIST\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"bootstrap-640\").withNamespace(\"default\").withResourceVersion(\"1\").build()).addToData(\"application.properties\",\"spring.cloud.kubernetes.configuration.watcher.refreshDelay\u003d0\\n\" + \"logging.level.org.springframework.cloud.kubernetes\u003dTRACE\").build());\n  private static final V1ConfigMapList YAML_CONFIGMAP_LIST\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"bootstrap-641\").withNamespace(\"default\").withResourceVersion(\"1\").build()).addToData(\"application.yaml\",\"dummy:\\n  property:\\n    string2: \\\"a\\\"\\n    int2: 1\\n    bool2: true\\n\").build());\n  private static WireMockServer wireMockServer;\n  @BeforeAll public static void setup();\n  @AfterAll public static void after();\n  @AfterEach public void afterEach();\n  @Test public void propertiesFile();\n  @Test public void yamlFile();\n  @Test public void propertiesFileWithPrefix();\n  @Test void constructorWithNamespaceMustNotFail();\n  @Test public void constructorShouldThrowExceptionOnFailureWhenFailFastIsEnabled();\n  @Test public void constructorShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/NamedConfigMapContextToSourceDataProviderTests.java",
        "name": "NamedConfigMapContextToSourceDataProviderTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.NamedConfigMapContextToSourceDataProviderTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class NamedConfigMapContextToSourceDataProviderTests {\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String RED_CONFIG_MAP_NAME\u003d\"red\";\n  private static final String RED_WITH_PROFILE_CONFIG_MAP_NAME\u003dRED_CONFIG_MAP_NAME + \"-with-profile\";\n  private static final String BLUE_CONFIG_MAP_NAME\u003d\"blue\";\n  private static final Map\u003cString,String\u003e COLOR_REALLY_RED\u003dMap.of(\"color\",\"really-red\");\n  private static final Map\u003cString,String\u003e TASTE_MANGO\u003dMap.of(\"taste\",\"mango\");\n  @BeforeAll static void setup(){\n    WireMockServer wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    client.setDebugging(true);\n    Configuration.setDefaultApiClient(client);\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n    new KubernetesClientConfigMapsCache().discardAll();\n  }\n  /** \n * \u003cpre\u003e one configmap deployed with name \"red\" we search by name, but for the \"blue\" one, as such not find it \u003c/pre\u003e\n */\n  @Test void noMatch(){\n    V1ConfigMap redConfigMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(RED_CONFIG_MAP_NAME).withNamespace(NAMESPACE).build()).addToData(COLOR_REALLY_RED).build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(redConfigMap);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(BLUE_CONFIG_MAP_NAME,NAMESPACE,true,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.blue.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Map.of());\n  }\n  /** \n * \u003cpre\u003e one configmap deployed with name \"red\" we search by name, for the \"red\" one, as such we find it \u003c/pre\u003e\n */\n  @Test void match(){\n    V1ConfigMap configMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(RED_CONFIG_MAP_NAME).withNamespace(NAMESPACE).build()).addToData(COLOR_REALLY_RED).build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(configMap);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(RED_CONFIG_MAP_NAME,NAMESPACE,true,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red.default\");\n    Assertions.assertEquals(sourceData.sourceData(),COLOR_REALLY_RED);\n  }\n  /** \n * \u003cpre\u003e - two configmaps deployed : \"red\" and \"red-with-profile\". - \"red\" is matched directly, \"red-with-profile\" is matched because we have an active profile \"active-profile\" \u003c/pre\u003e\n */\n  @Test void matchIncludeSingleProfile(){\n    V1ConfigMap red\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(RED_CONFIG_MAP_NAME).withNamespace(NAMESPACE).build()).addToData(COLOR_REALLY_RED).build();\n    V1ConfigMap redWithProfile\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(RED_WITH_PROFILE_CONFIG_MAP_NAME).withNamespace(NAMESPACE).build()).addToData(TASTE_MANGO).build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(red).addItemsItem(redWithProfile);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(RED_CONFIG_MAP_NAME,NAMESPACE,true,ConfigUtils.Prefix.DEFAULT,true,true);\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"with-profile\");\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,environment,false);\n    KubernetesClientContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red.red-with-profile.default.with-profile\");\n    Assertions.assertEquals(sourceData.sourceData().size(),1);\n    Assertions.assertEquals(sourceData.sourceData().get(\"taste\"),\"mango\");\n  }\n  /** \n * \u003cpre\u003e - two configmaps deployed : \"red\" and \"red-with-profile\". - \"red\" is matched directly, \"red-with-profile\" is matched because we have an active profile \"active-profile\" -  This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based config maps as well. \u003c/pre\u003e\n */\n  @Test void matchIncludeSingleProfileWithPrefix(){\n    V1ConfigMap red\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(RED_CONFIG_MAP_NAME).withNamespace(NAMESPACE).build()).addToData(COLOR_REALLY_RED).build();\n    V1ConfigMap redWithTaste\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(RED_WITH_PROFILE_CONFIG_MAP_NAME).withNamespace(NAMESPACE).build()).addToData(TASTE_MANGO).build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(red).addItemsItem(redWithTaste);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    ConfigUtils.Prefix prefix\u003dConfigUtils.findPrefix(\"some\",false,false,null);\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(RED_CONFIG_MAP_NAME,NAMESPACE,true,prefix,true);\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"with-profile\");\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,environment);\n    KubernetesClientContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red.red-with-profile.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.color\"),\"really-red\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.taste\"),\"mango\");\n  }\n  /** \n * \u003cpre\u003e - three configmaps deployed : \"red\", \"red-with-taste\" and \"red-with-shape\" - \"red\" is matched directly, the other two are matched because of active profiles -  This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based config maps as well. \u003c/pre\u003e\n */\n  @Test void matchIncludeTwoProfilesWithPrefix(){\n    V1ConfigMap red\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(RED_CONFIG_MAP_NAME).withNamespace(NAMESPACE).build()).addToData(COLOR_REALLY_RED).build();\n    V1ConfigMap redWithTaste\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(RED_CONFIG_MAP_NAME + \"-with-taste\").withNamespace(NAMESPACE).withResourceVersion(\"1\").build()).addToData(TASTE_MANGO).build();\n    V1ConfigMap redWithShape\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(RED_CONFIG_MAP_NAME + \"-with-shape\").withNamespace(NAMESPACE).build()).addToData(\"shape\",\"round\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(red).addItemsItem(redWithTaste).addItemsItem(redWithShape);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    ConfigUtils.Prefix prefix\u003dConfigUtils.findPrefix(\"some\",false,false,null);\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(RED_CONFIG_MAP_NAME,NAMESPACE,true,prefix,true);\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"with-taste\",\"with-shape\");\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,environment);\n    KubernetesClientContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red.red-with-shape.red-with-taste.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),3);\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.color\"),\"really-red\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.taste\"),\"mango\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"some.shape\"),\"round\");\n  }\n  /** \n * \u003cpre\u003e proves that an implicit configmap is going to be generated and read, even if we did not provide one \u003c/pre\u003e\n */\n  @Test void matchWithName(){\n    V1ConfigMap red\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"application\").withNamespace(NAMESPACE).build()).addToData(\"color\",\"red\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(red);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    ConfigUtils.Prefix prefix\u003dConfigUtils.findPrefix(\"some\",false,false,null);\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(\"application\",NAMESPACE,true,prefix,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.application.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Collections.singletonMap(\"some.color\",\"red\"));\n  }\n  /** \n * \u003cpre\u003e - NamedSecretContextToSourceDataProvider gets as input a KubernetesClientConfigContext. - This context has a namespace as well as a NormalizedSource, that has a namespace too. - This test makes sure that we use the proper one. \u003c/pre\u003e\n */\n  @Test void namespaceMatch(){\n    V1ConfigMap configMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(RED_CONFIG_MAP_NAME).withNamespace(NAMESPACE).build()).addToData(COLOR_REALLY_RED).build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(configMap);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    String wrongNamespace\u003dNAMESPACE + \"nope\";\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(RED_CONFIG_MAP_NAME,wrongNamespace,true,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red.default\");\n    Assertions.assertEquals(sourceData.sourceData(),COLOR_REALLY_RED);\n  }\n  /** \n * \u003cpre\u003e - proves that single yaml file gets special treatment \u003c/pre\u003e\n */\n  @Test void testSingleYaml(){\n    V1ConfigMap singleYaml\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(RED_CONFIG_MAP_NAME).withNamespace(NAMESPACE).build()).addToData(\"single.yaml\",\"key: value\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(singleYaml);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(RED_CONFIG_MAP_NAME,NAMESPACE,true,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Map.of(\"key\",\"value\"));\n  }\n  /** \n * \u003cpre\u003e - one configmap is deployed with name \"one\" - profile is enabled with name \"k8s\" we assert that the name of the source is \"one\" and does not contain \"one-dev\" \u003c/pre\u003e\n */\n  @Test void testCorrectNameWithProfile(){\n    V1ConfigMap one\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"one\").withNamespace(NAMESPACE).build()).addToData(\"key\",\"value\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(one);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource source\u003dnew NamedConfigMapNormalizedSource(\"one\",NAMESPACE,true,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,environment);\n    KubernetesClientContextToSourceData data\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.one.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Map.of(\"key\",\"value\"));\n  }\n  /** \n * \u003cpre\u003e - one configmap is deployed with name \"red\" - one configmap is deployed with name \"green\" - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output){\n    V1ConfigMap red\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"red\").withNamespace(NAMESPACE).build()).addToData(\"color\",\"red\").build();\n    V1ConfigMap green\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"green\").withNamespace(NAMESPACE).build()).addToData(\"color\",\"green\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(red).addItemsItem(green);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    NormalizedSource redSource\u003dnew NamedConfigMapNormalizedSource(\"red\",NAMESPACE,true,false);\n    KubernetesClientConfigContext redContext\u003dnew KubernetesClientConfigContext(api,redSource,NAMESPACE,environment);\n    KubernetesClientContextToSourceData redData\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData redSourceData\u003dredData.apply(redContext);\n    Assertions.assertEquals(redSourceData.sourceName(),\"configmap.red.default\");\n    Assertions.assertEquals(redSourceData.sourceData(),Map.of(\"color\",\"red\"));\n    Assertions.assertTrue(output.getAll().contains(\"Loaded all config maps in namespace \u0027\" + NAMESPACE + \"\u0027\"));\n    NormalizedSource greenSource\u003dnew NamedConfigMapNormalizedSource(\"green\",NAMESPACE,true,true);\n    KubernetesClientConfigContext greenContext\u003dnew KubernetesClientConfigContext(api,greenSource,NAMESPACE,environment);\n    KubernetesClientContextToSourceData greenData\u003dnew NamedConfigMapContextToSourceDataProvider().get();\n    SourceData greenSourceData\u003dgreenData.apply(greenContext);\n    Assertions.assertEquals(greenSourceData.sourceName(),\"configmap.green.default\");\n    Assertions.assertEquals(greenSourceData.sourceData(),Map.of(\"color\",\"green\"));\n    String[] out\u003doutput.getAll().split(\"Loaded all config maps in namespace\");\n    Assertions.assertEquals(out.length,2);\n    out\u003doutput.getAll().split(\"Loaded \\\\(from cache\\\\) all config maps in namespace\");\n    Assertions.assertEquals(out.length,2);\n  }\n  private void stubCall(  V1ConfigMapList list){\n    stubFor(get(\"/api/v1/namespaces/default/configmaps\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(list))));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class NamedConfigMapContextToSourceDataProviderTests {\n  private static final String NAMESPACE\u003d\"default\";\n  private static final String RED_CONFIG_MAP_NAME\u003d\"red\";\n  private static final String RED_WITH_PROFILE_CONFIG_MAP_NAME\u003dRED_CONFIG_MAP_NAME + \"-with-profile\";\n  private static final String BLUE_CONFIG_MAP_NAME\u003d\"blue\";\n  private static final Map\u003cString,String\u003e COLOR_REALLY_RED\u003dMap.of(\"color\",\"really-red\");\n  private static final Map\u003cString,String\u003e TASTE_MANGO\u003dMap.of(\"taste\",\"mango\");\n  @BeforeAll static void setup();\n  @AfterEach void afterEach();\n  /** \n * \u003cpre\u003e one configmap deployed with name \"red\" we search by name, but for the \"blue\" one, as such not find it \u003c/pre\u003e\n */\n  @Test void noMatch();\n  /** \n * \u003cpre\u003e one configmap deployed with name \"red\" we search by name, for the \"red\" one, as such we find it \u003c/pre\u003e\n */\n  @Test void match();\n  /** \n * \u003cpre\u003e - two configmaps deployed : \"red\" and \"red-with-profile\". - \"red\" is matched directly, \"red-with-profile\" is matched because we have an active profile \"active-profile\" \u003c/pre\u003e\n */\n  @Test void matchIncludeSingleProfile();\n  /** \n * \u003cpre\u003e - two configmaps deployed : \"red\" and \"red-with-profile\". - \"red\" is matched directly, \"red-with-profile\" is matched because we have an active profile \"active-profile\" -  This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based config maps as well. \u003c/pre\u003e\n */\n  @Test void matchIncludeSingleProfileWithPrefix();\n  /** \n * \u003cpre\u003e - three configmaps deployed : \"red\", \"red-with-taste\" and \"red-with-shape\" - \"red\" is matched directly, the other two are matched because of active profiles -  This takes into consideration the prefix, that we explicitly specify. Notice that prefix works for profile based config maps as well. \u003c/pre\u003e\n */\n  @Test void matchIncludeTwoProfilesWithPrefix();\n  /** \n * \u003cpre\u003e proves that an implicit configmap is going to be generated and read, even if we did not provide one \u003c/pre\u003e\n */\n  @Test void matchWithName();\n  /** \n * \u003cpre\u003e - NamedSecretContextToSourceDataProvider gets as input a KubernetesClientConfigContext. - This context has a namespace as well as a NormalizedSource, that has a namespace too. - This test makes sure that we use the proper one. \u003c/pre\u003e\n */\n  @Test void namespaceMatch();\n  /** \n * \u003cpre\u003e - proves that single yaml file gets special treatment \u003c/pre\u003e\n */\n  @Test void testSingleYaml();\n  /** \n * \u003cpre\u003e - one configmap is deployed with name \"one\" - profile is enabled with name \"k8s\" we assert that the name of the source is \"one\" and does not contain \"one-dev\" \u003c/pre\u003e\n */\n  @Test void testCorrectNameWithProfile();\n  /** \n * \u003cpre\u003e - one configmap is deployed with name \"red\" - one configmap is deployed with name \"green\" - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output);\n  private void stubCall(  V1ConfigMapList list);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientConfigMapPropertySourceLocatorTests.java",
        "name": "KubernetesClientConfigMapPropertySourceLocatorTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientConfigMapPropertySourceLocatorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\nclass KubernetesClientConfigMapPropertySourceLocatorTests {\n  private static final V1ConfigMapList PROPERTIES_CONFIGMAP_LIST\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"bootstrap-640\").withNamespace(\"default\").withResourceVersion(\"1\").build()).addToData(\"application.properties\",\"spring.cloud.kubernetes.configuration.watcher.refreshDelay\u003d0\\n\" + \"logging.level.org.springframework.cloud.kubernetes\u003dTRACE\").build());\n  private static WireMockServer wireMockServer;\n  private static final MockEnvironment ENV\u003dnew MockEnvironment();\n  @BeforeAll public static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    client.setDebugging(true);\n    Configuration.setDefaultApiClient(client);\n  }\n  @AfterAll public static void after(){\n    wireMockServer.stop();\n  }\n  @AfterEach public void afterEach(){\n    WireMock.reset();\n  }\n  @Test void locateWithoutSources(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(\"/api/v1/namespaces/default/configmaps\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(PROPERTIES_CONFIGMAP_LIST))));\n    ConfigMapConfigProperties configMapConfigProperties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(),Map.of(),true,\"bootstrap-640\",null,false,false,false,RetryProperties.DEFAULT);\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setProperty(\"spring.cloud.kubernetes.client.namespace\",\"default\");\n    PropertySource\u003c?\u003e propertySource\u003dnew KubernetesClientConfigMapPropertySourceLocator(api,configMapConfigProperties,new KubernetesNamespaceProvider(mockEnvironment)).locate(ENV);\n    assertThat(propertySource.containsProperty(\"spring.cloud.kubernetes.configuration.watcher.refreshDelay\")).isTrue();\n  }\n  @Test void locateWithSources(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(\"/api/v1/namespaces/default/configmaps\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(PROPERTIES_CONFIGMAP_LIST))));\n    ConfigMapConfigProperties.Source source\u003dnew ConfigMapConfigProperties.Source(\"bootstrap-640\",\"default\",Collections.emptyMap(),null,null,null);\n    ConfigMapConfigProperties configMapConfigProperties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(source),Map.of(),true,\"fake-name\",null,false,false,false,RetryProperties.DEFAULT);\n    PropertySource\u003c?\u003e propertySource\u003dnew KubernetesClientConfigMapPropertySourceLocator(api,configMapConfigProperties,new KubernetesNamespaceProvider(new MockEnvironment())).locate(ENV);\n    assertThat(propertySource.containsProperty(\"spring.cloud.kubernetes.configuration.watcher.refreshDelay\")).isTrue();\n  }\n  /** \n * \u003cpre\u003e 1. not providing the namespace \u003c/pre\u003e will result in an Exception\n */\n  @Test void testLocateWithoutNamespaceConstructor(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(\"/api/v1/namespaces/default/configmaps\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(PROPERTIES_CONFIGMAP_LIST))));\n    ConfigMapConfigProperties configMapConfigProperties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(),Map.of(),true,\"bootstrap-640\",null,false,false,false,RetryProperties.DEFAULT);\n    assertThatThrownBy(() -\u003e new KubernetesClientConfigMapPropertySourceLocator(api,configMapConfigProperties,new KubernetesNamespaceProvider(new MockEnvironment())).locate(ENV)).isInstanceOf(NamespaceResolutionFailedException.class);\n  }\n  /** \n * \u003cpre\u003e 1. not providing the namespace \u003c/pre\u003e will result in an Exception\n */\n  @Test void testLocateWithoutNamespace(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(\"/api/v1/namespaces/default/configmaps\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(PROPERTIES_CONFIGMAP_LIST))));\n    ConfigMapConfigProperties configMapConfigProperties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(),Map.of(),true,\"bootstrap-640\",null,false,false,false,RetryProperties.DEFAULT);\n    assertThatThrownBy(() -\u003e new KubernetesClientConfigMapPropertySourceLocator(api,configMapConfigProperties,new KubernetesNamespaceProvider(ENV)).locate(ENV)).isInstanceOf(NamespaceResolutionFailedException.class);\n  }\n  @Test public void locateShouldThrowExceptionOnFailureWhenFailFastIsEnabled(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(\"/api/v1/namespaces/default/configmaps\").willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    ConfigMapConfigProperties configMapConfigProperties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(),Map.of(),true,\"bootstrap-640\",\"default\",false,false,true,RetryProperties.DEFAULT);\n    KubernetesClientConfigMapPropertySourceLocator locator\u003dnew KubernetesClientConfigMapPropertySourceLocator(api,configMapConfigProperties,new KubernetesNamespaceProvider(new MockEnvironment()));\n    assertThatThrownBy(() -\u003e locator.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessage(\"Internal Server Error\");\n  }\n  @Test public void locateShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled(){\n    CoreV1Api api\u003dnew CoreV1Api();\n    stubFor(get(\"/api/v1/namespaces/default/configmaps\").willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    ConfigMapConfigProperties configMapConfigProperties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(),Map.of(),true,\"bootstrap-640\",\"default\",false,false,false,RetryProperties.DEFAULT);\n    KubernetesClientConfigMapPropertySourceLocator locator\u003dnew KubernetesClientConfigMapPropertySourceLocator(api,configMapConfigProperties,new KubernetesNamespaceProvider(new MockEnvironment()));\n    assertThatNoException().isThrownBy(() -\u003e locator.locate(new MockEnvironment()));\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\nclass KubernetesClientConfigMapPropertySourceLocatorTests {\n  private static final V1ConfigMapList PROPERTIES_CONFIGMAP_LIST\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"bootstrap-640\").withNamespace(\"default\").withResourceVersion(\"1\").build()).addToData(\"application.properties\",\"spring.cloud.kubernetes.configuration.watcher.refreshDelay\u003d0\\n\" + \"logging.level.org.springframework.cloud.kubernetes\u003dTRACE\").build());\n  private static WireMockServer wireMockServer;\n  private static final MockEnvironment ENV\u003dnew MockEnvironment();\n  @BeforeAll public static void setup();\n  @AfterAll public static void after();\n  @AfterEach public void afterEach();\n  @Test void locateWithoutSources();\n  @Test void locateWithSources();\n  /** \n * \u003cpre\u003e 1. not providing the namespace \u003c/pre\u003e will result in an Exception\n */\n  @Test void testLocateWithoutNamespaceConstructor();\n  /** \n * \u003cpre\u003e 1. not providing the namespace \u003c/pre\u003e will result in an Exception\n */\n  @Test void testLocateWithoutNamespace();\n  @Test public void locateShouldThrowExceptionOnFailureWhenFailFastIsEnabled();\n  @Test public void locateShouldNotThrowExceptionOnFailureWhenFailFastIsDisabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap/stubs/NamedConfigMapWithProfileConfigurationStub.java",
        "name": "NamedConfigMapWithProfileConfigurationStub",
        "modifiers": "@Order(0) @Configuration @ConditionalOnProperty(\"named.config.map.with.profile.stub\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedConfigMapWithProfileConfigurationStub",
        "extend": "",
        "implements": "",
        "raw": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"named.config.map.with.profile.stub\") public class NamedConfigMapWithProfileConfigurationStub {\n  @Bean public WireMockServer wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    return server;\n  }\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer){\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    io.kubernetes.client.openapi.Configuration.setDefaultApiClient(apiClient);\n    apiClient.setDebugging(true);\n    stubData();\n    return apiClient;\n  }\n  public static void stubData(){\n    V1ConfigMap one\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"configmap-one\").withNamespace(\"spring-k8s\").build()).addToData(Collections.singletonMap(\"one.property\",\"one\")).build();\n    V1ConfigMap oneFromK8s\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"configmap-one-k8s\").withNamespace(\"spring-k8s\").build()).addToData(Collections.singletonMap(\"one.property\",\"one-from-k8s\")).build();\n    V1ConfigMap two\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"configmap-two\").withNamespace(\"spring-k8s\").build()).addToData(Collections.singletonMap(\"property\",\"two\")).build();\n    V1ConfigMap twoFromK8s\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"configmap-two-k8s\").withNamespace(\"spring-k8s\").build()).addToData(Collections.singletonMap(\"property\",\"two-from-k8s\")).build();\n    V1ConfigMap three\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"configmap-three\").withNamespace(\"spring-k8s\").build()).addToData(Collections.singletonMap(\"property\",\"three\")).build();\n    V1ConfigMap threeFromK8s\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"configmap-three-k8s\").withNamespace(\"spring-k8s\").build()).addToData(Collections.singletonMap(\"property\",\"three-from-k8s\")).build();\n    V1ConfigMapList allConfigMaps\u003dnew V1ConfigMapList();\n    allConfigMaps.setItems(Arrays.asList(one,oneFromK8s,two,twoFromK8s,three,threeFromK8s));\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/spring-k8s/configmaps\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(allConfigMaps))));\n  }\n}\n",
        "abstract": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"named.config.map.with.profile.stub\") public class NamedConfigMapWithProfileConfigurationStub {\n  @Bean public WireMockServer wireMock();\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer);\n  public static void stubData();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap/stubs/NamedSecretWithProfileConfigurationStub.java",
        "name": "NamedSecretWithProfileConfigurationStub",
        "modifiers": "@Order(0) @Configuration @ConditionalOnProperty(\"named.secret.with.profile.stub\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedSecretWithProfileConfigurationStub",
        "extend": "",
        "implements": "",
        "raw": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"named.secret.with.profile.stub\") public class NamedSecretWithProfileConfigurationStub {\n  @Bean public WireMockServer wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    return server;\n  }\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer){\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    io.kubernetes.client.openapi.Configuration.setDefaultApiClient(apiClient);\n    stubData();\n    return apiClient;\n  }\n  public static void stubData(){\n    V1Secret one\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"secret-one\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"one.property\",\"one\".getBytes())).build();\n    V1Secret oneWithProfile\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"secret-one-k8s\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"one.property\",\"one-from-k8s\".getBytes())).build();\n    V1Secret two\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"secret-two\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"property\",\"two\".getBytes())).build();\n    V1Secret twoWithProfile\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"secret-two-k8s\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"property\",\"two-from-k8s\".getBytes())).build();\n    V1Secret three\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"secret-three\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"property\",\"three\".getBytes())).build();\n    V1Secret threeFromProfile\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"secret-three-k8s\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"property\",\"three-from-k8s\".getBytes())).build();\n    V1SecretList allSecrets\u003dnew V1SecretList();\n    allSecrets.setItems(Arrays.asList(one,oneWithProfile,two,twoWithProfile,three,threeFromProfile));\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/spring-k8s/secrets\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(allSecrets))));\n  }\n}\n",
        "abstract": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"named.secret.with.profile.stub\") public class NamedSecretWithProfileConfigurationStub {\n  @Bean public WireMockServer wireMock();\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer);\n  public static void stubData();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap/stubs/LabeledSecretWithPrefixConfigurationStub.java",
        "name": "LabeledSecretWithPrefixConfigurationStub",
        "modifiers": "@Order(0) @Configuration @ConditionalOnProperty(\"labeled.secret.with.prefix.stub\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.LabeledSecretWithPrefixConfigurationStub",
        "extend": "",
        "implements": "",
        "raw": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"labeled.secret.with.prefix.stub\") public class LabeledSecretWithPrefixConfigurationStub {\n  @Bean public WireMockServer wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    return server;\n  }\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer){\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    io.kubernetes.client.openapi.Configuration.setDefaultApiClient(apiClient);\n    apiClient.setDebugging(true);\n    stubData();\n    return apiClient;\n  }\n  public static void stubData(){\n    V1Secret one\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"secret-one\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"letter\",\"a\")).withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"one.property\",\"one\".getBytes())).build();\n    V1Secret two\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"secret-two\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"letter\",\"b\")).withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"property\",\"two\".getBytes())).build();\n    V1Secret three\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"secret-three\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"letter\",\"c\")).withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"property\",\"three\".getBytes())).build();\n    V1Secret four\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"secret-four\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"letter\",\"d\")).withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"property\",\"four\".getBytes())).build();\n    V1SecretList secrets\u003dnew V1SecretList();\n    secrets.addItemsItem(one);\n    secrets.addItemsItem(two);\n    secrets.addItemsItem(three);\n    secrets.addItemsItem(four);\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/spring-k8s/secrets\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(secrets))));\n  }\n}\n",
        "abstract": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"labeled.secret.with.prefix.stub\") public class LabeledSecretWithPrefixConfigurationStub {\n  @Bean public WireMockServer wireMock();\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer);\n  public static void stubData();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap/stubs/SourcesOrderConfigurationStub.java",
        "name": "SourcesOrderConfigurationStub",
        "modifiers": "@Order(0) @Configuration @ConditionalOnProperty(\"sources.order.stub\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.SourcesOrderConfigurationStub",
        "extend": "",
        "implements": "",
        "raw": "@Order(0) @Configuration @ConditionalOnProperty(\"sources.order.stub\") public class SourcesOrderConfigurationStub {\n  @Bean public WireMockServer wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    return server;\n  }\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer){\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    io.kubernetes.client.openapi.Configuration.setDefaultApiClient(apiClient);\n    apiClient.setDebugging(true);\n    stubConfigMapData();\n    stubSecretsData();\n    return apiClient;\n  }\n  public static void stubConfigMapData(){\n    Map\u003cString,String\u003e configMapData\u003dnew HashMap\u003c\u003e();\n    configMapData.put(\"my.key\",\"from-configmap\");\n    configMapData.put(\"my.two\",\"two\");\n    V1ConfigMap myConfigMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"my-configmap\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(configMapData).build();\n    V1ConfigMapList allConfigMaps\u003dnew V1ConfigMapList();\n    allConfigMaps.setItems(Collections.singletonList(myConfigMap));\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/spring-k8s/configmaps\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(allConfigMaps))));\n  }\n  public static void stubSecretsData(){\n    Map\u003cString,byte[]\u003e secretData\u003dnew HashMap\u003c\u003e();\n    secretData.put(\"my.key\",\"from-secret\".getBytes(StandardCharsets.UTF_8));\n    secretData.put(\"my.one\",\"one\".getBytes(StandardCharsets.UTF_8));\n    V1Secret mySecret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"my-secret\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(secretData).build();\n    V1SecretList allConfigMaps\u003dnew V1SecretList();\n    allConfigMaps.setItems(Collections.singletonList(mySecret));\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/spring-k8s/secrets\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(allConfigMaps))));\n  }\n}\n",
        "abstract": "@Order(0) @Configuration @ConditionalOnProperty(\"sources.order.stub\") public class SourcesOrderConfigurationStub {\n  @Bean public WireMockServer wireMock();\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer);\n  public static void stubConfigMapData();\n  public static void stubSecretsData();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap/stubs/LabeledConfigMapWithPrefixConfigurationStub.java",
        "name": "LabeledConfigMapWithPrefixConfigurationStub",
        "modifiers": "@Order(0) @Configuration @ConditionalOnProperty(\"labeled.config.map.with.prefix.stub\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.LabeledConfigMapWithPrefixConfigurationStub",
        "extend": "",
        "implements": "",
        "raw": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"labeled.config.map.with.prefix.stub\") public class LabeledConfigMapWithPrefixConfigurationStub {\n  @Bean public WireMockServer wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    return server;\n  }\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer){\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    io.kubernetes.client.openapi.Configuration.setDefaultApiClient(apiClient);\n    apiClient.setDebugging(true);\n    stubData();\n    return apiClient;\n  }\n  public static void stubData(){\n    V1ConfigMap one\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"configmap-one\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"letter\",\"a\")).build()).addToData(Collections.singletonMap(\"one.property\",\"one\")).build();\n    V1ConfigMap two\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"configmap-two\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"letter\",\"b\")).build()).addToData(Collections.singletonMap(\"property\",\"two\")).build();\n    V1ConfigMap three\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"configmap-three\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"letter\",\"c\")).build()).addToData(Collections.singletonMap(\"property\",\"three\")).build();\n    V1ConfigMap four\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"configmap-four\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"letter\",\"d\")).build()).addToData(Collections.singletonMap(\"property\",\"four\")).build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList();\n    configMapList.addItemsItem(one);\n    configMapList.addItemsItem(two);\n    configMapList.addItemsItem(three);\n    configMapList.addItemsItem(four);\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/spring-k8s/configmaps\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(configMapList))));\n  }\n}\n",
        "abstract": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"labeled.config.map.with.prefix.stub\") public class LabeledConfigMapWithPrefixConfigurationStub {\n  @Bean public WireMockServer wireMock();\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer);\n  public static void stubData();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap/stubs/LabeledConfigMapWithProfileConfigurationStub.java",
        "name": "LabeledConfigMapWithProfileConfigurationStub",
        "modifiers": "@Order(0) @Configuration @ConditionalOnProperty(\"labeled.config.map.with.profile.stub\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.LabeledConfigMapWithProfileConfigurationStub",
        "extend": "",
        "implements": "",
        "raw": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"labeled.config.map.with.profile.stub\") public class LabeledConfigMapWithProfileConfigurationStub {\n  @Bean public WireMockServer wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    return server;\n  }\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer){\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    io.kubernetes.client.openapi.Configuration.setDefaultApiClient(apiClient);\n    apiClient.setDebugging(true);\n    stubData();\n    return apiClient;\n  }\n  /** \n * \u003cpre\u003e - configmap with name \"color-configmap\", with labels: \"{color: blue}\" and \"explicitPrefix: blue\" - configmap with name \"green-configmap\", with labels: \"{color: green}\" and \"explicitPrefix: blue-again\" - configmap with name \"red-configmap\", with labels \"{color: not-red}\" and \"useNameAsPrefix: true\" - configmap with name \"yellow-configmap\" with labels \"{color: not-yellow}\" and useNameAsPrefix: true - configmap with name \"color-configmap-k8s\", with labels : \"{color: not-blue}\" - configmap with name \"green-configmap-k8s\", with labels : \"{color: green-k8s}\" - configmap with name \"green-configmap-prod\", with labels : \"{color: green-prod}\" # a test that proves order: first read non-profile based configmaps, thus profile based # configmaps override non-profile ones. - configmap with name \"green-purple-configmap\", labels \"{color: green, shape: round}\", data: \"{eight: 8}\" - configmap with name \"green-purple-configmap-k8s\", labels \"{color: black}\", data: \"{eight: eight-ish}\" \u003c/pre\u003e\n */\n  public static void stubData(){\n    V1ConfigMap colorConfigMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"color-configmap\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"blue\")).build()).addToData(Collections.singletonMap(\"one\",\"1\")).build();\n    V1ConfigMap colorConfigMapK8s\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"color-configmap-k8s\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"not-blue\")).build()).addToData(Collections.singletonMap(\"five\",\"5\")).build();\n    V1ConfigMap greenConfigMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"green-configmap\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"green\")).build()).addToData(Collections.singletonMap(\"two\",\"2\")).build();\n    V1ConfigMap greenConfigMapK8s\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"green-configmap-k8s\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"green-k8s\")).build()).addToData(Collections.singletonMap(\"six\",\"6\")).build();\n    V1ConfigMap greenConfigMapProd\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"green-configmap-prod\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"green-prod\")).build()).addToData(Collections.singletonMap(\"seven\",\"7\")).build();\n    V1ConfigMap redConfigMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"red-configmap\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"red\")).build()).addToData(Collections.singletonMap(\"three\",\"3\")).build();\n    V1ConfigMap yellowConfigMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"yellow-configmap\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"yellow\")).build()).addToData(Collections.singletonMap(\"four\",\"4\")).build();\n    V1ConfigMap greenPurpleConfigMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"green-purple-configmap\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"green\",\"shape\",\"round\")).build()).addToData(Collections.singletonMap(\"eight\",\"8\")).build();\n    V1ConfigMap greenPurpleConfigMapK8s\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"green-purple-configmap-k8s\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"black\")).build()).addToData(Collections.singletonMap(\"eight\",\"eight-ish\")).build();\n    V1ConfigMapList configMaps\u003dnew V1ConfigMapList();\n    configMaps.addItemsItem(colorConfigMap);\n    configMaps.addItemsItem(colorConfigMapK8s);\n    configMaps.addItemsItem(greenConfigMap);\n    configMaps.addItemsItem(greenConfigMapK8s);\n    configMaps.addItemsItem(greenConfigMapProd);\n    configMaps.addItemsItem(redConfigMap);\n    configMaps.addItemsItem(yellowConfigMap);\n    configMaps.addItemsItem(greenPurpleConfigMap);\n    configMaps.addItemsItem(greenPurpleConfigMapK8s);\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/spring-k8s/configmaps\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(configMaps))));\n  }\n}\n",
        "abstract": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"labeled.config.map.with.profile.stub\") public class LabeledConfigMapWithProfileConfigurationStub {\n  @Bean public WireMockServer wireMock();\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer);\n  /** \n * \u003cpre\u003e - configmap with name \"color-configmap\", with labels: \"{color: blue}\" and \"explicitPrefix: blue\" - configmap with name \"green-configmap\", with labels: \"{color: green}\" and \"explicitPrefix: blue-again\" - configmap with name \"red-configmap\", with labels \"{color: not-red}\" and \"useNameAsPrefix: true\" - configmap with name \"yellow-configmap\" with labels \"{color: not-yellow}\" and useNameAsPrefix: true - configmap with name \"color-configmap-k8s\", with labels : \"{color: not-blue}\" - configmap with name \"green-configmap-k8s\", with labels : \"{color: green-k8s}\" - configmap with name \"green-configmap-prod\", with labels : \"{color: green-prod}\" # a test that proves order: first read non-profile based configmaps, thus profile based # configmaps override non-profile ones. - configmap with name \"green-purple-configmap\", labels \"{color: green, shape: round}\", data: \"{eight: 8}\" - configmap with name \"green-purple-configmap-k8s\", labels \"{color: black}\", data: \"{eight: eight-ish}\" \u003c/pre\u003e\n */\n  public static void stubData();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap/stubs/NamedSecretWithPrefixConfigurationStub.java",
        "name": "NamedSecretWithPrefixConfigurationStub",
        "modifiers": "@Order(0) @Configuration @ConditionalOnProperty(\"named.secret.with.prefix.stub\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedSecretWithPrefixConfigurationStub",
        "extend": "",
        "implements": "",
        "raw": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"named.secret.with.prefix.stub\") public class NamedSecretWithPrefixConfigurationStub {\n  @Bean public WireMockServer wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    return server;\n  }\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer){\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    io.kubernetes.client.openapi.Configuration.setDefaultApiClient(apiClient);\n    stubData();\n    return apiClient;\n  }\n  public static void stubData(){\n    V1Secret one\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"secret-one\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"one.property\",\"one\".getBytes())).build();\n    V1Secret two\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"secret-two\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"property\",\"two\".getBytes())).build();\n    V1Secret three\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"secret-three\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"property\",\"three\".getBytes())).build();\n    V1SecretList allSecrets\u003dnew V1SecretList();\n    allSecrets.setItems(Arrays.asList(one,two,three));\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/spring-k8s/secrets\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(allSecrets))));\n  }\n}\n",
        "abstract": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"named.secret.with.prefix.stub\") public class NamedSecretWithPrefixConfigurationStub {\n  @Bean public WireMockServer wireMock();\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer);\n  public static void stubData();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap/stubs/SingleSourceMultipleFilesConfigurationStub.java",
        "name": "SingleSourceMultipleFilesConfigurationStub",
        "modifiers": "@Order(0) @Configuration @ConditionalOnProperty(\"single.source.multiple.files.stub\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.SingleSourceMultipleFilesConfigurationStub",
        "extend": "",
        "implements": "",
        "raw": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"single.source.multiple.files.stub\") public class SingleSourceMultipleFilesConfigurationStub {\n  @Bean public WireMockServer wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    return server;\n  }\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer){\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    io.kubernetes.client.openapi.Configuration.setDefaultApiClient(apiClient);\n    stubData();\n    return apiClient;\n  }\n  public static void stubData(){\n    Map\u003cString,String\u003e one\u003dnew HashMap\u003c\u003e();\n    one.put(\"fruit.type\",\"yummy\");\n    one.put(\"fruit.properties\",\"cool.name\u003dbanana\");\n    one.put(\"fruit-color.properties\",\"color.when.raw\u003dgreen\\ncolor.when.ripe\u003dyellow\");\n    one.put(\"fruit-shape.properties\",\"shape.when.raw\u003dsmall-sphere\\nshape.when.ripe\u003dbigger-sphere\");\n    V1ConfigMap configMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"my-configmap\").withNamespace(\"spring-k8s\").build()).addToData(one).build();\n    V1ConfigMapList allConfigMaps\u003dnew V1ConfigMapList();\n    allConfigMaps.addItemsItem(configMap);\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/spring-k8s/configmaps\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(allConfigMaps))));\n  }\n}\n",
        "abstract": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"single.source.multiple.files.stub\") public class SingleSourceMultipleFilesConfigurationStub {\n  @Bean public WireMockServer wireMock();\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer);\n  public static void stubData();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap/stubs/NamedConfigMapWithPrefixConfigurationStub.java",
        "name": "NamedConfigMapWithPrefixConfigurationStub",
        "modifiers": "@Order(0) @Configuration @ConditionalOnProperty(\"named.config.map.with.prefix.stub\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedConfigMapWithPrefixConfigurationStub",
        "extend": "",
        "implements": "",
        "raw": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"named.config.map.with.prefix.stub\") public class NamedConfigMapWithPrefixConfigurationStub {\n  @Bean public WireMockServer wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    return server;\n  }\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer){\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    io.kubernetes.client.openapi.Configuration.setDefaultApiClient(apiClient);\n    apiClient.setDebugging(true);\n    stubData();\n    return apiClient;\n  }\n  public static void stubData(){\n    V1ConfigMap one\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"config-map-one\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"one.property\",\"one\")).build();\n    V1ConfigMap two\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"config-map-two\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"property\",\"two\")).build();\n    V1ConfigMap three\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"config-map-three\").withNamespace(\"spring-k8s\").withResourceVersion(\"1\").build()).addToData(Collections.singletonMap(\"property\",\"three\")).build();\n    V1ConfigMapList allConfigMaps\u003dnew V1ConfigMapList();\n    allConfigMaps.setItems(Arrays.asList(one,two,three));\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/spring-k8s/configmaps\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(allConfigMaps))));\n  }\n}\n",
        "abstract": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"named.config.map.with.prefix.stub\") public class NamedConfigMapWithPrefixConfigurationStub {\n  @Bean public WireMockServer wireMock();\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer);\n  public static void stubData();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap/stubs/LabeledSecretWithProfileConfigurationStub.java",
        "name": "LabeledSecretWithProfileConfigurationStub",
        "modifiers": "@Order(0) @Configuration @ConditionalOnProperty(\"labeled.secret.with.profile.stub\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.LabeledSecretWithProfileConfigurationStub",
        "extend": "",
        "implements": "",
        "raw": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"labeled.secret.with.profile.stub\") public class LabeledSecretWithProfileConfigurationStub {\n  @Bean public WireMockServer wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    return server;\n  }\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer){\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    io.kubernetes.client.openapi.Configuration.setDefaultApiClient(apiClient);\n    apiClient.setDebugging(true);\n    stubData();\n    return apiClient;\n  }\n  /** \n * \u003cpre\u003e - secret with name \"color-secret\", with labels: \"{color: blue}\" and \"explicitPrefix: blue\" - secret with name \"green-secret\", with labels: \"{color: green}\" and \"explicitPrefix: blue-again\" - secret with name \"red-secret\", with labels \"{color: not-red}\" and \"useNameAsPrefix: true\" - secret with name \"yellow-secret\" with labels \"{color: not-yellow}\" and useNameAsPrefix: true - secret with name \"color-secret-k8s\", with labels : \"{color: not-blue}\" - secret with name \"green-secret-k8s\", with labels : \"{color: green-k8s}\" - secret with name \"green-secret-prod\", with labels : \"{color: green-prod}\" # a test that proves order: first read non-profile based secrets, thus profile based # secrets override non-profile ones. - secret with name \"green-purple-secret\", labels \"{color: green, shape: round}\", data: \"{eight: 8}\" - secret with name \"green-purple-secret-k8s\", labels \"{color: black}\", data: \"{eight: eight-ish}\" \u003c/pre\u003e\n */\n  public static void stubData(){\n    V1Secret colorSecret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"color-secret\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"blue\")).build()).addToData(Collections.singletonMap(\"one\",\"1\".getBytes(StandardCharsets.UTF_8))).build();\n    V1Secret colorSecretK8s\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"color-secret-k8s\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"not-blue\")).build()).addToData(Collections.singletonMap(\"five\",\"5\".getBytes(StandardCharsets.UTF_8))).build();\n    V1Secret greenSecret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"green-secret\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"green\")).build()).addToData(Collections.singletonMap(\"two\",\"2\".getBytes(StandardCharsets.UTF_8))).build();\n    V1Secret greenSecretK8s\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"green-secret-k8s\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"green-k8s\")).build()).addToData(Collections.singletonMap(\"six\",\"6\".getBytes(StandardCharsets.UTF_8))).build();\n    V1Secret shapeSecretProd\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"green-secret-prod\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"green-prod\")).build()).addToData(Collections.singletonMap(\"seven\",\"7\".getBytes(StandardCharsets.UTF_8))).build();\n    V1Secret redSecret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"red-secret\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"not-red\")).build()).addToData(Collections.singletonMap(\"three\",\"3\".getBytes(StandardCharsets.UTF_8))).build();\n    V1Secret yellowSecret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"yellow-secret\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"not-yellow\")).build()).addToData(Collections.singletonMap(\"four\",\"4\".getBytes(StandardCharsets.UTF_8))).build();\n    V1Secret greenPurpleSecret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"green-purple-secret\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"green\",\"shape\",\"round\")).build()).addToData(Collections.singletonMap(\"eight\",\"8\".getBytes(StandardCharsets.UTF_8))).build();\n    V1Secret greenPurpleSecretK8s\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"green-purple-secret-k8s\").withNamespace(\"spring-k8s\").withLabels(Map.of(\"color\",\"black\")).build()).addToData(Collections.singletonMap(\"eight\",\"eight-ish\".getBytes(StandardCharsets.UTF_8))).build();\n    V1SecretList secrets\u003dnew V1SecretList();\n    secrets.addItemsItem(colorSecret);\n    secrets.addItemsItem(colorSecretK8s);\n    secrets.addItemsItem(greenSecret);\n    secrets.addItemsItem(greenSecretK8s);\n    secrets.addItemsItem(shapeSecretProd);\n    secrets.addItemsItem(redSecret);\n    secrets.addItemsItem(yellowSecret);\n    secrets.addItemsItem(greenPurpleSecret);\n    secrets.addItemsItem(greenPurpleSecretK8s);\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/spring-k8s/secrets\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(secrets))));\n  }\n}\n",
        "abstract": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"labeled.secret.with.profile.stub\") public class LabeledSecretWithProfileConfigurationStub {\n  @Bean public WireMockServer wireMock();\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer);\n  /** \n * \u003cpre\u003e - secret with name \"color-secret\", with labels: \"{color: blue}\" and \"explicitPrefix: blue\" - secret with name \"green-secret\", with labels: \"{color: green}\" and \"explicitPrefix: blue-again\" - secret with name \"red-secret\", with labels \"{color: not-red}\" and \"useNameAsPrefix: true\" - secret with name \"yellow-secret\" with labels \"{color: not-yellow}\" and useNameAsPrefix: true - secret with name \"color-secret-k8s\", with labels : \"{color: not-blue}\" - secret with name \"green-secret-k8s\", with labels : \"{color: green-k8s}\" - secret with name \"green-secret-prod\", with labels : \"{color: green-prod}\" # a test that proves order: first read non-profile based secrets, thus profile based # secrets override non-profile ones. - secret with name \"green-purple-secret\", labels \"{color: green, shape: round}\", data: \"{eight: 8}\" - secret with name \"green-purple-secret-k8s\", labels \"{color: black}\", data: \"{eight: eight-ish}\" \u003c/pre\u003e\n */\n  public static void stubData();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap/stubs/BootstrapKubernetesClientSanitizeEnvEndpointStub.java",
        "name": "BootstrapKubernetesClientSanitizeEnvEndpointStub",
        "modifiers": "@Order(0) @Configuration @ConditionalOnProperty(\"bootstrap.sanitize\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.boostrap.stubs.BootstrapKubernetesClientSanitizeEnvEndpointStub",
        "extend": "",
        "implements": "",
        "raw": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"bootstrap.sanitize\") public class BootstrapKubernetesClientSanitizeEnvEndpointStub {\n  @Bean public WireMockServer wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    return server;\n  }\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer){\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    io.kubernetes.client.openapi.Configuration.setDefaultApiClient(apiClient);\n    apiClient.setDebugging(true);\n    stubData();\n    return apiClient;\n  }\n  public static void stubData(){\n    V1ConfigMap one\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"sanitize-configmap\").withNamespace(\"test\").build()).addToData(Map.of(\"sanitize.sanitizeConfigMapName\",\"sanitizeConfigMapValue\")).build();\n    V1Secret secretOne\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"sanitize-secret\").withNamespace(\"test\").build()).addToData(Map.of(\"sanitize.sanitizeSecretName\",\"sanitizeSecretValue\".getBytes())).build();\n    V1Secret secretTwo\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"sanitize-secret-two\").withNamespace(\"test\").build()).addToData(Map.of(\"sanitize.sanitizeSecretNameTwo\",\"sanitizeSecretValueTwo\".getBytes())).build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList();\n    configMapList.addItemsItem(one);\n    V1SecretList secretList\u003dnew V1SecretList();\n    secretList.addItemsItem(secretOne);\n    secretList.addItemsItem(secretTwo);\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/test/configmaps\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(configMapList))));\n    WireMock.stubFor(WireMock.get(\"/api/v1/namespaces/test/secrets\").willReturn(WireMock.aResponse().withStatus(200).withBody(new JSON().serialize(secretList))));\n  }\n}\n",
        "abstract": "/** \n * A test bootstrap that takes care to initialize ApiClient _before_ our main bootstrap context; with some stub data already present.\n * @author wind57\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"bootstrap.sanitize\") public class BootstrapKubernetesClientSanitizeEnvEndpointStub {\n  @Bean public WireMockServer wireMock();\n  @Bean public ApiClient apiClient(  WireMockServer wireMockServer);\n  public static void stubData();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/BootstrapConfigFailFastDisabled.java",
        "name": "BootstrapConfigFailFastDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApp.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.BootstrapConfigFailFastDisabled",
        "extend": "ConfigFailFastDisabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApp.class) class BootstrapConfigFailFastDisabled extends ConfigFailFastDisabled {\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApp.class) class BootstrapConfigFailFastDisabled extends ConfigFailFastDisabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/ConfigMapEnableRetryWithoutFailFastTest.java",
        "name": "ConfigMapEnableRetryWithoutFailFastTest",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.ConfigMapEnableRetryWithoutFailFastTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class ConfigMapEnableRetryWithoutFailFastTest {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static final String SECRETS_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private ConfigurableApplicationContext context;\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll public static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build());\n    stubConfigMapAndSecretsDefaults();\n  }\n  private static void stubConfigMapAndSecretsDefaults(){\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1ConfigMapList()))));\n    stubFor(get(SECRETS_API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1SecretList()))));\n  }\n  @AfterAll public static void teardown(){\n    wireMockServer.stop();\n    clientUtilsMock.close();\n  }\n  protected void setup(  String... env){\n    List\u003cString\u003e envList\u003d(env !\u003d null) ? new ArrayList\u003c\u003e(Arrays.asList(env)) : new ArrayList\u003c\u003e();\n    envList.add(\"spring.cloud.kubernetes.client.namespace\u003ddefault\");\n    String[] envArray\u003denvList.toArray(new String[0]);\n    context\u003dnew SpringApplicationBuilder(RetryConfiguration.class,PropertyPlaceholderAutoConfiguration.class,ConfigReloadAutoConfiguration.class,RefreshAutoConfiguration.class,EndpointAutoConfiguration.class,InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,ConfigurationPropertiesBindingPostProcessor.class,ConfigurationPropertiesRebinderAutoConfiguration.class,KubernetesClientBootstrapConfiguration.class,KubernetesClientRetryBootstrapConfiguration.class,KubernetesBootstrapConfiguration.class,KubernetesClientConfigReloadAutoConfiguration.class).web(org.springframework.boot.WebApplicationType.NONE).properties(envArray).run();\n  }\n  @AfterEach public void afterEach(){\n    if (this.context !\u003d null) {\n      this.context.close();\n      this.context\u003dnull;\n    }\n  }\n  @Test public void doesNotContainRetryableConfigMapPropertySourceLocator() throws Exception {\n    stubFor(get(API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    setup(\"debug\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.test.enable-retry\u003dtrue\");\n    assertThat(context.containsBean(\"retryableConfigMapPropertySourceLocator\")).isFalse();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class ConfigMapEnableRetryWithoutFailFastTest {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static final String SECRETS_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private ConfigurableApplicationContext context;\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll public static void setup();\n  private static void stubConfigMapAndSecretsDefaults();\n  @AfterAll public static void teardown();\n  protected void setup(  String... env);\n  @AfterEach public void afterEach();\n  @Test public void doesNotContainRetryableConfigMapPropertySourceLocator() throws Exception;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/BootstrapConfigRetryDisabledButSecretsRetryEnabled.java",
        "name": "BootstrapConfigRetryDisabledButSecretsRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApp.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.BootstrapConfigRetryDisabledButSecretsRetryEnabled",
        "extend": "ConfigRetryDisabledButSecretsRetryEnabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApp.class) class BootstrapConfigRetryDisabledButSecretsRetryEnabled extends ConfigRetryDisabledButSecretsRetryEnabled {\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApp.class) class BootstrapConfigRetryDisabledButSecretsRetryEnabled extends ConfigRetryDisabledButSecretsRetryEnabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/BootstrapConfigFailFastEnabledButRetryDisabled.java",
        "name": "BootstrapConfigFailFastEnabledButRetryDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApp.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.BootstrapConfigFailFastEnabledButRetryDisabled",
        "extend": "ConfigFailFastEnabledButRetryDisabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApp.class) class BootstrapConfigFailFastEnabledButRetryDisabled extends ConfigFailFastEnabledButRetryDisabled {\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApp.class) class BootstrapConfigFailFastEnabledButRetryDisabled extends ConfigFailFastEnabledButRetryDisabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/ConfigRetryDisabledButSecretsRetryEnabled.java",
        "name": "ConfigRetryDisabledButSecretsRetryEnabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.ConfigRetryDisabledButSecretsRetryEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\nabstract class ConfigRetryDisabledButSecretsRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static final String SECRETS_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"default\");\n    stubConfigMapAndSecretsDefaults();\n  }\n  private static void stubConfigMapAndSecretsDefaults(){\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1ConfigMapList()))));\n    stubFor(get(SECRETS_API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1SecretList()))));\n  }\n  @AfterAll static void teardown(){\n    wireMockServer.stop();\n    clientUtilsMock.close();\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n    stubConfigMapAndSecretsDefaults();\n  }\n  @Autowired private KubernetesClientConfigMapPropertySourceLocator propertySourceLocator;\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying(){\n    propertySourceLocator\u003dspy(propertySourceLocator);\n    stubFor(get(API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    assertThatThrownBy(() -\u003e propertySourceLocator.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessage(\"Internal Server Error\");\n    verify(propertySourceLocator,times(1)).locate(any());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\nabstract class ConfigRetryDisabledButSecretsRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static final String SECRETS_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup();\n  private static void stubConfigMapAndSecretsDefaults();\n  @AfterAll static void teardown();\n  @AfterEach void afterEach();\n  @Autowired private KubernetesClientConfigMapPropertySourceLocator propertySourceLocator;\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/ConfigDataConfigFailFastEnabledButRetryDisabled.java",
        "name": "ConfigDataConfigFailFastEnabledButRetryDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApp.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.ConfigDataConfigFailFastEnabledButRetryDisabled",
        "extend": "ConfigFailFastEnabledButRetryDisabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApp.class) class ConfigDataConfigFailFastEnabledButRetryDisabled extends ConfigFailFastEnabledButRetryDisabled {\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApp.class) class ConfigDataConfigFailFastEnabledButRetryDisabled extends ConfigFailFastEnabledButRetryDisabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/App.java",
        "name": "App",
        "modifiers": "@SpringBootApplication",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.App",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication class App {\n}\n",
        "abstract": "@SpringBootApplication class App {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/ConfigDataConfigFailFastDisabled.java",
        "name": "ConfigDataConfigFailFastDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApp.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.ConfigDataConfigFailFastDisabled",
        "extend": "ConfigFailFastDisabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApp.class) class ConfigDataConfigFailFastDisabled extends ConfigFailFastDisabled {\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApp.class) class ConfigDataConfigFailFastDisabled extends ConfigFailFastDisabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/BootstrapConfigRetryEnabled.java",
        "name": "BootstrapConfigRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApp.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.BootstrapConfigRetryEnabled",
        "extend": "ConfigRetryEnabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApp.class) class BootstrapConfigRetryEnabled extends ConfigRetryEnabled {\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"},classes\u003dApp.class) class BootstrapConfigRetryEnabled extends ConfigRetryEnabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/ConfigDataConfigRetryDisabledButSecretsRetryEnabled.java",
        "name": "ConfigDataConfigRetryDisabledButSecretsRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApp.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.ConfigDataConfigRetryDisabledButSecretsRetryEnabled",
        "extend": "ConfigRetryDisabledButSecretsRetryEnabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApp.class) class ConfigDataConfigRetryDisabledButSecretsRetryEnabled extends ConfigRetryDisabledButSecretsRetryEnabled {\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApp.class) class ConfigDataConfigRetryDisabledButSecretsRetryEnabled extends ConfigRetryDisabledButSecretsRetryEnabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/ConfigRetryEnabled.java",
        "name": "ConfigRetryEnabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.ConfigRetryEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\nabstract class ConfigRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"default\");\n    stubConfigMapAndSecretsDefaults();\n  }\n  private static void stubConfigMapAndSecretsDefaults(){\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1ConfigMapList()))));\n  }\n  @AfterAll static void teardown(){\n    wireMockServer.stop();\n    clientUtilsMock.close();\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n    stubConfigMapAndSecretsDefaults();\n  }\n  @Autowired private ConfigMapPropertySourceLocator retryablePl;\n  @Test void locateShouldNotRetryWhenThereIsNoFailure(){\n    ConfigMapPropertySourceLocator propertySourceLocator\u003dspy(retryablePl);\n    Map\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"some.prop\",\"theValue\");\n    data.put(\"some.number\",\"0\");\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMap().metadata(new V1ObjectMeta().name(\"application\")).data(data));\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(configMapList))));\n    PropertySource\u003c?\u003e propertySource\u003dAssertions.assertDoesNotThrow(() -\u003e propertySourceLocator.locate(new MockEnvironment()));\n    WireMock.verify(1,getRequestedFor(urlEqualTo(API)));\n    assertThat(propertySource.getProperty(\"some.prop\")).isEqualTo(\"theValue\");\n    assertThat(propertySource.getProperty(\"some.number\")).isEqualTo(\"0\");\n  }\n  @Test void locateShouldRetryAndRecover(){\n    ConfigMapPropertySourceLocator propertySourceLocator\u003dspy(retryablePl);\n    Map\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"some.prop\",\"theValue\");\n    data.put(\"some.number\",\"0\");\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMap().metadata(new V1ObjectMeta().name(\"application\")).data(data));\n    stubFor(get(API).inScenario(\"Retry and Recover\").whenScenarioStateIs(STARTED).willReturn(aResponse().withStatus(500)).willSetStateTo(\"Failed once\"));\n    stubFor(get(API).inScenario(\"Retry and Recover\").whenScenarioStateIs(\"Failed once\").willReturn(aResponse().withStatus(500)).willSetStateTo(\"Failed twice\"));\n    stubFor(get(API).inScenario(\"Retry and Recover\").whenScenarioStateIs(\"Failed twice\").willReturn(aResponse().withStatus(500)).willSetStateTo(\"Failed thrice\"));\n    stubFor(get(API).inScenario(\"Retry and Recover\").whenScenarioStateIs(\"Failed thrice\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(configMapList))));\n    PropertySource\u003c?\u003e propertySource\u003dAssertions.assertDoesNotThrow(() -\u003e propertySourceLocator.locate(new MockEnvironment()));\n    WireMock.verify(5,getRequestedFor(urlEqualTo(API)));\n    assertThat(propertySource.getProperty(\"some.prop\")).isEqualTo(\"theValue\");\n    assertThat(propertySource.getProperty(\"some.number\")).isEqualTo(\"0\");\n  }\n  @Test void locateShouldRetryAndFail(){\n    ConfigMapPropertySourceLocator propertySourceLocator\u003dspy(retryablePl);\n    stubFor(get(API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    assertThatThrownBy(() -\u003e propertySourceLocator.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessage(\"Internal Server Error\");\n    WireMock.verify(5,getRequestedFor(urlEqualTo(API)));\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\nabstract class ConfigRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup();\n  private static void stubConfigMapAndSecretsDefaults();\n  @AfterAll static void teardown();\n  @AfterEach void afterEach();\n  @Autowired private ConfigMapPropertySourceLocator retryablePl;\n  @Test void locateShouldNotRetryWhenThereIsNoFailure();\n  @Test void locateShouldRetryAndRecover();\n  @Test void locateShouldRetryAndFail();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/ConfigDataConfigRetryEnabled.java",
        "name": "ConfigDataConfigRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApp.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.ConfigDataConfigRetryEnabled",
        "extend": "ConfigRetryEnabled",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApp.class) class ConfigDataConfigRetryEnabled extends ConfigRetryEnabled {\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dApp.class) class ConfigDataConfigRetryEnabled extends ConfigRetryEnabled {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/ConfigFailFastDisabled.java",
        "name": "ConfigFailFastDisabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.ConfigFailFastDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\nabstract class ConfigFailFastDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build());\n    stubConfigMapAndSecretsDefaults();\n  }\n  private static void stubConfigMapAndSecretsDefaults(){\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1ConfigMapList()))));\n  }\n  @AfterAll static void teardown(){\n    wireMockServer.stop();\n    clientUtilsMock.close();\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n    stubConfigMapAndSecretsDefaults();\n  }\n  @Autowired private KubernetesClientConfigMapPropertySourceLocator propertySourceLocator;\n  @Test void locateShouldNotRetry(){\n    propertySourceLocator\u003dspy(propertySourceLocator);\n    stubFor(get(API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    Assertions.assertDoesNotThrow(() -\u003e propertySourceLocator.locate(new MockEnvironment()));\n    verify(propertySourceLocator,times(1)).locate(any());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\nabstract class ConfigFailFastDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup();\n  private static void stubConfigMapAndSecretsDefaults();\n  @AfterAll static void teardown();\n  @AfterEach void afterEach();\n  @Autowired private KubernetesClientConfigMapPropertySourceLocator propertySourceLocator;\n  @Test void locateShouldNotRetry();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/configmap_retry/ConfigFailFastEnabledButRetryDisabled.java",
        "name": "ConfigFailFastEnabledButRetryDisabled",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.configmap_retry.ConfigFailFastEnabledButRetryDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\nabstract class ConfigFailFastEnabledButRetryDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"default\");\n    stubConfigMapAndSecretsDefaults();\n  }\n  private static void stubConfigMapAndSecretsDefaults(){\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1ConfigMapList()))));\n  }\n  @AfterAll static void teardown(){\n    wireMockServer.stop();\n    clientUtilsMock.close();\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n    stubConfigMapAndSecretsDefaults();\n  }\n  @Autowired private KubernetesClientConfigMapPropertySourceLocator propertySourceLocator;\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying(){\n    propertySourceLocator\u003dspy(propertySourceLocator);\n    stubFor(get(API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    assertThat(context.containsBean(\"kubernetesConfigRetryInterceptor\")).isFalse();\n    assertThatThrownBy(() -\u003e propertySourceLocator.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessage(\"Internal Server Error\");\n    verify(propertySourceLocator,times(1)).locate(any());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\nabstract class ConfigFailFastEnabledButRetryDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup();\n  private static void stubConfigMapAndSecretsDefaults();\n  @AfterAll static void teardown();\n  @AfterEach void afterEach();\n  @Autowired private KubernetesClientConfigMapPropertySourceLocator propertySourceLocator;\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap_configurations/KubernetesClientBootstrapConfigurationNotInsideK8s.java",
        "name": "KubernetesClientBootstrapConfigurationNotInsideK8s",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"kubernetes.manifests.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap_configurations.KubernetesClientBootstrapConfigurationNotInsideK8s",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"kubernetes.manifests.enabled\u003dfalse\"}) class KubernetesClientBootstrapConfigurationNotInsideK8s {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void bothMissing(){\n    assertThat(context.getBeanNamesForType(KubernetesClientConfigMapPropertySourceLocator.class)).hasSize(0);\n    assertThat(context.getBeanNamesForType(KubernetesClientSecretsPropertySourceLocator.class)).hasSize(0);\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"kubernetes.manifests.enabled\u003dfalse\"}) class KubernetesClientBootstrapConfigurationNotInsideK8s {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void bothMissing();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap_configurations/KubernetesClientBootstrapConfigurationInsideK8s.java",
        "name": "KubernetesClientBootstrapConfigurationInsideK8s",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003dabc\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap_configurations.KubernetesClientBootstrapConfigurationInsideK8s",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003dabc\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class KubernetesClientBootstrapConfigurationInsideK8s {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test public void bothPresent(){\n    assertThat(context.getBeanNamesForType(KubernetesClientConfigMapPropertySourceLocator.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(KubernetesClientSecretsPropertySourceLocator.class)).hasSize(1);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.namespace\u003dabc\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class KubernetesClientBootstrapConfigurationInsideK8s {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test public void bothPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap_configurations/KubernetesDisabled.java",
        "name": "KubernetesDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"kubernetes.informer.enabled\u003dfalse\",\"kubernetes.manifests.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap_configurations.KubernetesDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"kubernetes.informer.enabled\u003dfalse\",\"kubernetes.manifests.enabled\u003dfalse\"}) class KubernetesDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void configAndSecretsBeansAreNotPresent(){\n    assertThat(context.getBeanNamesForType(KubernetesClientConfigMapPropertySourceLocator.class)).hasSize(0);\n    assertThat(context.getBeanNamesForType(KubernetesClientSecretsPropertySourceLocator.class)).hasSize(0);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"kubernetes.informer.enabled\u003dfalse\",\"kubernetes.manifests.enabled\u003dfalse\"}) class KubernetesDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void configAndSecretsBeansAreNotPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap_configurations/KubernetesEnabledOnPurpose.java",
        "name": "KubernetesEnabledOnPurpose",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap_configurations.KubernetesEnabledOnPurpose",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class KubernetesEnabledOnPurpose {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void configAndSecretsBeansArePresent(){\n    assertThat(context.getBeanNamesForType(KubernetesClientConfigMapPropertySourceLocator.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(KubernetesClientSecretsPropertySourceLocator.class)).hasSize(1);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class KubernetesEnabledOnPurpose {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void configAndSecretsBeansArePresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap_configurations/KubernetesEnabledSecretsAndConfigDisabled.java",
        "name": "KubernetesEnabledSecretsAndConfigDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap_configurations.KubernetesEnabledSecretsAndConfigDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class KubernetesEnabledSecretsAndConfigDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void secretsOnlyPresent(){\n    assertThat(context.getBeanNamesForType(KubernetesClientConfigMapPropertySourceLocator.class)).hasSize(0);\n    assertThat(context.getBeanNamesForType(KubernetesClientSecretsPropertySourceLocator.class)).hasSize(0);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\"}) class KubernetesEnabledSecretsAndConfigDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void secretsOnlyPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap_configurations/KubernetesEnabledSecretsDisabled.java",
        "name": "KubernetesEnabledSecretsDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap_configurations.KubernetesEnabledSecretsDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class KubernetesEnabledSecretsDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void secretsOnlyPresent(){\n    assertThat(context.getBeanNamesForType(KubernetesClientConfigMapPropertySourceLocator.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(KubernetesClientSecretsPropertySourceLocator.class)).hasSize(0);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class KubernetesEnabledSecretsDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void secretsOnlyPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap_configurations/KubernetesEnabled.java",
        "name": "KubernetesEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap_configurations.KubernetesEnabled",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class KubernetesEnabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void configAndSecretsBeansArePresent(){\n    assertThat(context.getBeanNamesForType(KubernetesClientConfigMapPropertySourceLocator.class)).hasSize(1);\n    assertThat(context.getBeanNamesForType(KubernetesClientSecretsPropertySourceLocator.class)).hasSize(1);\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class KubernetesEnabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void configAndSecretsBeansArePresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/bootstrap_configurations/KubernetesEnabledConfigDisabled.java",
        "name": "KubernetesEnabledConfigDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.bootstrap_configurations.KubernetesEnabledConfigDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class KubernetesEnabledConfigDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void secretsOnlyPresent(){\n    assertThat(context.getBeanNamesForType(KubernetesClientConfigMapPropertySourceLocator.class)).hasSize(0);\n    assertThat(context.getBeanNamesForType(KubernetesClientSecretsPropertySourceLocator.class)).hasSize(1);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dApplication.class,properties\u003d{\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class KubernetesEnabledConfigDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void secretsOnlyPresent();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/LabeledConfigMapContextToSourceDataProviderTests.java",
        "name": "LabeledConfigMapContextToSourceDataProviderTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.LabeledConfigMapContextToSourceDataProviderTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class LabeledConfigMapContextToSourceDataProviderTests {\n  private static final Map\u003cString,String\u003e LABELS\u003dnew LinkedHashMap\u003c\u003e();\n  private static final Map\u003cString,String\u003e RED_LABEL\u003dMap.of(\"color\",\"red\");\n  private static final Map\u003cString,String\u003e BLUE_LABEL\u003dMap.of(\"color\",\"blue\");\n  private static final Map\u003cString,String\u003e PINK_LABEL\u003dMap.of(\"color\",\"pink\");\n  private static final String NAMESPACE\u003d\"default\";\nstatic {\n    LABELS.put(\"label2\",\"value2\");\n    LABELS.put(\"label1\",\"value1\");\n  }\n  @BeforeAll static void setup(){\n    WireMockServer wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    client.setDebugging(true);\n    Configuration.setDefaultApiClient(client);\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n    new KubernetesClientConfigMapsCache().discardAll();\n  }\n  /** \n * we have a single config map deployed. it has two labels and these match against our queries.\n */\n  @Test void singleConfigMapMatchAgainstLabels(){\n    V1ConfigMap one\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"test-configmap\").withLabels(LABELS).withNamespace(NAMESPACE).build()).addToData(\"name\",\"value\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(one);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,LABELS,true,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(\"configmap.test-configmap.default\",sourceData.sourceName());\n    Assertions.assertEquals(Map.of(\"name\",\"value\"),sourceData.sourceData());\n  }\n  /** \n * we have three configmaps deployed. two of them have labels that match (color\u003dred), one does not (color\u003dblue).\n */\n  @Test void twoConfigMapsMatchAgainstLabels(){\n    V1ConfigMap redOne\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"red-configmap\").withLabels(RED_LABEL).withNamespace(NAMESPACE).build()).addToData(\"colorOne\",\"really-red\").build();\n    V1ConfigMap redTwo\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"red-configmap-again\").withLabels(RED_LABEL).withNamespace(NAMESPACE).build()).addToData(\"colorTwo\",\"really-red-again\").build();\n    V1ConfigMap blue\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"blue-configmap\").withLabels(BLUE_LABEL).withNamespace(NAMESPACE).build()).addToData(\"color\",\"blue\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(redOne).addItemsItem(redTwo).addItemsItem(blue);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,RED_LABEL,true,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.red-configmap.red-configmap-again.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"colorOne\"),\"really-red\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"colorTwo\"),\"really-red-again\");\n  }\n  /** \n * one configmap deployed (pink), does not match our query (blue).\n */\n  @Test void configMapNoMatch(){\n    V1ConfigMap one\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"pink-configmap\").withLabels(PINK_LABEL).withNamespace(NAMESPACE).build()).addToData(\"color\",\"pink\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(one);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,BLUE_LABEL,true,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.color.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Collections.emptyMap());\n  }\n  /** \n * LabeledConfigMapContextToSourceDataProvider gets as input a Fabric8ConfigContext. This context has a namespace as well as a NormalizedSource, that has a namespace too. It is easy to get confused in code on which namespace to use. This test makes sure that we use the proper one.\n */\n  @Test void namespaceMatch(){\n    V1ConfigMap one\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"test-configmap\").withLabels(LABELS).withNamespace(NAMESPACE).build()).addToData(\"name\",\"value\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(one);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    String wrongNamespace\u003dNAMESPACE + \"nope\";\n    NormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(wrongNamespace,LABELS,true,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(\"configmap.test-configmap.default\",sourceData.sourceName());\n    Assertions.assertEquals(Map.of(\"name\",\"value\"),sourceData.sourceData());\n  }\n  /** \n * one configmap with name : \"blue-configmap\" and labels \"color\u003dblue\" is deployed. we search it with the same labels, find it, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided an explicit prefix).\n */\n  @Test void testWithPrefix(){\n    V1ConfigMap one\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"blue-configmap\").withLabels(BLUE_LABEL).withNamespace(NAMESPACE).build()).addToData(\"what-color\",\"blue-color\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(one);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    ConfigUtils.Prefix mePrefix\u003dConfigUtils.findPrefix(\"me\",false,false,\"irrelevant\");\n    NormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,BLUE_LABEL,true,mePrefix,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(\"configmap.blue-configmap.default\",sourceData.sourceName());\n    Assertions.assertEquals(Map.of(\"me.what-color\",\"blue-color\"),sourceData.sourceData());\n  }\n  /** \n * two configmaps are deployed (name:blue-configmap, name:another-blue-configmap) and labels \"color\u003dblue\" (on both). we search with the same labels, find them, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided a delayed prefix). Also notice that the prefix is made up from both configmap names.\n */\n  @Test void testTwoConfigmapsWithPrefix(){\n    V1ConfigMap one\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"blue-configmap\").withLabels(BLUE_LABEL).withNamespace(NAMESPACE).build()).addToData(\"first\",\"blue\").build();\n    V1ConfigMap two\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"another-blue-configmap\").withLabels(BLUE_LABEL).withNamespace(NAMESPACE).build()).addToData(\"second\",\"blue\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(one).addItemsItem(two);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,BLUE_LABEL,true,ConfigUtils.Prefix.DELAYED,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.another-blue-configmap.blue-configmap.default\");\n    Map\u003cString,Object\u003e properties\u003dsourceData.sourceData();\n    Assertions.assertEquals(2,properties.size());\n    Iterator\u003cString\u003e keys\u003dproperties.keySet().iterator();\n    String firstKey\u003dkeys.next();\n    String secondKey\u003dkeys.next();\n    if (firstKey.contains(\"first\")) {\n      Assertions.assertEquals(firstKey,\"another-blue-configmap.blue-configmap.first\");\n    }\n    Assertions.assertEquals(secondKey,\"another-blue-configmap.blue-configmap.second\");\n    Assertions.assertEquals(properties.get(firstKey),\"blue\");\n    Assertions.assertEquals(properties.get(secondKey),\"blue\");\n  }\n  /** \n * two configmaps are deployed: \"color-configmap\" with label: \"{color:blue}\" and \"color-configmap-k8s\" with no labels. We search by \"{color:red}\", do not find anything and thus have an empty SourceData. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsNoConfigmapsFound(){\n    V1ConfigMap one\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"color-configmap\").withLabels(BLUE_LABEL).withNamespace(NAMESPACE).build()).addToData(\"one\",\"1\").build();\n    V1ConfigMap two\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"color-config-k8s\").withNamespace(NAMESPACE).build()).addToData(\"two\",\"2\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(one).addItemsItem(two);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,RED_LABEL,true,ConfigUtils.Prefix.DEFAULT,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertTrue(sourceData.sourceData().isEmpty());\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.color.default\");\n  }\n  /** \n * two configmaps are deployed: \"color-configmap\" with label: \"{color:blue}\" and \"shape-configmap\" with label: \"{shape:round}\". We search by \"{color:blue}\" and find one configmap. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsOneConfigMapFound(){\n    V1ConfigMap one\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"color-configmap\").withLabels(BLUE_LABEL).withNamespace(NAMESPACE).build()).addToData(\"one\",\"1\").build();\n    V1ConfigMap two\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"shape-configmap\").withNamespace(NAMESPACE).build()).addToData(\"two\",\"2\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(one).addItemsItem(two);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,BLUE_LABEL,true,ConfigUtils.Prefix.DEFAULT,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),1);\n    Assertions.assertEquals(sourceData.sourceData().get(\"one\"),\"1\");\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.color-configmap.default\");\n  }\n  /** \n * two configmaps are deployed: \"color-configmap\" with label: \"{color:blue}\" and \"color-configmap-k8s\" with label: \"{color:red}\". We search by \"{color:blue}\" and find one configmap. Since profiles are enabled, we will also be reading \"color-configmap-k8s\", even if its labels do not match provided ones.\n */\n  @Test void searchWithLabelsOneConfigMapFoundAndOneFromProfileFound(){\n    V1ConfigMap one\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"color-configmap\").withLabels(BLUE_LABEL).withNamespace(NAMESPACE).build()).addToData(\"one\",\"1\").build();\n    V1ConfigMap two\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"color-configmap-k8s\").withLabels(RED_LABEL).withNamespace(NAMESPACE).build()).addToData(\"two\",\"2\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(one).addItemsItem(two);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,BLUE_LABEL,true,ConfigUtils.Prefix.DELAYED,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,environment);\n    KubernetesClientContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-configmap.color-configmap-k8s.one\"),\"1\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-configmap.color-configmap-k8s.two\"),\"2\");\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.color-configmap.color-configmap-k8s.default\");\n  }\n  /** \n * \u003cpre\u003e - configmap \"color-configmap\" with label \"{color:blue}\" - configmap \"shape-configmap\" with labels \"{color:blue, shape:round}\" - configmap \"no-fit\" with labels \"{tag:no-fit}\" - configmap \"color-configmap-k8s\" with label \"{color:red}\" - configmap \"shape-configmap-k8s\" with label \"{shape:triangle}\" \u003c/pre\u003e\n */\n  @Test void searchWithLabelsTwoConfigMapsFoundAndOneFromProfileFound(){\n    V1ConfigMap colorConfigMap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"color-configmap\").withLabels(BLUE_LABEL).withNamespace(NAMESPACE).build()).addToData(\"one\",\"1\").build();\n    V1ConfigMap shapeConfigmap\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"shape-configmap\").withLabels(Map.of(\"color\",\"blue\",\"shape\",\"round\")).withNamespace(NAMESPACE).build()).addToData(\"two\",\"2\").build();\n    V1ConfigMap noFit\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"no-fit\").withLabels(Map.of(\"tag\",\"no-fit\")).withNamespace(NAMESPACE).build()).addToData(\"three\",\"3\").build();\n    V1ConfigMap colorConfigmapK8s\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"color-configmap-k8s\").withLabels(RED_LABEL).withNamespace(NAMESPACE).build()).addToData(\"four\",\"4\").build();\n    V1ConfigMap shapeConfigmapK8s\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"shape-configmap-k8s\").withLabels(Map.of(\"shape\",\"triangle\")).withNamespace(NAMESPACE).build()).addToData(\"five\",\"5\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(colorConfigMap).addItemsItem(shapeConfigmap).addItemsItem(noFit).addItemsItem(colorConfigmapK8s).addItemsItem(shapeConfigmapK8s);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,BLUE_LABEL,true,ConfigUtils.Prefix.DELAYED,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,environment);\n    KubernetesClientContextToSourceData data\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),4);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-configmap.color-configmap-k8s.shape-configmap.shape-configmap-k8s.one\"),\"1\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-configmap.color-configmap-k8s.shape-configmap.shape-configmap-k8s.two\"),\"2\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-configmap.color-configmap-k8s.shape-configmap.shape-configmap-k8s.four\"),\"4\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-configmap.color-configmap-k8s.shape-configmap.shape-configmap-k8s.five\"),\"5\");\n    Assertions.assertEquals(sourceData.sourceName(),\"configmap.color-configmap.color-configmap-k8s.shape-configmap.shape-configmap-k8s.default\");\n  }\n  /** \n * \u003cpre\u003e - one configmap is deployed with label {\"color\", \"red\"} - one configmap is deployed with label {\"color\", \"green\"} - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output){\n    V1ConfigMap red\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"red\")).withNamespace(NAMESPACE).withName(\"red-configmap\").build()).addToData(\"color\",\"red\").build();\n    V1ConfigMap green\u003dnew V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"green\")).withNamespace(NAMESPACE).withName(\"green-configmap\").build()).addToData(\"color\",\"green\").build();\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().addItemsItem(red).addItemsItem(green);\n    stubCall(configMapList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource redSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,Map.of(\"color\",\"red\"),false,ConfigUtils.Prefix.DEFAULT,false);\n    KubernetesClientConfigContext redContext\u003dnew KubernetesClientConfigContext(api,redSource,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData redData\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData redSourceData\u003dredData.apply(redContext);\n    Assertions.assertEquals(redSourceData.sourceData().size(),1);\n    Assertions.assertEquals(redSourceData.sourceData().get(\"color\"),\"red\");\n    Assertions.assertEquals(redSourceData.sourceName(),\"configmap.red-configmap.default\");\n    Assertions.assertTrue(output.getAll().contains(\"Loaded all config maps in namespace \u0027\" + NAMESPACE + \"\u0027\"));\n    NormalizedSource greenSource\u003dnew LabeledConfigMapNormalizedSource(NAMESPACE,Map.of(\"color\",\"green\"),false,ConfigUtils.Prefix.DEFAULT,false);\n    KubernetesClientConfigContext greenContext\u003dnew KubernetesClientConfigContext(api,greenSource,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData greenData\u003dnew LabeledConfigMapContextToSourceDataProvider().get();\n    SourceData greenSourceData\u003dgreenData.apply(greenContext);\n    Assertions.assertEquals(greenSourceData.sourceData().size(),1);\n    Assertions.assertEquals(greenSourceData.sourceData().get(\"color\"),\"green\");\n    Assertions.assertEquals(greenSourceData.sourceName(),\"configmap.green-configmap.default\");\n    String[] out\u003doutput.getAll().split(\"Loaded all config maps in namespace\");\n    Assertions.assertEquals(out.length,2);\n    out\u003doutput.getAll().split(\"Loaded \\\\(from cache\\\\) all config maps in namespace\");\n    Assertions.assertEquals(out.length,2);\n  }\n  private void stubCall(  V1ConfigMapList list){\n    stubFor(get(\"/api/v1/namespaces/default/configmaps\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(list))));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class LabeledConfigMapContextToSourceDataProviderTests {\n  private static final Map\u003cString,String\u003e LABELS\u003dnew LinkedHashMap\u003c\u003e();\n  private static final Map\u003cString,String\u003e RED_LABEL\u003dMap.of(\"color\",\"red\");\n  private static final Map\u003cString,String\u003e BLUE_LABEL\u003dMap.of(\"color\",\"blue\");\n  private static final Map\u003cString,String\u003e PINK_LABEL\u003dMap.of(\"color\",\"pink\");\n  private static final String NAMESPACE\u003d\"default\";\nstatic {\n    LABELS.put(\"label2\",\"value2\");\n    LABELS.put(\"label1\",\"value1\");\n  }\n  @BeforeAll static void setup();\n  @AfterEach void afterEach();\n  /** \n * we have a single config map deployed. it has two labels and these match against our queries.\n */\n  @Test void singleConfigMapMatchAgainstLabels();\n  /** \n * we have three configmaps deployed. two of them have labels that match (color\u003dred), one does not (color\u003dblue).\n */\n  @Test void twoConfigMapsMatchAgainstLabels();\n  /** \n * one configmap deployed (pink), does not match our query (blue).\n */\n  @Test void configMapNoMatch();\n  /** \n * LabeledConfigMapContextToSourceDataProvider gets as input a Fabric8ConfigContext. This context has a namespace as well as a NormalizedSource, that has a namespace too. It is easy to get confused in code on which namespace to use. This test makes sure that we use the proper one.\n */\n  @Test void namespaceMatch();\n  /** \n * one configmap with name : \"blue-configmap\" and labels \"color\u003dblue\" is deployed. we search it with the same labels, find it, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided an explicit prefix).\n */\n  @Test void testWithPrefix();\n  /** \n * two configmaps are deployed (name:blue-configmap, name:another-blue-configmap) and labels \"color\u003dblue\" (on both). we search with the same labels, find them, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided a delayed prefix). Also notice that the prefix is made up from both configmap names.\n */\n  @Test void testTwoConfigmapsWithPrefix();\n  /** \n * two configmaps are deployed: \"color-configmap\" with label: \"{color:blue}\" and \"color-configmap-k8s\" with no labels. We search by \"{color:red}\", do not find anything and thus have an empty SourceData. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsNoConfigmapsFound();\n  /** \n * two configmaps are deployed: \"color-configmap\" with label: \"{color:blue}\" and \"shape-configmap\" with label: \"{shape:round}\". We search by \"{color:blue}\" and find one configmap. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsOneConfigMapFound();\n  /** \n * two configmaps are deployed: \"color-configmap\" with label: \"{color:blue}\" and \"color-configmap-k8s\" with label: \"{color:red}\". We search by \"{color:blue}\" and find one configmap. Since profiles are enabled, we will also be reading \"color-configmap-k8s\", even if its labels do not match provided ones.\n */\n  @Test void searchWithLabelsOneConfigMapFoundAndOneFromProfileFound();\n  /** \n * \u003cpre\u003e - configmap \"color-configmap\" with label \"{color:blue}\" - configmap \"shape-configmap\" with labels \"{color:blue, shape:round}\" - configmap \"no-fit\" with labels \"{tag:no-fit}\" - configmap \"color-configmap-k8s\" with label \"{color:red}\" - configmap \"shape-configmap-k8s\" with label \"{shape:triangle}\" \u003c/pre\u003e\n */\n  @Test void searchWithLabelsTwoConfigMapsFoundAndOneFromProfileFound();\n  /** \n * \u003cpre\u003e - one configmap is deployed with label {\"color\", \"red\"} - one configmap is deployed with label {\"color\", \"green\"} - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output);\n  private void stubCall(  V1ConfigMapList list);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientConfigUtilsTests.java",
        "name": "KubernetesClientConfigUtilsTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientConfigUtilsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesClientConfigUtilsTests {\n  @Test void testNamespacesFromProperties(){\n    ConfigReloadProperties properties\u003dnew ConfigReloadProperties(false,false,false,ConfigReloadProperties.ReloadStrategy.REFRESH,ConfigReloadProperties.ReloadDetectionMode.EVENT,Duration.ofMillis(15000),Set.of(\"non-default\"),false,Duration.ofSeconds(2));\n    Set\u003cString\u003e namespaces\u003dKubernetesClientConfigUtils.namespaces(new KubernetesNamespaceProvider(new MockEnvironment()),properties,\"configmap\");\n    Assertions.assertEquals(1,namespaces.size());\n    Assertions.assertEquals(namespaces.iterator().next(),\"non-default\");\n  }\n  @Test void testNamespacesFromProvider(){\n    ConfigReloadProperties properties\u003dConfigReloadProperties.DEFAULT;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.client.namespace\",\"some\");\n    KubernetesNamespaceProvider provider\u003dnew KubernetesNamespaceProvider(environment);\n    Set\u003cString\u003e namespaces\u003dKubernetesClientConfigUtils.namespaces(provider,properties,\"configmap\");\n    Assertions.assertEquals(1,namespaces.size());\n    Assertions.assertEquals(namespaces.iterator().next(),\"some\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesClientConfigUtilsTests {\n  @Test void testNamespacesFromProperties();\n  @Test void testNamespacesFromProvider();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientConfigReloadAutoConfigurationTest.java",
        "name": "KubernetesClientConfigReloadAutoConfigurationTest",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientConfigReloadAutoConfigurationTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Haytham Mohamed\n */\npublic class KubernetesClientConfigReloadAutoConfigurationTest {\n  private ConfigurableApplicationContext context;\n  public static WireMockServer wireMockServer;\n  protected void setup(  String... env){\n    List\u003cString\u003e envList\u003d(env !\u003d null) ? new ArrayList\u003c\u003e(Arrays.asList(env)) : new ArrayList\u003c\u003e();\n    envList.add(\"spring.cloud.kubernetes.client.namespace\u003ddefault\");\n    String[] envArray\u003denvList.toArray(new String[0]);\n    context\u003dnew SpringApplicationBuilder(PropertyPlaceholderAutoConfiguration.class,LocalTestConfig.class,ConfigReloadAutoConfiguration.class,RefreshAutoConfiguration.class,EndpointAutoConfiguration.class,InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,ConfigurationPropertiesBindingPostProcessor.class,ConfigReloadPropertiesAutoConfiguration.class,ConfigurationPropertiesRebinderAutoConfiguration.class,KubernetesClientBootstrapConfiguration.class,KubernetesBootstrapConfiguration.class,KubernetesClientConfigReloadAutoConfiguration.class).web(org.springframework.boot.WebApplicationType.NONE).properties(envArray).run();\n  }\n  @BeforeAll static void startWireMockServer(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n  }\n  @AfterEach void afterEach(){\n    if (this.context !\u003d null) {\n      this.context.close();\n      this.context\u003dnull;\n    }\n  }\n  @BeforeEach void beforeEach(){\n    V1ConfigMapList TEST_CONFIGMAP\u003dnew V1ConfigMapList().addItemsItem(new V1ConfigMapBuilder().withMetadata(new V1ObjectMetaBuilder().withName(\"test-cm\").withNamespace(\"default\").withResourceVersion(\"1\").build()).addToData(\"app.name\",\"test\").build());\n    WireMock.stubFor(get(urlMatching(\"^/api/v1/namespaces/default/configmaps.*\")).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(TEST_CONFIGMAP))));\n  }\n  @Test void kubernetesWatchersWhenKubernetesDisabled(){\n    setup();\n    assertThat(context.containsBean(\"configMapPropertySourceLocator\")).isFalse();\n    assertThat(context.containsBean(\"secretsPropertySourceLocator\")).isFalse();\n    assertThat(context.containsBean(\"configMapPropertyChangePollingWatcher\")).isFalse();\n    assertThat(context.containsBean(\"secretsPropertyChangePollingWatcher\")).isFalse();\n    assertThat(context.containsBean(\"configMapPropertyChangeEventWatcher\")).isFalse();\n    assertThat(context.containsBean(\"secretsPropertyChangeEventWatcher\")).isFalse();\n  }\n  @Test void kubernetesWatchersWhenConfigDisabled(){\n    setup(\"spring.cloud.kubernetes.config.enabled\u003dfalse\");\n    assertThat(context.containsBean(\"configMapPropertyChangePollingWatcher\")).isFalse();\n    assertThat(context.containsBean(\"secretsPropertyChangePollingWatcher\")).isFalse();\n    assertThat(context.containsBean(\"configMapPropertyChangeEventWatcher\")).isFalse();\n    assertThat(context.containsBean(\"secretsPropertyChangeEventWatcher\")).isFalse();\n  }\n  @Test void kubernetesWatchersWhenReloadDisabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dfalse\");\n    assertThat(context.containsBean(\"configMapPropertyChangePollingWatcher\")).isFalse();\n    assertThat(context.containsBean(\"secretsPropertyChangePollingWatcher\")).isFalse();\n    assertThat(context.containsBean(\"configMapPropertyChangeEventWatcher\")).isFalse();\n    assertThat(context.containsBean(\"secretsPropertyChangeEventWatcher\")).isFalse();\n  }\n  @Test void kubernetesReloadEnabledButSecretAndConfigDisabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\");\n    assertThat(context.containsBean(\"configMapPropertyChangePollingWatcher\")).isFalse();\n    assertThat(context.containsBean(\"secretsPropertyChangePollingWatcher\")).isFalse();\n    assertThat(context.containsBean(\"configMapPropertyChangeEventWatcher\")).isFalse();\n    assertThat(context.containsBean(\"secretsPropertyChangeEventWatcher\")).isFalse();\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true by default - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabledByDefault(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dcontext.getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    Assertions.assertTrue(map.values().iterator().next().getClass().isAssignableFrom(KubernetesClientEventBasedConfigMapChangeDetector.class));\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true by default - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003devent\",\"spring.main.cloud-platform\u003dKUBERNETES\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dcontext.getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    Assertions.assertTrue(map.values().iterator().next().getClass().isAssignableFrom(KubernetesClientEventBasedConfigMapChangeDetector.class));\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsDisabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003devent\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dfalse\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dcontext.getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),0);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via poll reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsDisabledMonitoringSecretsDisabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003dpolling\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dfalse\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dcontext.getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),0);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via poll reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true by default - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - config map polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsEnabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003dpolling\",\"spring.main.cloud-platform\u003dKUBERNETES\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dcontext.getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    Assertions.assertTrue(map.values().iterator().next().getClass().isAssignableFrom(PollingConfigMapChangeDetector.class));\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsDisabledMonitoringSecretsEnabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dtrue\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dfalse\",\"spring.cloud.kubernetes.reload.mode\u003devent\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dcontext.getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    Assertions.assertTrue(map.values().iterator().next().getClass().isAssignableFrom(KubernetesClientEventBasedSecretsChangeDetector.class));\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsDisabledMonitoringSecretsEnabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dtrue\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dfalse\",\"spring.cloud.kubernetes.reload.mode\u003dpolling\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dcontext.getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    Assertions.assertTrue(map.values().iterator().next().getClass().isAssignableFrom(PollingSecretsChangeDetector.class));\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is true - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabledMonitoringSecretsEnabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dtrue\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003devent\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dcontext.getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),2);\n    List\u003cConfigurationChangeDetector\u003e result\u003dmap.values().stream().sorted(Comparator.comparing(x -\u003e x.getClass().getName())).toList();\n    Assertions.assertEquals(result.get(0).getClass(),KubernetesClientEventBasedConfigMapChangeDetector.class);\n    Assertions.assertEquals(result.get(1).getClass(),KubernetesClientEventBasedSecretsChangeDetector.class);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is true - config map event watcher is not picked up - config map polling watcher is picked up - secrets event watcher is not picked up - secrets polling watcher is picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsEnabledMonitoringSecretsEnabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dtrue\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003dpolling\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dcontext.getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),2);\n    List\u003cConfigurationChangeDetector\u003e result\u003dmap.values().stream().sorted(Comparator.comparing(x -\u003e x.getClass().getName())).toList();\n    Assertions.assertEquals(result.get(0).getClass(),PollingConfigMapChangeDetector.class);\n    Assertions.assertEquals(result.get(1).getClass(),PollingSecretsChangeDetector.class);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsDisabledMonitoringSecretsDisabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003devent\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dfalse\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dfalse\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dcontext.getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),0);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via poll reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitorConfigMapsDisabledMonitoringSecretsDisabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003dpolling\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dfalse\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dfalse\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dcontext.getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),0);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabledMonitoringSecretsDisabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003devent\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dtrue\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dfalse\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dcontext.getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    List\u003cConfigurationChangeDetector\u003e result\u003dmap.values().stream().sorted(Comparator.comparing(x -\u003e x.getClass().getName())).toList();\n    Assertions.assertEquals(result.get(0).getClass(),KubernetesClientEventBasedConfigMapChangeDetector.class);\n  }\n  /** \n * \u003cpre\u003e - reload mode is enabled (via polling reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is not picked up - config map polling watcher is picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsEnabledMonitoringSecretsDisabled(){\n    setup(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.mode\u003dpolling\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.monitoring-configMaps\u003dtrue\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dfalse\");\n    Map\u003cString,ConfigurationChangeDetector\u003e map\u003dcontext.getBeansOfType(ConfigurationChangeDetector.class);\n    Assertions.assertEquals(map.size(),1);\n    List\u003cConfigurationChangeDetector\u003e result\u003dmap.values().stream().sorted(Comparator.comparing(x -\u003e x.getClass().getName())).toList();\n    Assertions.assertEquals(result.get(0).getClass(),PollingConfigMapChangeDetector.class);\n  }\n  @Test void kubernetesConfigAndSecretEnabledByDefault(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\");\n    assertThat(context.containsBean(\"configMapPropertySourceLocator\")).isTrue();\n    assertThat(context.containsBean(\"secretsPropertySourceLocator\")).isTrue();\n  }\n  @Test void kubernetesConfigEnabledButSecretDisabled(){\n    setup(\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\");\n    assertThat(context.containsBean(\"configMapPropertySourceLocator\")).isTrue();\n    assertThat(context.containsBean(\"secretsPropertySourceLocator\")).isFalse();\n  }\n  @Test void kubernetesSecretsEnabledButConfigDisabled(){\n    setup(\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\");\n    assertThat(context.containsBean(\"configMapPropertySourceLocator\")).isFalse();\n    assertThat(context.containsBean(\"secretsPropertySourceLocator\")).isTrue();\n  }\n@Configuration(proxyBeanMethods\u003dfalse) @AutoConfigureBefore(KubernetesClientAutoConfiguration.class) static class LocalTestConfig {\n    @ConditionalOnMissingBean(KubernetesClientProperties.class) @Bean KubernetesClientProperties kubernetesClientProperties(){\n      return new KubernetesClientProperties(null,null,null,\"default\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null);\n    }\n    @Bean ApiClient apiClient(){\n      ApiClient apiClient\u003dnew ClientBuilder().setBasePath(wireMockServer.baseUrl()).build();\n      apiClient.setDebugging(true);\n      apiClient.setReadTimeout(0);\n      return apiClient;\n    }\n    @Bean CoreV1Api coreApi(    ApiClient apiClient){\n      return new CoreV1Api(apiClient);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Haytham Mohamed\n */\npublic class KubernetesClientConfigReloadAutoConfigurationTest {\n  private ConfigurableApplicationContext context;\n  public static WireMockServer wireMockServer;\n  protected void setup(  String... env);\n  @BeforeAll static void startWireMockServer();\n  @AfterEach void afterEach();\n  @BeforeEach void beforeEach();\n  @Test void kubernetesWatchersWhenKubernetesDisabled();\n  @Test void kubernetesWatchersWhenConfigDisabled();\n  @Test void kubernetesWatchersWhenReloadDisabled();\n  @Test void kubernetesReloadEnabledButSecretAndConfigDisabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true by default - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabledByDefault();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true by default - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsDisabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via poll reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsDisabledMonitoringSecretsDisabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via poll reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true by default - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - config map polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsEnabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsDisabledMonitoringSecretsEnabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsDisabledMonitoringSecretsEnabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is true - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabledMonitoringSecretsEnabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-secrets is true - spring.cloud.kubernetes.reload.monitoring-configMaps is true - config map event watcher is not picked up - config map polling watcher is picked up - secrets event watcher is not picked up - secrets polling watcher is picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsEnabledMonitoringSecretsEnabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsDisabledMonitoringSecretsDisabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via poll reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is false - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is not picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitorConfigMapsDisabledMonitoringSecretsDisabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via event reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is picked up - config map polling watcher is not picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadEventEnabledMonitoringConfigMapsEnabledMonitoringSecretsDisabled();\n  /** \n * \u003cpre\u003e - reload mode is enabled (via polling reload) - spring.cloud.kubernetes.reload.monitoring-configMaps is true - spring.cloud.kubernetes.reload.monitoring-secrets is false - config map event watcher is not picked up - config map polling watcher is picked up - secrets event watcher is not picked up - secrets polling watcher is not picked up \u003c/pre\u003e\n */\n  @Test void reloadPollingEnabledMonitoringConfigMapsEnabledMonitoringSecretsDisabled();\n  @Test void kubernetesConfigAndSecretEnabledByDefault();\n  @Test void kubernetesConfigEnabledButSecretDisabled();\n  @Test void kubernetesSecretsEnabledButConfigDisabled();\n@Configuration(proxyBeanMethods\u003dfalse) @AutoConfigureBefore(KubernetesClientAutoConfiguration.class) static class LocalTestConfig {\n    @ConditionalOnMissingBean(KubernetesClientProperties.class) @Bean KubernetesClientProperties kubernetesClientProperties();\n    @Bean ApiClient apiClient();\n    @Bean CoreV1Api coreApi(    ApiClient apiClient);\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/single_source_multiple_files/properties/Type.java",
        "name": "Type",
        "modifiers": "@ConfigurationProperties(\"fruit\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.single_source_multiple_files.properties.Type",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"fruit\") public class Type {\n  private String type;\n  public String getType(){\n    return type;\n  }\n  public void setType(  String type){\n    this.type\u003dtype;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"fruit\") public class Type {\n  private String type;\n  public String getType();\n  public void setType(  String type);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/single_source_multiple_files/properties/Shape.java",
        "name": "Shape",
        "modifiers": "@ConfigurationProperties(\"shape.when\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.single_source_multiple_files.properties.Shape",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"shape.when\") public class Shape {\n  private String raw;\n  private String ripe;\n  public String getRaw(){\n    return raw;\n  }\n  public void setRaw(  String raw){\n    this.raw\u003draw;\n  }\n  public String getRipe(){\n    return ripe;\n  }\n  public void setRipe(  String ripe){\n    this.ripe\u003dripe;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"shape.when\") public class Shape {\n  private String raw;\n  private String ripe;\n  public String getRaw();\n  public void setRaw(  String raw);\n  public String getRipe();\n  public void setRipe(  String ripe);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/single_source_multiple_files/properties/Name.java",
        "name": "Name",
        "modifiers": "@ConfigurationProperties(\"cool\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.single_source_multiple_files.properties.Name",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"cool\") public class Name {\n  private String name;\n  public String getName(){\n    return name;\n  }\n  public void setName(  String name){\n    this.name\u003dname;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"cool\") public class Name {\n  private String name;\n  public String getName();\n  public void setName(  String name);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/single_source_multiple_files/properties/Color.java",
        "name": "Color",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"color.when\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.single_source_multiple_files.properties.Color",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"color.when\") public class Color {\n  private String raw;\n  private String ripe;\n  public String getRaw(){\n    return raw;\n  }\n  public void setRaw(  String raw){\n    this.raw\u003draw;\n  }\n  public String getRipe(){\n    return ripe;\n  }\n  public void setRipe(  String ripe){\n    this.ripe\u003dripe;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"color.when\") public class Color {\n  private String raw;\n  private String ripe;\n  public String getRaw();\n  public void setRaw(  String raw);\n  public String getRipe();\n  public void setRipe(  String ripe);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/single_source_multiple_files/controller/SingleSourceMultipleFilesController.java",
        "name": "SingleSourceMultipleFilesController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.single_source_multiple_files.controller.SingleSourceMultipleFilesController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class SingleSourceMultipleFilesController {\n  private final Name name;\n  private final Shape shape;\n  private final Color color;\n  private final Type type;\n  public SingleSourceMultipleFilesController(  Name name,  Shape shape,  Color color,  Type type){\n    this.name\u003dname;\n    this.shape\u003dshape;\n    this.color\u003dcolor;\n    this.type\u003dtype;\n  }\n  @GetMapping(\"/single_source-multiple-files/type\") public String type(){\n    return type.getType();\n  }\n  @GetMapping(\"/single_source-multiple-files/shape\") public String shape(){\n    return shape.getRaw();\n  }\n  @GetMapping(\"/single_source-multiple-files/color\") public String color(){\n    return \"raw:\" + color.getRaw() + \"###\"+ \"ripe:\"+ color.getRipe();\n  }\n  @GetMapping(\"/single_source-multiple-files/name\") public String name(){\n    return name.getName();\n  }\n}\n",
        "abstract": "@RestController public class SingleSourceMultipleFilesController {\n  private final Name name;\n  private final Shape shape;\n  private final Color color;\n  private final Type type;\n  public SingleSourceMultipleFilesController(  Name name,  Shape shape,  Color color,  Type type);\n  @GetMapping(\"/single_source-multiple-files/type\") public String type();\n  @GetMapping(\"/single_source-multiple-files/shape\") public String shape();\n  @GetMapping(\"/single_source-multiple-files/color\") public String color();\n  @GetMapping(\"/single_source-multiple-files/name\") public String name();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/single_source_multiple_files/SingleSourceMultipleFilesApp.java",
        "name": "SingleSourceMultipleFilesApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({Name.class,Shape.class,Color.class,Type.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.single_source_multiple_files.SingleSourceMultipleFilesApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({Name.class,Shape.class,Color.class,Type.class}) public class SingleSourceMultipleFilesApp {\n  public static void main(  String[] args){\n    SpringApplication.run(SingleSourceMultipleFilesApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({Name.class,Shape.class,Color.class,Type.class}) public class SingleSourceMultipleFilesApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/single_source_multiple_files/SingleSourceMultipleFilesBootstrapTests.java",
        "name": "SingleSourceMultipleFilesBootstrapTests",
        "modifiers": "@ActiveProfiles(\"color\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSingleSourceMultipleFilesApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsingle-source-multiple-files\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\",\"single.source.multiple.files.stub\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.single_source_multiple_files.SingleSourceMultipleFilesBootstrapTests",
        "extend": "SingleSourceMultipleFilesTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles(\"color\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSingleSourceMultipleFilesApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsingle-source-multiple-files\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\",\"single.source.multiple.files.stub\u003dtrue\"}) class SingleSourceMultipleFilesBootstrapTests extends SingleSourceMultipleFilesTests {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles(\"color\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSingleSourceMultipleFilesApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsingle-source-multiple-files\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\",\"single.source.multiple.files.stub\u003dtrue\"}) class SingleSourceMultipleFilesBootstrapTests extends SingleSourceMultipleFilesTests {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/single_source_multiple_files/SingleSourceMultipleFilesConfigDataTests.java",
        "name": "SingleSourceMultipleFilesConfigDataTests",
        "modifiers": "@ActiveProfiles(\"color\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSingleSourceMultipleFilesApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./single-source-multiple-files.yaml\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.single_source_multiple_files.SingleSourceMultipleFilesConfigDataTests",
        "extend": "SingleSourceMultipleFilesTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles(\"color\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSingleSourceMultipleFilesApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./single-source-multiple-files.yaml\"}) class SingleSourceMultipleFilesConfigDataTests extends SingleSourceMultipleFilesTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(server.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"spring-k8s\");\n    stubData();\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles(\"color\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSingleSourceMultipleFilesApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./single-source-multiple-files.yaml\"}) class SingleSourceMultipleFilesConfigDataTests extends SingleSourceMultipleFilesTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock();\n  @AfterAll static void teardown();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/single_source_multiple_files/SingleSourceMultipleFilesTests.java",
        "name": "SingleSourceMultipleFilesTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.single_source_multiple_files.SingleSourceMultipleFilesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57Stub for this test is here : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.SingleSourceMultipleFilesConfigurationStub}issue: https://github.com/spring-cloud/spring-cloud-kubernetes/issues/640\n */\nabstract class SingleSourceMultipleFilesTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach(){\n    WireMock.reset();\n  }\n  @AfterAll static void afterAll(){\n    WireMock.shutdownServer();\n  }\n  /** \n * \u003cpre\u003e \"fruit-color.properties\" is taken since \"spring.application.name\u003dfruit\" and \"color\" is an active profile \u003c/pre\u003e\n */\n  @Test void color(){\n    this.webClient.get().uri(\"/single_source-multiple-files/color\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"raw:green###ripe:yellow\"));\n  }\n  /** \n * \u003cpre\u003e \"fruit.properties\" is read, since it matches \"spring.application.name\" \u003c/pre\u003e\n */\n  @Test void name(){\n    this.webClient.get().uri(\"/single_source-multiple-files/name\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"banana\"));\n  }\n  /** \n * \u003cpre\u003e shape profile is not active, thus property \"fruit-shape.properties\" is skipped and as such, a null comes here. \u003c/pre\u003e\n */\n  @Test void shape(){\n    this.webClient.get().uri(\"/single_source-multiple-files/shape\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.nullValue());\n  }\n  /** \n * \u003cpre\u003e this is a non-file property in the configmap \u003c/pre\u003e\n */\n  @Test void type(){\n    this.webClient.get().uri(\"/single_source-multiple-files/type\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"yummy\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57Stub for this test is here : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.SingleSourceMultipleFilesConfigurationStub}issue: https://github.com/spring-cloud/spring-cloud-kubernetes/issues/640\n */\nabstract class SingleSourceMultipleFilesTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e \"fruit-color.properties\" is taken since \"spring.application.name\u003dfruit\" and \"color\" is an active profile \u003c/pre\u003e\n */\n  @Test void color();\n  /** \n * \u003cpre\u003e \"fruit.properties\" is read, since it matches \"spring.application.name\" \u003c/pre\u003e\n */\n  @Test void name();\n  /** \n * \u003cpre\u003e shape profile is not active, thus property \"fruit-shape.properties\" is skipped and as such, a null comes here. \u003c/pre\u003e\n */\n  @Test void shape();\n  /** \n * \u003cpre\u003e this is a non-file property in the configmap \u003c/pre\u003e\n */\n  @Test void type();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_prefix/properties/One.java",
        "name": "One",
        "modifiers": "@ConfigurationProperties(\"one\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_prefix.properties.One",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_prefix/properties/Two.java",
        "name": "Two",
        "modifiers": "@ConfigurationProperties(\"two\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_prefix.properties.Two",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_prefix/properties/Three.java",
        "name": "Three",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"configmap-three\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_prefix.properties.Three",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"configmap-three\") public class Three {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"configmap-three\") public class Three {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_prefix/properties/Four.java",
        "name": "Four",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"configmap-four\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_prefix.properties.Four",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"configmap-four\") public class Four {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"configmap-four\") public class Four {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_prefix/LabeledConfigMapWithPrefixApp.java",
        "name": "LabeledConfigMapWithPrefixApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class,Four.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_prefix.LabeledConfigMapWithPrefixApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class,Four.class}) public class LabeledConfigMapWithPrefixApp {\n  public static void main(  String[] args){\n    SpringApplication.run(LabeledConfigMapWithPrefixApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class,Four.class}) public class LabeledConfigMapWithPrefixApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_prefix/controller/LabeledConfigMapWithPrefixController.java",
        "name": "LabeledConfigMapWithPrefixController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_prefix.controller.LabeledConfigMapWithPrefixController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class LabeledConfigMapWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  private final Four four;\n  public LabeledConfigMapWithPrefixController(  One one,  Two two,  Three three,  Four four){\n    this.one\u003done;\n    this.two\u003dtwo;\n    this.three\u003dthree;\n    this.four\u003dfour;\n  }\n  @GetMapping(\"/labeled-configmap/prefix/one\") public String one(){\n    return one.getProperty();\n  }\n  @GetMapping(\"/labeled-configmap/prefix/two\") public String two(){\n    return two.getProperty();\n  }\n  @GetMapping(\"/labeled-configmap/prefix/three\") public String three(){\n    return three.getProperty();\n  }\n  @GetMapping(\"/labeled-configmap/prefix/four\") public String four(){\n    return four.getProperty();\n  }\n}\n",
        "abstract": "@RestController public class LabeledConfigMapWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  private final Four four;\n  public LabeledConfigMapWithPrefixController(  One one,  Two two,  Three three,  Four four);\n  @GetMapping(\"/labeled-configmap/prefix/one\") public String one();\n  @GetMapping(\"/labeled-configmap/prefix/two\") public String two();\n  @GetMapping(\"/labeled-configmap/prefix/three\") public String three();\n  @GetMapping(\"/labeled-configmap/prefix/four\") public String four();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_prefix/LabeledConfigMapWithPrefixTests.java",
        "name": "LabeledConfigMapWithPrefixTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_prefix.LabeledConfigMapWithPrefixTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Stub data is in {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.LabeledConfigMapWithPrefixConfigurationStub}\n * @author wind57\n */\nabstract class LabeledConfigMapWithPrefixTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach(){\n    WireMock.reset();\n  }\n  @AfterAll static void afterAll(){\n    WireMock.shutdownServer();\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.configmap.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.configmap.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne(){\n    this.webClient.get().uri(\"/labeled-configmap/prefix/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo(){\n    this.webClient.get().uri(\"/labeled-configmap/prefix/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[2].labels\u003dletter:c\u0027 (\"property\", \"three\") We find the configmap by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"configmap-three\") \u003c/pre\u003e\n */\n  @Test void testThree(){\n    this.webClient.get().uri(\"/labeled-configmap/prefix/three\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"three\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[3].labels\u003dletter:d\u0027 (\"property\", \"four\") We find the configmap by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"configmap-four\") \u003c/pre\u003e\n */\n  @Test void testFour(){\n    this.webClient.get().uri(\"/labeled-configmap/prefix/four\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"four\"));\n  }\n}\n",
        "abstract": "/** \n * Stub data is in {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.LabeledConfigMapWithPrefixConfigurationStub}\n * @author wind57\n */\nabstract class LabeledConfigMapWithPrefixTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.configmap.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.configmap.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[2].labels\u003dletter:c\u0027 (\"property\", \"three\") We find the configmap by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"configmap-three\") \u003c/pre\u003e\n */\n  @Test void testThree();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[3].labels\u003dletter:d\u0027 (\"property\", \"four\") We find the configmap by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"configmap-four\") \u003c/pre\u003e\n */\n  @Test void testFour();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_prefix/LabeledConfigMapWithPrefixConfigDataTests.java",
        "name": "LabeledConfigMapWithPrefixConfigDataTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.application.name\u003dlabeled-configmap-with-prefix\",\"labeled.config.map.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-configmap-with-prefix.yaml\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_prefix.LabeledConfigMapWithPrefixConfigDataTests",
        "extend": "LabeledConfigMapWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.application.name\u003dlabeled-configmap-with-prefix\",\"labeled.config.map.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-configmap-with-prefix.yaml\"}) class LabeledConfigMapWithPrefixConfigDataTests extends LabeledConfigMapWithPrefixTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(server.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"spring-k8s\");\n    stubData();\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.application.name\u003dlabeled-configmap-with-prefix\",\"labeled.config.map.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-configmap-with-prefix.yaml\"}) class LabeledConfigMapWithPrefixConfigDataTests extends LabeledConfigMapWithPrefixTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock();\n  @AfterAll static void teardown();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_prefix/LabeledConfigMapWithPrefixBootstrapTests.java",
        "name": "LabeledConfigMapWithPrefixBootstrapTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-configmap-with-prefix\",\"labeled.config.map.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_prefix.LabeledConfigMapWithPrefixBootstrapTests",
        "extend": "LabeledConfigMapWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-configmap-with-prefix\",\"labeled.config.map.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class LabeledConfigMapWithPrefixBootstrapTests extends LabeledConfigMapWithPrefixTests {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-configmap-with-prefix\",\"labeled.config.map.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class LabeledConfigMapWithPrefixBootstrapTests extends LabeledConfigMapWithPrefixTests {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_prefix/properties/One.java",
        "name": "One",
        "modifiers": "@ConfigurationProperties(\"one\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_prefix.properties.One",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_prefix/properties/Two.java",
        "name": "Two",
        "modifiers": "@ConfigurationProperties(\"two\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_prefix.properties.Two",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_prefix/properties/Three.java",
        "name": "Three",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"secret-three\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_prefix.properties.Three",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"secret-three\") public class Three {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"secret-three\") public class Three {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_prefix/properties/Four.java",
        "name": "Four",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"secret-four\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_prefix.properties.Four",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"secret-four\") public class Four {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"secret-four\") public class Four {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_prefix/LabeledSecretWithPrefixConfigDataTests.java",
        "name": "LabeledSecretWithPrefixConfigDataTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.application.name\u003dlabeled-secret-with-prefix\",\"labeled.secret.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-secret-with-prefix.yaml\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_prefix.LabeledSecretWithPrefixConfigDataTests",
        "extend": "LabeledSecretWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.application.name\u003dlabeled-secret-with-prefix\",\"labeled.secret.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-secret-with-prefix.yaml\"}) class LabeledSecretWithPrefixConfigDataTests extends LabeledSecretWithPrefixTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(server.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"spring-k8s\");\n    stubData();\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.application.name\u003dlabeled-secret-with-prefix\",\"labeled.secret.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-secret-with-prefix.yaml\"}) class LabeledSecretWithPrefixConfigDataTests extends LabeledSecretWithPrefixTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock();\n  @AfterAll static void teardown();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_prefix/controller/LabeledSecretWithPrefixController.java",
        "name": "LabeledSecretWithPrefixController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_prefix.controller.LabeledSecretWithPrefixController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class LabeledSecretWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  private final Four four;\n  public LabeledSecretWithPrefixController(  One one,  Two two,  Three three,  Four four){\n    this.one\u003done;\n    this.two\u003dtwo;\n    this.three\u003dthree;\n    this.four\u003dfour;\n  }\n  @GetMapping(\"/labeled-secret/prefix/one\") public String one(){\n    return one.getProperty();\n  }\n  @GetMapping(\"/labeled-secret/prefix/two\") public String two(){\n    return two.getProperty();\n  }\n  @GetMapping(\"/labeled-secret/prefix/three\") public String three(){\n    return three.getProperty();\n  }\n  @GetMapping(\"/labeled-secret/prefix/four\") public String four(){\n    return four.getProperty();\n  }\n}\n",
        "abstract": "@RestController public class LabeledSecretWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  private final Four four;\n  public LabeledSecretWithPrefixController(  One one,  Two two,  Three three,  Four four);\n  @GetMapping(\"/labeled-secret/prefix/one\") public String one();\n  @GetMapping(\"/labeled-secret/prefix/two\") public String two();\n  @GetMapping(\"/labeled-secret/prefix/three\") public String three();\n  @GetMapping(\"/labeled-secret/prefix/four\") public String four();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_prefix/LabeledSecretWithPrefixTests.java",
        "name": "LabeledSecretWithPrefixTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_prefix.LabeledSecretWithPrefixTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * The stub data for this test is in :  {@link LabeledSecretWithPrefixConfigurationStub}\n * @author wind57\n */\nabstract class LabeledSecretWithPrefixTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach(){\n    WireMock.reset();\n  }\n  @AfterAll static void afterAll(){\n    WireMock.shutdownServer();\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne(){\n    this.webClient.get().uri(\"/labeled-secret/prefix/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo(){\n    this.webClient.get().uri(\"/labeled-secret/prefix/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[2].labels\u003dletter:c\u0027 (\"property\", \"three\") We find the secret by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"secret-three\") \u003c/pre\u003e\n */\n  @Test void testThree(){\n    this.webClient.get().uri(\"/labeled-secret/prefix/three\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"three\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[3].labels\u003dletter:d\u0027 (\"property\", \"four\") We find the secret by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"secret-four\") \u003c/pre\u003e\n */\n  @Test void testFour(){\n    this.webClient.get().uri(\"/labeled-secret/prefix/four\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"four\"));\n  }\n}\n",
        "abstract": "/** \n * The stub data for this test is in :  {@link LabeledSecretWithPrefixConfigurationStub}\n * @author wind57\n */\nabstract class LabeledSecretWithPrefixTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[2].labels\u003dletter:c\u0027 (\"property\", \"three\") We find the secret by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"secret-three\") \u003c/pre\u003e\n */\n  @Test void testThree();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[3].labels\u003dletter:d\u0027 (\"property\", \"four\") We find the secret by labels, and use it\u0027s name as the prefix. As such: @ConfigurationProperties(prefix \u003d \"secret-four\") \u003c/pre\u003e\n */\n  @Test void testFour();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_prefix/LabeledSecretWithPrefixBootstrapTests.java",
        "name": "LabeledSecretWithPrefixBootstrapTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-secret-with-prefix\",\"labeled.secret.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_prefix.LabeledSecretWithPrefixBootstrapTests",
        "extend": "LabeledSecretWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-secret-with-prefix\",\"labeled.secret.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class LabeledSecretWithPrefixBootstrapTests extends LabeledSecretWithPrefixTests {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-secret-with-prefix\",\"labeled.secret.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class LabeledSecretWithPrefixBootstrapTests extends LabeledSecretWithPrefixTests {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_prefix/LabeledSecretWithPrefixApp.java",
        "name": "LabeledSecretWithPrefixApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class,Four.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_prefix.LabeledSecretWithPrefixApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class,Four.class}) public class LabeledSecretWithPrefixApp {\n  public static void main(  String[] args){\n    SpringApplication.run(LabeledSecretWithPrefixApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class,Four.class}) public class LabeledSecretWithPrefixApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_prefix/NamedSecretWithPrefixConfigDataTests.java",
        "name": "NamedSecretWithPrefixConfigDataTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.application.name\u003dnamed-secret-with-prefix\",\"named.secret.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-secret-with-prefix.yaml\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_prefix.NamedSecretWithPrefixConfigDataTests",
        "extend": "NamedSecretWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.application.name\u003dnamed-secret-with-prefix\",\"named.secret.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-secret-with-prefix.yaml\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class NamedSecretWithPrefixConfigDataTests extends NamedSecretWithPrefixTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(server.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"spring-k8s\");\n    stubData();\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.application.name\u003dnamed-secret-with-prefix\",\"named.secret.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-secret-with-prefix.yaml\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class NamedSecretWithPrefixConfigDataTests extends NamedSecretWithPrefixTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock();\n  @AfterAll static void teardown();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_prefix/properties/One.java",
        "name": "One",
        "modifiers": "@ConfigurationProperties(\"one\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_prefix.properties.One",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_prefix/properties/Two.java",
        "name": "Two",
        "modifiers": "@ConfigurationProperties(\"two\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_prefix.properties.Two",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_prefix/properties/Three.java",
        "name": "Three",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"secret-three\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_prefix.properties.Three",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"secret-three\") public class Three {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"secret-three\") public class Three {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_prefix/NamedSecretWithPrefixBootstrapTests.java",
        "name": "NamedSecretWithPrefixBootstrapTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-secret-with-prefix\",\"named.secret.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_prefix.NamedSecretWithPrefixBootstrapTests",
        "extend": "NamedSecretWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-secret-with-prefix\",\"named.secret.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class NamedSecretWithPrefixBootstrapTests extends NamedSecretWithPrefixTests {\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-secret-with-prefix\",\"named.secret.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class NamedSecretWithPrefixBootstrapTests extends NamedSecretWithPrefixTests {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_prefix/NamedSecretWithPrefixApp.java",
        "name": "NamedSecretWithPrefixApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_prefix.NamedSecretWithPrefixApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedSecretWithPrefixApp {\n  public static void main(  String[] args){\n    SpringApplication.run(NamedSecretWithPrefixApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedSecretWithPrefixApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_prefix/controller/NamedSecretWithPrefixController.java",
        "name": "NamedSecretWithPrefixController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_prefix.controller.NamedSecretWithPrefixController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class NamedSecretWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedSecretWithPrefixController(  One one,  Two two,  Three three){\n    this.one\u003done;\n    this.two\u003dtwo;\n    this.three\u003dthree;\n  }\n  @GetMapping(\"/named-secret/prefix/one\") public String one(){\n    return one.getProperty();\n  }\n  @GetMapping(\"/named-secret/prefix/two\") public String two(){\n    return two.getProperty();\n  }\n  @GetMapping(\"/named-secret/prefix/three\") public String three(){\n    return three.getProperty();\n  }\n}\n",
        "abstract": "@RestController public class NamedSecretWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedSecretWithPrefixController(  One one,  Two two,  Three three);\n  @GetMapping(\"/named-secret/prefix/one\") public String one();\n  @GetMapping(\"/named-secret/prefix/two\") public String two();\n  @GetMapping(\"/named-secret/prefix/three\") public String three();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_prefix/NamedSecretWithPrefixTests.java",
        "name": "NamedSecretWithPrefixTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_prefix.NamedSecretWithPrefixTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedSecretWithPrefixConfigurationStub}\n * @author wind57\n */\nabstract class NamedSecretWithPrefixTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach(){\n    WireMock.reset();\n  }\n  @AfterAll static void afterAll(){\n    WireMock.shutdownServer();\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne(){\n    this.webClient.get().uri(\"/named-secret/prefix/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo(){\n    this.webClient.get().uri(\"/named-secret/prefix/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[2].name\u003dconfig-map-three\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"config-map-three\") \u003c/pre\u003e\n */\n  @Test void testThree(){\n    this.webClient.get().uri(\"/named-secret/prefix/three\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"three\"));\n  }\n}\n",
        "abstract": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedSecretWithPrefixConfigurationStub}\n * @author wind57\n */\nabstract class NamedSecretWithPrefixTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[2].name\u003dconfig-map-three\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"config-map-three\") \u003c/pre\u003e\n */\n  @Test void testThree();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_profile/properties/Green.java",
        "name": "Green",
        "modifiers": "@ConfigurationProperties(\"green-purple-secret.green-purple-secret-k8s.green-secret.green-secret-k8s.green-secret-prod\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_profile.properties.Green",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"green-purple-secret.green-purple-secret-k8s.green-secret.green-secret-k8s.green-secret-prod\") public class Green {\n  private String two;\n  private String six;\n  private String seven;\n  private String eight;\n  public String getTwo(){\n    return two;\n  }\n  public void setTwo(  String two){\n    this.two\u003dtwo;\n  }\n  public String getSix(){\n    return six;\n  }\n  public void setSix(  String six){\n    this.six\u003dsix;\n  }\n  public String getSeven(){\n    return seven;\n  }\n  public void setSeven(  String seven){\n    this.seven\u003dseven;\n  }\n  public String getEight(){\n    return eight;\n  }\n  public void setEight(  String eight){\n    this.eight\u003deight;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"green-purple-secret.green-purple-secret-k8s.green-secret.green-secret-k8s.green-secret-prod\") public class Green {\n  private String two;\n  private String six;\n  private String seven;\n  private String eight;\n  public String getTwo();\n  public void setTwo(  String two);\n  public String getSix();\n  public void setSix(  String six);\n  public String getSeven();\n  public void setSeven(  String seven);\n  public String getEight();\n  public void setEight(  String eight);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_profile/properties/Blue.java",
        "name": "Blue",
        "modifiers": "@ConfigurationProperties(\"blue\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_profile.properties.Blue",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"blue\") public class Blue {\n  private String one;\n  public String getOne(){\n    return one;\n  }\n  public void setOne(  String one){\n    this.one\u003done;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"blue\") public class Blue {\n  private String one;\n  public String getOne();\n  public void setOne(  String one);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_profile/LabeledSecretWithProfileConfigDataTests.java",
        "name": "LabeledSecretWithProfileConfigDataTests",
        "modifiers": "@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithProfileApp.class,properties\u003d{\"spring.application.name\u003dlabeled-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-secret-with-profile.yaml\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_profile.LabeledSecretWithProfileConfigDataTests",
        "extend": "LabeledSecretWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithProfileApp.class,properties\u003d{\"spring.application.name\u003dlabeled-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-secret-with-profile.yaml\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"}) class LabeledSecretWithProfileConfigDataTests extends LabeledSecretWithProfileTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(server.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"spring-k8s\");\n    stubData();\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithProfileApp.class,properties\u003d{\"spring.application.name\u003dlabeled-secret-with-profile\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-secret-with-profile.yaml\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\"}) class LabeledSecretWithProfileConfigDataTests extends LabeledSecretWithProfileTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock();\n  @AfterAll static void teardown();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_profile/LabeledSecretWithProfileTests.java",
        "name": "LabeledSecretWithProfileTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_profile.LabeledSecretWithProfileTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Stubs for this test are in {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.LabeledSecretWithProfileConfigurationStub}\n * @author wind57\n */\nabstract class LabeledSecretWithProfileTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach public void afterEach(){\n    WireMock.reset();\n  }\n  @AfterAll static void afterAll(){\n    WireMock.shutdownServer();\n  }\n  /** \n * \u003cpre\u003e this one is taken from : \"blue.one\". We find \"color-secret\" by labels, and \"color-secrets-k8s\" exists, but \"includeProfileSpecificSources\u003dfalse\", thus not taken. Since \"explicitPrefix\u003dblue\", we take \"blue.one\" \u003c/pre\u003e\n */\n  @Test void testBlue(){\n    this.webClient.get().uri(\"/labeled-secret/profile/blue\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"1\"));\n  }\n  /** \n * \u003cpre\u003e this one is taken from : \"green-purple-secret.green-purple-secret-k8s.green-secret.green-secret-k8s.green-secret-prod\". We find \"green-secret\" by labels, also \"green-secrets-k8s\" and \"green-secrets-prod\" exists, because \"includeProfileSpecificSources\u003dtrue\" is set. Also \"green-purple-secret\" and \"green-purple-secret-k8s\" are found. \u003c/pre\u003e\n */\n  @Test void testGreen(){\n    this.webClient.get().uri(\"/labeled-secret/profile/green\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"2#6#7#eight-ish\"));\n  }\n}\n",
        "abstract": "/** \n * Stubs for this test are in {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.LabeledSecretWithProfileConfigurationStub}\n * @author wind57\n */\nabstract class LabeledSecretWithProfileTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach public void afterEach();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e this one is taken from : \"blue.one\". We find \"color-secret\" by labels, and \"color-secrets-k8s\" exists, but \"includeProfileSpecificSources\u003dfalse\", thus not taken. Since \"explicitPrefix\u003dblue\", we take \"blue.one\" \u003c/pre\u003e\n */\n  @Test void testBlue();\n  /** \n * \u003cpre\u003e this one is taken from : \"green-purple-secret.green-purple-secret-k8s.green-secret.green-secret-k8s.green-secret-prod\". We find \"green-secret\" by labels, also \"green-secrets-k8s\" and \"green-secrets-prod\" exists, because \"includeProfileSpecificSources\u003dtrue\" is set. Also \"green-purple-secret\" and \"green-purple-secret-k8s\" are found. \u003c/pre\u003e\n */\n  @Test void testGreen();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_profile/controller/LabeledSecretWithProfileController.java",
        "name": "LabeledSecretWithProfileController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_profile.controller.LabeledSecretWithProfileController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class LabeledSecretWithProfileController {\n  private final Blue blue;\n  private final Green green;\n  public LabeledSecretWithProfileController(  Blue blue,  Green green){\n    this.blue\u003dblue;\n    this.green\u003dgreen;\n  }\n  @GetMapping(\"/labeled-secret/profile/blue\") public String blue(){\n    return blue.getOne();\n  }\n  @GetMapping(\"/labeled-secret/profile/green\") public String green(){\n    return green.getTwo() + \"#\" + green.getSix()+ \"#\"+ green.getSeven()+ \"#\"+ green.getEight();\n  }\n}\n",
        "abstract": "@RestController public class LabeledSecretWithProfileController {\n  private final Blue blue;\n  private final Green green;\n  public LabeledSecretWithProfileController(  Blue blue,  Green green);\n  @GetMapping(\"/labeled-secret/profile/blue\") public String blue();\n  @GetMapping(\"/labeled-secret/profile/green\") public String green();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_profile/LabeledSecretWithProfileApp.java",
        "name": "LabeledSecretWithProfileApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({Blue.class,Green.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_profile.LabeledSecretWithProfileApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({Blue.class,Green.class}) public class LabeledSecretWithProfileApp {\n  public static void main(  String[] args){\n    SpringApplication.run(LabeledSecretWithProfileApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({Blue.class,Green.class}) public class LabeledSecretWithProfileApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_secret_with_profile/LabeledSecretWithProfileBootstrapTests.java",
        "name": "LabeledSecretWithProfileBootstrapTests",
        "modifiers": "@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-secret-with-profile\",\"labeled.secret.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_secret_with_profile.LabeledSecretWithProfileBootstrapTests",
        "extend": "LabeledSecretWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-secret-with-profile\",\"labeled.secret.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class LabeledSecretWithProfileBootstrapTests extends LabeledSecretWithProfileTests {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledSecretWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-secret-with-profile\",\"labeled.secret.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class LabeledSecretWithProfileBootstrapTests extends LabeledSecretWithProfileTests {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_profile/properties/One.java",
        "name": "One",
        "modifiers": "@ConfigurationProperties(\"one\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_profile.properties.One",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_profile/properties/Two.java",
        "name": "Two",
        "modifiers": "@ConfigurationProperties(\"two\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_profile.properties.Two",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_profile/properties/Three.java",
        "name": "Three",
        "modifiers": "@ConfigurationProperties(\"configmap-three\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_profile.properties.Three",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"configmap-three\") public class Three {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"configmap-three\") public class Three {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_profile/controller/NamedConfigMapWithProfileController.java",
        "name": "NamedConfigMapWithProfileController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_profile.controller.NamedConfigMapWithProfileController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class NamedConfigMapWithProfileController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedConfigMapWithProfileController(  One one,  Two two,  Three three){\n    this.one\u003done;\n    this.two\u003dtwo;\n    this.three\u003dthree;\n  }\n  @GetMapping(\"/named-configmap/profile/one\") public String one(){\n    return one.getProperty();\n  }\n  @GetMapping(\"/named-configmap/profile/two\") public String two(){\n    return two.getProperty();\n  }\n  @GetMapping(\"/named-configmap/profile/three\") public String three(){\n    return three.getProperty();\n  }\n}\n",
        "abstract": "@RestController public class NamedConfigMapWithProfileController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedConfigMapWithProfileController(  One one,  Two two,  Three three);\n  @GetMapping(\"/named-configmap/profile/one\") public String one();\n  @GetMapping(\"/named-configmap/profile/two\") public String two();\n  @GetMapping(\"/named-configmap/profile/three\") public String three();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_profile/NamedConfigMapWithProfileTests.java",
        "name": "NamedConfigMapWithProfileTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_profile.NamedConfigMapWithProfileTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedConfigMapWithProfileConfigurationStub}\n * @author wind57\n */\nabstract class NamedConfigMapWithProfileTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach public void afterEach(){\n    WireMock.reset();\n  }\n  @AfterAll static void afterAll(){\n    WireMock.shutdownServer();\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[0].useNameAsPrefix\u003dfalse\u0027 \u0027spring.cloud.kubernetes.config.sources[0].includeProfileSpecificSources\u003dtrue\u0027 (\"one.property\", \"one-from-k8s\") As such: @ConfigurationProperties(\"one\"), value is overridden by the one that we read from the profile based source. \u003c/pre\u003e\n */\n  @Test void testOne(){\n    this.webClient.get().uri(\"/named-configmap/profile/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one-from-k8s\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[1].explicitPrefix\u003dtwo\u0027 \u0027spring.cloud.kubernetes.config.sources[1].includeProfileSpecificSources\u003dfalse\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\"). Even if there is a profile based source, we disabled reading it. \u003c/pre\u003e\n */\n  @Test void testTwo(){\n    this.webClient.get().uri(\"/named-configmap/profile/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[2].name\u003dconfigmap-three\u0027 \u0027spring.cloud.kubernetes.config.sources[1].includeProfileSpecificSources\u003dtrue\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"config-three\"), value is overridden by the one that we read from the profile based source \u003c/pre\u003e\n */\n  @Test void testThree(){\n    this.webClient.get().uri(\"/named-configmap/profile/three\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"three-from-k8s\"));\n  }\n}\n",
        "abstract": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedConfigMapWithProfileConfigurationStub}\n * @author wind57\n */\nabstract class NamedConfigMapWithProfileTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach public void afterEach();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[0].useNameAsPrefix\u003dfalse\u0027 \u0027spring.cloud.kubernetes.config.sources[0].includeProfileSpecificSources\u003dtrue\u0027 (\"one.property\", \"one-from-k8s\") As such: @ConfigurationProperties(\"one\"), value is overridden by the one that we read from the profile based source. \u003c/pre\u003e\n */\n  @Test void testOne();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[1].explicitPrefix\u003dtwo\u0027 \u0027spring.cloud.kubernetes.config.sources[1].includeProfileSpecificSources\u003dfalse\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\"). Even if there is a profile based source, we disabled reading it. \u003c/pre\u003e\n */\n  @Test void testTwo();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[2].name\u003dconfigmap-three\u0027 \u0027spring.cloud.kubernetes.config.sources[1].includeProfileSpecificSources\u003dtrue\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"config-three\"), value is overridden by the one that we read from the profile based source \u003c/pre\u003e\n */\n  @Test void testThree();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_profile/NamedConfigMapWithProfileApp.java",
        "name": "NamedConfigMapWithProfileApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_profile.NamedConfigMapWithProfileApp",
        "extend": "",
        "implements": "",
        "raw": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedConfigMapWithProfileConfigurationStub}\n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) class NamedConfigMapWithProfileApp {\n  public static void main(  String[] args){\n    SpringApplication.run(NamedConfigMapWithProfileApp.class,args);\n  }\n}\n",
        "abstract": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedConfigMapWithProfileConfigurationStub}\n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) class NamedConfigMapWithProfileApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_profile/NamedConfigMapWithProfileBootstrapTests.java",
        "name": "NamedConfigMapWithProfileBootstrapTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-configmap-with-profile\",\"named.config.map.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) @ActiveProfiles(\"k8s\")",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_profile.NamedConfigMapWithProfileBootstrapTests",
        "extend": "NamedConfigMapWithProfileTests",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-configmap-with-profile\",\"named.config.map.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) @ActiveProfiles(\"k8s\") class NamedConfigMapWithProfileBootstrapTests extends NamedConfigMapWithProfileTests {\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-configmap-with-profile\",\"named.config.map.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) @ActiveProfiles(\"k8s\") class NamedConfigMapWithProfileBootstrapTests extends NamedConfigMapWithProfileTests {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_profile/NamedConfigMapWithProfileConfigDataTests.java",
        "name": "NamedConfigMapWithProfileConfigDataTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithProfileApp.class,properties\u003d{\"spring.application.name\u003dnamed-config-map-with-profile\",\"include.profile.specific.sources\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-configmap-with-profile.yaml\"}) @ActiveProfiles(\"k8s\")",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_profile.NamedConfigMapWithProfileConfigDataTests",
        "extend": "NamedConfigMapWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithProfileApp.class,properties\u003d{\"spring.application.name\u003dnamed-config-map-with-profile\",\"include.profile.specific.sources\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-configmap-with-profile.yaml\"}) @ActiveProfiles(\"k8s\") class NamedConfigMapWithProfileConfigDataTests extends NamedConfigMapWithProfileTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll public static void wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(server.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"spring-k8s\");\n    stubData();\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithProfileApp.class,properties\u003d{\"spring.application.name\u003dnamed-config-map-with-profile\",\"include.profile.specific.sources\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-configmap-with-profile.yaml\"}) @ActiveProfiles(\"k8s\") class NamedConfigMapWithProfileConfigDataTests extends NamedConfigMapWithProfileTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll public static void wireMock();\n  @AfterAll static void teardown();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_prefix/NamedConfigMapWithPrefixTests.java",
        "name": "NamedConfigMapWithPrefixTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_prefix.NamedConfigMapWithPrefixTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedConfigMapWithPrefixConfigurationStub}\n * @author wind57\n */\nabstract class NamedConfigMapWithPrefixTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach public void afterEach(){\n    WireMock.reset();\n  }\n  @AfterAll static void afterAll(){\n    WireMock.shutdownServer();\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne(){\n    this.webClient.get().uri(\"/named-configmap/prefix/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo(){\n    this.webClient.get().uri(\"/named-configmap/prefix/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[2].name\u003dconfig-map-three\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"config-map-three\") \u003c/pre\u003e\n */\n  @Test void testThree(){\n    this.webClient.get().uri(\"/named-configmap/prefix/three\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"three\"));\n  }\n}\n",
        "abstract": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedConfigMapWithPrefixConfigurationStub}\n * @author wind57\n */\nabstract class NamedConfigMapWithPrefixTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach public void afterEach();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[0].useNameAsPrefix\u003dfalse\u0027 (\"one.property\", \"one\") As such: @ConfigurationProperties(\"one\") \u003c/pre\u003e\n */\n  @Test void testOne();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[1].explicitPrefix\u003dtwo\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\") \u003c/pre\u003e\n */\n  @Test void testTwo();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.config.sources[2].name\u003dconfig-map-three\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"config-map-three\") \u003c/pre\u003e\n */\n  @Test void testThree();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_prefix/properties/One.java",
        "name": "One",
        "modifiers": "@ConfigurationProperties(\"one\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_prefix.properties.One",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_prefix/properties/Two.java",
        "name": "Two",
        "modifiers": "@ConfigurationProperties(\"two\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_prefix.properties.Two",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_prefix/properties/Three.java",
        "name": "Three",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"config-map-three\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_prefix.properties.Three",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"config-map-three\") public class Three {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"config-map-three\") public class Three {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_prefix/NamedConfigMapWithPrefixConfigDataTests.java",
        "name": "NamedConfigMapWithPrefixConfigDataTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.application.name\u003dnamed-configmap-with-prefix\",\"named.config.map.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-configmap-with-prefix.yaml\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_prefix.NamedConfigMapWithPrefixConfigDataTests",
        "extend": "NamedConfigMapWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.application.name\u003dnamed-configmap-with-prefix\",\"named.config.map.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-configmap-with-prefix.yaml\"}) class NamedConfigMapWithPrefixConfigDataTests extends NamedConfigMapWithPrefixTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(server.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"spring-k8s\");\n    stubData();\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.application.name\u003dnamed-configmap-with-prefix\",\"named.config.map.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-configmap-with-prefix.yaml\"}) class NamedConfigMapWithPrefixConfigDataTests extends NamedConfigMapWithPrefixTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock();\n  @AfterAll static void teardown();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_prefix/NamedConfigMapWithPrefixApp.java",
        "name": "NamedConfigMapWithPrefixApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_prefix.NamedConfigMapWithPrefixApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedConfigMapWithPrefixApp {\n  public static void main(  String[] args){\n    SpringApplication.run(NamedConfigMapWithPrefixApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedConfigMapWithPrefixApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_prefix/controller/NamedConfigWithPrefixController.java",
        "name": "NamedConfigWithPrefixController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_prefix.controller.NamedConfigWithPrefixController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class NamedConfigWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedConfigWithPrefixController(  One one,  Two two,  Three three){\n    this.one\u003done;\n    this.two\u003dtwo;\n    this.three\u003dthree;\n  }\n  @GetMapping(\"/named-configmap/prefix/one\") public String one(){\n    return one.getProperty();\n  }\n  @GetMapping(\"/named-configmap/prefix/two\") public String two(){\n    return two.getProperty();\n  }\n  @GetMapping(\"/named-configmap/prefix/three\") public String three(){\n    return three.getProperty();\n  }\n}\n",
        "abstract": "@RestController public class NamedConfigWithPrefixController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedConfigWithPrefixController(  One one,  Two two,  Three three);\n  @GetMapping(\"/named-configmap/prefix/one\") public String one();\n  @GetMapping(\"/named-configmap/prefix/two\") public String two();\n  @GetMapping(\"/named-configmap/prefix/three\") public String three();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_config_map_with_prefix/NamedConfigMapWithPrefixBootstrapTests.java",
        "name": "NamedConfigMapWithPrefixBootstrapTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-configmap-with-prefix\",\"named.config.map.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_config_map_with_prefix.NamedConfigMapWithPrefixBootstrapTests",
        "extend": "NamedConfigMapWithPrefixTests",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-configmap-with-prefix\",\"named.config.map.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class NamedConfigMapWithPrefixBootstrapTests extends NamedConfigMapWithPrefixTests {\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedConfigMapWithPrefixApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-configmap-with-prefix\",\"named.config.map.with.prefix.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class NamedConfigMapWithPrefixBootstrapTests extends NamedConfigMapWithPrefixTests {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_profile/properties/One.java",
        "name": "One",
        "modifiers": "@ConfigurationProperties(\"one\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_profile.properties.One",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"one\") public class One {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_profile/properties/Two.java",
        "name": "Two",
        "modifiers": "@ConfigurationProperties(\"two\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_profile.properties.Two",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"two\") public class Two {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_profile/properties/Three.java",
        "name": "Three",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"secret-three\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_profile.properties.Three",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(prefix\u003d\"secret-three\") public class Three {\n  private String property;\n  public String getProperty(){\n    return property;\n  }\n  public void setProperty(  String property){\n    this.property\u003dproperty;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(prefix\u003d\"secret-three\") public class Three {\n  private String property;\n  public String getProperty();\n  public void setProperty(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_profile/NamedSecretWithProfileTests.java",
        "name": "NamedSecretWithProfileTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_profile.NamedSecretWithProfileTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedSecretWithProfileConfigurationStub}\n * @author wind57\n */\nabstract class NamedSecretWithProfileTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach(){\n    WireMock.reset();\n  }\n  @AfterAll static void afterAll(){\n    WireMock.shutdownServer();\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].useNameAsPrefix\u003dfalse\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].includeProfileSpecificSources\u003dtrue\u0027 (\"one.property\", \"one-from-k8s\") As such: @ConfigurationProperties(\"one\"), value is overridden by the one that we read from the profile based source. \u003c/pre\u003e\n */\n  @Test void testOne(){\n    this.webClient.get().uri(\"/named-secret/profile/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one-from-k8s\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].explicitPrefix\u003dtwo\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].includeProfileSpecificSources\u003dfalse\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\"). Even if there is a profile based source, we disabled reading it. \u003c/pre\u003e\n */\n  @Test void testTwo(){\n    this.webClient.get().uri(\"/named-secret/profile/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n  }\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[2].name\u003dsecret-three\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].includeProfileSpecificSources\u003dtrue\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"secret-three\"), value is overridden by the one that we read from * \t the profile based source \u003c/pre\u003e\n */\n  @Test void testThree(){\n    this.webClient.get().uri(\"/named-secret/profile/three\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"three-from-k8s\"));\n  }\n}\n",
        "abstract": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.NamedSecretWithProfileConfigurationStub}\n * @author wind57\n */\nabstract class NamedSecretWithProfileTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].useNameAsPrefix\u003dfalse\u0027 \u0027spring.cloud.kubernetes.secrets.sources[0].includeProfileSpecificSources\u003dtrue\u0027 (\"one.property\", \"one-from-k8s\") As such: @ConfigurationProperties(\"one\"), value is overridden by the one that we read from the profile based source. \u003c/pre\u003e\n */\n  @Test void testOne();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].explicitPrefix\u003dtwo\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].includeProfileSpecificSources\u003dfalse\u0027 (\"property\", \"two\") As such: @ConfigurationProperties(\"two\"). Even if there is a profile based source, we disabled reading it. \u003c/pre\u003e\n */\n  @Test void testTwo();\n  /** \n * \u003cpre\u003e \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u003dtrue\u0027 \u0027spring.cloud.kubernetes.secrets.sources[2].name\u003dsecret-three\u0027 \u0027spring.cloud.kubernetes.secrets.sources[1].includeProfileSpecificSources\u003dtrue\u0027 (\"property\", \"three\") As such: @ConfigurationProperties(prefix \u003d \"secret-three\"), value is overridden by the one that we read from * \t the profile based source \u003c/pre\u003e\n */\n  @Test void testThree();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_profile/NamedSecretWithProfileBootstrapTests.java",
        "name": "NamedSecretWithProfileBootstrapTests",
        "modifiers": "@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithLabelApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-secret-with-profile\",\"named.secret.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_profile.NamedSecretWithProfileBootstrapTests",
        "extend": "NamedSecretWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithLabelApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-secret-with-profile\",\"named.secret.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class NamedSecretWithProfileBootstrapTests extends NamedSecretWithProfileTests {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithLabelApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dnamed-secret-with-profile\",\"named.secret.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class NamedSecretWithProfileBootstrapTests extends NamedSecretWithProfileTests {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_profile/NamedSecretWithLabelApp.java",
        "name": "NamedSecretWithLabelApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_profile.NamedSecretWithLabelApp",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedSecretWithLabelApp {\n  public static void main(  String[] args){\n    SpringApplication.run(NamedSecretWithLabelApp.class,args);\n  }\n}\n",
        "abstract": "@SpringBootApplication @EnableConfigurationProperties({One.class,Two.class,Three.class}) public class NamedSecretWithLabelApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_profile/controller/NamedSecretWithProfileController.java",
        "name": "NamedSecretWithProfileController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_profile.controller.NamedSecretWithProfileController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class NamedSecretWithProfileController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedSecretWithProfileController(  One one,  Two two,  Three three){\n    this.one\u003done;\n    this.two\u003dtwo;\n    this.three\u003dthree;\n  }\n  @GetMapping(\"/named-secret/profile/one\") public String one(){\n    return one.getProperty();\n  }\n  @GetMapping(\"/named-secret/profile/two\") public String two(){\n    return two.getProperty();\n  }\n  @GetMapping(\"/named-secret/profile/three\") public String three(){\n    return three.getProperty();\n  }\n}\n",
        "abstract": "@RestController public class NamedSecretWithProfileController {\n  private final One one;\n  private final Two two;\n  private final Three three;\n  public NamedSecretWithProfileController(  One one,  Two two,  Three three);\n  @GetMapping(\"/named-secret/profile/one\") public String one();\n  @GetMapping(\"/named-secret/profile/two\") public String two();\n  @GetMapping(\"/named-secret/profile/three\") public String three();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/named_secret_with_profile/NamedSecretWithProfileConfigDataTests.java",
        "name": "NamedSecretWithProfileConfigDataTests",
        "modifiers": "@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithLabelApp.class,properties\u003d{\"spring.cloud.application.name\u003dnamed-secret-with-profile\",\"named.secret.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-secret-with-profile.yaml\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.named_secret_with_profile.NamedSecretWithProfileConfigDataTests",
        "extend": "NamedSecretWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithLabelApp.class,properties\u003d{\"spring.cloud.application.name\u003dnamed-secret-with-profile\",\"named.secret.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-secret-with-profile.yaml\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class NamedSecretWithProfileConfigDataTests extends NamedSecretWithProfileTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(server.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"spring-k8s\");\n    stubData();\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles(\"k8s\") @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dNamedSecretWithLabelApp.class,properties\u003d{\"spring.cloud.application.name\u003dnamed-secret-with-profile\",\"named.secret.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./named-secret-with-profile.yaml\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class NamedSecretWithProfileConfigDataTests extends NamedSecretWithProfileTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock();\n  @AfterAll static void teardown();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/sources_order/properties/Properties.java",
        "name": "Properties",
        "modifiers": "@ConfigurationProperties(\"my\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.sources_order.properties.Properties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"my\") public class Properties {\n  private String key;\n  private String one;\n  private String two;\n  public String getKey(){\n    return key;\n  }\n  public void setKey(  String key){\n    this.key\u003dkey;\n  }\n  public String getOne(){\n    return one;\n  }\n  public void setOne(  String one){\n    this.one\u003done;\n  }\n  public String getTwo(){\n    return two;\n  }\n  public void setTwo(  String two){\n    this.two\u003dtwo;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"my\") public class Properties {\n  private String key;\n  private String one;\n  private String two;\n  public String getKey();\n  public void setKey(  String key);\n  public String getOne();\n  public void setOne(  String one);\n  public String getTwo();\n  public void setTwo(  String two);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/sources_order/SourcesOrderApp.java",
        "name": "SourcesOrderApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties(Properties.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.sources_order.SourcesOrderApp",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties(Properties.class) public class SourcesOrderApp {\n  public static void main(  String[] args){\n    SpringApplication.run(SourcesOrderApp.class,args);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties(Properties.class) public class SourcesOrderApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/sources_order/SourcesOrderTests.java",
        "name": "SourcesOrderTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.sources_order.SourcesOrderTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.SourcesOrderConfigurationStub}\n * @author wind57\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient abstract class SourcesOrderTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach(){\n    WireMock.reset();\n  }\n  @AfterAll static void afterAll(){\n    WireMock.shutdownServer();\n  }\n  /** \n * \u003cpre\u003e 1. There is one secret deployed: my-secret. It has two properties: {my.one\u003done, my.key\u003dfrom-secret} 2. There is one configmap deployed: my-configmap. It has two properties: {my.two\u003dtwo, my.key\u003dfrom-configmap} We invoke three endpoints: /one, /two, /key. The first two prove that both the secret and configmap have been read, the last one proves that config maps have a higher precedence. \u003c/pre\u003e\n */\n  @Test void test(){\n    this.webClient.get().uri(\"/one\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"one\"));\n    this.webClient.get().uri(\"/two\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"two\"));\n    this.webClient.get().uri(\"/key\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"from-configmap\"));\n  }\n}\n",
        "abstract": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.SourcesOrderConfigurationStub}\n * @author wind57\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient abstract class SourcesOrderTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e 1. There is one secret deployed: my-secret. It has two properties: {my.one\u003done, my.key\u003dfrom-secret} 2. There is one configmap deployed: my-configmap. It has two properties: {my.two\u003dtwo, my.key\u003dfrom-configmap} We invoke three endpoints: /one, /two, /key. The first two prove that both the secret and configmap have been read, the last one proves that config maps have a higher precedence. \u003c/pre\u003e\n */\n  @Test void test();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/sources_order/controller/SourcesOrderController.java",
        "name": "SourcesOrderController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.sources_order.controller.SourcesOrderController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController public class SourcesOrderController {\n  private final Properties properties;\n  SourcesOrderController(  Properties properties){\n    this.properties\u003dproperties;\n  }\n  @GetMapping(\"/key\") String key(){\n    return properties.getKey();\n  }\n  @GetMapping(\"/one\") String one(){\n    return properties.getOne();\n  }\n  @GetMapping(\"/two\") String two(){\n    return properties.getTwo();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController public class SourcesOrderController {\n  private final Properties properties;\n  SourcesOrderController(  Properties properties);\n  @GetMapping(\"/key\") String key();\n  @GetMapping(\"/one\") String one();\n  @GetMapping(\"/two\") String two();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/sources_order/ConfigDataRetryableSourcesOrderTests.java",
        "name": "ConfigDataRetryableSourcesOrderTests",
        "modifiers": "@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dretryable-sources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.sources_order.ConfigDataRetryableSourcesOrderTests",
        "extend": "SourcesOrderTests",
        "implements": "",
        "raw": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.SourcesOrderConfigurationStub}\n * @author wind57\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dretryable-sources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient class ConfigDataRetryableSourcesOrderTests extends SourcesOrderTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(server.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"spring-k8s\");\n    stubConfigMapData();\n    stubSecretsData();\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n}\n",
        "abstract": "/** \n * The stub data for this test is in : {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.SourcesOrderConfigurationStub}\n * @author wind57\n */\n@ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dretryable-sources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) @AutoConfigureWebTestClient class ConfigDataRetryableSourcesOrderTests extends SourcesOrderTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock();\n  @AfterAll static void teardown();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/sources_order/BootstrapRetryableSourcesOrderTests.java",
        "name": "BootstrapRetryableSourcesOrderTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dretryable-sources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.sources_order.BootstrapRetryableSourcesOrderTests",
        "extend": "SourcesOrderTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dretryable-sources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapRetryableSourcesOrderTests extends SourcesOrderTests {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dretryable-sources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapRetryableSourcesOrderTests extends SourcesOrderTests {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/sources_order/ConfigDataSourcesOrderTests.java",
        "name": "ConfigDataSourcesOrderTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.application.name\u003dsources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./sources-order.yaml\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.sources_order.ConfigDataSourcesOrderTests",
        "extend": "SourcesOrderTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.application.name\u003dsources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./sources-order.yaml\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class ConfigDataSourcesOrderTests extends SourcesOrderTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(server.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"spring-k8s\");\n    stubConfigMapData();\n    stubSecretsData();\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.application.name\u003dsources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./sources-order.yaml\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class ConfigDataSourcesOrderTests extends SourcesOrderTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock();\n  @AfterAll static void teardown();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/sources_order/BootstrapSourcesOrderTests.java",
        "name": "BootstrapSourcesOrderTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.sources_order.BootstrapSourcesOrderTests",
        "extend": "SourcesOrderTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapSourcesOrderTests extends SourcesOrderTests {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSourcesOrderApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dsources-order\",\"sources.order.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\"}) class BootstrapSourcesOrderTests extends SourcesOrderTests {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_profile/properties/Green.java",
        "name": "Green",
        "modifiers": "@ConfigurationProperties(\"green-configmap.green-configmap-k8s.green-configmap-prod.green-purple-configmap.green-purple-configmap-k8s\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_profile.properties.Green",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"green-configmap.green-configmap-k8s.green-configmap-prod.green-purple-configmap.green-purple-configmap-k8s\") public class Green {\n  private String two;\n  private String six;\n  private String seven;\n  private String eight;\n  public String getTwo(){\n    return two;\n  }\n  public void setTwo(  String two){\n    this.two\u003dtwo;\n  }\n  public String getSix(){\n    return six;\n  }\n  public void setSix(  String six){\n    this.six\u003dsix;\n  }\n  public String getSeven(){\n    return seven;\n  }\n  public void setSeven(  String seven){\n    this.seven\u003dseven;\n  }\n  public String getEight(){\n    return eight;\n  }\n  public void setEight(  String eight){\n    this.eight\u003deight;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"green-configmap.green-configmap-k8s.green-configmap-prod.green-purple-configmap.green-purple-configmap-k8s\") public class Green {\n  private String two;\n  private String six;\n  private String seven;\n  private String eight;\n  public String getTwo();\n  public void setTwo(  String two);\n  public String getSix();\n  public void setSix(  String six);\n  public String getSeven();\n  public void setSeven(  String seven);\n  public String getEight();\n  public void setEight(  String eight);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_profile/properties/Blue.java",
        "name": "Blue",
        "modifiers": "@ConfigurationProperties(\"blue\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_profile.properties.Blue",
        "extend": "",
        "implements": "",
        "raw": "@ConfigurationProperties(\"blue\") public class Blue {\n  private String one;\n  public String getOne(){\n    return one;\n  }\n  public void setOne(  String one){\n    this.one\u003done;\n  }\n}\n",
        "abstract": "@ConfigurationProperties(\"blue\") public class Blue {\n  private String one;\n  public String getOne();\n  public void setOne(  String one);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_profile/LabeledConfigMapWithProfileBootstrapTests.java",
        "name": "LabeledConfigMapWithProfileBootstrapTests",
        "modifiers": "@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-configmap-with-profile\",\"labeled.config.map.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_profile.LabeledConfigMapWithProfileBootstrapTests",
        "extend": "LabeledConfigMapWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-configmap-with-profile\",\"labeled.config.map.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class LabeledConfigMapWithProfileBootstrapTests extends LabeledConfigMapWithProfileTests {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.bootstrap.name\u003dlabeled-configmap-with-profile\",\"labeled.config.map.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dspring-k8s\"}) class LabeledConfigMapWithProfileBootstrapTests extends LabeledConfigMapWithProfileTests {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_profile/LabeledConfigMapWithProfileConfigDataTests.java",
        "name": "LabeledConfigMapWithProfileConfigDataTests",
        "modifiers": "@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.application.name\u003dlabeled-configmap-with-profile\",\"labeled.config.map.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-configmap-with-profile.yaml\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_profile.LabeledConfigMapWithProfileConfigDataTests",
        "extend": "LabeledConfigMapWithProfileTests",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.application.name\u003dlabeled-configmap-with-profile\",\"labeled.config.map.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-configmap-with-profile.yaml\"}) class LabeledConfigMapWithProfileConfigDataTests extends LabeledConfigMapWithProfileTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(server.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"spring-k8s\");\n    stubData();\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ActiveProfiles({\"k8s\",\"prod\"}) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dLabeledConfigMapWithProfileApp.class,properties\u003d{\"spring.cloud.application.name\u003dlabeled-configmap-with-profile\",\"labeled.config.map.with.profile.stub\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./labeled-configmap-with-profile.yaml\"}) class LabeledConfigMapWithProfileConfigDataTests extends LabeledConfigMapWithProfileTests {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock();\n  @AfterAll static void teardown();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_profile/controller/LabeledConfigMapWithProfileController.java",
        "name": "LabeledConfigMapWithProfileController",
        "modifiers": "@RestController public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_profile.controller.LabeledConfigMapWithProfileController",
        "extend": "",
        "implements": "",
        "raw": "@RestController public class LabeledConfigMapWithProfileController {\n  private final Blue blue;\n  private final Green green;\n  public LabeledConfigMapWithProfileController(  Blue blue,  Green green){\n    this.blue\u003dblue;\n    this.green\u003dgreen;\n  }\n  @GetMapping(\"/labeled-configmap/profile/blue\") public String blue(){\n    return blue.getOne();\n  }\n  @GetMapping(\"/labeled-configmap/profile/green\") public String green(){\n    return green.getTwo() + \"#\" + green.getSix()+ \"#\"+ green.getSeven()+ \"#\"+ green.getEight();\n  }\n}\n",
        "abstract": "@RestController public class LabeledConfigMapWithProfileController {\n  private final Blue blue;\n  private final Green green;\n  public LabeledConfigMapWithProfileController(  Blue blue,  Green green);\n  @GetMapping(\"/labeled-configmap/profile/blue\") public String blue();\n  @GetMapping(\"/labeled-configmap/profile/green\") public String green();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_profile/LabeledConfigMapWithProfileApp.java",
        "name": "LabeledConfigMapWithProfileApp",
        "modifiers": "@SpringBootApplication @EnableConfigurationProperties({Blue.class,Green.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_profile.LabeledConfigMapWithProfileApp",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties({Blue.class,Green.class}) public class LabeledConfigMapWithProfileApp {\n  public static void main(  String[] args){\n    SpringApplication.run(LabeledConfigMapWithProfileApp.class,args);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootApplication @EnableConfigurationProperties({Blue.class,Green.class}) public class LabeledConfigMapWithProfileApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/applications/labeled_config_map_with_profile/LabeledConfigMapWithProfileTests.java",
        "name": "LabeledConfigMapWithProfileTests",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.applications.labeled_config_map_with_profile.LabeledConfigMapWithProfileTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Stub data is in {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.LabeledConfigMapWithProfileConfigurationStub}\n * @author wind57\n */\nabstract class LabeledConfigMapWithProfileTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach(){\n    WireMock.reset();\n  }\n  @AfterAll static void afterAll(){\n    WireMock.shutdownServer();\n  }\n  /** \n * \u003cpre\u003e this one is taken from : \"blue.one\". We find \"color-configmap\" by labels, and \"color-configmap-k8s\" exists, but \"includeProfileSpecificSources\u003dfalse\", thus not taken. Since \"explicitPrefix\u003dblue\", we take \"blue.one\" \u003c/pre\u003e\n */\n  @Test void testBlue(){\n    this.webClient.get().uri(\"/labeled-configmap/profile/blue\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"1\"));\n  }\n  /** \n * \u003cpre\u003e this one is taken from : \"\"green-configmap.green-configmap-k8s.green-configmap-prod.green-purple-configmap.green-purple-configmap-k8s\"\". We find \"green-configmap\" by labels, also \"green-configmap-k8s\", \"green-configmap-prod\" exists, because \"includeProfileSpecificSources\u003dtrue\" is set. Also \"green-purple-configmap\" and \"green-purple-configmap-k8s\" are found. \u003c/pre\u003e\n */\n  @Test void testGreen(){\n    this.webClient.get().uri(\"/labeled-configmap/profile/green\").exchange().expectStatus().isOk().expectBody(String.class).value(Matchers.equalTo(\"2#6#7#eight-ish\"));\n  }\n}\n",
        "abstract": "/** \n * Stub data is in {@link org.springframework.cloud.kubernetes.client.config.bootstrap.stubs.LabeledConfigMapWithProfileConfigurationStub}\n * @author wind57\n */\nabstract class LabeledConfigMapWithProfileTests {\n  @Autowired private WebTestClient webClient;\n  @AfterEach void afterEach();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e this one is taken from : \"blue.one\". We find \"color-configmap\" by labels, and \"color-configmap-k8s\" exists, but \"includeProfileSpecificSources\u003dfalse\", thus not taken. Since \"explicitPrefix\u003dblue\", we take \"blue.one\" \u003c/pre\u003e\n */\n  @Test void testBlue();\n  /** \n * \u003cpre\u003e this one is taken from : \"\"green-configmap.green-configmap-k8s.green-configmap-prod.green-purple-configmap.green-purple-configmap-k8s\"\". We find \"green-configmap\" by labels, also \"green-configmap-k8s\", \"green-configmap-prod\" exists, because \"includeProfileSpecificSources\u003dtrue\" is set. Also \"green-purple-configmap\" and \"green-purple-configmap-k8s\" are found. \u003c/pre\u003e\n */\n  @Test void testGreen();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/LabeledSecretContextToSourceDataProviderTests.java",
        "name": "LabeledSecretContextToSourceDataProviderTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.LabeledSecretContextToSourceDataProviderTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class LabeledSecretContextToSourceDataProviderTests {\n  private static final Map\u003cString,String\u003e LABELS\u003dnew LinkedHashMap\u003c\u003e();\n  private static final Map\u003cString,String\u003e RED_LABEL\u003dMap.of(\"color\",\"red\");\n  private static final String NAMESPACE\u003d\"default\";\nstatic {\n    LABELS.put(\"label2\",\"value2\");\n    LABELS.put(\"label1\",\"value1\");\n  }\n  @BeforeAll static void setup(){\n    WireMockServer wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    ApiClient client\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    client.setDebugging(true);\n    Configuration.setDefaultApiClient(client);\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n    new KubernetesClientSecretsCache().discardAll();\n  }\n  /** \n * we have a single secret deployed. it does not match our query.\n */\n  @Test void noMatch(){\n    V1Secret red\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Collections.singletonMap(\"color\",\"red\")).withNamespace(NAMESPACE).withName(\"red-secret\").build()).addToData(\"color\",Base64.getEncoder().encode(\"really-red\".getBytes())).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(red);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Collections.singletonMap(\"color\",\"blue\"),false,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.color.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Collections.emptyMap());\n  }\n  /** \n * we have a single secret deployed. it has two labels and these match against our queries.\n */\n  @Test void singleSecretMatchAgainstLabels(){\n    V1Secret red\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(LABELS).withNamespace(NAMESPACE).withName(\"test-secret\").build()).addToData(\"color\",\"really-red\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(red);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew LabeledSecretNormalizedSource(NAMESPACE,LABELS,false,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.test-secret.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Map.of(\"color\",\"really-red\"));\n  }\n  /** \n * we have two secrets deployed. both of them have labels that match (color\u003dred).\n */\n  @Test void twoSecretsMatchAgainstLabels(){\n    V1Secret one\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(RED_LABEL).withNamespace(NAMESPACE).withName(\"color-one\").build()).addToData(\"colorOne\",\"really-red-one\".getBytes()).build();\n    V1Secret two\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(RED_LABEL).withNamespace(NAMESPACE).withName(\"color-two\").build()).addToData(\"colorTwo\",\"really-red-two\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(one).addItemsItem(two);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew LabeledSecretNormalizedSource(NAMESPACE,RED_LABEL,false,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.color-one.color-two.default\");\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"colorOne\"),\"really-red-one\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"colorTwo\"),\"really-red-two\");\n  }\n  @Test void namespaceMatch(){\n    V1Secret one\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(LABELS).withNamespace(NAMESPACE).withName(\"test-secret\").build()).addToData(\"color\",\"really-red\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(one);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew LabeledSecretNormalizedSource(NAMESPACE + \"nope\",LABELS,false,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.test-secret.default\");\n    Assertions.assertEquals(sourceData.sourceData(),Map.of(\"color\",\"really-red\"));\n  }\n  /** \n * one secret with name : \"blue-secret\" and labels \"color\u003dblue\" is deployed. we search it with the same labels, find it, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided an explicit prefix).\n */\n  @Test void testWithPrefix(){\n    V1Secret one\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"blue\")).withNamespace(NAMESPACE).withName(\"blue-secret\").build()).addToData(\"what-color\",\"blue-color\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(one);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    ConfigUtils.Prefix prefix\u003dConfigUtils.findPrefix(\"me\",false,false,null);\n    NormalizedSource source\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Map.of(\"color\",\"blue\"),false,prefix,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(\"secret.blue-secret.default\",sourceData.sourceName());\n    Assertions.assertEquals(Map.of(\"me.what-color\",\"blue-color\"),sourceData.sourceData());\n  }\n  /** \n * two secrets are deployed (name:blue-secret, name:another-blue-secret) and labels \"color\u003dblue\" (on both). we search with the same labels, find them, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided a delayed prefix). Also notice that the prefix is made up from both secret names.\n */\n  @Test void testTwoSecretsWithPrefix(){\n    V1Secret one\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"blue\")).withNamespace(NAMESPACE).withName(\"blue-secret\").build()).addToData(\"first\",\"blue\".getBytes()).build();\n    V1Secret two\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"blue\")).withNamespace(NAMESPACE).withName(\"another-blue-secret\").build()).addToData(\"second\",\"blue\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(one).addItemsItem(two);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Map.of(\"color\",\"blue\"),false,ConfigUtils.Prefix.DELAYED,false);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(46,sourceData.sourceName().length());\n    Assertions.assertTrue(sourceData.sourceName().contains(\"secret\"));\n    Assertions.assertTrue(sourceData.sourceName().contains(\"blue-secret\"));\n    Assertions.assertTrue(sourceData.sourceName().contains(\"another-blue-secret\"));\n    Assertions.assertTrue(sourceData.sourceName().contains(\"default\"));\n    Map\u003cString,Object\u003e properties\u003dsourceData.sourceData();\n    Assertions.assertEquals(2,properties.size());\n    Iterator\u003cString\u003e keys\u003dproperties.keySet().iterator();\n    String firstKey\u003dkeys.next();\n    String secondKey\u003dkeys.next();\n    if (firstKey.contains(\"first\")) {\n      Assertions.assertEquals(firstKey,\"another-blue-secret.blue-secret.first\");\n    }\n    Assertions.assertEquals(secondKey,\"another-blue-secret.blue-secret.second\");\n    Assertions.assertEquals(properties.get(firstKey),\"blue\");\n    Assertions.assertEquals(properties.get(secondKey),\"blue\");\n  }\n  /** \n * two secrets are deployed: secret \"color-secret\" with label: \"{color:blue}\" and \"shape-secret\" with label: \"{shape:round}\". We search by \"{color:blue}\" and find one secret. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsOneSecretFound(){\n    V1Secret colorSecret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"blue\")).withNamespace(NAMESPACE).withName(\"color-secret\").build()).addToData(\"one\",\"1\".getBytes()).build();\n    V1Secret shapeSecret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"shape\",\"round\")).withNamespace(NAMESPACE).withName(\"shape-secret\").build()).addToData(\"two\",\"2\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(colorSecret).addItemsItem(shapeSecret);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Map.of(\"color\",\"blue\"),false,ConfigUtils.Prefix.DEFAULT,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),1);\n    Assertions.assertEquals(sourceData.sourceData().get(\"one\"),\"1\");\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.color-secret.default\");\n  }\n  /** \n * two secrets are deployed: secret \"color-secret\" with label: \"{color:blue}\" and \"color-secret-k8s\" with label: \"{color:red}\". We search by \"{color:blue}\" and find one secret. Since profiles are enabled, we will also be reading \"color-secret-k8s\", even if its labels do not match provided ones.\n */\n  @Test void searchWithLabelsOneSecretFoundAndOneFromProfileFound(){\n    V1Secret colorSecret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"blue\")).withNamespace(NAMESPACE).withName(\"color-secret\").build()).addToData(\"one\",\"1\".getBytes()).build();\n    V1Secret shapeSecret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"red\")).withNamespace(NAMESPACE).withName(\"color-secret-k8s\").build()).addToData(\"two\",\"2\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(colorSecret).addItemsItem(shapeSecret);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource source\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Map.of(\"color\",\"blue\"),false,ConfigUtils.Prefix.DELAYED,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,environment);\n    KubernetesClientContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),2);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-secret.color-secret-k8s.one\"),\"1\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-secret.color-secret-k8s.two\"),\"2\");\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.color-secret.color-secret-k8s.default\");\n  }\n  /** \n * \u003cpre\u003e - secret \"color-secret\" with label \"{color:blue}\" - secret \"shape-secret\" with labels \"{color:blue, shape:round}\" - secret \"no-fit\" with labels \"{tag:no-fit}\" - secret \"color-secret-k8s\" with label \"{color:red}\" - secret \"shape-secret-k8s\" with label \"{shape:triangle}\" \u003c/pre\u003e\n */\n  @Test void searchWithLabelsTwoSecretsFoundAndOneFromProfileFound(){\n    V1Secret colorSecret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"blue\")).withNamespace(NAMESPACE).withName(\"color-secret\").build()).addToData(\"one\",\"1\".getBytes()).build();\n    V1Secret shapeSecret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"blue\",\"shape\",\"round\")).withNamespace(NAMESPACE).withName(\"shape-secret\").build()).addToData(\"two\",\"2\".getBytes()).build();\n    V1Secret noFit\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"tag\",\"no-fit\")).withNamespace(NAMESPACE).withName(\"no-fit\").build()).addToData(\"three\",\"3\".getBytes()).build();\n    V1Secret colorSecretK8s\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"red\")).withNamespace(NAMESPACE).withName(\"color-secret-k8s\").build()).addToData(\"four\",\"4\".getBytes()).build();\n    V1Secret shapeSecretK8s\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"shape\",\"triangle\")).withNamespace(NAMESPACE).withName(\"shape-secret-k8s\").build()).addToData(\"five\",\"5\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(colorSecret).addItemsItem(shapeSecret).addItemsItem(noFit).addItemsItem(colorSecretK8s).addItemsItem(shapeSecretK8s);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    NormalizedSource source\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Map.of(\"color\",\"blue\"),false,ConfigUtils.Prefix.DELAYED,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,environment);\n    KubernetesClientContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),4);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-secret.color-secret-k8s.shape-secret.shape-secret-k8s.one\"),\"1\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-secret.color-secret-k8s.shape-secret.shape-secret-k8s.two\"),\"2\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-secret.color-secret-k8s.shape-secret.shape-secret-k8s.four\"),\"4\");\n    Assertions.assertEquals(sourceData.sourceData().get(\"color-secret.color-secret-k8s.shape-secret.shape-secret-k8s.five\"),\"5\");\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.color-secret.color-secret-k8s.shape-secret.shape-secret-k8s.default\");\n  }\n  /** \n * yaml/properties gets special treatment\n */\n  @Test void testYaml(){\n    V1Secret colorSecret\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"blue\")).withNamespace(NAMESPACE).withName(\"color-secret\").build()).addToData(\"test.yaml\",\"color: blue\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(colorSecret);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource source\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Map.of(\"color\",\"blue\"),false,ConfigUtils.Prefix.DEFAULT,true);\n    KubernetesClientConfigContext context\u003dnew KubernetesClientConfigContext(api,source,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData data\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData sourceData\u003ddata.apply(context);\n    Assertions.assertEquals(sourceData.sourceData().size(),1);\n    Assertions.assertEquals(sourceData.sourceData().get(\"color\"),\"blue\");\n    Assertions.assertEquals(sourceData.sourceName(),\"secret.color-secret.default\");\n  }\n  /** \n * \u003cpre\u003e - one secret is deployed with label {\"color\", \"red\"} - one secret is deployed with label {\"color\", \"green\"} - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output){\n    V1Secret red\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"red\")).withNamespace(NAMESPACE).withName(\"red\").build()).addToData(\"color\",\"red\".getBytes()).build();\n    V1Secret green\u003dnew V1SecretBuilder().withMetadata(new V1ObjectMetaBuilder().withLabels(Map.of(\"color\",\"green\")).withNamespace(NAMESPACE).withName(\"green\").build()).addToData(\"color\",\"green\".getBytes()).build();\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(red).addItemsItem(green);\n    stubCall(secretList);\n    CoreV1Api api\u003dnew CoreV1Api();\n    NormalizedSource redSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Map.of(\"color\",\"red\"),false,ConfigUtils.Prefix.DEFAULT,false);\n    KubernetesClientConfigContext redContext\u003dnew KubernetesClientConfigContext(api,redSource,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData redData\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData redSourceData\u003dredData.apply(redContext);\n    Assertions.assertEquals(redSourceData.sourceData().size(),1);\n    Assertions.assertEquals(redSourceData.sourceData().get(\"color\"),\"red\");\n    Assertions.assertEquals(redSourceData.sourceName(),\"secret.red.default\");\n    Assertions.assertTrue(output.getAll().contains(\"Loaded all secrets in namespace \u0027\" + NAMESPACE + \"\u0027\"));\n    NormalizedSource greenSource\u003dnew LabeledSecretNormalizedSource(NAMESPACE,Map.of(\"color\",\"green\"),false,ConfigUtils.Prefix.DEFAULT,false);\n    KubernetesClientConfigContext greenContext\u003dnew KubernetesClientConfigContext(api,greenSource,NAMESPACE,new MockEnvironment());\n    KubernetesClientContextToSourceData greenData\u003dnew LabeledSecretContextToSourceDataProvider().get();\n    SourceData greenSourceData\u003dgreenData.apply(greenContext);\n    Assertions.assertEquals(greenSourceData.sourceData().size(),1);\n    Assertions.assertEquals(greenSourceData.sourceData().get(\"color\"),\"green\");\n    Assertions.assertEquals(greenSourceData.sourceName(),\"secret.green.default\");\n    String[] out\u003doutput.getAll().split(\"Loaded all secrets in namespace\");\n    Assertions.assertEquals(out.length,2);\n    out\u003doutput.getAll().split(\"Loaded \\\\(from cache\\\\) all secrets in namespace\");\n    Assertions.assertEquals(out.length,2);\n  }\n  private void stubCall(  V1SecretList list){\n    stubFor(get(\"/api/v1/namespaces/default/secrets\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(list))));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class LabeledSecretContextToSourceDataProviderTests {\n  private static final Map\u003cString,String\u003e LABELS\u003dnew LinkedHashMap\u003c\u003e();\n  private static final Map\u003cString,String\u003e RED_LABEL\u003dMap.of(\"color\",\"red\");\n  private static final String NAMESPACE\u003d\"default\";\nstatic {\n    LABELS.put(\"label2\",\"value2\");\n    LABELS.put(\"label1\",\"value1\");\n  }\n  @BeforeAll static void setup();\n  @AfterEach void afterEach();\n  /** \n * we have a single secret deployed. it does not match our query.\n */\n  @Test void noMatch();\n  /** \n * we have a single secret deployed. it has two labels and these match against our queries.\n */\n  @Test void singleSecretMatchAgainstLabels();\n  /** \n * we have two secrets deployed. both of them have labels that match (color\u003dred).\n */\n  @Test void twoSecretsMatchAgainstLabels();\n  @Test void namespaceMatch();\n  /** \n * one secret with name : \"blue-secret\" and labels \"color\u003dblue\" is deployed. we search it with the same labels, find it, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided an explicit prefix).\n */\n  @Test void testWithPrefix();\n  /** \n * two secrets are deployed (name:blue-secret, name:another-blue-secret) and labels \"color\u003dblue\" (on both). we search with the same labels, find them, and assert that name of the SourceData (it must use its name, not its labels) and values in the SourceData must be prefixed (since we have provided a delayed prefix). Also notice that the prefix is made up from both secret names.\n */\n  @Test void testTwoSecretsWithPrefix();\n  /** \n * two secrets are deployed: secret \"color-secret\" with label: \"{color:blue}\" and \"shape-secret\" with label: \"{shape:round}\". We search by \"{color:blue}\" and find one secret. profile based sources are enabled, but it has no effect.\n */\n  @Test void searchWithLabelsOneSecretFound();\n  /** \n * two secrets are deployed: secret \"color-secret\" with label: \"{color:blue}\" and \"color-secret-k8s\" with label: \"{color:red}\". We search by \"{color:blue}\" and find one secret. Since profiles are enabled, we will also be reading \"color-secret-k8s\", even if its labels do not match provided ones.\n */\n  @Test void searchWithLabelsOneSecretFoundAndOneFromProfileFound();\n  /** \n * \u003cpre\u003e - secret \"color-secret\" with label \"{color:blue}\" - secret \"shape-secret\" with labels \"{color:blue, shape:round}\" - secret \"no-fit\" with labels \"{tag:no-fit}\" - secret \"color-secret-k8s\" with label \"{color:red}\" - secret \"shape-secret-k8s\" with label \"{shape:triangle}\" \u003c/pre\u003e\n */\n  @Test void searchWithLabelsTwoSecretsFoundAndOneFromProfileFound();\n  /** \n * yaml/properties gets special treatment\n */\n  @Test void testYaml();\n  /** \n * \u003cpre\u003e - one secret is deployed with label {\"color\", \"red\"} - one secret is deployed with label {\"color\", \"green\"} - we first search for \"red\" and find it, and it is retrieved from the cluster via the client. - we then search for the \"green\" one, and it is retrieved from the cache this time. \u003c/pre\u003e\n */\n  @Test void cache(  CapturedOutput output);\n  private void stubCall(  V1SecretList list);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/KubernetesClientConfigDataLocationResolverTests.java",
        "name": "KubernetesClientConfigDataLocationResolverTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.KubernetesClientConfigDataLocationResolverTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesClientConfigDataLocationResolverTests {\n  private static final DeferredLogFactory FACTORY\u003dSupplier::get;\n  private static final ConfigDataLocationResolverContext RESOLVER_CONTEXT\u003dMockito.mock(ConfigDataLocationResolverContext.class);\n  private static final KubernetesClientConfigDataLocationResolver RESOLVER\u003dnew KubernetesClientConfigDataLocationResolver(FACTORY);\n  @Test void testBothMissing(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.config.enabled\",\"false\");\n    environment.setProperty(\"spring.cloud.kubernetes.secrets.enabled\",\"false\");\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    DefaultBootstrapContext context\u003dnew DefaultBootstrapContext();\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(context);\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertTrue(context.isRegistered(KubernetesClientProperties.class));\n    Assertions.assertTrue(context.isRegistered(CoreV1Api.class));\n    Assertions.assertTrue(context.isRegistered(ApiClient.class));\n    Assertions.assertFalse(context.isRegistered(ConfigMapConfigProperties.class));\n    Assertions.assertFalse(context.isRegistered(SecretsConfigProperties.class));\n    Assertions.assertFalse(context.isRegistered(ConfigMapPropertySourceLocator.class));\n    Assertions.assertFalse(context.isRegistered(SecretsPropertySourceLocator.class));\n  }\n  @Test void testBothPresent(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    DefaultBootstrapContext context\u003dnew DefaultBootstrapContext();\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(context);\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertTrue(context.isRegistered(KubernetesClientProperties.class));\n    Assertions.assertTrue(context.isRegistered(CoreV1Api.class));\n    Assertions.assertTrue(context.isRegistered(ApiClient.class));\n    Assertions.assertTrue(context.isRegistered(ConfigMapConfigProperties.class));\n    Assertions.assertTrue(context.isRegistered(SecretsConfigProperties.class));\n    Assertions.assertTrue(context.isRegistered(ConfigMapPropertySourceLocator.class));\n    Assertions.assertTrue(context.isRegistered(SecretsPropertySourceLocator.class));\n    ConfigMapPropertySourceLocator configMapPropertySourceLocator\u003dcontext.get(ConfigMapPropertySourceLocator.class);\n    Assertions.assertSame(KubernetesClientConfigMapPropertySourceLocator.class,configMapPropertySourceLocator.getClass());\n    SecretsPropertySourceLocator secretsPropertySourceLocator\u003dcontext.get(SecretsPropertySourceLocator.class);\n    Assertions.assertSame(KubernetesClientSecretsPropertySourceLocator.class,secretsPropertySourceLocator.getClass());\n  }\n  /** \n * both ConfigMapConfigProperties and SecretsConfigProperties are enabled explicitly, as such they are both registered. It also means that ConfigMapPropertySourceLocator and SecretsPropertySourceLocator are registered too. Since retry is not enabled explicitly, we also assert the types to ensure that these are not retryable beans.\n */\n  @Test void testBothPresentExplicitly(  CapturedOutput capturedOutput){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.config.enabled\",\"true\");\n    environment.setProperty(\"spring.cloud.kubernetes.secrets.enabled\",\"true\");\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    DefaultBootstrapContext context\u003dnew DefaultBootstrapContext();\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(context);\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertTrue(context.isRegistered(KubernetesClientProperties.class));\n    Assertions.assertTrue(context.isRegistered(CoreV1Api.class));\n    Assertions.assertTrue(context.isRegistered(ApiClient.class));\n    Assertions.assertTrue(context.isRegistered(ConfigMapConfigProperties.class));\n    Assertions.assertTrue(context.isRegistered(SecretsConfigProperties.class));\n    ConfigMapPropertySourceLocator configMapPropertySourceLocator\u003dcontext.get(ConfigMapPropertySourceLocator.class);\n    Assertions.assertSame(KubernetesClientConfigMapPropertySourceLocator.class,configMapPropertySourceLocator.getClass());\n    SecretsPropertySourceLocator secretsPropertySourceLocator\u003dcontext.get(SecretsPropertySourceLocator.class);\n    Assertions.assertSame(KubernetesClientSecretsPropertySourceLocator.class,secretsPropertySourceLocator.getClass());\n    Assertions.assertTrue(capturedOutput.getOut().contains(\"Could not create the Kubernetes ApiClient in a cluster environment, because connection port \" + \"was not provided.\"));\n  }\n  @Test void testBothPresentAndRetryEnabled(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.config.retry.enabled\",\"true\");\n    environment.setProperty(\"spring.cloud.kubernetes.config.fail-fast\",\"true\");\n    environment.setProperty(\"spring.cloud.kubernetes.secrets.retry.enabled\",\"true\");\n    environment.setProperty(\"spring.cloud.kubernetes.secrets.fail-fast\",\"true\");\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    DefaultBootstrapContext context\u003dnew DefaultBootstrapContext();\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(context);\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertTrue(context.isRegistered(KubernetesClientProperties.class));\n    Assertions.assertTrue(context.isRegistered(CoreV1Api.class));\n    Assertions.assertTrue(context.isRegistered(ApiClient.class));\n    Assertions.assertTrue(context.isRegistered(ConfigMapConfigProperties.class));\n    Assertions.assertTrue(context.isRegistered(SecretsConfigProperties.class));\n    Assertions.assertTrue(context.isRegistered(ConfigMapPropertySourceLocator.class));\n    Assertions.assertTrue(context.isRegistered(SecretsPropertySourceLocator.class));\n    ConfigMapPropertySourceLocator configMapPropertySourceLocator\u003dcontext.get(ConfigMapPropertySourceLocator.class);\n    Assertions.assertSame(ConfigDataRetryableConfigMapPropertySourceLocator.class,configMapPropertySourceLocator.getClass());\n    SecretsPropertySourceLocator secretsPropertySourceLocator\u003dcontext.get(SecretsPropertySourceLocator.class);\n    Assertions.assertSame(ConfigDataRetryableSecretsPropertySourceLocator.class,secretsPropertySourceLocator.getClass());\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesClientConfigDataLocationResolverTests {\n  private static final DeferredLogFactory FACTORY\u003dSupplier::get;\n  private static final ConfigDataLocationResolverContext RESOLVER_CONTEXT\u003dMockito.mock(ConfigDataLocationResolverContext.class);\n  private static final KubernetesClientConfigDataLocationResolver RESOLVER\u003dnew KubernetesClientConfigDataLocationResolver(FACTORY);\n  @Test void testBothMissing();\n  @Test void testBothPresent();\n  /** \n * both ConfigMapConfigProperties and SecretsConfigProperties are enabled explicitly, as such they are both registered. It also means that ConfigMapPropertySourceLocator and SecretsPropertySourceLocator are registered too. Since retry is not enabled explicitly, we also assert the types to ensure that these are not retryable beans.\n */\n  @Test void testBothPresentExplicitly(  CapturedOutput capturedOutput);\n  @Test void testBothPresentAndRetryEnabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/EnableRetryBootstrapConfiguration.java",
        "name": "EnableRetryBootstrapConfiguration",
        "modifiers": "@Order(0) @Configuration @ConditionalOnProperty(\"spring.cloud.kubernetes.test.enable-retry\") @EnableRetry public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.EnableRetryBootstrapConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"spring.cloud.kubernetes.test.enable-retry\") @EnableRetry public class EnableRetryBootstrapConfiguration {\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Order(0) @Configuration @ConditionalOnProperty(\"spring.cloud.kubernetes.test.enable-retry\") @EnableRetry public class EnableRetryBootstrapConfiguration {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/reload/KubernetesClientEventBasedConfigMapChangeDetectorTests.java",
        "name": "KubernetesClientEventBasedConfigMapChangeDetectorTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.reload.KubernetesClientEventBasedConfigMapChangeDetectorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass KubernetesClientEventBasedConfigMapChangeDetectorTests {\n  private static WireMockServer wireMockServer;\n  @BeforeAll public static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n  }\n  @AfterAll public static void after(){\n    wireMockServer.stop();\n  }\n  @AfterEach public void afterEach(){\n    WireMock.reset();\n  }\n  @Test void watch(){\n    GsonBuilder builder\u003dnew GsonBuilder();\n    builder.excludeFieldsWithModifiers(Modifier.STATIC,Modifier.TRANSIENT,Modifier.VOLATILE).registerTypeAdapter(OffsetDateTime.class,new GsonOffsetDateTimeAdapter());\n    Gson gson\u003dbuilder.create();\n    Map\u003cString,String\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"application.properties\",\"spring.cloud.kubernetes.configuration.watcher.refreshDelay\u003d0\\n\" + \"logging.level.org.springframework.cloud.kubernetes\u003dTRACE\");\n    Map\u003cString,String\u003e updateData\u003dnew HashMap\u003c\u003e();\n    updateData.put(\"application.properties\",\"spring.cloud.kubernetes.configuration.watcher.refreshDelay\u003d1\\n\" + \"logging.level.org.springframework.cloud.kubernetes\u003dTRACE\");\n    V1ConfigMap applicationConfig\u003dnew V1ConfigMap().kind(\"ConfigMap\").metadata(new V1ObjectMeta().namespace(\"default\").name(\"bar1\")).data(data);\n    V1ConfigMapList configMapList\u003dnew V1ConfigMapList().metadata(new V1ListMeta().resourceVersion(\"0\")).items(List.of(applicationConfig));\n    stubFor(get(urlMatching(\"^/api/v1/namespaces/default/configmaps.*\")).inScenario(\"watch\").whenScenarioStateIs(STARTED).withQueryParam(\"watch\",equalTo(\"false\")).willReturn(aResponse().withStatus(200).withBody(gson.toJson(configMapList))).willSetStateTo(\"update\"));\n    Watch.Response\u003cV1ConfigMap\u003e watchResponse\u003dnew Watch.Response\u003c\u003e(EventType.MODIFIED.name(),new V1ConfigMap().kind(\"ConfigMap\").metadata(new V1ObjectMeta().namespace(\"default\").name(\"bar1\")).data(updateData));\n    stubFor(get(urlMatching(\"^/api/v1/namespaces/default/configmaps.*\")).inScenario(\"watch\").whenScenarioStateIs(\"update\").withQueryParam(\"watch\",equalTo(\"true\")).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(watchResponse))).willSetStateTo(\"add\"));\n    stubFor(get(urlMatching(\"^/api/v1/namespaces/default/configmaps.*\")).inScenario(\"watch\").whenScenarioStateIs(\"add\").withQueryParam(\"watch\",equalTo(\"true\")).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new Watch.Response\u003c\u003e(EventType.ADDED.name(),new V1ConfigMap().kind(\"ConfigMap\").metadata(new V1ObjectMeta().namespace(\"default\").name(\"bar3\")).putDataItem(\"application.properties\",\"debug\u003dtrue\"))))).willSetStateTo(\"delete\"));\n    stubFor(get(urlMatching(\"^/api/v1/namespaces/default/configmaps.*\")).inScenario(\"watch\").whenScenarioStateIs(\"delete\").withQueryParam(\"watch\",equalTo(\"true\")).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new Watch.Response\u003c\u003e(EventType.DELETED.name(),new V1ConfigMap().kind(\"ConfigMap\").metadata(new V1ObjectMeta().namespace(\"default\").name(\"bar1\")).putDataItem(\"application.properties\",\"debug\u003dtrue\"))))).willSetStateTo(\"done\"));\n    stubFor(get(urlMatching(\"^/api/v1/namespaces/default/configmaps.*\")).inScenario(\"watch\").whenScenarioStateIs(\"done\").withQueryParam(\"watch\",equalTo(\"true\")).willReturn(aResponse().withStatus(200)));\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    OkHttpClient httpClient\u003dapiClient.getHttpClient().newBuilder().readTimeout(0,TimeUnit.SECONDS).build();\n    apiClient.setHttpClient(httpClient);\n    CoreV1Api coreV1Api\u003dnew CoreV1Api(apiClient);\n    int[] howMany\u003dnew int[1];\n    Runnable run\u003d() -\u003e {\n      ++howMany[0];\n    }\n;\n    ConfigurationUpdateStrategy strategy\u003dnew ConfigurationUpdateStrategy(\"strategy\",run);\n    KubernetesMockEnvironment environment\u003dnew KubernetesMockEnvironment(mock(KubernetesClientConfigMapPropertySource.class)).withProperty(\"debug\",\"true\");\n    KubernetesClientConfigMapPropertySourceLocator locator\u003dmock(KubernetesClientConfigMapPropertySourceLocator.class);\n    when(locator.locate(environment)).thenAnswer(x -\u003e new MockPropertySource().withProperty(\"debug\",\"false\"));\n    KubernetesNamespaceProvider kubernetesNamespaceProvider\u003dmock(KubernetesNamespaceProvider.class);\n    when(kubernetesNamespaceProvider.getNamespace()).thenReturn(\"default\");\n    KubernetesClientEventBasedConfigMapChangeDetector changeDetector\u003dnew KubernetesClientEventBasedConfigMapChangeDetector(coreV1Api,environment,ConfigReloadProperties.DEFAULT,strategy,locator,kubernetesNamespaceProvider);\n    Thread controllerThread\u003dnew Thread(changeDetector::inform);\n    controllerThread.setDaemon(true);\n    controllerThread.start();\n    await().timeout(Duration.ofSeconds(10)).pollInterval(Duration.ofSeconds(2)).until(() -\u003e howMany[0] \u003e\u003d 4);\n  }\npublic final static class GsonOffsetDateTimeAdapter extends TypeAdapter\u003cOffsetDateTime\u003e {\n    @Override public void write(    JsonWriter jsonWriter,    OffsetDateTime localDateTime) throws IOException {\n      jsonWriter.value(OffsetDateTime.now().toString());\n    }\n    @Override public OffsetDateTime read(    JsonReader jsonReader){\n      return OffsetDateTime.now();\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass KubernetesClientEventBasedConfigMapChangeDetectorTests {\n  private static WireMockServer wireMockServer;\n  @BeforeAll public static void setup();\n  @AfterAll public static void after();\n  @AfterEach public void afterEach();\n  @Test void watch();\npublic final static class GsonOffsetDateTimeAdapter extends TypeAdapter\u003cOffsetDateTime\u003e {\n    @Override public void write(    JsonWriter jsonWriter,    OffsetDateTime localDateTime) throws IOException;\n    @Override public OffsetDateTime read(    JsonReader jsonReader);\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/reload/KubernetesClientEventBasedSecretsChangeDetectorTests.java",
        "name": "KubernetesClientEventBasedSecretsChangeDetectorTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.reload.KubernetesClientEventBasedSecretsChangeDetectorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass KubernetesClientEventBasedSecretsChangeDetectorTests {\n  private static final Map\u003cString,StringValuePattern\u003e WATCH_FALSE\u003dMap.of(\"watch\",equalTo(\"false\"));\n  private static final Map\u003cString,StringValuePattern\u003e WATCH_TRUE\u003dMap.of(\"watch\",equalTo(\"true\"));\n  private static final String SCENARIO\u003d\"watch\";\n  private static WireMockServer wireMockServer;\n  @BeforeAll public static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n  }\n  @AfterAll public static void after(){\n    wireMockServer.stop();\n  }\n  @AfterEach public void afterEach(){\n    WireMock.reset();\n  }\n  @Test void watch(){\n    V1Secret dbPassword\u003dnew V1Secret().metadata(new V1ObjectMeta().name(\"db-password\")).putStringDataItem(\"password\",Base64.getEncoder().encodeToString(\"p455w0rd\".getBytes())).putDataItem(\"password\",Base64.getEncoder().encode(\"p455w0rd\".getBytes())).putStringDataItem(\"username\",Base64.getEncoder().encodeToString(\"user\".getBytes())).putDataItem(\"username\",Base64.getEncoder().encode(\"user\".getBytes()));\n    V1SecretList secretList\u003dnew V1SecretList().metadata(new V1ListMeta().resourceVersion(\"0\")).items(List.of(dbPassword));\n    V1Secret dbPasswordUpdated\u003dnew V1Secret().metadata(new V1ObjectMeta().name(\"db-password\")).putStringDataItem(\"password\",Base64.getEncoder().encodeToString(\"p455w0rd2\".getBytes())).putDataItem(\"password\",Base64.getEncoder().encode(\"p455w0rd2\".getBytes())).putStringDataItem(\"username\",Base64.getEncoder().encodeToString(\"user\".getBytes())).putDataItem(\"username\",Base64.getEncoder().encode(\"user\".getBytes()));\n    Watch.Response\u003cV1Secret\u003e watchResponse\u003dnew Watch.Response\u003c\u003e(EventType.MODIFIED.name(),dbPasswordUpdated);\n    stubFor(get(urlMatching(\"/api/v1/namespaces/default/secrets.*\")).inScenario(SCENARIO).whenScenarioStateIs(STARTED).withQueryParams(WATCH_FALSE).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(secretList))).willSetStateTo(\"update\"));\n    stubFor(get(urlMatching(\"/api/v1/namespaces/default/secrets.*\")).inScenario(SCENARIO).whenScenarioStateIs(\"update\").withQueryParams(WATCH_TRUE).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(watchResponse))).willSetStateTo(\"add\"));\n    stubFor(get(urlMatching(\"/api/v1/namespaces/default/secrets.*\")).inScenario(SCENARIO).whenScenarioStateIs(\"add\").withQueryParams(WATCH_TRUE).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new Watch.Response\u003c\u003e(EventType.ADDED.name(),new V1Secret().metadata(new V1ObjectMeta().name(\"rabbit-password\")).putDataItem(\"rabbit-pw\",Base64.getEncoder().encode(\"password\".getBytes())))))).willSetStateTo(\"delete\"));\n    stubFor(get(urlMatching(\"/api/v1/namespaces/default/secrets.*\")).inScenario(SCENARIO).whenScenarioStateIs(\"delete\").withQueryParams(WATCH_TRUE).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new Watch.Response\u003c\u003e(EventType.DELETED.name(),new V1Secret().metadata(new V1ObjectMeta().name(\"rabbit-password\")).putDataItem(\"rabbit-pw\",Base64.getEncoder().encode(\"password\".getBytes())))))).willSetStateTo(\"done\"));\n    stubFor(get(urlMatching(\"/api/v1/namespaces/default/secrets.*\")).inScenario(\"watch\").whenScenarioStateIs(\"done\").withQueryParam(\"watch\",equalTo(\"true\")).willReturn(aResponse().withStatus(200)));\n    ApiClient apiClient\u003dnew ClientBuilder().setBasePath(\"http://localhost:\" + wireMockServer.port()).build();\n    OkHttpClient httpClient\u003dapiClient.getHttpClient().newBuilder().readTimeout(0,TimeUnit.SECONDS).build();\n    apiClient.setHttpClient(httpClient);\n    CoreV1Api coreV1Api\u003dnew CoreV1Api(apiClient);\n    int[] howMany\u003dnew int[1];\n    Runnable run\u003d() -\u003e {\n      ++howMany[0];\n    }\n;\n    ConfigurationUpdateStrategy strategy\u003dnew ConfigurationUpdateStrategy(\"strategy\",run);\n    KubernetesMockEnvironment environment\u003dnew KubernetesMockEnvironment(mock(KubernetesClientSecretsPropertySource.class)).withProperty(\"db-password\",\"p455w0rd\");\n    KubernetesClientSecretsPropertySourceLocator locator\u003dmock(KubernetesClientSecretsPropertySourceLocator.class);\n    when(locator.locate(environment)).thenAnswer(ignoreMe -\u003e new MockPropertySource().withProperty(\"db-password\",\"p455w0rd2\"));\n    ConfigReloadProperties properties\u003dnew ConfigReloadProperties(false,false,true,ConfigReloadProperties.ReloadStrategy.REFRESH,ConfigReloadProperties.ReloadDetectionMode.EVENT,Duration.ofMillis(15000),Set.of(),false,Duration.ofSeconds(2));\n    KubernetesNamespaceProvider kubernetesNamespaceProvider\u003dmock(KubernetesNamespaceProvider.class);\n    when(kubernetesNamespaceProvider.getNamespace()).thenReturn(\"default\");\n    KubernetesClientEventBasedSecretsChangeDetector changeDetector\u003dnew KubernetesClientEventBasedSecretsChangeDetector(coreV1Api,environment,properties,strategy,locator,kubernetesNamespaceProvider);\n    Thread controllerThread\u003dnew Thread(changeDetector::inform);\n    controllerThread.setDaemon(true);\n    controllerThread.start();\n    await().timeout(Duration.ofSeconds(10)).pollInterval(Duration.ofSeconds(2)).until(() -\u003e howMany[0] \u003e\u003d 4);\n  }\n  /** \n * both are null, treat that as no change.\n */\n  @Test void equalsOne(){\n    Map\u003cString,byte[]\u003e left\u003dnull;\n    Map\u003cString,byte[]\u003e right\u003dnull;\n    boolean result\u003dKubernetesClientEventBasedSecretsChangeDetector.equals(left,right);\n    Assertions.assertTrue(result);\n  }\n  /** \n * - left is empty map - right is null treat as equal, that is: no change\n */\n  @Test void equalsTwo(){\n    Map\u003cString,byte[]\u003e left\u003dMap.of();\n    Map\u003cString,byte[]\u003e right\u003dnull;\n    boolean result\u003dKubernetesClientEventBasedSecretsChangeDetector.equals(left,right);\n    Assertions.assertTrue(result);\n  }\n  /** \n * - left is empty map - right is null treat as equal, that is: no change\n */\n  @Test void equalsThree(){\n    Map\u003cString,byte[]\u003e left\u003dMap.of();\n    Map\u003cString,byte[]\u003e right\u003dnull;\n    boolean result\u003dKubernetesClientEventBasedSecretsChangeDetector.equals(left,right);\n    Assertions.assertTrue(result);\n  }\n  /** \n * - left is null - right is empty map treat as equal, that is: no change\n */\n  @Test void equalsFour(){\n    Map\u003cString,byte[]\u003e left\u003dnull;\n    Map\u003cString,byte[]\u003e right\u003dMap.of();\n    boolean result\u003dKubernetesClientEventBasedSecretsChangeDetector.equals(left,right);\n    Assertions.assertTrue(result);\n  }\n  /** \n * - left is empty map - right is empty map treat as equal, that is: no change\n */\n  @Test void equalsFive(){\n    Map\u003cString,byte[]\u003e left\u003dMap.of();\n    Map\u003cString,byte[]\u003e right\u003dMap.of();\n    boolean result\u003dKubernetesClientEventBasedSecretsChangeDetector.equals(left,right);\n    Assertions.assertTrue(result);\n  }\n  /** \n * - left is empty map - right is [1, b] treat as non-equal, that is change\n */\n  @Test void equalsSix(){\n    Map\u003cString,byte[]\u003e left\u003dMap.of();\n    Map\u003cString,byte[]\u003e right\u003dMap.of(\"1\",\"b\".getBytes());\n    boolean result\u003dKubernetesClientEventBasedSecretsChangeDetector.equals(left,right);\n    Assertions.assertFalse(result);\n  }\n  /** \n * - left is [1, a] - right is [1, b] treat as non-equal, that is change\n */\n  @Test void equalsSeven(){\n    Map\u003cString,byte[]\u003e left\u003dMap.of(\"1\",\"a\".getBytes());\n    Map\u003cString,byte[]\u003e right\u003dMap.of(\"1\",\"b\".getBytes());\n    boolean result\u003dKubernetesClientEventBasedSecretsChangeDetector.equals(left,right);\n    Assertions.assertFalse(result);\n  }\n  /** \n * - left is [1, a, 2 aa] - right is [1, b, 2, aa] treat as non-equal, that is change\n */\n  @Test void equalsEight(){\n    Map\u003cString,byte[]\u003e left\u003dMap.of(\"1\",\"a\".getBytes(),\"2\",\"aa\".getBytes());\n    Map\u003cString,byte[]\u003e right\u003dMap.of(\"1\",\"b\".getBytes(),\"2\",\"aa\".getBytes());\n    boolean result\u003dKubernetesClientEventBasedSecretsChangeDetector.equals(left,right);\n    Assertions.assertFalse(result);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass KubernetesClientEventBasedSecretsChangeDetectorTests {\n  private static final Map\u003cString,StringValuePattern\u003e WATCH_FALSE\u003dMap.of(\"watch\",equalTo(\"false\"));\n  private static final Map\u003cString,StringValuePattern\u003e WATCH_TRUE\u003dMap.of(\"watch\",equalTo(\"true\"));\n  private static final String SCENARIO\u003d\"watch\";\n  private static WireMockServer wireMockServer;\n  @BeforeAll public static void setup();\n  @AfterAll public static void after();\n  @AfterEach public void afterEach();\n  @Test void watch();\n  /** \n * both are null, treat that as no change.\n */\n  @Test void equalsOne();\n  /** \n * - left is empty map - right is null treat as equal, that is: no change\n */\n  @Test void equalsTwo();\n  /** \n * - left is empty map - right is null treat as equal, that is: no change\n */\n  @Test void equalsThree();\n  /** \n * - left is null - right is empty map treat as equal, that is: no change\n */\n  @Test void equalsFour();\n  /** \n * - left is empty map - right is empty map treat as equal, that is: no change\n */\n  @Test void equalsFive();\n  /** \n * - left is empty map - right is [1, b] treat as non-equal, that is change\n */\n  @Test void equalsSix();\n  /** \n * - left is [1, a] - right is [1, b] treat as non-equal, that is change\n */\n  @Test void equalsSeven();\n  /** \n * - left is [1, a, 2 aa] - right is [1, b, 2, aa] treat as non-equal, that is change\n */\n  @Test void equalsEight();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/reload/KubernetesMockEnvironment.java",
        "name": "KubernetesMockEnvironment",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.reload.KubernetesMockEnvironment",
        "extend": "AbstractEnvironment",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesMockEnvironment extends AbstractEnvironment {\n  private PropertySource propertySource\u003dmock(KubernetesClientSecretsPropertySource.class);\n  private Map\u003cString,Object\u003e map\u003dnew HashMap\u003c\u003e();\n  public KubernetesMockEnvironment(  PropertySource mockPropertySource){\n    this.propertySource\u003dmockPropertySource;\n    this.getPropertySources().addLast(this.propertySource);\n    when(propertySource.getSource()).thenReturn(map);\n  }\n  public void setProperty(  String key,  String value){\n    map.put(key,value);\n    when(propertySource.getProperty(eq(key))).thenReturn(value);\n  }\n  public KubernetesMockEnvironment withProperty(  String key,  String value){\n    this.setProperty(key,value);\n    return this;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesMockEnvironment extends AbstractEnvironment {\n  private PropertySource propertySource\u003dmock(KubernetesClientSecretsPropertySource.class);\n  private Map\u003cString,Object\u003e map\u003dnew HashMap\u003c\u003e();\n  public KubernetesMockEnvironment(  PropertySource mockPropertySource);\n  public void setProperty(  String key,  String value);\n  public KubernetesMockEnvironment withProperty(  String key,  String value);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/sanitize_secrets/ConfigDataFabric8ConfigpropsEndpointTests.java",
        "name": "ConfigDataFabric8ConfigpropsEndpointTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.sanitize_secrets.ConfigDataFabric8ConfigpropsEndpointTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass ConfigDataFabric8ConfigpropsEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\"}) @Nested class DefaultSettingsTest extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeConfigMapName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeSecretName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"management.endpoint.configprops.show-values\u003dNEVER\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\"}) @Nested class ExplicitNever extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeConfigMapName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeSecretName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\"}) @Nested class AlwaysWithoutSanitizingFunction extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeConfigMapName\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeSecretName\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize-two.yaml\"}) @Nested class AlwaysWithSanitizingFunction extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeConfigMapName\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeSecretName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.sanitize.beans.[*].properties.sanitizeSecretNameTwo\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass ConfigDataFabric8ConfigpropsEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\"}) @Nested class DefaultSettingsTest extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"management.endpoint.configprops.show-values\u003dNEVER\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\"}) @Nested class ExplicitNever extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\"}) @Nested class AlwaysWithoutSanitizingFunction extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize-two.yaml\"}) @Nested class AlwaysWithSanitizingFunction extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/sanitize_secrets/SanitizeApp.java",
        "name": "SanitizeApp",
        "modifiers": "@EnableConfigurationProperties(SanitizeProperties.class) @SpringBootApplication",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.sanitize_secrets.SanitizeApp",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@EnableConfigurationProperties(SanitizeProperties.class) @SpringBootApplication class SanitizeApp {\n  public static void main(  String[] args){\n    SpringApplication.run(SanitizeApp.class,args);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@EnableConfigurationProperties(SanitizeProperties.class) @SpringBootApplication class SanitizeApp {\n  public static void main(  String[] args);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/sanitize_secrets/ConfigDataKubernetesClientSanitizeEnvEndpointTests.java",
        "name": "ConfigDataKubernetesClientSanitizeEnvEndpointTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.sanitize_secrets.ConfigDataKubernetesClientSanitizeEnvEndpointTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass ConfigDataKubernetesClientSanitizeEnvEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class DefaultSettingsTest extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\",\"management.endpoint.env.show-values\u003dNEVER\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class ExplicitNever extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class AlwaysWithoutSanitizingFunction extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize-two.yaml\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class AlwaysWithSanitizingFunction extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretNameTwo\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass ConfigDataKubernetesClientSanitizeEnvEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class DefaultSettingsTest extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\",\"management.endpoint.env.show-values\u003dNEVER\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class ExplicitNever extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize.yaml\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class AlwaysWithoutSanitizingFunction extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.config.import\u003dkubernetes:,classpath:./sanitize-two.yaml\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class AlwaysWithSanitizingFunction extends ConfigDataSanitize {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/sanitize_secrets/ConfigDataSanitize.java",
        "name": "ConfigDataSanitize",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.sanitize_secrets.ConfigDataSanitize",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nabstract class ConfigDataSanitize {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock(){\n    WireMockServer server\u003dnew WireMockServer(options().dynamicPort());\n    server.start();\n    WireMock.configureFor(\"localhost\",server.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(server.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"test\");\n    stubData();\n  }\n  @AfterAll static void teardown(){\n    clientUtilsMock.close();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nabstract class ConfigDataSanitize {\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void wireMock();\n  @AfterAll static void teardown();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/sanitize_secrets/SanitizeProperties.java",
        "name": "SanitizeProperties",
        "modifiers": "@ConfigurationProperties(\"sanitize\")",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.sanitize_secrets.SanitizeProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"sanitize\") class SanitizeProperties {\n  private String sanitizeSecretName;\n  private String sanitizeSecretNameTwo;\n  private String sanitizeConfigMapName;\n  public String getSanitizeSecretName(){\n    return sanitizeSecretName;\n  }\n  public void setSanitizeSecretName(  String sanitizeSecretName){\n    this.sanitizeSecretName\u003dsanitizeSecretName;\n  }\n  public String getSanitizeConfigMapName(){\n    return sanitizeConfigMapName;\n  }\n  public void setSanitizeConfigMapName(  String sanitizeConfigMapName){\n    this.sanitizeConfigMapName\u003dsanitizeConfigMapName;\n  }\n  public String getSanitizeSecretNameTwo(){\n    return sanitizeSecretNameTwo;\n  }\n  public void setSanitizeSecretNameTwo(  String sanitizeSecretNameTwo){\n    this.sanitizeSecretNameTwo\u003dsanitizeSecretNameTwo;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConfigurationProperties(\"sanitize\") class SanitizeProperties {\n  private String sanitizeSecretName;\n  private String sanitizeSecretNameTwo;\n  private String sanitizeConfigMapName;\n  public String getSanitizeSecretName();\n  public void setSanitizeSecretName(  String sanitizeSecretName);\n  public String getSanitizeConfigMapName();\n  public void setSanitizeConfigMapName(  String sanitizeConfigMapName);\n  public String getSanitizeSecretNameTwo();\n  public void setSanitizeSecretNameTwo(  String sanitizeSecretNameTwo);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/sanitize_secrets/BootstrapKubernetesClientSanitizeEnvEndpointTests.java",
        "name": "BootstrapKubernetesClientSanitizeEnvEndpointTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.sanitize_secrets.BootstrapKubernetesClientSanitizeEnvEndpointTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass BootstrapKubernetesClientSanitizeEnvEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class DefaultSettingsTest {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.env.show-values\u003dNEVER\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class ExplicitNever {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class AlwaysWithoutSanitizingFunction {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize-two\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class AlwaysWithSanitizingFunction {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeConfigMapName\u0027].value\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretName\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/env\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"propertySources.[*].properties.[\u0027sanitize.sanitizeSecretNameTwo\u0027].value\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass BootstrapKubernetesClientSanitizeEnvEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class DefaultSettingsTest {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.env.show-values\u003dNEVER\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class ExplicitNever {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class AlwaysWithoutSanitizingFunction {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.env.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize-two\",\"management.endpoint.env.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class AlwaysWithSanitizingFunction {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/sanitize_secrets/SanitizeController.java",
        "name": "SanitizeController",
        "modifiers": "@RestController",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.sanitize_secrets.SanitizeController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@RestController class SanitizeController {\n  private final SanitizeProperties sanitizeProperties;\n  SanitizeController(  SanitizeProperties sanitizeProperties){\n    this.sanitizeProperties\u003dsanitizeProperties;\n  }\n  @GetMapping(\"/secret\") String secret(){\n    return sanitizeProperties.getSanitizeSecretName();\n  }\n  @GetMapping(\"/configmap\") String configmap(){\n    return sanitizeProperties.getSanitizeConfigMapName();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@RestController class SanitizeController {\n  private final SanitizeProperties sanitizeProperties;\n  SanitizeController(  SanitizeProperties sanitizeProperties);\n  @GetMapping(\"/secret\") String secret();\n  @GetMapping(\"/configmap\") String configmap();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/sanitize_secrets/BootstrapKubernetesClientSanitizeConfigpropsEndpointTests.java",
        "name": "BootstrapKubernetesClientSanitizeConfigpropsEndpointTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.sanitize_secrets.BootstrapKubernetesClientSanitizeConfigpropsEndpointTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass BootstrapKubernetesClientSanitizeConfigpropsEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class DefaultSettingsTest {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeConfigMapName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeSecretName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.configprops.show-values\u003dNEVER\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class ExplicitNever {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeConfigMapName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeSecretName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class AlwaysWithoutSanitizingFunction {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeConfigMapName\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeSecretName\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize-two\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class AlwaysWithSanitizingFunction {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test(){\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeConfigMapName\").isEqualTo(\"sanitizeConfigMapValue\");\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeSecretName\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/actuator/configprops\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"contexts.[\u0027sanitize-1\u0027].beans.[*].properties.sanitizeSecretNameTwo\").isEqualTo(SanitizableData.SANITIZED_VALUE);\n      webClient.get().uri(\"http://localhost:{port}/secret\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeSecretValue\");\n      webClient.get().uri(\"http://localhost:{port}/configmap\",this.port).exchange().expectStatus().isOk().expectBody().jsonPath(\"$\").isEqualTo(\"sanitizeConfigMapValue\");\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass BootstrapKubernetesClientSanitizeConfigpropsEndpointTests {\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class DefaultSettingsTest {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.configprops.show-values\u003dNEVER\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class ExplicitNever {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d false Sanitizing functions must apply, but we have none registered, as such everything is visible in plain text, both from configmaps and secrets. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dfalse\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class AlwaysWithoutSanitizingFunction {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n  /** \n * \u003cpre\u003e - management.endpoint.configprops.show-values \u003d ALWAYS - spring.cloud.kubernetes.sanitize.secrets \u003d true Sanitizing functions must apply, and we have one registered, as such configmap is visible in plain text, but secrets are sanitized. \u003c/pre\u003e\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,classes\u003dSanitizeApp.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.bootstrap.enabled\u003dtrue\",\"management.endpoints.web.exposure.include\u003d*\",\"spring.cloud.bootstrap.name\u003dsanitize-two\",\"management.endpoint.configprops.show-values\u003dALWAYS\",\"spring.cloud.kubernetes.sanitize.secrets\u003dtrue\",\"bootstrap.sanitize\u003dtrue\",\"spring.cloud.kubernetes.client.namespace\u003dtest\"}) @Nested class AlwaysWithSanitizingFunction {\n    @Autowired private WebTestClient webClient;\n    @LocalManagementPort private int port;\n    @Test void test();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/secrets_retry/SecretsRetryEnabled.java",
        "name": "SecretsRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.max-attempts\u003d5\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dSecretsRetryApplication.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.secrets_retry.SecretsRetryEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.max-attempts\u003d5\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dSecretsRetryApplication.class) class SecretsRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"default\");\n    stubConfigMapAndSecretsDefaults();\n  }\n  private static void stubConfigMapAndSecretsDefaults(){\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1SecretList()))));\n  }\n  @AfterAll static void teardown(){\n    wireMockServer.stop();\n    clientUtilsMock.close();\n  }\n  @Autowired private SecretsPropertySourceLocator psl;\n  @BeforeEach void afterEach(){\n    WireMock.reset();\n    stubConfigMapAndSecretsDefaults();\n  }\n  @Test void locateShouldNotRetryWhenThereIsNoFailure(){\n    SecretsPropertySourceLocator propertySourceLocator\u003dspy(psl);\n    Map\u003cString,byte[]\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"some.sensitive.prop\",\"theSensitiveValue\".getBytes());\n    data.put(\"some.sensitive.number\",\"1\".getBytes());\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(new V1Secret().metadata(new V1ObjectMeta().name(\"my-secret\")).data(data));\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(secretList))));\n    PropertySource\u003c?\u003e propertySource\u003dAssertions.assertDoesNotThrow(() -\u003e propertySourceLocator.locate(new MockEnvironment()));\n    WireMock.verify(1,getRequestedFor(urlEqualTo(API)));\n    assertThat(propertySource.getProperty(\"some.sensitive.prop\")).isEqualTo(\"theSensitiveValue\");\n    assertThat(propertySource.getProperty(\"some.sensitive.number\")).isEqualTo(\"1\");\n  }\n  @Test void locateShouldRetryAndRecover(){\n    SecretsPropertySourceLocator propertySourceLocator\u003dspy(psl);\n    Map\u003cString,byte[]\u003e data\u003dnew HashMap\u003c\u003e();\n    data.put(\"some.sensitive.prop\",\"theSensitiveValue\".getBytes());\n    data.put(\"some.sensitive.number\",\"1\".getBytes());\n    V1SecretList secretList\u003dnew V1SecretList().addItemsItem(new V1Secret().metadata(new V1ObjectMeta().name(\"my-secret\")).data(data));\n    stubFor(get(API).inScenario(\"Retry and Recover\").whenScenarioStateIs(STARTED).willReturn(aResponse().withStatus(500)).willSetStateTo(\"Failed once\"));\n    stubFor(get(API).inScenario(\"Retry and Recover\").whenScenarioStateIs(\"Failed once\").willReturn(aResponse().withStatus(500)).willSetStateTo(\"Failed twice\"));\n    stubFor(get(API).inScenario(\"Retry and Recover\").whenScenarioStateIs(\"Failed twice\").willReturn(aResponse().withStatus(500)).willSetStateTo(\"Failed thrice\"));\n    stubFor(get(API).inScenario(\"Retry and Recover\").whenScenarioStateIs(\"Failed thrice\").willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(secretList))));\n    PropertySource\u003c?\u003e propertySource\u003dAssertions.assertDoesNotThrow(() -\u003e propertySourceLocator.locate(new MockEnvironment()));\n    WireMock.verify(4,getRequestedFor(urlEqualTo(API)));\n    assertThat(propertySource.getProperty(\"some.sensitive.prop\")).isEqualTo(\"theSensitiveValue\");\n    assertThat(propertySource.getProperty(\"some.sensitive.number\")).isEqualTo(\"1\");\n  }\n  @Test void locateShouldRetryAndFail(){\n    SecretsPropertySourceLocator propertySourceLocator\u003dspy(psl);\n    stubFor(get(API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    assertThatThrownBy(() -\u003e propertySourceLocator.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessage(\"Internal Server Error\");\n    WireMock.verify(5,getRequestedFor(urlEqualTo(API)));\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.max-attempts\u003d5\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dSecretsRetryApplication.class) class SecretsRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup();\n  private static void stubConfigMapAndSecretsDefaults();\n  @AfterAll static void teardown();\n  @Autowired private SecretsPropertySourceLocator psl;\n  @BeforeEach void afterEach();\n  @Test void locateShouldNotRetryWhenThereIsNoFailure();\n  @Test void locateShouldRetryAndRecover();\n  @Test void locateShouldRetryAndFail();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/secrets_retry/SecretsFailFastEnabledButRetryDisabled.java",
        "name": "SecretsFailFastEnabledButRetryDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dSecretsRetryApplication.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.secrets_retry.SecretsFailFastEnabledButRetryDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dSecretsRetryApplication.class) class SecretsFailFastEnabledButRetryDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final String CONFIG_MAPS_API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"default\");\n    stubConfigMapAndSecretsDefaults();\n  }\n  private static void stubConfigMapAndSecretsDefaults(){\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1SecretList()))));\n    stubFor(get(CONFIG_MAPS_API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1ConfigMapList()))));\n  }\n  @AfterAll static void teardown(){\n    wireMockServer.stop();\n    clientUtilsMock.close();\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n    stubConfigMapAndSecretsDefaults();\n  }\n  @Autowired private KubernetesClientSecretsPropertySourceLocator psl;\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying(){\n    KubernetesClientSecretsPropertySourceLocator propertySourceLocator\u003dspy(psl);\n    stubFor(get(API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    assertThat(context.containsBean(\"kubernetesSecretsRetryInterceptor\")).isFalse();\n    assertThatThrownBy(() -\u003e propertySourceLocator.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessage(\"Internal Server Error\");\n    verify(propertySourceLocator,times(1)).locate(any());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dSecretsRetryApplication.class) class SecretsFailFastEnabledButRetryDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final String CONFIG_MAPS_API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup();\n  private static void stubConfigMapAndSecretsDefaults();\n  @AfterAll static void teardown();\n  @AfterEach void afterEach();\n  @Autowired private KubernetesClientSecretsPropertySourceLocator psl;\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/secrets_retry/SecretsFailFastDisabled.java",
        "name": "SecretsFailFastDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dSecretsRetryApplication.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.secrets_retry.SecretsFailFastDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dSecretsRetryApplication.class) class SecretsFailFastDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build());\n    stubConfigMapAndSecretsDefaults();\n  }\n  private static void stubConfigMapAndSecretsDefaults(){\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1SecretList()))));\n  }\n  @AfterAll static void teardown(){\n    wireMockServer.stop();\n    clientUtilsMock.close();\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n    stubConfigMapAndSecretsDefaults();\n  }\n  @Autowired private KubernetesClientSecretsPropertySourceLocator psl;\n  @Test void locateShouldNotRetry(){\n    KubernetesClientSecretsPropertySourceLocator propertySourceLocator\u003dspy(psl);\n    stubFor(get(API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    Assertions.assertDoesNotThrow(() -\u003e propertySourceLocator.locate(new MockEnvironment()));\n    verify(propertySourceLocator,times(1)).locate(any());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.client.namespace\u003ddefault\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dSecretsRetryApplication.class) class SecretsFailFastDisabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup();\n  private static void stubConfigMapAndSecretsDefaults();\n  @AfterAll static void teardown();\n  @AfterEach void afterEach();\n  @Autowired private KubernetesClientSecretsPropertySourceLocator psl;\n  @Test void locateShouldNotRetry();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/secrets_retry/SecretsEnableRetryWithoutFailFastTest.java",
        "name": "SecretsEnableRetryWithoutFailFastTest",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.secrets_retry.SecretsEnableRetryWithoutFailFastTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class SecretsEnableRetryWithoutFailFastTest {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static final String SECRETS_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private ConfigurableApplicationContext context;\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll public static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build());\n    stubConfigMapAndSecretsDefaults();\n  }\n  private static void stubConfigMapAndSecretsDefaults(){\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1ConfigMapList()))));\n    stubFor(get(SECRETS_API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1SecretList()))));\n  }\n  @AfterAll public static void teardown(){\n    wireMockServer.stop();\n    clientUtilsMock.close();\n  }\n  protected void setup(  String... env){\n    List\u003cString\u003e envList\u003d(env !\u003d null) ? new ArrayList\u003c\u003e(Arrays.asList(env)) : new ArrayList\u003c\u003e();\n    envList.add(\"spring.cloud.kubernetes.client.namespace\u003ddefault\");\n    String[] envArray\u003denvList.toArray(new String[0]);\n    context\u003dnew SpringApplicationBuilder(RetryConfiguration.class,PropertyPlaceholderAutoConfiguration.class,ConfigReloadAutoConfiguration.class,RefreshAutoConfiguration.class,EndpointAutoConfiguration.class,InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,ConfigurationPropertiesBindingPostProcessor.class,ConfigurationPropertiesRebinderAutoConfiguration.class,KubernetesClientBootstrapConfiguration.class,KubernetesClientRetryBootstrapConfiguration.class,KubernetesBootstrapConfiguration.class,KubernetesClientConfigReloadAutoConfiguration.class).web(org.springframework.boot.WebApplicationType.NONE).properties(envArray).run();\n  }\n  @AfterEach public void afterEach(){\n    if (this.context !\u003d null) {\n      this.context.close();\n      this.context\u003dnull;\n    }\n  }\n  @Test public void doesNotContainRetryableSecretsPropertySourceLocator() throws Exception {\n    stubFor(get(API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    setup(\"debug\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.test.enable-retry\u003dtrue\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\");\n    assertThat(context.containsBean(\"retryableSecretsPropertySourceLocator\")).isFalse();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class SecretsEnableRetryWithoutFailFastTest {\n  private static final String API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static final String SECRETS_API\u003d\"/api/v1/namespaces/default/secrets\";\n  private ConfigurableApplicationContext context;\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll public static void setup();\n  private static void stubConfigMapAndSecretsDefaults();\n  @AfterAll public static void teardown();\n  protected void setup(  String... env);\n  @AfterEach public void afterEach();\n  @Test public void doesNotContainRetryableSecretsPropertySourceLocator() throws Exception;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/secrets_retry/SecretsRetryDisabledButConfigRetryEnabled.java",
        "name": "SecretsRetryDisabledButConfigRetryEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dSecretsRetryApplication.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.secrets_retry.SecretsRetryDisabledButConfigRetryEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dSecretsRetryApplication.class) class SecretsRetryDisabledButConfigRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final String CONFIG_MAPS_API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    clientUtilsMock\u003dmockStatic(KubernetesClientUtils.class);\n    clientUtilsMock.when(KubernetesClientUtils::kubernetesApiClient).thenReturn(new ClientBuilder().setBasePath(wireMockServer.baseUrl()).build());\n    clientUtilsMock.when(() -\u003e KubernetesClientUtils.getApplicationNamespace(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(\"default\");\n    stubConfigMapAndSecretsDefaults();\n  }\n  private static void stubConfigMapAndSecretsDefaults(){\n    stubFor(get(API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1SecretList()))));\n    stubFor(get(CONFIG_MAPS_API).willReturn(aResponse().withStatus(200).withBody(new JSON().serialize(new V1ConfigMapList()))));\n  }\n  @AfterAll static void teardown(){\n    wireMockServer.stop();\n    clientUtilsMock.close();\n  }\n  @AfterEach void afterEach(){\n    WireMock.reset();\n    stubConfigMapAndSecretsDefaults();\n  }\n  @Autowired private KubernetesClientSecretsPropertySourceLocator psl;\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying(){\n    KubernetesClientSecretsPropertySourceLocator propertySourceLocator\u003dspy(psl);\n    stubFor(get(API).willReturn(aResponse().withStatus(500).withBody(\"Internal Server Error\")));\n    assertThatThrownBy(() -\u003e propertySourceLocator.locate(new MockEnvironment())).isInstanceOf(IllegalStateException.class).hasMessage(\"Internal Server Error\");\n    verify(propertySourceLocator,times(1)).locate(any());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.name\u003dmy-secret\",\"spring.cloud.kubernetes.secrets.enable-api\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.config.import\u003dkubernetes:\"},classes\u003dSecretsRetryApplication.class) class SecretsRetryDisabledButConfigRetryEnabled {\n  private static final String API\u003d\"/api/v1/namespaces/default/secrets\";\n  private static final String CONFIG_MAPS_API\u003d\"/api/v1/namespaces/default/configmaps\";\n  private static WireMockServer wireMockServer;\n  private static MockedStatic\u003cKubernetesClientUtils\u003e clientUtilsMock;\n  @BeforeAll static void setup();\n  private static void stubConfigMapAndSecretsDefaults();\n  @AfterAll static void teardown();\n  @AfterEach void afterEach();\n  @Autowired private KubernetesClientSecretsPropertySourceLocator psl;\n  @Autowired private ApplicationContext context;\n  @Test void locateShouldFailWithoutRetrying();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-client-config/src/test/java/org/springframework/cloud/kubernetes/client/config/secrets_retry/SecretsRetryApplication.java",
        "name": "SecretsRetryApplication",
        "modifiers": "@SpringBootApplication",
        "qualified_name": "org.springframework.cloud.kubernetes.client.config.secrets_retry.SecretsRetryApplication",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication class SecretsRetryApplication {\n}\n",
        "abstract": "@SpringBootApplication class SecretsRetryApplication {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/.mvn/wrapper/MavenWrapperDownloader.java",
        "name": "MavenWrapperDownloader",
        "modifiers": "public",
        "qualified_name": "MavenWrapperDownloader",
        "extend": "",
        "implements": "",
        "raw": "public class MavenWrapperDownloader {\n  /** \n * Default URL to download the maven-wrapper.jar from, if no \u0027downloadUrl\u0027 is provided.\n */\n  private static final String DEFAULT_DOWNLOAD_URL\u003d\"https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.4.2/maven-wrapper-0.4.2.jar\";\n  /** \n * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to use instead of the default one.\n */\n  private static final String MAVEN_WRAPPER_PROPERTIES_PATH\u003d\".mvn/wrapper/maven-wrapper.properties\";\n  /** \n * Path where the maven-wrapper.jar will be saved to.\n */\n  private static final String MAVEN_WRAPPER_JAR_PATH\u003d\".mvn/wrapper/maven-wrapper.jar\";\n  /** \n * Name of the property which should be used to override the default download url for the wrapper.\n */\n  private static final String PROPERTY_NAME_WRAPPER_URL\u003d\"wrapperUrl\";\n  public static void main(  String args[]){\n    System.out.println(\"- Downloader started\");\n    File baseDirectory\u003dnew File(args[0]);\n    System.out.println(\"- Using base directory: \" + baseDirectory.getAbsolutePath());\n    File mavenWrapperPropertyFile\u003dnew File(baseDirectory,MAVEN_WRAPPER_PROPERTIES_PATH);\n    String url\u003dDEFAULT_DOWNLOAD_URL;\n    if (mavenWrapperPropertyFile.exists()) {\n      FileInputStream mavenWrapperPropertyFileInputStream\u003dnull;\n      try {\n        mavenWrapperPropertyFileInputStream\u003dnew FileInputStream(mavenWrapperPropertyFile);\n        Properties mavenWrapperProperties\u003dnew Properties();\n        mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);\n        url\u003dmavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL,url);\n      }\n catch (      IOException e) {\n        System.out.println(\"- ERROR loading \u0027\" + MAVEN_WRAPPER_PROPERTIES_PATH + \"\u0027\");\n      }\n finally {\n        try {\n          if (mavenWrapperPropertyFileInputStream !\u003d null) {\n            mavenWrapperPropertyFileInputStream.close();\n          }\n        }\n catch (        IOException e) {\n        }\n      }\n    }\n    System.out.println(\"- Downloading from: : \" + url);\n    File outputFile\u003dnew File(baseDirectory.getAbsolutePath(),MAVEN_WRAPPER_JAR_PATH);\n    if (!outputFile.getParentFile().exists()) {\n      if (!outputFile.getParentFile().mkdirs()) {\n        System.out.println(\"- ERROR creating output direcrory \u0027\" + outputFile.getParentFile().getAbsolutePath() + \"\u0027\");\n      }\n    }\n    System.out.println(\"- Downloading to: \" + outputFile.getAbsolutePath());\n    try {\n      downloadFileFromURL(url,outputFile);\n      System.out.println(\"Done\");\n      System.exit(0);\n    }\n catch (    Throwable e) {\n      System.out.println(\"- Error downloading\");\n      e.printStackTrace();\n      System.exit(1);\n    }\n  }\n  private static void downloadFileFromURL(  String urlString,  File destination) throws Exception {\n    URL website\u003dnew URL(urlString);\n    ReadableByteChannel rbc;\n    rbc\u003dChannels.newChannel(website.openStream());\n    FileOutputStream fos\u003dnew FileOutputStream(destination);\n    fos.getChannel().transferFrom(rbc,0,Long.MAX_VALUE);\n    fos.close();\n    rbc.close();\n  }\n}\n",
        "abstract": "public class MavenWrapperDownloader {\n  /** \n * Default URL to download the maven-wrapper.jar from, if no \u0027downloadUrl\u0027 is provided.\n */\n  private static final String DEFAULT_DOWNLOAD_URL\u003d\"https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.4.2/maven-wrapper-0.4.2.jar\";\n  /** \n * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to use instead of the default one.\n */\n  private static final String MAVEN_WRAPPER_PROPERTIES_PATH\u003d\".mvn/wrapper/maven-wrapper.properties\";\n  /** \n * Path where the maven-wrapper.jar will be saved to.\n */\n  private static final String MAVEN_WRAPPER_JAR_PATH\u003d\".mvn/wrapper/maven-wrapper.jar\";\n  /** \n * Name of the property which should be used to override the default download url for the wrapper.\n */\n  private static final String PROPERTY_NAME_WRAPPER_URL\u003d\"wrapperUrl\";\n  public static void main(  String args[]);\n  private static void downloadFileFromURL(  String urlString,  File destination) throws Exception;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/main/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/Fabric8LoadBalancerAutoConfiguration.java",
        "name": "Fabric8LoadBalancerAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @EnableConfigurationProperties(KubernetesLoadBalancerProperties.class) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesLoadBalancerEnabled @LoadBalancerClients(defaultConfiguration\u003dFabric8LoadBalancerClientConfiguration.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.Fabric8LoadBalancerAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Kubernetes load balancer auto-configuration.\n * @author Piotr Minkowski\n */\n@Configuration(proxyBeanMethods\u003dfalse) @EnableConfigurationProperties(KubernetesLoadBalancerProperties.class) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesLoadBalancerEnabled @LoadBalancerClients(defaultConfiguration\u003dFabric8LoadBalancerClientConfiguration.class) public class Fabric8LoadBalancerAutoConfiguration {\n  @Bean Fabric8ServiceInstanceMapper mapper(  KubernetesLoadBalancerProperties properties,  KubernetesDiscoveryProperties discoveryProperties){\n    return new Fabric8ServiceInstanceMapper(properties,discoveryProperties);\n  }\n}\n",
        "abstract": "/** \n * Kubernetes load balancer auto-configuration.\n * @author Piotr Minkowski\n */\n@Configuration(proxyBeanMethods\u003dfalse) @EnableConfigurationProperties(KubernetesLoadBalancerProperties.class) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesLoadBalancerEnabled @LoadBalancerClients(defaultConfiguration\u003dFabric8LoadBalancerClientConfiguration.class) public class Fabric8LoadBalancerAutoConfiguration {\n  @Bean Fabric8ServiceInstanceMapper mapper(  KubernetesLoadBalancerProperties properties,  KubernetesDiscoveryProperties discoveryProperties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/main/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/Fabric8ServiceInstanceMapper.java",
        "name": "Fabric8ServiceInstanceMapper",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.Fabric8ServiceInstanceMapper",
        "extend": "",
        "implements": "KubernetesServiceInstanceMapper\u003cService\u003e",
        "raw": "/** \n * Class for mapping Kubernetes Service object into  {@link KubernetesServiceInstance}.\n * @author Piotr Minkowski\n */\npublic class Fabric8ServiceInstanceMapper implements KubernetesServiceInstanceMapper\u003cService\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8ServiceInstanceMapper.class));\n  /** \n * empty on purpose, load balancer implementation does not need them.\n */\n  private static final Map\u003cString,Integer\u003e PORTS_DATA\u003dMap.of();\n  private final KubernetesLoadBalancerProperties properties;\n  private final KubernetesDiscoveryProperties discoveryProperties;\n  private final ServicePortSecureResolver resolver;\n  Fabric8ServiceInstanceMapper(  KubernetesLoadBalancerProperties properties,  KubernetesDiscoveryProperties discoveryProperties){\n    this.properties\u003dproperties;\n    this.discoveryProperties\u003ddiscoveryProperties;\n    resolver\u003dnew ServicePortSecureResolver(discoveryProperties);\n  }\n  @Override public KubernetesServiceInstance map(  Service service){\n    ObjectMeta metadata\u003dservice.getMetadata();\n    List\u003cServicePort\u003e ports\u003dservice.getSpec().getPorts();\n    ServicePort port;\n    if (ports.isEmpty()) {\n      LOG.warn(() -\u003e \"service : \" + metadata.getName() + \" does not have any ServicePort(s),\"+ \" will not consider it for load balancing\");\n      return null;\n    }\n    if (ports.size() \u003d\u003d 1) {\n      LOG.debug(() -\u003e \"single ServicePort found, will use it as-is \" + \"(without checking \" + PORT_NAME_PROPERTY + \")\");\n      port\u003dports.get(0);\n    }\n else {\n      String portNameFromProperties\u003dproperties.getPortName();\n      if (StringUtils.hasText(portNameFromProperties)) {\n        Optional\u003cServicePort\u003e optionalPort\u003dports.stream().filter(x -\u003e Objects.equals(x.getName(),portNameFromProperties)).findAny();\n        if (optionalPort.isPresent()) {\n          LOG.debug(() -\u003e \"found port name that matches : \" + portNameFromProperties);\n          port\u003doptionalPort.get();\n        }\n else {\n          logWarning(portNameFromProperties);\n          port\u003dports.get(0);\n        }\n      }\n else {\n        LOG.warn(() -\u003e PORT_NAME_PROPERTY + \" is not set\");\n        LOG.warn(() -\u003e NON_DETERMINISTIC_PORT_MESSAGE);\n        port\u003dports.get(0);\n      }\n    }\n    String host\u003dKubernetesServiceInstanceMapper.createHost(service.getMetadata().getName(),service.getMetadata().getNamespace(),properties.getClusterDomain());\n    boolean secure\u003dsecure(port,service);\n    return new DefaultKubernetesServiceInstance(metadata.getUid(),metadata.getName(),host,port.getPort(),serviceMetadata(service),secure);\n  }\n  Map\u003cString,String\u003e serviceMetadata(  Service service){\n    ServiceMetadata serviceMetadata\u003dFabric8Utils.serviceMetadata(service);\n    return DiscoveryClientUtils.serviceInstanceMetadata(PORTS_DATA,serviceMetadata,discoveryProperties);\n  }\n  private boolean secure(  ServicePort port,  Service service){\n    ObjectMeta metadata\u003dservice.getMetadata();\n    ServicePortNameAndNumber portNameAndNumber\u003dnew ServicePortNameAndNumber(port.getPort(),port.getName());\n    Input input\u003dnew Input(portNameAndNumber,metadata.getName(),metadata.getLabels(),metadata.getAnnotations());\n    return resolver.resolve(input);\n  }\n  private void logWarning(  String portNameFromProperties){\n    LOG.warn(() -\u003e \"Did not find a port name that is equal to the value \" + portNameFromProperties);\n    LOG.warn(() -\u003e NON_DETERMINISTIC_PORT_MESSAGE);\n  }\n}\n",
        "abstract": "/** \n * Class for mapping Kubernetes Service object into  {@link KubernetesServiceInstance}.\n * @author Piotr Minkowski\n */\npublic class Fabric8ServiceInstanceMapper implements KubernetesServiceInstanceMapper\u003cService\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8ServiceInstanceMapper.class));\n  /** \n * empty on purpose, load balancer implementation does not need them.\n */\n  private static final Map\u003cString,Integer\u003e PORTS_DATA\u003dMap.of();\n  private final KubernetesLoadBalancerProperties properties;\n  private final KubernetesDiscoveryProperties discoveryProperties;\n  private final ServicePortSecureResolver resolver;\n  Fabric8ServiceInstanceMapper(  KubernetesLoadBalancerProperties properties,  KubernetesDiscoveryProperties discoveryProperties);\n  @Override public KubernetesServiceInstance map(  Service service);\n  Map\u003cString,String\u003e serviceMetadata(  Service service);\n  private boolean secure(  ServicePort port,  Service service);\n  private void logWarning(  String portNameFromProperties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/main/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/Fabric8ServicesListSupplier.java",
        "name": "Fabric8ServicesListSupplier",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.Fabric8ServicesListSupplier",
        "extend": "KubernetesServicesListSupplier\u003cService\u003e",
        "implements": "",
        "raw": "/** \n * Implementation of  {@link ServiceInstanceListSupplier} for load balancer in SERVICEmode.\n * @author Piotr Minkowski\n */\npublic class Fabric8ServicesListSupplier extends KubernetesServicesListSupplier\u003cService\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8ServicesListSupplier.class));\n  private final KubernetesClient kubernetesClient;\n  private final KubernetesNamespaceProvider namespaceProvider;\n  Fabric8ServicesListSupplier(  Environment environment,  KubernetesClient kubernetesClient,  Fabric8ServiceInstanceMapper mapper,  KubernetesDiscoveryProperties discoveryProperties){\n    super(environment,mapper,discoveryProperties);\n    this.kubernetesClient\u003dkubernetesClient;\n    namespaceProvider\u003dnew KubernetesNamespaceProvider(environment);\n  }\n  @Override public Flux\u003cList\u003cServiceInstance\u003e\u003e get(){\n    List\u003cServiceInstance\u003e result\u003dnew ArrayList\u003c\u003e();\n    String serviceName\u003dgetServiceId();\n    LOG.debug(() -\u003e \"serviceID : \" + serviceName);\n    if (discoveryProperties.allNamespaces()) {\n      LOG.debug(() -\u003e \"discovering services in all namespaces\");\n      List\u003cService\u003e services\u003dkubernetesClient.services().inAnyNamespace().withField(\"metadata.name\",serviceName).list().getItems();\n      services.forEach(service -\u003e addMappedService(mapper,result,service));\n    }\n else     if (!discoveryProperties.namespaces().isEmpty()) {\n      List\u003cString\u003e selectiveNamespaces\u003ddiscoveryProperties.namespaces().stream().sorted().toList();\n      LOG.debug(() -\u003e \"discovering services in selective namespaces : \" + selectiveNamespaces);\n      selectiveNamespaces.forEach(selectiveNamespace -\u003e {\n        Service service\u003dkubernetesClient.services().inNamespace(selectiveNamespace).withName(serviceName).get();\n        if (service !\u003d null) {\n          addMappedService(mapper,result,service);\n        }\n else {\n          LOG.debug(() -\u003e \"did not find service with name : \" + serviceName + \" in namespace : \"+ selectiveNamespace);\n        }\n      }\n);\n    }\n else {\n      String namespace\u003dFabric8Utils.getApplicationNamespace(kubernetesClient,null,\"loadbalancer-service\",namespaceProvider);\n      LOG.debug(() -\u003e \"discovering services in namespace : \" + namespace);\n      Service service\u003dkubernetesClient.services().inNamespace(namespace).withName(serviceName).get();\n      if (service !\u003d null) {\n        addMappedService(mapper,result,service);\n      }\n else {\n        LOG.debug(() -\u003e \"did not find service with name : \" + serviceName + \" in namespace : \"+ namespace);\n      }\n    }\n    LOG.debug(() -\u003e \"found services : \" + result);\n    return Flux.defer(() -\u003e Flux.just(result));\n  }\n  private void addMappedService(  KubernetesServiceInstanceMapper\u003cService\u003e mapper,  List\u003cServiceInstance\u003e services,  Service service){\n    services.add(mapper.map(service));\n  }\n}\n",
        "abstract": "/** \n * Implementation of  {@link ServiceInstanceListSupplier} for load balancer in SERVICEmode.\n * @author Piotr Minkowski\n */\npublic class Fabric8ServicesListSupplier extends KubernetesServicesListSupplier\u003cService\u003e {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(Fabric8ServicesListSupplier.class));\n  private final KubernetesClient kubernetesClient;\n  private final KubernetesNamespaceProvider namespaceProvider;\n  Fabric8ServicesListSupplier(  Environment environment,  KubernetesClient kubernetesClient,  Fabric8ServiceInstanceMapper mapper,  KubernetesDiscoveryProperties discoveryProperties);\n  @Override public Flux\u003cList\u003cServiceInstance\u003e\u003e get();\n  private void addMappedService(  KubernetesServiceInstanceMapper\u003cService\u003e mapper,  List\u003cServiceInstance\u003e services,  Service service);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/main/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/Fabric8LoadBalancerClientConfiguration.java",
        "name": "Fabric8LoadBalancerClientConfiguration",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.Fabric8LoadBalancerClientConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Kubernetes load balancer client configuration.\n * @author Piotr Minkowski\n */\npublic class Fabric8LoadBalancerClientConfiguration {\n  @Bean @ConditionalOnKubernetesLoadBalancerServiceModeEnabled ServiceInstanceListSupplier kubernetesServicesListSupplier(  Environment environment,  KubernetesClient kubernetesClient,  Fabric8ServiceInstanceMapper mapper,  KubernetesDiscoveryProperties discoveryProperties,  ConfigurableApplicationContext context){\n    return ServiceInstanceListSupplier.builder().withBase(new Fabric8ServicesListSupplier(environment,kubernetesClient,mapper,discoveryProperties)).withCaching().build(context);\n  }\n}\n",
        "abstract": "/** \n * Kubernetes load balancer client configuration.\n * @author Piotr Minkowski\n */\npublic class Fabric8LoadBalancerClientConfiguration {\n  @Bean @ConditionalOnKubernetesLoadBalancerServiceModeEnabled ServiceInstanceListSupplier kubernetesServicesListSupplier(  Environment environment,  KubernetesClient kubernetesClient,  Fabric8ServiceInstanceMapper mapper,  KubernetesDiscoveryProperties discoveryProperties,  ConfigurableApplicationContext context);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/it/Util.java",
        "name": "Util",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.it.Util",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic final class Util {\n  private Util(){\n  }\n  public static Service service(  String namespace,  String name,  int port){\n    return new ServiceBuilder().withNewMetadata().withNamespace(namespace).withName(name).endMetadata().withSpec(new ServiceSpecBuilder().withPorts(new ServicePortBuilder().withName(\"http\").withPort(port).build()).build()).build();\n  }\n  public static Endpoints endpoints(  int port,  String host,  String namespace){\n    return new EndpointsBuilder().withSubsets(new EndpointSubsetBuilder().withPorts(new EndpointPortBuilder().withPort(port).build()).withAddresses(new EndpointAddressBuilder().withIp(host).build()).build()).withMetadata(new ObjectMetaBuilder().withName(\"random-name\").withNamespace(namespace).build()).build();\n  }\n@TestConfiguration public static class LoadBalancerConfiguration {\n    @Bean @LoadBalanced WebClient.Builder client(){\n      return WebClient.builder();\n    }\n  }\n@SpringBootApplication public static class Configuration {\n    public static void main(    String[] args){\n      SpringApplication.run(Configuration.class);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic final class Util {\n  private Util();\n  public static Service service(  String namespace,  String name,  int port);\n  public static Endpoints endpoints(  int port,  String host,  String namespace);\n@TestConfiguration public static class LoadBalancerConfiguration {\n    @Bean @LoadBalanced WebClient.Builder client();\n  }\n@SpringBootApplication public static class Configuration {\n    public static void main(    String[] args);\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/it/mode/service/SpecificNamespaceTest.java",
        "name": "SpecificNamespaceTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003da\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) @ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.it.mode.service.SpecificNamespaceTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003da\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) @ExtendWith(OutputCaptureExtension.class) class SpecificNamespaceTest {\n  private static final String MY_SERVICE_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    serviceAMockServer\u003dnew WireMockServer(SERVICE_A_PORT);\n    serviceAMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_A_PORT);\n    serviceBMockServer\u003dnew WireMockServer(SERVICE_B_PORT);\n    serviceBMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_B_PORT);\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"a\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"b\",\"cluster.local\")).thenReturn(\"localhost\");\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,\"http://localhost:\" + wireMockServer.port());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterAll static void afterAll(){\n    wireMockServer.stop();\n    serviceAMockServer.stop();\n    serviceBMockServer.stop();\n    MOCKED_STATIC.close();\n  }\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - we enable search in namespace \u0027a\u0027 - load balancer mode is \u0027SERVICE\u0027 - as such, only my-service in namespace a is load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the SERVICE mode. \u003c/pre\u003e\n */\n  @Test void test(  CapturedOutput output){\n    Service serviceA\u003dUtil.service(\"a\",\"my-service\",SERVICE_A_PORT);\n    Service serviceB\u003dUtil.service(\"b\",\"my-service\",SERVICE_B_PORT);\n    String serviceAJson\u003dSerialization.asJson(serviceA);\n    String serviceBJson\u003dSerialization.asJson(serviceB);\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/a/services/my-service\")).willReturn(WireMock.aResponse().withBody(serviceAJson).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/b/services/my-service\")).willReturn(WireMock.aResponse().withBody(serviceBJson).withStatus(200)));\n    serviceAMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-a-reached\").withStatus(200)));\n    serviceBMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-b-reached\").withStatus(200)));\n    String serviceAResult\u003dbuilder.baseUrl(MY_SERVICE_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    Assertions.assertThat(serviceAResult).isEqualTo(\"service-a-reached\");\n    CachingServiceInstanceListSupplier supplier\u003d(CachingServiceInstanceListSupplier)loadBalancerClientFactory.getIfAvailable().getProvider(\"my-service\",ServiceInstanceListSupplier.class).getIfAvailable();\n    Assertions.assertThat(supplier.getDelegate().getClass()).isSameAs(Fabric8ServicesListSupplier.class);\n    Assertions.assertThat(output.getOut()).contains(\"serviceID : my-service\");\n    Assertions.assertThat(output.getOut()).contains(\"discovering services in namespace : a\");\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/a/services/my-service\")));\n    wireMockServer.verify(WireMock.exactly(0),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/b/services/my-service\")));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003da\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) @ExtendWith(OutputCaptureExtension.class) class SpecificNamespaceTest {\n  private static final String MY_SERVICE_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - we enable search in namespace \u0027a\u0027 - load balancer mode is \u0027SERVICE\u0027 - as such, only my-service in namespace a is load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the SERVICE mode. \u003c/pre\u003e\n */\n  @Test void test(  CapturedOutput output);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/it/mode/service/AllNamespacesTest.java",
        "name": "AllNamespacesTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dtrue\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) @ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.it.mode.service.AllNamespacesTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dtrue\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) @ExtendWith(OutputCaptureExtension.class) class AllNamespacesTest {\n  private static final String SERVICE_A_URL\u003d\"http://service-a\";\n  private static final String SERVICE_B_URL\u003d\"http://service-b\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    serviceAMockServer\u003dnew WireMockServer(SERVICE_A_PORT);\n    serviceAMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_A_PORT);\n    serviceBMockServer\u003dnew WireMockServer(SERVICE_B_PORT);\n    serviceBMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_B_PORT);\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"service-a\",\"a\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"service-b\",\"b\",\"cluster.local\")).thenReturn(\"localhost\");\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,\"http://localhost:\" + wireMockServer.port());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterAll static void afterAll(){\n    wireMockServer.stop();\n    serviceAMockServer.stop();\n    serviceBMockServer.stop();\n    MOCKED_STATIC.close();\n  }\n  /** \n * \u003cpre\u003e - service-a is present in namespace a with exposed port 8888 - service-b is present in namespace b with exposed port 8889 - we make two calls to them via the load balancer \u003c/pre\u003e\n */\n  @Test void test(  CapturedOutput output){\n    Service serviceA\u003dUtil.service(\"a\",\"service-a\",SERVICE_A_PORT);\n    Service serviceB\u003dUtil.service(\"b\",\"service-b\",SERVICE_B_PORT);\n    String serviceListAJson\u003dSerialization.asJson(new ServiceListBuilder().withItems(serviceA).build());\n    String serviceListBJson\u003dSerialization.asJson(new ServiceListBuilder().withItems(serviceB).build());\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/services?fieldSelector\u003dmetadata.name%3Dservice-a\")).willReturn(WireMock.aResponse().withBody(serviceListAJson).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/services?fieldSelector\u003dmetadata.name%3Dservice-b\")).willReturn(WireMock.aResponse().withBody(serviceListBJson).withStatus(200)));\n    serviceAMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-a-reached\").withStatus(200)));\n    serviceBMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-b-reached\").withStatus(200)));\n    String serviceAResult\u003dbuilder.baseUrl(SERVICE_A_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    Assertions.assertThat(serviceAResult).isEqualTo(\"service-a-reached\");\n    String serviceBResult\u003dbuilder.baseUrl(SERVICE_B_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    Assertions.assertThat(serviceBResult).isEqualTo(\"service-b-reached\");\n    CachingServiceInstanceListSupplier supplierA\u003d(CachingServiceInstanceListSupplier)loadBalancerClientFactory.getIfAvailable().getProvider(\"service-a\",ServiceInstanceListSupplier.class).getIfAvailable();\n    Assertions.assertThat(supplierA.getDelegate().getClass()).isSameAs(Fabric8ServicesListSupplier.class);\n    CachingServiceInstanceListSupplier supplierB\u003d(CachingServiceInstanceListSupplier)loadBalancerClientFactory.getIfAvailable().getProvider(\"service-b\",ServiceInstanceListSupplier.class).getIfAvailable();\n    Assertions.assertThat(supplierB.getDelegate().getClass()).isSameAs(Fabric8ServicesListSupplier.class);\n    Assertions.assertThat(output.getOut()).contains(\"serviceID : service-a\");\n    Assertions.assertThat(output.getOut()).contains(\"serviceID : service-b\");\n    Assertions.assertThat(output.getOut()).contains(\"discovering services in all namespaces\");\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/services?fieldSelector\u003dmetadata.name%3Dservice-a\")));\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/services?fieldSelector\u003dmetadata.name%3Dservice-b\")));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dtrue\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) @ExtendWith(OutputCaptureExtension.class) class AllNamespacesTest {\n  private static final String SERVICE_A_URL\u003d\"http://service-a\";\n  private static final String SERVICE_B_URL\u003d\"http://service-b\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e - service-a is present in namespace a with exposed port 8888 - service-b is present in namespace b with exposed port 8889 - we make two calls to them via the load balancer \u003c/pre\u003e\n */\n  @Test void test(  CapturedOutput output);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/it/mode/service/SelectiveNamespacesTest.java",
        "name": "SelectiveNamespacesTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces.[0]\u003da\",\"spring.cloud.kubernetes.discovery.namespaces.[1]\u003db\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) @ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.it.mode.service.SelectiveNamespacesTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces.[0]\u003da\",\"spring.cloud.kubernetes.discovery.namespaces.[1]\u003db\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) @ExtendWith(OutputCaptureExtension.class) class SelectiveNamespacesTest {\n  private static final String MY_SERVICE_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8887;\n  private static final int SERVICE_B_PORT\u003d8888;\n  private static final int SERVICE_C_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static WireMockServer serviceCMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    serviceAMockServer\u003dnew WireMockServer(SERVICE_A_PORT);\n    serviceAMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_A_PORT);\n    serviceBMockServer\u003dnew WireMockServer(SERVICE_B_PORT);\n    serviceBMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_B_PORT);\n    serviceCMockServer\u003dnew WireMockServer(SERVICE_C_PORT);\n    serviceCMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_C_PORT);\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"a\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"b\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"c\",\"cluster.local\")).thenReturn(\"localhost\");\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,\"http://localhost:\" + wireMockServer.port());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterAll static void afterAll(){\n    wireMockServer.stop();\n    serviceAMockServer.stop();\n    serviceBMockServer.stop();\n    serviceCMockServer.stop();\n    MOCKED_STATIC.close();\n  }\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - my-service is present in \u0027c\u0027 namespace - we enable search in selective namespaces [a, b] - load balancer mode is \u0027SERVICE\u0027 - as such, only service in namespace a and b are load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the SERVICE mode. \u003c/pre\u003e\n */\n  @Test void test(  CapturedOutput output){\n    Service serviceA\u003dUtil.service(\"a\",\"my-service\",SERVICE_A_PORT);\n    Service serviceB\u003dUtil.service(\"b\",\"my-service\",SERVICE_B_PORT);\n    Service serviceC\u003dUtil.service(\"c\",\"my-service\",SERVICE_C_PORT);\n    String serviceAJson\u003dSerialization.asJson(serviceA);\n    String serviceBJson\u003dSerialization.asJson(serviceB);\n    String serviceCJson\u003dSerialization.asJson(serviceC);\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/a/services/my-service\")).willReturn(WireMock.aResponse().withBody(serviceAJson).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/b/services/my-service\")).willReturn(WireMock.aResponse().withBody(serviceBJson).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/c/services/my-service\")).willReturn(WireMock.aResponse().withBody(serviceCJson).withStatus(200)));\n    serviceAMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-a-reached\").withStatus(200)));\n    serviceBMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-b-reached\").withStatus(200)));\n    serviceCMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-c-reached\").withStatus(200)));\n    String firstCallResult\u003dbuilder.baseUrl(MY_SERVICE_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    String secondCallResult\u003dbuilder.baseUrl(MY_SERVICE_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    if (firstCallResult.equals(\"service-a-reached\")) {\n      Assertions.assertThat(secondCallResult).isEqualTo(\"service-b-reached\");\n    }\n else {\n      Assertions.assertThat(firstCallResult).isEqualTo(\"service-b-reached\");\n      Assertions.assertThat(secondCallResult).isEqualTo(\"service-a-reached\");\n    }\n    CachingServiceInstanceListSupplier supplier\u003d(CachingServiceInstanceListSupplier)loadBalancerClientFactory.getIfAvailable().getProvider(\"my-service\",ServiceInstanceListSupplier.class).getIfAvailable();\n    Assertions.assertThat(supplier.getDelegate().getClass()).isSameAs(Fabric8ServicesListSupplier.class);\n    Assertions.assertThat(output.getOut()).contains(\"serviceID : my-service\");\n    Assertions.assertThat(output.getOut()).contains(\"discovering services in selective namespaces : [a, b]\");\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/a/services/my-service\")));\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/b/services/my-service\")));\n    wireMockServer.verify(WireMock.exactly(0),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/c/services/my-service\")));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces.[0]\u003da\",\"spring.cloud.kubernetes.discovery.namespaces.[1]\u003db\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) @ExtendWith(OutputCaptureExtension.class) class SelectiveNamespacesTest {\n  private static final String MY_SERVICE_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8887;\n  private static final int SERVICE_B_PORT\u003d8888;\n  private static final int SERVICE_C_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static WireMockServer serviceCMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - my-service is present in \u0027c\u0027 namespace - we enable search in selective namespaces [a, b] - load balancer mode is \u0027SERVICE\u0027 - as such, only service in namespace a and b are load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the SERVICE mode. \u003c/pre\u003e\n */\n  @Test void test(  CapturedOutput output);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/it/mode/pod/SpecificNamespaceTest.java",
        "name": "SpecificNamespaceTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003da\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.it.mode.pod.SpecificNamespaceTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003da\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class SpecificNamespaceTest {\n  private static final String SERVICE_A_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    serviceAMockServer\u003dnew WireMockServer(SERVICE_A_PORT);\n    serviceAMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_A_PORT);\n    serviceBMockServer\u003dnew WireMockServer(SERVICE_B_PORT);\n    serviceBMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_B_PORT);\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"a\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"b\",\"cluster.local\")).thenReturn(\"localhost\");\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,\"http://localhost:\" + wireMockServer.port());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterAll static void afterAll(){\n    wireMockServer.stop();\n    serviceAMockServer.stop();\n    serviceBMockServer.stop();\n    MOCKED_STATIC.close();\n  }\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - we enable search in namespace \u0027a\u0027 - load balancer mode is \u0027POD\u0027 - as such, only my-service in namespace a is load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the POD mode. \u003c/pre\u003e\n */\n  @Test void test(){\n    Service serviceA\u003dUtil.service(\"a\",\"my-service\",SERVICE_A_PORT);\n    Service serviceB\u003dUtil.service(\"b\",\"my-service\",SERVICE_B_PORT);\n    Endpoints endpointsA\u003dUtil.endpoints(SERVICE_A_PORT,\"127.0.0.1\",\"a\");\n    Endpoints endpointsB\u003dUtil.endpoints(SERVICE_B_PORT,\"127.0.0.1\",\"b\");\n    String endpointsAListAsString\u003dSerialization.asJson(new EndpointsListBuilder().withItems(endpointsA).build());\n    String endpointsBListAsString\u003dSerialization.asJson(new EndpointsListBuilder().withItems(endpointsB).build());\n    String serviceAString\u003dSerialization.asJson(serviceA);\n    String serviceBString\u003dSerialization.asJson(serviceB);\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/a/endpoints?fieldSelector\u003dmetadata.name%3Dmy-service\")).willReturn(WireMock.aResponse().withBody(endpointsAListAsString).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/b/endpoints?fieldSelector\u003dmetadata.name%3Dmy-service\")).willReturn(WireMock.aResponse().withBody(endpointsBListAsString).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/a/services/my-service\")).willReturn(WireMock.aResponse().withBody(serviceAString).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/b/services/my-service\")).willReturn(WireMock.aResponse().withBody(serviceBString).withStatus(200)));\n    serviceAMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-a-reached\").withStatus(200)));\n    serviceBMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-b-reached\").withStatus(200)));\n    String serviceAResult\u003dbuilder.baseUrl(SERVICE_A_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    Assertions.assertThat(serviceAResult).isEqualTo(\"service-a-reached\");\n    CachingServiceInstanceListSupplier supplier\u003d(CachingServiceInstanceListSupplier)loadBalancerClientFactory.getIfAvailable().getProvider(\"my-service\",ServiceInstanceListSupplier.class).getIfAvailable();\n    Assertions.assertThat(supplier.getDelegate().getClass()).isSameAs(DiscoveryClientServiceInstanceListSupplier.class);\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/a/endpoints?fieldSelector\u003dmetadata.name%3Dmy-service\")));\n    wireMockServer.verify(WireMock.exactly(0),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/b/endpoints?fieldSelector\u003dmetadata.name%3Dmy-service\")));\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/a/services/my-service\")));\n    wireMockServer.verify(WireMock.exactly(0),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/b/services/me-service\")));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.client.namespace\u003da\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class SpecificNamespaceTest {\n  private static final String SERVICE_A_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - we enable search in namespace \u0027a\u0027 - load balancer mode is \u0027POD\u0027 - as such, only my-service in namespace a is load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the POD mode. \u003c/pre\u003e\n */\n  @Test void test();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/it/mode/pod/AllNamespacesTest.java",
        "name": "AllNamespacesTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dtrue\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.it.mode.pod.AllNamespacesTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dtrue\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class AllNamespacesTest {\n  private static final String SERVICE_A_URL\u003d\"http://service-a\";\n  private static final String SERVICE_B_URL\u003d\"http://service-b\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    serviceAMockServer\u003dnew WireMockServer(SERVICE_A_PORT);\n    serviceAMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_A_PORT);\n    serviceBMockServer\u003dnew WireMockServer(SERVICE_B_PORT);\n    serviceBMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_B_PORT);\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"service-a\",\"a\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"service-b\",\"b\",\"cluster.local\")).thenReturn(\"localhost\");\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,\"http://localhost:\" + wireMockServer.port());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterAll static void afterAll(){\n    wireMockServer.stop();\n    serviceAMockServer.stop();\n    serviceBMockServer.stop();\n    MOCKED_STATIC.close();\n  }\n  /** \n * \u003cpre\u003e - service-a is present in namespace a with exposed port 8888 - service-b is present in namespace b with exposed port 8889 - we make two calls to them via the load balancer \u003c/pre\u003e\n */\n  @Test void test(){\n    Service serviceA\u003dUtil.service(\"a\",\"service-a\",SERVICE_A_PORT);\n    Service serviceB\u003dUtil.service(\"b\",\"service-b\",SERVICE_B_PORT);\n    Endpoints endpointsA\u003dUtil.endpoints(SERVICE_A_PORT,\"127.0.0.1\",\"a\");\n    Endpoints endpointsB\u003dUtil.endpoints(SERVICE_B_PORT,\"127.0.0.1\",\"b\");\n    String endpointsAListAsString\u003dSerialization.asJson(new EndpointsListBuilder().withItems(endpointsA).build());\n    String endpointsBListAsString\u003dSerialization.asJson(new EndpointsListBuilder().withItems(endpointsB).build());\n    String serviceAString\u003dSerialization.asJson(serviceA);\n    String serviceBString\u003dSerialization.asJson(serviceB);\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/endpoints?fieldSelector\u003dmetadata.name%3Dservice-a\")).willReturn(WireMock.aResponse().withBody(endpointsAListAsString).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/endpoints?fieldSelector\u003dmetadata.name%3Dservice-b\")).willReturn(WireMock.aResponse().withBody(endpointsBListAsString).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/a/services/service-a\")).willReturn(WireMock.aResponse().withBody(serviceAString).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/b/services/service-b\")).willReturn(WireMock.aResponse().withBody(serviceBString).withStatus(200)));\n    serviceAMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-a-reached\").withStatus(200)));\n    serviceBMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-b-reached\").withStatus(200)));\n    String serviceAResult\u003dbuilder.baseUrl(SERVICE_A_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    Assertions.assertThat(serviceAResult).isEqualTo(\"service-a-reached\");\n    String serviceBResult\u003dbuilder.baseUrl(SERVICE_B_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    Assertions.assertThat(serviceBResult).isEqualTo(\"service-b-reached\");\n    CachingServiceInstanceListSupplier supplier\u003d(CachingServiceInstanceListSupplier)loadBalancerClientFactory.getIfAvailable().getProvider(\"service-a\",ServiceInstanceListSupplier.class).getIfAvailable();\n    Assertions.assertThat(supplier.getDelegate().getClass()).isSameAs(DiscoveryClientServiceInstanceListSupplier.class);\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/endpoints?fieldSelector\u003dmetadata.name%3Dservice-a\")));\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/endpoints?fieldSelector\u003dmetadata.name%3Dservice-b\")));\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/a/services/service-a\")));\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/b/services/service-b\")));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dtrue\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class AllNamespacesTest {\n  private static final String SERVICE_A_URL\u003d\"http://service-a\";\n  private static final String SERVICE_B_URL\u003d\"http://service-b\";\n  private static final int SERVICE_A_PORT\u003d8888;\n  private static final int SERVICE_B_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e - service-a is present in namespace a with exposed port 8888 - service-b is present in namespace b with exposed port 8889 - we make two calls to them via the load balancer \u003c/pre\u003e\n */\n  @Test void test();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/it/mode/pod/SelectiveNamespacesTest.java",
        "name": "SelectiveNamespacesTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces.[0]\u003da\",\"spring.cloud.kubernetes.discovery.namespaces.[1]\u003db\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.it.mode.pod.SelectiveNamespacesTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces.[0]\u003da\",\"spring.cloud.kubernetes.discovery.namespaces.[1]\u003db\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class SelectiveNamespacesTest {\n  private static final String MY_SERVICE_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8887;\n  private static final int SERVICE_B_PORT\u003d8888;\n  private static final int SERVICE_C_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static WireMockServer serviceCMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(\"localhost\",wireMockServer.port());\n    serviceAMockServer\u003dnew WireMockServer(SERVICE_A_PORT);\n    serviceAMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_A_PORT);\n    serviceBMockServer\u003dnew WireMockServer(SERVICE_B_PORT);\n    serviceBMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_B_PORT);\n    serviceCMockServer\u003dnew WireMockServer(SERVICE_C_PORT);\n    serviceCMockServer.start();\n    WireMock.configureFor(\"localhost\",SERVICE_C_PORT);\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"a\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"b\",\"cluster.local\")).thenReturn(\"localhost\");\n    MOCKED_STATIC.when(() -\u003e KubernetesServiceInstanceMapper.createHost(\"my-service\",\"c\",\"cluster.local\")).thenReturn(\"localhost\");\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,\"http://localhost:\" + wireMockServer.port());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterAll static void afterAll(){\n    wireMockServer.stop();\n    serviceAMockServer.stop();\n    serviceBMockServer.stop();\n    serviceCMockServer.stop();\n    MOCKED_STATIC.close();\n  }\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - my-service is present in \u0027c\u0027 namespace - we enable search in selective namespaces [a, b] - load balancer mode is \u0027POD\u0027 - as such, only service in namespace a and b are load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the POD mode. \u003c/pre\u003e\n */\n  @Test void test(){\n    Service serviceA\u003dUtil.service(\"a\",\"my-service\",SERVICE_A_PORT);\n    Service serviceB\u003dUtil.service(\"b\",\"my-service\",SERVICE_B_PORT);\n    Service serviceC\u003dUtil.service(\"c\",\"my-service\",SERVICE_C_PORT);\n    Endpoints endpointsA\u003dUtil.endpoints(SERVICE_A_PORT,\"127.0.0.1\",\"a\");\n    Endpoints endpointsB\u003dUtil.endpoints(SERVICE_B_PORT,\"127.0.0.1\",\"b\");\n    Endpoints endpointsC\u003dUtil.endpoints(SERVICE_C_PORT,\"127.0.0.1\",\"c\");\n    String serviceAJson\u003dSerialization.asJson(serviceA);\n    String serviceBJson\u003dSerialization.asJson(serviceB);\n    String serviceCJson\u003dSerialization.asJson(serviceC);\n    String endpointsAListAsString\u003dSerialization.asJson(new EndpointsListBuilder().withItems(endpointsA).build());\n    String endpointsBListAsString\u003dSerialization.asJson(new EndpointsListBuilder().withItems(endpointsB).build());\n    String endpointsCListAsString\u003dSerialization.asJson(new EndpointsListBuilder().withItems(endpointsC).build());\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/a/services/my-service\")).willReturn(WireMock.aResponse().withBody(serviceAJson).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/b/services/my-service\")).willReturn(WireMock.aResponse().withBody(serviceBJson).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/c/services/my-service\")).willReturn(WireMock.aResponse().withBody(serviceCJson).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/a/endpoints?fieldSelector\u003dmetadata.name%3Dmy-service\")).willReturn(WireMock.aResponse().withBody(endpointsAListAsString).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/b/endpoints?fieldSelector\u003dmetadata.name%3Dmy-service\")).willReturn(WireMock.aResponse().withBody(endpointsBListAsString).withStatus(200)));\n    wireMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/api/v1/namespaces/c/endpoints?fieldSelector\u003dmetadata.name%3Dmy-service\")).willReturn(WireMock.aResponse().withBody(endpointsCListAsString).withStatus(200)));\n    serviceAMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-a-reached\").withStatus(200)));\n    serviceBMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-b-reached\").withStatus(200)));\n    serviceCMockServer.stubFor(WireMock.get(WireMock.urlEqualTo(\"/\")).willReturn(WireMock.aResponse().withBody(\"service-c-reached\").withStatus(200)));\n    String firstCallResult\u003dbuilder.baseUrl(MY_SERVICE_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    String secondCallResult\u003dbuilder.baseUrl(MY_SERVICE_URL).build().method(HttpMethod.GET).retrieve().bodyToMono(String.class).block();\n    if (firstCallResult.equals(\"service-a-reached\")) {\n      Assertions.assertThat(secondCallResult).isEqualTo(\"service-b-reached\");\n    }\n else {\n      Assertions.assertThat(firstCallResult).isEqualTo(\"service-b-reached\");\n      Assertions.assertThat(secondCallResult).isEqualTo(\"service-a-reached\");\n    }\n    CachingServiceInstanceListSupplier supplier\u003d(CachingServiceInstanceListSupplier)loadBalancerClientFactory.getIfAvailable().getProvider(\"my-service\",ServiceInstanceListSupplier.class).getIfAvailable();\n    Assertions.assertThat(supplier.getDelegate().getClass()).isSameAs(DiscoveryClientServiceInstanceListSupplier.class);\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/a/services/my-service\")));\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/b/services/my-service\")));\n    wireMockServer.verify(WireMock.exactly(0),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/c/services/my-service\")));\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/a/endpoints?fieldSelector\u003dmetadata.name%3Dmy-service\")));\n    wireMockServer.verify(WireMock.exactly(1),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/b/endpoints?fieldSelector\u003dmetadata.name%3Dmy-service\")));\n    wireMockServer.verify(WireMock.exactly(0),WireMock.getRequestedFor(WireMock.urlEqualTo(\"/api/v1/namespaces/c/endpoints?fieldSelector\u003dmetadata.name%3Dmy-service\")));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.cloud.kubernetes.loadbalancer.mode\u003dPOD\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.all-namespaces\u003dfalse\",\"spring.cloud.kubernetes.discovery.namespaces.[0]\u003da\",\"spring.cloud.kubernetes.discovery.namespaces.[1]\u003db\"},classes\u003d{LoadBalancerConfiguration.class,Configuration.class}) class SelectiveNamespacesTest {\n  private static final String MY_SERVICE_URL\u003d\"http://my-service\";\n  private static final int SERVICE_A_PORT\u003d8887;\n  private static final int SERVICE_B_PORT\u003d8888;\n  private static final int SERVICE_C_PORT\u003d8889;\n  private static WireMockServer wireMockServer;\n  private static WireMockServer serviceAMockServer;\n  private static WireMockServer serviceBMockServer;\n  private static WireMockServer serviceCMockServer;\n  private static final MockedStatic\u003cKubernetesServiceInstanceMapper\u003e MOCKED_STATIC\u003dMockito.mockStatic(KubernetesServiceInstanceMapper.class);\n  @Autowired private WebClient.Builder builder;\n  @Autowired private ObjectProvider\u003cLoadBalancerClientFactory\u003e loadBalancerClientFactory;\n  @BeforeAll static void beforeAll();\n  @AfterAll static void afterAll();\n  /** \n * \u003cpre\u003e - my-service is present in \u0027a\u0027 namespace - my-service is present in \u0027b\u0027 namespace - my-service is present in \u0027c\u0027 namespace - we enable search in selective namespaces [a, b] - load balancer mode is \u0027POD\u0027 - as such, only service in namespace a and b are load balanced - we also assert the type of ServiceInstanceListSupplier corresponding to the POD mode. \u003c/pre\u003e\n */\n  @Test void test();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/Fabric8ServiceInstanceMapperTests.java",
        "name": "Fabric8ServiceInstanceMapperTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.Fabric8ServiceInstanceMapperTests",
        "extend": "",
        "implements": "",
        "raw": "@ExtendWith(OutputCaptureExtension.class) class Fabric8ServiceInstanceMapperTests {\n  @Test void testMapperSimple(){\n    KubernetesLoadBalancerProperties properties\u003dnew KubernetesLoadBalancerProperties();\n    Service service\u003dbuildService(\"test\",\"test-namespace\",\"abc\",8080,null,Map.of());\n    KubernetesServiceInstance instance\u003dnew Fabric8ServiceInstanceMapper(properties,KubernetesDiscoveryProperties.DEFAULT).map(service);\n    Assertions.assertNotNull(instance);\n    Assertions.assertEquals(\"test\",instance.getServiceId());\n    Assertions.assertEquals(\"abc\",instance.getInstanceId());\n  }\n  @Test void testMapperMultiplePorts(){\n    KubernetesLoadBalancerProperties properties\u003dnew KubernetesLoadBalancerProperties();\n    properties.setPortName(\"http\");\n    List\u003cServicePort\u003e ports\u003dnew ArrayList\u003c\u003e();\n    ports.add(new ServicePortBuilder().withPort(8080).withName(\"web\").build());\n    ports.add(new ServicePortBuilder().withPort(9000).withName(\"http\").build());\n    Service service\u003dbuildService(\"test\",\"test-namespace\",\"abc\",ports,Map.of());\n    KubernetesServiceInstance instance\u003dnew Fabric8ServiceInstanceMapper(properties,KubernetesDiscoveryProperties.DEFAULT).map(service);\n    Assertions.assertNotNull(instance);\n    Assertions.assertEquals(\"test\",instance.getServiceId());\n    Assertions.assertEquals(\"abc\",instance.getInstanceId());\n    Assertions.assertEquals(9000,instance.getPort());\n  }\n  @Test void testMapperSecure(){\n    KubernetesLoadBalancerProperties properties\u003dnew KubernetesLoadBalancerProperties();\n    Service service\u003dbuildService(\"test\",\"test-namespace\",\"abc\",443,null,Map.of());\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false,null);\n    KubernetesServiceInstance instance\u003dnew Fabric8ServiceInstanceMapper(properties,discoveryProperties).map(service);\n    Assertions.assertNotNull(instance);\n    Assertions.assertEquals(\"test\",instance.getServiceId());\n    Assertions.assertEquals(\"abc\",instance.getInstanceId());\n    Assertions.assertTrue(instance.isSecure());\n  }\n  @Test void testMapperSecureNullLabelsAndAnnotations(){\n    KubernetesLoadBalancerProperties properties\u003dnew KubernetesLoadBalancerProperties();\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    List\u003cServicePort\u003e ports\u003dnew ArrayList\u003c\u003e();\n    ports.add(new ServicePortBuilder().withPort(443).build());\n    Service service\u003dbuildService(\"test\",\"test-namespace\",\"abc\",ports,null,null);\n    KubernetesServiceInstance instance\u003dnew Fabric8ServiceInstanceMapper(properties,discoveryProperties).map(service);\n    Assertions.assertNotNull(instance);\n    Assertions.assertEquals(\"test\",instance.getServiceId());\n    Assertions.assertEquals(\"abc\",instance.getInstanceId());\n    Assertions.assertTrue(instance.isSecure());\n  }\n  @Test void testMapperSecureWithLabels(){\n    KubernetesLoadBalancerProperties properties\u003dnew KubernetesLoadBalancerProperties();\n    Map\u003cString,String\u003e labels\u003dMap.of(\"secured\",\"true\",\"label1\",\"123\");\n    Service service\u003dbuildService(\"test\",\"test-namespace\",\"abc\",8080,null,labels);\n    KubernetesServiceInstance instance\u003dnew Fabric8ServiceInstanceMapper(properties,KubernetesDiscoveryProperties.DEFAULT).map(service);\n    Assertions.assertNotNull(instance);\n    Assertions.assertEquals(\"test\",instance.getServiceId());\n    Assertions.assertEquals(\"abc\",instance.getInstanceId());\n    Assertions.assertTrue(instance.isSecure());\n    Assertions.assertEquals(4,instance.getMetadata().keySet().size());\n  }\n  @Test void serviceMetadataTest(){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    List\u003cServicePort\u003e ports\u003dnew ArrayList\u003c\u003e();\n    ports.add(new ServicePortBuilder().withPort(443).build());\n    Map\u003cString,String\u003e labels\u003dMap.of(\"one\",\"1\");\n    Map\u003cString,String\u003e annotations\u003dMap.of(\"two\",\"2\");\n    Service service\u003dbuildService(\"test\",\"test-namespace\",\"abc\",ports,labels,annotations);\n    Map\u003cString,String\u003e result\u003dnew Fabric8ServiceInstanceMapper(loadBalancerProperties,discoveryProperties).serviceMetadata(service);\n    Assertions.assertEquals(result.size(),4);\n    Assertions.assertEquals(result.get(\"k8s_namespace\"),\"test-namespace\");\n    Assertions.assertEquals(result.get(\"type\"),\"ClusterIP\");\n    Assertions.assertEquals(result.get(\"one\"),\"1\");\n    Assertions.assertEquals(result.get(\"two\"),\"2\");\n  }\n  /** \n * \u003cpre\u003e service has no ServicePorts \u003c/pre\u003e\n */\n  @Test void testMapEmptyPorts(  CapturedOutput output){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    List\u003cServicePort\u003e ports\u003dList.of();\n    Service service\u003dbuildService(\"test\",\"test-namespace\",\"abc\",ports,Map.of(),Map.of());\n    KubernetesServiceInstance result\u003dnew Fabric8ServiceInstanceMapper(loadBalancerProperties,discoveryProperties).map(service);\n    Assertions.assertNull(result);\n    Assertions.assertTrue(output.getOut().contains(\"service : test does not have any ServicePort(s), will not consider it for load balancing\"));\n  }\n  /** \n * \u003cpre\u003e service has a single ServicePort, and its name matches \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027 \u003c/pre\u003e\n */\n  @Test void testSinglePortsMatchesProperty(  CapturedOutput output){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    loadBalancerProperties.setPortName(\"my-port-name\");\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    List\u003cServicePort\u003e ports\u003dList.of(new ServicePortBuilder().withPort(8080).withName(\"my-port-name\").build());\n    Service service\u003dbuildService(\"test\",\"test-namespace\",\"abc\",ports,Map.of(),Map.of());\n    KubernetesServiceInstance result\u003dnew Fabric8ServiceInstanceMapper(loadBalancerProperties,discoveryProperties).map(service);\n    Assertions.assertNotNull(result);\n    Assertions.assertTrue(output.getOut().contains(\"single ServicePort found, will use it as-is (without checking \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027)\"));\n  }\n  /** \n * \u003cpre\u003e service has a single ServicePort, and its name does not match \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027. in this case, service is still considered, because we don\u0027t care about the property name when there is a single service port. \u003c/pre\u003e\n */\n  @Test void testSinglePortDoesNotMatchProperty(  CapturedOutput output){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    loadBalancerProperties.setPortName(\"my-different-port-name\");\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    List\u003cServicePort\u003e ports\u003dList.of(new ServicePortBuilder().withPort(8080).withName(\"my-port-name\").build());\n    Service service\u003dbuildService(\"test\",\"test-namespace\",\"abc\",ports,Map.of(),Map.of());\n    KubernetesServiceInstance result\u003dnew Fabric8ServiceInstanceMapper(loadBalancerProperties,discoveryProperties).map(service);\n    Assertions.assertNotNull(result);\n    Assertions.assertTrue(output.getOut().contains(\"single ServicePort found, will use it as-is (without checking \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027)\"));\n  }\n  /** \n * \u003cpre\u003e service has multiple ServicePorts, and \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027 is empty. in this case, a single, \u0027first\u0027, port will be returned. \u003c/pre\u003e\n */\n  @Test void testMultiplePortsWithoutPortNameProperty(  CapturedOutput output){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    loadBalancerProperties.setPortName(\"\");\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    List\u003cServicePort\u003e ports\u003dList.of(new ServicePortBuilder().withPort(8080).withName(\"one\").build(),new ServicePortBuilder().withPort(8081).withName(\"two\").build());\n    Service service\u003dbuildService(\"test\",\"test-namespace\",\"abc\",ports,Map.of(),Map.of());\n    KubernetesServiceInstance result\u003dnew Fabric8ServiceInstanceMapper(loadBalancerProperties,discoveryProperties).map(service);\n    Assertions.assertNotNull(result);\n    Assertions.assertTrue(output.getOut().contains(\"\u0027spring.cloud.kubernetes.loadbalancer.portName\u0027 is not set\"));\n    Assertions.assertTrue(output.getOut().contains(\"Will return \u0027first\u0027 port found, which is non-deterministic\"));\n  }\n  /** \n * \u003cpre\u003e service has multiple ServicePorts, and \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027 is not empty. \u003c/pre\u003e\n */\n  @Test void testMultiplePortsWithPortNamePropertyMatch(  CapturedOutput output){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    loadBalancerProperties.setPortName(\"one\");\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    List\u003cServicePort\u003e ports\u003dList.of(new ServicePortBuilder().withPort(8080).withName(\"one\").build(),new ServicePortBuilder().withPort(8081).withName(\"two\").build());\n    Service service\u003dbuildService(\"test\",\"test-namespace\",\"abc\",ports,Map.of(),Map.of());\n    KubernetesServiceInstance result\u003dnew Fabric8ServiceInstanceMapper(loadBalancerProperties,discoveryProperties).map(service);\n    Assertions.assertNotNull(result);\n    Assertions.assertTrue(output.getOut().contains(\"found port name that matches : one\"));\n  }\n  /** \n * \u003cpre\u003e service has multiple ServicePorts, and \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027 is not empty. property name also does not match \u0027potName\u0027 \u003c/pre\u003e\n */\n  @Test void testMultiplePortsWithPortNamePropertyNoMatch(  CapturedOutput output){\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    loadBalancerProperties.setPortName(\"three\");\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,false,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    List\u003cServicePort\u003e ports\u003dList.of(new ServicePortBuilder().withPort(8080).withName(\"one\").build(),new ServicePortBuilder().withPort(8081).withName(\"two\").build());\n    Service service\u003dbuildService(\"test\",\"test-namespace\",\"abc\",ports,Map.of(),Map.of());\n    KubernetesServiceInstance result\u003dnew Fabric8ServiceInstanceMapper(loadBalancerProperties,discoveryProperties).map(service);\n    Assertions.assertNotNull(result);\n    Assertions.assertTrue(output.getOut().contains(\"Did not find a port name that is equal to the value three\"));\n    Assertions.assertTrue(output.getOut().contains(\"Will return \u0027first\u0027 port found, which is non-deterministic\"));\n    Assertions.assertTrue(result.getPort() \u003d\u003d 8081 || result.getPort() \u003d\u003d 8080);\n  }\n  private Service buildService(  String name,  String namespace,  String uid,  int port,  String portName,  Map\u003cString,String\u003e labels){\n    ServicePort servicePort\u003dnew ServicePortBuilder().withPort(port).withName(portName).build();\n    return buildService(name,namespace,uid,Collections.singletonList(servicePort),labels);\n  }\n  private Service buildService(  String name,  String namespace,  String uid,  List\u003cServicePort\u003e ports,  Map\u003cString,String\u003e labels,  Map\u003cString,String\u003e annotations){\n    return new ServiceBuilder().withNewMetadata().withNamespace(namespace).withName(name).withUid(uid).addToLabels(labels).withAnnotations(annotations).endMetadata().withNewSpec().addAllToPorts(ports).withType(\"ClusterIP\").endSpec().build();\n  }\n  private Service buildService(  String name,  String namespace,  String uid,  List\u003cServicePort\u003e ports,  Map\u003cString,String\u003e labels){\n    return buildService(name,namespace,uid,ports,labels,Map.of());\n  }\n}\n",
        "abstract": "@ExtendWith(OutputCaptureExtension.class) class Fabric8ServiceInstanceMapperTests {\n  @Test void testMapperSimple();\n  @Test void testMapperMultiplePorts();\n  @Test void testMapperSecure();\n  @Test void testMapperSecureNullLabelsAndAnnotations();\n  @Test void testMapperSecureWithLabels();\n  @Test void serviceMetadataTest();\n  /** \n * \u003cpre\u003e service has no ServicePorts \u003c/pre\u003e\n */\n  @Test void testMapEmptyPorts(  CapturedOutput output);\n  /** \n * \u003cpre\u003e service has a single ServicePort, and its name matches \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027 \u003c/pre\u003e\n */\n  @Test void testSinglePortsMatchesProperty(  CapturedOutput output);\n  /** \n * \u003cpre\u003e service has a single ServicePort, and its name does not match \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027. in this case, service is still considered, because we don\u0027t care about the property name when there is a single service port. \u003c/pre\u003e\n */\n  @Test void testSinglePortDoesNotMatchProperty(  CapturedOutput output);\n  /** \n * \u003cpre\u003e service has multiple ServicePorts, and \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027 is empty. in this case, a single, \u0027first\u0027, port will be returned. \u003c/pre\u003e\n */\n  @Test void testMultiplePortsWithoutPortNameProperty(  CapturedOutput output);\n  /** \n * \u003cpre\u003e service has multiple ServicePorts, and \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027 is not empty. \u003c/pre\u003e\n */\n  @Test void testMultiplePortsWithPortNamePropertyMatch(  CapturedOutput output);\n  /** \n * \u003cpre\u003e service has multiple ServicePorts, and \u0027spring.cloud.kubernetes.loadbalancer.portName\u0027 is not empty. property name also does not match \u0027potName\u0027 \u003c/pre\u003e\n */\n  @Test void testMultiplePortsWithPortNamePropertyNoMatch(  CapturedOutput output);\n  private Service buildService(  String name,  String namespace,  String uid,  int port,  String portName,  Map\u003cString,String\u003e labels);\n  private Service buildService(  String name,  String namespace,  String uid,  List\u003cServicePort\u003e ports,  Map\u003cString,String\u003e labels,  Map\u003cString,String\u003e annotations);\n  private Service buildService(  String name,  String namespace,  String uid,  List\u003cServicePort\u003e ports,  Map\u003cString,String\u003e labels);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/Fabric8ServicesListSupplierMockClientTests.java",
        "name": "Fabric8ServicesListSupplierMockClientTests",
        "modifiers": "@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.Fabric8ServicesListSupplierMockClientTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class) class Fabric8ServicesListSupplierMockClientTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass(){\n    System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY,mockClient.getConfiguration().getMasterUrl());\n    System.setProperty(Config.KUBERNETES_TRUST_CERT_SYSTEM_PROPERTY,\"true\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYKUBECONFIG_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_AUTH_TRYSERVICEACCOUNT_SYSTEM_PROPERTY,\"false\");\n    System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY,\"test\");\n    System.setProperty(Config.KUBERNETES_HTTP2_DISABLE,\"true\");\n  }\n  @AfterEach void afterEach(){\n    mockClient.services().inAnyNamespace().delete();\n  }\n  @Test void testAllNamespaces(  CapturedOutput output){\n    createService(\"a\",\"service-a\",8887);\n    createService(\"b\",\"service-b\",8888);\n    createService(\"c\",\"service-a\",8889);\n    Environment environment\u003dnew MockEnvironment().withProperty(\"loadbalancer.client.name\",\"service-a\");\n    boolean allNamespaces\u003dtrue;\n    Set\u003cString\u003e selectiveNamespaces\u003dSet.of();\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,selectiveNamespaces,true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false,null);\n    Fabric8ServicesListSupplier supplier\u003dnew Fabric8ServicesListSupplier(environment,mockClient,new Fabric8ServiceInstanceMapper(loadBalancerProperties,discoveryProperties),discoveryProperties);\n    List\u003cList\u003cServiceInstance\u003e\u003e serviceInstances\u003dsupplier.get().collectList().block();\n    Assertions.assertEquals(serviceInstances.size(),1);\n    List\u003cServiceInstance\u003e serviceInstancesSorted\u003dserviceInstances.get(0).stream().sorted(Comparator.comparing(ServiceInstance::getServiceId)).toList();\n    Assertions.assertEquals(serviceInstancesSorted.size(),2);\n    Assertions.assertEquals(serviceInstancesSorted.get(0).getServiceId(),\"service-a\");\n    Assertions.assertEquals(serviceInstancesSorted.get(0).getHost(),\"service-a.a.svc.cluster.local\");\n    Assertions.assertEquals(serviceInstancesSorted.get(0).getPort(),8887);\n    Assertions.assertEquals(serviceInstancesSorted.get(1).getServiceId(),\"service-a\");\n    Assertions.assertEquals(serviceInstancesSorted.get(1).getHost(),\"service-a.c.svc.cluster.local\");\n    Assertions.assertEquals(serviceInstancesSorted.get(1).getPort(),8889);\n    Assertions.assertTrue(output.getOut().contains(\"discovering services in all namespaces\"));\n  }\n  @Test void testOneNamespace(  CapturedOutput output){\n    createService(\"a\",\"service-c\",8887);\n    createService(\"b\",\"service-b\",8888);\n    createService(\"c\",\"service-c\",8889);\n    Environment environment\u003dnew MockEnvironment().withProperty(\"spring.cloud.kubernetes.client.namespace\",\"c\").withProperty(\"loadbalancer.client.name\",\"service-c\");\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e selectiveNamespaces\u003dSet.of();\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,selectiveNamespaces,true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false,null);\n    Fabric8ServicesListSupplier supplier\u003dnew Fabric8ServicesListSupplier(environment,mockClient,new Fabric8ServiceInstanceMapper(loadBalancerProperties,discoveryProperties),discoveryProperties);\n    List\u003cList\u003cServiceInstance\u003e\u003e serviceInstances\u003dsupplier.get().collectList().block();\n    Assertions.assertEquals(serviceInstances.size(),1);\n    List\u003cServiceInstance\u003e inner\u003dserviceInstances.get(0);\n    List\u003cServiceInstance\u003e serviceInstancesSorted\u003dserviceInstances.get(0).stream().sorted(Comparator.comparing(ServiceInstance::getServiceId)).toList();\n    Assertions.assertEquals(serviceInstancesSorted.size(),1);\n    Assertions.assertEquals(inner.get(0).getServiceId(),\"service-c\");\n    Assertions.assertEquals(inner.get(0).getHost(),\"service-c.c.svc.cluster.local\");\n    Assertions.assertEquals(inner.get(0).getPort(),8889);\n    Assertions.assertTrue(output.getOut().contains(\"discovering services in namespace : c\"));\n  }\n  @Test void testSelectiveNamespaces(  CapturedOutput output){\n    createService(\"a\",\"my-service\",8887);\n    createService(\"b\",\"my-service\",8888);\n    createService(\"c\",\"my-service\",8889);\n    Environment environment\u003dnew MockEnvironment().withProperty(\"loadbalancer.client.name\",\"my-service\");\n    boolean allNamespaces\u003dfalse;\n    Set\u003cString\u003e selectiveNamespaces\u003dSet.of(\"a\",\"b\");\n    KubernetesLoadBalancerProperties loadBalancerProperties\u003dnew KubernetesLoadBalancerProperties();\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,allNamespaces,selectiveNamespaces,true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false,null);\n    Fabric8ServicesListSupplier supplier\u003dnew Fabric8ServicesListSupplier(environment,mockClient,new Fabric8ServiceInstanceMapper(loadBalancerProperties,discoveryProperties),discoveryProperties);\n    List\u003cList\u003cServiceInstance\u003e\u003e serviceInstances\u003dsupplier.get().collectList().block();\n    Assertions.assertEquals(serviceInstances.size(),1);\n    List\u003cServiceInstance\u003e serviceInstancesSorted\u003dserviceInstances.get(0).stream().sorted(Comparator.comparing(ServiceInstance::getPort)).toList();\n    Assertions.assertEquals(serviceInstancesSorted.size(),2);\n    Assertions.assertEquals(serviceInstancesSorted.get(0).getServiceId(),\"my-service\");\n    Assertions.assertEquals(serviceInstancesSorted.get(0).getHost(),\"my-service.a.svc.cluster.local\");\n    Assertions.assertEquals(serviceInstancesSorted.get(0).getPort(),8887);\n    Assertions.assertEquals(serviceInstancesSorted.get(1).getServiceId(),\"my-service\");\n    Assertions.assertEquals(serviceInstancesSorted.get(1).getHost(),\"my-service.b.svc.cluster.local\");\n    Assertions.assertEquals(serviceInstancesSorted.get(1).getPort(),8888);\n    Assertions.assertTrue(output.getOut().contains(\"discovering services in selective namespaces : [a, b]\"));\n  }\n  private void createService(  String namespace,  String name,  int port){\n    Service service\u003dnew ServiceBuilder().withNewMetadata().withNamespace(namespace).withName(name).endMetadata().withSpec(new ServiceSpecBuilder().withPorts(new ServicePortBuilder().withName(\"http\").withPort(port).build()).build()).build();\n    mockClient.services().resource(service).create();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@EnableKubernetesMockClient(crud\u003dtrue,https\u003dfalse) @ExtendWith(OutputCaptureExtension.class) class Fabric8ServicesListSupplierMockClientTests {\n  private static KubernetesClient mockClient;\n  @BeforeAll static void setUpBeforeClass();\n  @AfterEach void afterEach();\n  @Test void testAllNamespaces(  CapturedOutput output);\n  @Test void testOneNamespace(  CapturedOutput output);\n  @Test void testSelectiveNamespaces(  CapturedOutput output);\n  private void createService(  String namespace,  String name,  int port);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/Fabric8LoadBalancerAutoConfigurationTests.java",
        "name": "Fabric8LoadBalancerAutoConfigurationTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.Fabric8LoadBalancerAutoConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Thomas Vitale\n */\nclass Fabric8LoadBalancerAutoConfigurationTests {\n  @Test void kubernetesLoadBalancerWhenKubernetesDisabledAndLoadBalancerDisabled(){\n    new ApplicationContextRunner().withUserConfiguration(Fabric8LoadBalancerAutoConfigurationTests.Config.class).withConfiguration(AutoConfigurations.of(Fabric8LoadBalancerAutoConfiguration.class)).withPropertyValues(\"spring.cloud.kubernetes.loadbalancer.enabled\u003dfalse\").run(this::assertInstanceMapperMissing);\n  }\n  @Test void kubernetesLoadBalancerWhenKubernetesDisabledAndLoadBalancerEnabled(){\n    new ApplicationContextRunner().withUserConfiguration(Fabric8LoadBalancerAutoConfigurationTests.Config.class).withConfiguration(AutoConfigurations.of(Fabric8LoadBalancerAutoConfiguration.class)).withPropertyValues(\"spring.cloud.kubernetes.loadbalancer.enabled\u003dtrue\").run(this::assertInstanceMapperMissing);\n  }\n  @Test void kubernetesLoadBalancerWhenKubernetesEnabledAndLoadBalancerEnabled(){\n    new ApplicationContextRunner().withUserConfiguration(Fabric8LoadBalancerAutoConfigurationTests.Config.class).withConfiguration(AutoConfigurations.of(Fabric8LoadBalancerAutoConfiguration.class)).withPropertyValues(\"spring.cloud.kubernetes.loadbalancer.enabled\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\").run(this::assertInstanceMapperPresent);\n  }\n  @Test void kubernetesLoadBalancerWhenKubernetesEnabledAndLoadBalancerDisabled(){\n    new ApplicationContextRunner().withUserConfiguration(Fabric8LoadBalancerAutoConfigurationTests.Config.class).withConfiguration(AutoConfigurations.of(Fabric8LoadBalancerAutoConfiguration.class)).withPropertyValues(\"spring.cloud.kubernetes.loadbalancer.enabled\u003dfalse\",\"spring.main.cloud-platform\u003dKUBERNETES\").run(this::assertInstanceMapperMissing);\n  }\n  @Test void kubernetesLoadBalancerWhenDefaultProperties(){\n    new ApplicationContextRunner().withUserConfiguration(Fabric8LoadBalancerAutoConfigurationTests.Config.class).withConfiguration(AutoConfigurations.of(Fabric8LoadBalancerAutoConfiguration.class)).withPropertyValues(\"spring.main.cloud-platform\u003dKUBERNETES\").run(this::assertInstanceMapperPresent);\n  }\n  private void assertInstanceMapperMissing(  AssertableApplicationContext context){\n    assertThat(context.getBeanNamesForType(Fabric8ServiceInstanceMapper.class)).isEmpty();\n  }\n  private void assertInstanceMapperPresent(  AssertableApplicationContext context){\n    assertThat(context.getBeanNamesForType(Fabric8ServiceInstanceMapper.class)).hasSize(1);\n  }\n@EnableConfigurationProperties(KubernetesDiscoveryProperties.class) static class Config {\n  }\n}\n",
        "abstract": "/** \n * @author Thomas Vitale\n */\nclass Fabric8LoadBalancerAutoConfigurationTests {\n  @Test void kubernetesLoadBalancerWhenKubernetesDisabledAndLoadBalancerDisabled();\n  @Test void kubernetesLoadBalancerWhenKubernetesDisabledAndLoadBalancerEnabled();\n  @Test void kubernetesLoadBalancerWhenKubernetesEnabledAndLoadBalancerEnabled();\n  @Test void kubernetesLoadBalancerWhenKubernetesEnabledAndLoadBalancerDisabled();\n  @Test void kubernetesLoadBalancerWhenDefaultProperties();\n  private void assertInstanceMapperMissing(  AssertableApplicationContext context);\n  private void assertInstanceMapperPresent(  AssertableApplicationContext context);\n@EnableConfigurationProperties(KubernetesDiscoveryProperties.class) static class Config {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-loadbalancer/src/test/java/org/springframework/cloud/kubernetes/fabric8/loadbalancer/Fabric8ServiceListSupplierTests.java",
        "name": "Fabric8ServiceListSupplierTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.loadbalancer.Fabric8ServiceListSupplierTests",
        "extend": "",
        "implements": "",
        "raw": "class Fabric8ServiceListSupplierTests {\n  private final Environment environment\u003dnew MockEnvironment().withProperty(\"loadbalancer.client.name\",\"test-service\");\n  private final Fabric8ServiceInstanceMapper mapper\u003dMockito.mock(Fabric8ServiceInstanceMapper.class);\n  private final KubernetesClient client\u003dMockito.mock(KubernetesClient.class);\n  @SuppressWarnings(\"unchecked\") private final MixedOperation\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e serviceOperation\u003dMockito.mock(MixedOperation.class);\n  @SuppressWarnings(\"unchecked\") private final NonNamespaceOperation\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e namespaceOperation\u003dMockito.mock(NonNamespaceOperation.class);\n  @SuppressWarnings(\"unchecked\") private final ServiceResource\u003cService\u003e serviceResource\u003dMockito.mock(ServiceResource.class);\n  @SuppressWarnings(\"unchecked\") private final AnyNamespaceOperation\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e multiDeletable\u003dMockito.mock(AnyNamespaceOperation.class);\n  @Test void testPositiveMatch(){\n    when(mapper.map(any(Service.class))).thenReturn(new DefaultKubernetesServiceInstance(\"\",\"\",\"\",0,null,false));\n    when(this.client.getNamespace()).thenReturn(\"test\");\n    when(this.client.services()).thenReturn(this.serviceOperation);\n    when(this.serviceOperation.inNamespace(\"test\")).thenReturn(namespaceOperation);\n    when(this.namespaceOperation.withName(\"test-service\")).thenReturn(this.serviceResource);\n    when(this.serviceResource.get()).thenReturn(buildService(\"test-service\",8080));\n    KubernetesServicesListSupplier\u003cService\u003e supplier\u003dnew Fabric8ServicesListSupplier(environment,client,mapper,KubernetesDiscoveryProperties.DEFAULT);\n    List\u003cServiceInstance\u003e instances\u003dsupplier.get().blockFirst();\n    Assertions.assertEquals(1,instances.size());\n  }\n  @Test void testPositiveMatchAllNamespaces(){\n    when(mapper.map(any(Service.class))).thenReturn(new DefaultKubernetesServiceInstance(\"\",\"\",\"\",0,null,false));\n    when(this.client.services()).thenReturn(this.serviceOperation);\n    when(this.serviceOperation.inAnyNamespace()).thenReturn(this.multiDeletable);\n    when(this.multiDeletable.withField(\"metadata.name\",\"test-service\")).thenReturn(this.multiDeletable);\n    ServiceList serviceList\u003dnew ServiceList();\n    serviceList.getItems().add(buildService(\"test-service\",8080));\n    when(this.multiDeletable.list()).thenReturn(serviceList);\n    KubernetesDiscoveryProperties discoveryProperties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false);\n    KubernetesServicesListSupplier\u003cService\u003e supplier\u003dnew Fabric8ServicesListSupplier(environment,client,mapper,discoveryProperties);\n    List\u003cServiceInstance\u003e instances\u003dsupplier.get().blockFirst();\n    Assertions.assertEquals(1,instances.size());\n  }\n  private Service buildService(  String name,  int port){\n    return new ServiceBuilder().withNewMetadata().withName(name).endMetadata().withNewSpec().addNewPort().withPort(port).endPort().endSpec().build();\n  }\n}\n",
        "abstract": "class Fabric8ServiceListSupplierTests {\n  private final Environment environment\u003dnew MockEnvironment().withProperty(\"loadbalancer.client.name\",\"test-service\");\n  private final Fabric8ServiceInstanceMapper mapper\u003dMockito.mock(Fabric8ServiceInstanceMapper.class);\n  private final KubernetesClient client\u003dMockito.mock(KubernetesClient.class);\n  @SuppressWarnings(\"unchecked\") private final MixedOperation\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e serviceOperation\u003dMockito.mock(MixedOperation.class);\n  @SuppressWarnings(\"unchecked\") private final NonNamespaceOperation\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e namespaceOperation\u003dMockito.mock(NonNamespaceOperation.class);\n  @SuppressWarnings(\"unchecked\") private final ServiceResource\u003cService\u003e serviceResource\u003dMockito.mock(ServiceResource.class);\n  @SuppressWarnings(\"unchecked\") private final AnyNamespaceOperation\u003cService,ServiceList,ServiceResource\u003cService\u003e\u003e multiDeletable\u003dMockito.mock(AnyNamespaceOperation.class);\n  @Test void testPositiveMatch();\n  @Test void testPositiveMatchAllNamespaces();\n  private Service buildService(  String name,  int port);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/PodUtils.java",
        "name": "PodUtils",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.PodUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Utility interface to retrieve Pod related information.\n * @author Ioannis Canellos\n */\npublic interface PodUtils\u003cT\u003e {\n  /** \n * @return A supplier of the current Pod. The supplier will hold the current Pod ifinside Kubernetes or null, otherwise.\n */\n  Supplier\u003cT\u003e currentPod();\n  /** \n * @return true if called from within Kubernetes, false otherwise.\n */\n  boolean isInsideKubernetes();\n}\n",
        "abstract": "/** \n * Utility interface to retrieve Pod related information.\n * @author Ioannis Canellos\n */\npublic interface PodUtils\u003cT\u003e {\n  /** \n * @return A supplier of the current Pod. The supplier will hold the current Pod ifinside Kubernetes or null, otherwise.\n */\n  Supplier\u003cT\u003e currentPod();\n  /** \n * @return true if called from within Kubernetes, false otherwise.\n */\n  boolean isInsideKubernetes();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/AbstractKubernetesInfoContributor.java",
        "name": "AbstractKubernetesInfoContributor",
        "modifiers": "public abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.AbstractKubernetesInfoContributor",
        "extend": "",
        "implements": "InfoContributor",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic abstract class AbstractKubernetesInfoContributor implements InfoContributor {\n  /** \n * Kubernetes key.\n */\n  public static final String KUBERNETES\u003d\"kubernetes\";\n  /** \n * Inside key.\n */\n  public static final String INSIDE\u003d\"inside\";\n  /** \n * Namespace key.\n */\n  public static final String NAMESPACE\u003d\"namespace\";\n  /** \n * Pod name key.\n */\n  public static final String POD_NAME\u003d\"podName\";\n  /** \n * Pod IP key.\n */\n  public static final String POD_IP\u003d\"podIp\";\n  /** \n * Service account key.\n */\n  public static final String SERVICE_ACCOUNT\u003d\"serviceAccount\";\n  /** \n * Node name key.\n */\n  public static final String NODE_NAME\u003d\"nodeName\";\n  /** \n * Host IP key.\n */\n  public static final String HOST_IP\u003d\"hostIp\";\n  /** \n * Labels key.\n */\n  public static final String LABELS\u003d\"labels\";\n  private static final Log LOG\u003dLogFactory.getLog(AbstractKubernetesInfoContributor.class);\n  @Override public void contribute(  Info.Builder builder){\n    try {\n      builder.withDetail(KUBERNETES,getDetails());\n    }\n catch (    Exception e) {\n      LOG.warn(\"Failed to get pod details\",e);\n    }\n  }\n  public abstract Map\u003cString,Object\u003e getDetails();\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic abstract class AbstractKubernetesInfoContributor implements InfoContributor {\n  /** \n * Kubernetes key.\n */\n  public static final String KUBERNETES\u003d\"kubernetes\";\n  /** \n * Inside key.\n */\n  public static final String INSIDE\u003d\"inside\";\n  /** \n * Namespace key.\n */\n  public static final String NAMESPACE\u003d\"namespace\";\n  /** \n * Pod name key.\n */\n  public static final String POD_NAME\u003d\"podName\";\n  /** \n * Pod IP key.\n */\n  public static final String POD_IP\u003d\"podIp\";\n  /** \n * Service account key.\n */\n  public static final String SERVICE_ACCOUNT\u003d\"serviceAccount\";\n  /** \n * Node name key.\n */\n  public static final String NODE_NAME\u003d\"nodeName\";\n  /** \n * Host IP key.\n */\n  public static final String HOST_IP\u003d\"hostIp\";\n  /** \n * Labels key.\n */\n  public static final String LABELS\u003d\"labels\";\n  private static final Log LOG\u003dLogFactory.getLog(AbstractKubernetesInfoContributor.class);\n  @Override public void contribute(  Info.Builder builder);\n  public abstract Map\u003cString,Object\u003e getDetails();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/AbstractKubernetesHealthIndicator.java",
        "name": "AbstractKubernetesHealthIndicator",
        "modifiers": "public abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.AbstractKubernetesHealthIndicator",
        "extend": "AbstractHealthIndicator",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic abstract class AbstractKubernetesHealthIndicator extends AbstractHealthIndicator {\n  /** \n * Inside key.\n */\n  public static final String INSIDE\u003d\"inside\";\n  /** \n * Namespace key.\n */\n  public static final String NAMESPACE\u003d\"namespace\";\n  /** \n * Pod name key.\n */\n  public static final String POD_NAME\u003d\"podName\";\n  /** \n * Pod IP key.\n */\n  public static final String POD_IP\u003d\"podIp\";\n  /** \n * Service account key.\n */\n  public static final String SERVICE_ACCOUNT\u003d\"serviceAccount\";\n  /** \n * Node name key.\n */\n  public static final String NODE_NAME\u003d\"nodeName\";\n  /** \n * Host IP key.\n */\n  public static final String HOST_IP\u003d\"hostIp\";\n  /** \n * Labels key.\n */\n  public static final String LABELS\u003d\"labels\";\n  @Override protected void doHealthCheck(  Health.Builder builder){\n    try {\n      builder.up().withDetails(getDetails());\n    }\n catch (    Exception e) {\n      builder.down(e);\n    }\n  }\n  protected abstract Map\u003cString,Object\u003e getDetails() throws Exception ;\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic abstract class AbstractKubernetesHealthIndicator extends AbstractHealthIndicator {\n  /** \n * Inside key.\n */\n  public static final String INSIDE\u003d\"inside\";\n  /** \n * Namespace key.\n */\n  public static final String NAMESPACE\u003d\"namespace\";\n  /** \n * Pod name key.\n */\n  public static final String POD_NAME\u003d\"podName\";\n  /** \n * Pod IP key.\n */\n  public static final String POD_IP\u003d\"podIp\";\n  /** \n * Service account key.\n */\n  public static final String SERVICE_ACCOUNT\u003d\"serviceAccount\";\n  /** \n * Node name key.\n */\n  public static final String NODE_NAME\u003d\"nodeName\";\n  /** \n * Host IP key.\n */\n  public static final String HOST_IP\u003d\"hostIp\";\n  /** \n * Labels key.\n */\n  public static final String LABELS\u003d\"labels\";\n  @Override protected void doHealthCheck(  Health.Builder builder);\n  protected abstract Map\u003cString,Object\u003e getDetails() throws Exception ;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/loadbalancer/ConditionalOnKubernetesLoadBalancerEnabled.java",
        "name": "ConditionalOnKubernetesLoadBalancerEnabled",
        "modifiers": "@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.loadbalancer.enabled\",matchIfMissing\u003dtrue) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.loadbalancer.ConditionalOnKubernetesLoadBalancerEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.loadbalancer.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.loadbalancer.enabled\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesLoadBalancerEnabled {}\n",
        "abstract": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.loadbalancer.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.loadbalancer.enabled\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesLoadBalancerEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/loadbalancer/KubernetesServiceInstanceMapper.java",
        "name": "KubernetesServiceInstanceMapper",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.loadbalancer.KubernetesServiceInstanceMapper",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic interface KubernetesServiceInstanceMapper\u003cT\u003e {\n  KubernetesServiceInstance map(  T service);\n  static String createHost(  String serviceName,  String namespace,  String clusterDomain){\n    String namespaceToUse\u003dStringUtils.hasText(namespace) ? namespace : \"default\";\n    return new StringJoiner(\".\").add(serviceName).add(namespaceToUse).add(\"svc\").add(clusterDomain).toString();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic interface KubernetesServiceInstanceMapper\u003cT\u003e {\n  KubernetesServiceInstance map(  T service);\n  static String createHost(  String serviceName,  String namespace,  String clusterDomain);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/loadbalancer/KubernetesLoadBalancerProperties.java",
        "name": "KubernetesLoadBalancerProperties",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"spring.cloud.kubernetes.loadbalancer\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.loadbalancer.KubernetesLoadBalancerProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Kubernetes load balancer client properties.\n * @author Piotr Minkowski\n */\n@ConfigurationProperties(prefix\u003d\"spring.cloud.kubernetes.loadbalancer\") public class KubernetesLoadBalancerProperties {\n  /** \n * Load balancer enabled,default true.\n */\n  private Boolean enabled\u003dtrue;\n  /** \n * {@link KubernetesLoadBalancerMode} setting load balancer server list with ip of podor service name. default value is POD.\n */\n  private KubernetesLoadBalancerMode mode\u003dKubernetesLoadBalancerMode.POD;\n  /** \n * cluster domain.\n */\n  private String clusterDomain\u003d\"cluster.local\";\n  /** \n * service port name.\n */\n  private String portName\u003d\"http\";\n  /** \n * Get cluster domain.\n * @return the cluster domain\n */\n  public String getClusterDomain(){\n    return clusterDomain;\n  }\n  /** \n * Sets cluster domain.\n * @param clusterDomain the cluster domain\n */\n  public void setClusterDomain(  String clusterDomain){\n    this.clusterDomain\u003dclusterDomain;\n  }\n  /** \n * Gets mode.\n * @return the mode\n */\n  public KubernetesLoadBalancerMode getMode(){\n    return mode;\n  }\n  /** \n * Sets mode.\n * @param mode the mode\n */\n  public void setMode(  KubernetesLoadBalancerMode mode){\n    this.mode\u003dmode;\n  }\n  /** \n * Gets enabled.\n * @return the enabled\n */\n  public Boolean getEnabled(){\n    return enabled;\n  }\n  /** \n * Sets enabled.\n * @param enabled the enabled\n */\n  public void setEnabled(  Boolean enabled){\n    this.enabled\u003denabled;\n  }\n  /** \n * Gets portName.\n * @return portName port name\n */\n  public String getPortName(){\n    return portName;\n  }\n  /** \n * Sets portName.\n * @param portName port name\n */\n  public void setPortName(  String portName){\n    this.portName\u003dportName;\n  }\n}\n",
        "abstract": "/** \n * Kubernetes load balancer client properties.\n * @author Piotr Minkowski\n */\n@ConfigurationProperties(prefix\u003d\"spring.cloud.kubernetes.loadbalancer\") public class KubernetesLoadBalancerProperties {\n  /** \n * Load balancer enabled,default true.\n */\n  private Boolean enabled\u003dtrue;\n  /** \n * {@link KubernetesLoadBalancerMode} setting load balancer server list with ip of podor service name. default value is POD.\n */\n  private KubernetesLoadBalancerMode mode\u003dKubernetesLoadBalancerMode.POD;\n  /** \n * cluster domain.\n */\n  private String clusterDomain\u003d\"cluster.local\";\n  /** \n * service port name.\n */\n  private String portName\u003d\"http\";\n  /** \n * Get cluster domain.\n * @return the cluster domain\n */\n  public String getClusterDomain();\n  /** \n * Sets cluster domain.\n * @param clusterDomain the cluster domain\n */\n  public void setClusterDomain(  String clusterDomain);\n  /** \n * Gets mode.\n * @return the mode\n */\n  public KubernetesLoadBalancerMode getMode();\n  /** \n * Sets mode.\n * @param mode the mode\n */\n  public void setMode(  KubernetesLoadBalancerMode mode);\n  /** \n * Gets enabled.\n * @return the enabled\n */\n  public Boolean getEnabled();\n  /** \n * Sets enabled.\n * @param enabled the enabled\n */\n  public void setEnabled(  Boolean enabled);\n  /** \n * Gets portName.\n * @return portName port name\n */\n  public String getPortName();\n  /** \n * Sets portName.\n * @param portName port name\n */\n  public void setPortName(  String portName);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/loadbalancer/KubernetesLoadBalancerMode.java",
        "name": "KubernetesLoadBalancerMode",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.loadbalancer.KubernetesLoadBalancerMode",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Kubernetes load balancer mode enum.\n * @author Piotr Minkowski\n */\npublic enum KubernetesLoadBalancerMode {/** \n * using pod ip and port.\n */\nPOD, /** \n * using kubernetes service name and port.\n */\nSERVICE}\n",
        "abstract": "/** \n * Kubernetes load balancer mode enum.\n * @author Piotr Minkowski\n */\npublic enum KubernetesLoadBalancerMode {/** \n * using pod ip and port.\n */\nPOD, /** \n * using kubernetes service name and port.\n */\nSERVICE}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/loadbalancer/KubernetesServicesListSupplier.java",
        "name": "KubernetesServicesListSupplier",
        "modifiers": "public abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.loadbalancer.KubernetesServicesListSupplier",
        "extend": "",
        "implements": "ServiceInstanceListSupplier",
        "raw": "/** \n * Implementation of  {@link ServiceInstanceListSupplier} for load balancer in SERVICEmode.\n * @author Piotr Minkowski\n */\npublic abstract class KubernetesServicesListSupplier\u003cT\u003e implements ServiceInstanceListSupplier {\n  protected final Environment environment;\n  protected final KubernetesDiscoveryProperties discoveryProperties;\n  protected final KubernetesServiceInstanceMapper\u003cT\u003e mapper;\n  public KubernetesServicesListSupplier(  Environment environment,  KubernetesServiceInstanceMapper\u003cT\u003e mapper,  KubernetesDiscoveryProperties discoveryProperties){\n    this.environment\u003denvironment;\n    this.discoveryProperties\u003ddiscoveryProperties;\n    this.mapper\u003dmapper;\n  }\n  @Override public String getServiceId(){\n    return environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);\n  }\n  @Override public abstract Flux\u003cList\u003cServiceInstance\u003e\u003e get();\n}\n",
        "abstract": "/** \n * Implementation of  {@link ServiceInstanceListSupplier} for load balancer in SERVICEmode.\n * @author Piotr Minkowski\n */\npublic abstract class KubernetesServicesListSupplier\u003cT\u003e implements ServiceInstanceListSupplier {\n  protected final Environment environment;\n  protected final KubernetesDiscoveryProperties discoveryProperties;\n  protected final KubernetesServiceInstanceMapper\u003cT\u003e mapper;\n  public KubernetesServicesListSupplier(  Environment environment,  KubernetesServiceInstanceMapper\u003cT\u003e mapper,  KubernetesDiscoveryProperties discoveryProperties);\n  @Override public String getServiceId();\n  @Override public abstract Flux\u003cList\u003cServiceInstance\u003e\u003e get();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/loadbalancer/ConditionalOnKubernetesLoadBalancerServiceModeEnabled.java",
        "name": "ConditionalOnKubernetesLoadBalancerServiceModeEnabled",
        "modifiers": "@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(name\u003d\"spring.cloud.kubernetes.loadbalancer.mode\",havingValue\u003d\"SERVICE\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.loadbalancer.ConditionalOnKubernetesLoadBalancerServiceModeEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides a conditional for: \u003ccode\u003espring.cloud.kubernetes.loadbalancer.mode\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(name\u003d\"spring.cloud.kubernetes.loadbalancer.mode\",havingValue\u003d\"SERVICE\") public @interface ConditionalOnKubernetesLoadBalancerServiceModeEnabled {}\n",
        "abstract": "/** \n * Provides a conditional for: \u003ccode\u003espring.cloud.kubernetes.loadbalancer.mode\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(name\u003d\"spring.cloud.kubernetes.loadbalancer.mode\",havingValue\u003d\"SERVICE\") public @interface ConditionalOnKubernetesLoadBalancerServiceModeEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/KubernetesNamespaceProvider.java",
        "name": "KubernetesNamespaceProvider",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.KubernetesNamespaceProvider",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesNamespaceProvider {\n  /** \n * Property name for namespace.\n */\n  public static final String NAMESPACE_PROPERTY\u003d\"spring.cloud.kubernetes.client.namespace\";\n  /** \n * Property for namespace file path.\n */\n  public static final String NAMESPACE_PATH_PROPERTY\u003d\"spring.cloud.kubernetes.client.serviceAccountNamespacePath\";\n  private static final DeferredLog LOG\u003dnew DeferredLog();\n  private String namespacePropertyValue;\n  private BindHandler bindHandler;\n  private String serviceAccountNamespace;\n  private Environment environment;\n  private Binder binder;\n  public KubernetesNamespaceProvider(  Environment env){\n    this.environment\u003denv;\n    LOG.replayTo(KubernetesNamespaceProvider.class);\n  }\n  public KubernetesNamespaceProvider(  Binder binder,  BindHandler bindHandler){\n    this.binder\u003dbinder;\n    this.bindHandler\u003dbindHandler;\n  }\n  public KubernetesNamespaceProvider(  String namespacePropertyValue){\n    this.namespacePropertyValue\u003dnamespacePropertyValue;\n  }\n  public static String getNamespaceFromServiceAccountFile(  String path){\n    String namespace\u003dnull;\n    LOG.debug(\"Looking for service account namespace at: [\" + path + \"].\");\n    Path serviceAccountNamespacePath\u003dPaths.get(path);\n    boolean serviceAccountNamespaceExists\u003dFiles.isRegularFile(serviceAccountNamespacePath);\n    if (serviceAccountNamespaceExists) {\n      LOG.debug(\"Found service account namespace at: [\" + serviceAccountNamespacePath + \"].\");\n      try {\n        namespace\u003dnew String(Files.readAllBytes((serviceAccountNamespacePath)));\n        LOG.debug(\"Service account namespace value: \" + serviceAccountNamespacePath);\n      }\n catch (      IOException ioe) {\n        LOG.error(\"Error reading service account namespace from: [\" + serviceAccountNamespacePath + \"].\",ioe);\n      }\n    }\n    return namespace;\n  }\n  public String getNamespace(){\n    if (!ObjectUtils.isEmpty(namespacePropertyValue)) {\n      return namespacePropertyValue;\n    }\n    String namespace\u003dnull;\n    if (environment !\u003d null) {\n      namespace\u003denvironment.getProperty(NAMESPACE_PROPERTY);\n    }\n    if (ObjectUtils.isEmpty(namespace) \u0026\u0026 binder !\u003d null) {\n      namespace\u003dbinder.bind(NAMESPACE_PROPERTY,String.class).orElse(null);\n    }\n    return namespace !\u003d null ? namespace : getServiceAccountNamespace();\n  }\n  private String getServiceAccountNamespace(){\n    String serviceAccountNamespacePathString\u003dnull;\n    if (environment !\u003d null) {\n      serviceAccountNamespacePathString\u003denvironment.getProperty(NAMESPACE_PATH_PROPERTY,SERVICE_ACCOUNT_NAMESPACE_PATH);\n    }\n    if (ObjectUtils.isEmpty(serviceAccountNamespacePathString) \u0026\u0026 binder !\u003d null) {\n      serviceAccountNamespacePathString\u003dbinder.bind(\"spring.cloud.kubernetes.client.service-account-namespace-path\",Bindable.of(String.class),bindHandler).orElse(SERVICE_ACCOUNT_NAMESPACE_PATH);\n    }\n    if (serviceAccountNamespace \u003d\u003d null) {\n      serviceAccountNamespace\u003dgetNamespaceFromServiceAccountFile(serviceAccountNamespacePathString);\n    }\n    return serviceAccountNamespace;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesNamespaceProvider {\n  /** \n * Property name for namespace.\n */\n  public static final String NAMESPACE_PROPERTY\u003d\"spring.cloud.kubernetes.client.namespace\";\n  /** \n * Property for namespace file path.\n */\n  public static final String NAMESPACE_PATH_PROPERTY\u003d\"spring.cloud.kubernetes.client.serviceAccountNamespacePath\";\n  private static final DeferredLog LOG\u003dnew DeferredLog();\n  private String namespacePropertyValue;\n  private BindHandler bindHandler;\n  private String serviceAccountNamespace;\n  private Environment environment;\n  private Binder binder;\n  public KubernetesNamespaceProvider(  Environment env);\n  public KubernetesNamespaceProvider(  Binder binder,  BindHandler bindHandler);\n  public KubernetesNamespaceProvider(  String namespacePropertyValue);\n  public static String getNamespaceFromServiceAccountFile(  String path);\n  public String getNamespace();\n  private String getServiceAccountNamespace();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/KubernetesCommonsSanitizeAutoConfiguration.java",
        "name": "KubernetesCommonsSanitizeAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.endpoint.SanitizableData\") @ConditionalOnSanitizeSecrets",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.KubernetesCommonsSanitizeAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.endpoint.SanitizableData\") @ConditionalOnSanitizeSecrets class KubernetesCommonsSanitizeAutoConfiguration {\n  @Bean @ConditionalOnMissingBean SanitizingFunction secretsPropertySourceSanitizingFunction(){\n    return data -\u003e {\n      PropertySource\u003c?\u003e propertySource\u003ddata.getPropertySource();\n      if (propertySource instanceof BootstrapPropertySource\u003c?\u003e) {\n        PropertySource\u003c?\u003e source\u003dbootstrapPropertySource.getDelegate();\n        if (source instanceof SecretsPropertySource) {\n          return new SanitizableData(propertySource,data.getKey(),data.getValue()).withValue(SanitizableData.SANITIZED_VALUE);\n        }\n      }\n      if (propertySource instanceof SecretsPropertySource) {\n        return new SanitizableData(propertySource,data.getKey(),data.getValue()).withValue(SanitizableData.SANITIZED_VALUE);\n      }\n      if (propertySource instanceof CompositePropertySource) {\n        Collection\u003cPropertySource\u003c?\u003e\u003e sources\u003dcompositePropertySource.getPropertySources();\n        for (        PropertySource\u003c?\u003e one : sources) {\n          if (one.containsProperty(data.getKey()) \u0026\u0026 one instanceof SecretsPropertySource) {\n            return new SanitizableData(propertySource,data.getKey(),data.getValue()).withValue(SanitizableData.SANITIZED_VALUE);\n          }\n        }\n      }\n      return data;\n    }\n;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.endpoint.SanitizableData\") @ConditionalOnSanitizeSecrets class KubernetesCommonsSanitizeAutoConfiguration {\n  @Bean @ConditionalOnMissingBean SanitizingFunction secretsPropertySourceSanitizingFunction();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/LazilyInstantiate.java",
        "name": "LazilyInstantiate",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.LazilyInstantiate",
        "extend": "",
        "implements": "Supplier\u003cT\u003e",
        "raw": "/** \n * Lazy instantiation utility class.\n * @param \u003c T \u003e return type\n * @author Ioannis Canellos\n */\npublic final class LazilyInstantiate\u003cT\u003e implements Supplier\u003cT\u003e {\n  private volatile T t;\n  private final Supplier\u003cT\u003e supplier;\n  private LazilyInstantiate(  Supplier\u003cT\u003e supplier){\n    this.supplier\u003dsupplier;\n  }\n  public static \u003cT\u003eLazilyInstantiate\u003cT\u003e using(  Supplier\u003cT\u003e supplier){\n    return new LazilyInstantiate\u003c\u003e(supplier);\n  }\n  public T get(){\n    T localT\u003dt;\n    if (localT \u003d\u003d null) {\nsynchronized (this) {\n        localT\u003dt;\n        if (localT \u003d\u003d null) {\n          localT\u003dsupplier.get();\n          t\u003dlocalT;\n        }\n      }\n    }\n    return localT;\n  }\n}\n",
        "abstract": "/** \n * Lazy instantiation utility class.\n * @param \u003c T \u003e return type\n * @author Ioannis Canellos\n */\npublic final class LazilyInstantiate\u003cT\u003e implements Supplier\u003cT\u003e {\n  private volatile T t;\n  private final Supplier\u003cT\u003e supplier;\n  private LazilyInstantiate(  Supplier\u003cT\u003e supplier);\n  public static \u003cT\u003eLazilyInstantiate\u003cT\u003e using(  Supplier\u003cT\u003e supplier);\n  public T get();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/ConditionalOnKubernetesConfigEnabled.java",
        "name": "ConditionalOnKubernetesConfigEnabled",
        "modifiers": "@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.config.enabled\",matchIfMissing\u003dtrue) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.ConditionalOnKubernetesConfigEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.config.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.config.enabled\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesConfigEnabled {}\n",
        "abstract": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.config.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.config.enabled\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesConfigEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/ConditionalOnBlockingOrReactiveDiscoveryEnabled.java",
        "name": "ConditionalOnBlockingOrReactiveDiscoveryEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnBlockingOrReactiveDiscoveryEnabled.OnBlockingOrReactiveDiscoveryEnabled.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.ConditionalOnBlockingOrReactiveDiscoveryEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Conditional that is resolved to active when either {@link ConditionalOnBlockingDiscoveryEnabled} or{@link ConditionalOnReactiveDiscoveryEnabled} matches.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnBlockingOrReactiveDiscoveryEnabled.OnBlockingOrReactiveDiscoveryEnabled.class) public @interface ConditionalOnBlockingOrReactiveDiscoveryEnabled {class OnBlockingOrReactiveDiscoveryEnabled extends AnyNestedCondition {\n  OnBlockingOrReactiveDiscoveryEnabled(){\n    super(ConfigurationPhase.REGISTER_BEAN);\n  }\n@ConditionalOnBlockingDiscoveryEnabled static class OnBlockingDiscoveryEnabled {\n  }\n@ConditionalOnReactiveDiscoveryEnabled static class OnReactiveDiscoveryEnabled {\n  }\n}\n}\n",
        "abstract": "/** \n * Conditional that is resolved to active when either {@link ConditionalOnBlockingDiscoveryEnabled} or{@link ConditionalOnReactiveDiscoveryEnabled} matches.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnBlockingOrReactiveDiscoveryEnabled.OnBlockingOrReactiveDiscoveryEnabled.class) public @interface ConditionalOnBlockingOrReactiveDiscoveryEnabled {class OnBlockingOrReactiveDiscoveryEnabled extends AnyNestedCondition {\n  OnBlockingOrReactiveDiscoveryEnabled(){\n    super(ConfigurationPhase.REGISTER_BEAN);\n  }\n@ConditionalOnBlockingDiscoveryEnabled static class OnBlockingDiscoveryEnabled {\n  }\n@ConditionalOnReactiveDiscoveryEnabled static class OnReactiveDiscoveryEnabled {\n  }\n}\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/KubernetesServiceInstance.java",
        "name": "KubernetesServiceInstance",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.KubernetesServiceInstance",
        "extend": "",
        "implements": "ServiceInstance",
        "raw": "/** \n * @author wind57{@link ServiceInstance} with additional methods, specific to kubernetes.\n */\npublic interface KubernetesServiceInstance extends ServiceInstance {\n  permits DefaultKubernetesServiceInstance;\n{\n  }\n  String getNamespace();\n  String getCluster();\n  default Map\u003cString,Map\u003cString,String\u003e\u003e podMetadata(){\n    return Map.of();\n  }\n}\n",
        "abstract": "/** \n * @author wind57{@link ServiceInstance} with additional methods, specific to kubernetes.\n */\npublic interface KubernetesServiceInstance extends ServiceInstance {\n  permits DefaultKubernetesServiceInstance;\n{\n  }\n  String getNamespace();\n  String getCluster();\n  default Map\u003cString,Map\u003cString,String\u003e\u003e podMetadata();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/KubernetesDiscoveryConstants.java",
        "name": "KubernetesDiscoveryConstants",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.KubernetesDiscoveryConstants",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Constants that are to be used across discovery implementations.\n * @author wind57\n */\npublic final class KubernetesDiscoveryConstants {\n  private KubernetesDiscoveryConstants(){\n  }\n  /** \n * Primary port label.\n */\n  public static final String PRIMARY_PORT_NAME_LABEL_KEY\u003d\"primary-port-name\";\n  /** \n * Https scheme.\n */\n  public static final String HTTPS\u003d\"https\";\n  /** \n * Http scheme.\n */\n  public static final String HTTP\u003d\"http\";\n  /** \n * Key of the namespace metadata.\n */\n  public static final String NAMESPACE_METADATA_KEY\u003d\"k8s_namespace\";\n  /** \n * Port name to use when there isn\u0027t one set.\n */\n  public static final String UNSET_PORT_NAME\u003d\"\u003cunset\u003e\";\n  /** \n * Discovery group for Catalog Watch.\n */\n  public static final String DISCOVERY_GROUP\u003d\"discovery.k8s.io\";\n  /** \n * Discovery version for Catalog Watch.\n */\n  public static final String DISCOVERY_VERSION\u003d\"v1\";\n  /** \n * Endpoint slice name.\n */\n  public static final String ENDPOINT_SLICE\u003d\"EndpointSlice\";\n  /** \n * ExternalName type of service.\n */\n  public static final String EXTERNAL_NAME\u003d\"ExternalName\";\n  /** \n * Type of the service.\n */\n  public static final String SERVICE_TYPE\u003d\"type\";\n  /** \n * value of the \u0027secure\u0027 label or annotation.\n */\n  public static final String SECURED\u003d\"secured\";\n  /** \n * catalog watch delay property name.\n */\n  public static final String CATALOG_WATCH_PROPERTY_NAME\u003d\"spring.cloud.kubernetes.discovery.catalogServicesWatchDelay\";\n  /** \n * default delay for the configuration watcher.\n */\n  public static final String CATALOG_WATCHER_DEFAULT_DELAY\u003d\"30000\";\n  /** \n * catalog watch delay property name with default value.\n */\n  public static final String CATALOG_WATCH_PROPERTY_WITH_DEFAULT_VALUE\u003dCATALOG_WATCH_PROPERTY_NAME + \":\" + CATALOG_WATCHER_DEFAULT_DELAY;\n  /** \n * load balancer port name property.\n */\n  public static final String PORT_NAME_PROPERTY\u003d\"\u0027spring.cloud.kubernetes.loadbalancer.portName\u0027\";\n  /** \n * message for non-deterministic port.\n */\n  public static final String NON_DETERMINISTIC_PORT_MESSAGE\u003d\"Will return \u0027first\u0027 port found, which is non-deterministic\";\n}\n",
        "abstract": "/** \n * Constants that are to be used across discovery implementations.\n * @author wind57\n */\npublic final class KubernetesDiscoveryConstants {\n  private KubernetesDiscoveryConstants();\n  /** \n * Primary port label.\n */\n  public static final String PRIMARY_PORT_NAME_LABEL_KEY\u003d\"primary-port-name\";\n  /** \n * Https scheme.\n */\n  public static final String HTTPS\u003d\"https\";\n  /** \n * Http scheme.\n */\n  public static final String HTTP\u003d\"http\";\n  /** \n * Key of the namespace metadata.\n */\n  public static final String NAMESPACE_METADATA_KEY\u003d\"k8s_namespace\";\n  /** \n * Port name to use when there isn\u0027t one set.\n */\n  public static final String UNSET_PORT_NAME\u003d\"\u003cunset\u003e\";\n  /** \n * Discovery group for Catalog Watch.\n */\n  public static final String DISCOVERY_GROUP\u003d\"discovery.k8s.io\";\n  /** \n * Discovery version for Catalog Watch.\n */\n  public static final String DISCOVERY_VERSION\u003d\"v1\";\n  /** \n * Endpoint slice name.\n */\n  public static final String ENDPOINT_SLICE\u003d\"EndpointSlice\";\n  /** \n * ExternalName type of service.\n */\n  public static final String EXTERNAL_NAME\u003d\"ExternalName\";\n  /** \n * Type of the service.\n */\n  public static final String SERVICE_TYPE\u003d\"type\";\n  /** \n * value of the \u0027secure\u0027 label or annotation.\n */\n  public static final String SECURED\u003d\"secured\";\n  /** \n * catalog watch delay property name.\n */\n  public static final String CATALOG_WATCH_PROPERTY_NAME\u003d\"spring.cloud.kubernetes.discovery.catalogServicesWatchDelay\";\n  /** \n * default delay for the configuration watcher.\n */\n  public static final String CATALOG_WATCHER_DEFAULT_DELAY\u003d\"30000\";\n  /** \n * catalog watch delay property name with default value.\n */\n  public static final String CATALOG_WATCH_PROPERTY_WITH_DEFAULT_VALUE\u003dCATALOG_WATCH_PROPERTY_NAME + \":\" + CATALOG_WATCHER_DEFAULT_DELAY;\n  /** \n * load balancer port name property.\n */\n  public static final String PORT_NAME_PROPERTY\u003d\"\u0027spring.cloud.kubernetes.loadbalancer.portName\u0027\";\n  /** \n * message for non-deterministic port.\n */\n  public static final String NON_DETERMINISTIC_PORT_MESSAGE\u003d\"Will return \u0027first\u0027 port found, which is non-deterministic\";\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/KubernetesDiscoveryClientHealthIndicatorInitializer.java",
        "name": "KubernetesDiscoveryClientHealthIndicatorInitializer",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.KubernetesDiscoveryClientHealthIndicatorInitializer",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic final class KubernetesDiscoveryClientHealthIndicatorInitializer {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesDiscoveryClientHealthIndicatorInitializer.class));\n  private final PodUtils\u003c?\u003e podUtils;\n  private final ApplicationEventPublisher applicationEventPublisher;\n  public KubernetesDiscoveryClientHealthIndicatorInitializer(  PodUtils\u003c?\u003e podUtils,  ApplicationEventPublisher applicationEventPublisher){\n    this.podUtils\u003dpodUtils;\n    this.applicationEventPublisher\u003dapplicationEventPublisher;\n  }\n  @PostConstruct private void postConstruct(){\n    LOG.debug(() -\u003e \"publishing InstanceRegisteredEvent\");\n    InstanceRegisteredEvent\u003cRegisteredEventSource\u003e instanceRegisteredEvent\u003dnew InstanceRegisteredEvent\u003c\u003e(new RegisteredEventSource(\"kubernetes\",podUtils.isInsideKubernetes(),podUtils.currentPod().get()),null);\n    applicationEventPublisher.publishEvent(instanceRegisteredEvent);\n  }\n  /** \n * @param cloudPlatform \"kubernetes\" always\n * @param inside inside kubernetes or not\n * @param pod an actual pod or null, if we are outside kubernetes\n */\n  public record RegisteredEventSource(  String cloudPlatform,  boolean inside,  Object pod){\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic final class KubernetesDiscoveryClientHealthIndicatorInitializer {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesDiscoveryClientHealthIndicatorInitializer.class));\n  private final PodUtils\u003c?\u003e podUtils;\n  private final ApplicationEventPublisher applicationEventPublisher;\n  public KubernetesDiscoveryClientHealthIndicatorInitializer(  PodUtils\u003c?\u003e podUtils,  ApplicationEventPublisher applicationEventPublisher);\n  @PostConstruct private void postConstruct();\n  /** \n * @param cloudPlatform \"kubernetes\" always\n * @param inside inside kubernetes or not\n * @param pod an actual pod or null, if we are outside kubernetes\n */\n  public record RegisteredEventSource(  String cloudPlatform,  boolean inside,  Object pod);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/ConditionalOnHttpDiscoveryCatalogWatcherEnabled.java",
        "name": "ConditionalOnHttpDiscoveryCatalogWatcherEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\",matchIfMissing\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.ConditionalOnHttpDiscoveryCatalogWatcherEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides a more succinct conditional for: \u003ccode\u003espring.cloud.kubernetes.http.discovery.client.catalog.watcher.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\",matchIfMissing\u003dfalse) public @interface ConditionalOnHttpDiscoveryCatalogWatcherEnabled {}\n",
        "abstract": "/** \n * Provides a more succinct conditional for: \u003ccode\u003espring.cloud.kubernetes.http.discovery.client.catalog.watcher.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\",matchIfMissing\u003dfalse) public @interface ConditionalOnHttpDiscoveryCatalogWatcherEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/KubernetesDiscoveryPropertiesAutoConfiguration.java",
        "name": "KubernetesDiscoveryPropertiesAutoConfiguration",
        "modifiers": "@EnableConfigurationProperties(KubernetesDiscoveryProperties.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.KubernetesDiscoveryPropertiesAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@EnableConfigurationProperties(KubernetesDiscoveryProperties.class) public class KubernetesDiscoveryPropertiesAutoConfiguration {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@EnableConfigurationProperties(KubernetesDiscoveryProperties.class) public class KubernetesDiscoveryPropertiesAutoConfiguration {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/ConditionalOnKubernetesCatalogEnabled.java",
        "name": "ConditionalOnKubernetesCatalogEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.discovery.catalog-services-watch.enabled\",matchIfMissing\u003dtrue) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.ConditionalOnKubernetesCatalogEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.discovery.catalog-services-watch.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.discovery.catalog-services-watch.enabled\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesCatalogEnabled {}\n",
        "abstract": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.discovery.catalog-services-watch.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.discovery.catalog-services-watch.enabled\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesCatalogEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/ConditionalOnKubernetesCatalogWatcherEnabled.java",
        "name": "ConditionalOnKubernetesCatalogWatcherEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingOrReactiveDiscoveryEnabled @ConditionalOnKubernetesCatalogEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.ConditionalOnKubernetesCatalogWatcherEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides common conditionals to be used for catalog watcher.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingOrReactiveDiscoveryEnabled @ConditionalOnKubernetesCatalogEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public @interface ConditionalOnKubernetesCatalogWatcherEnabled {}\n",
        "abstract": "/** \n * Provides common conditionals to be used for catalog watcher.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingOrReactiveDiscoveryEnabled @ConditionalOnKubernetesCatalogEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public @interface ConditionalOnKubernetesCatalogWatcherEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/ConditionalOnSpringCloudKubernetesReactiveDiscovery.java",
        "name": "ConditionalOnSpringCloudKubernetesReactiveDiscovery",
        "modifiers": "@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnReactiveDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.ConditionalOnSpringCloudKubernetesReactiveDiscovery",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides common conditionals to be used for reactive discovery.\n * @author wind57\n */\n@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnReactiveDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public @interface ConditionalOnSpringCloudKubernetesReactiveDiscovery {}\n",
        "abstract": "/** \n * Provides common conditionals to be used for reactive discovery.\n * @author wind57\n */\n@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnReactiveDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public @interface ConditionalOnSpringCloudKubernetesReactiveDiscovery {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/ServicePortSecureResolver.java",
        "name": "ServicePortSecureResolver",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.ServicePortSecureResolver",
        "extend": "",
        "implements": "",
        "raw": "public final class ServicePortSecureResolver {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(ServicePortSecureResolver.class));\n  private static final Set\u003cString\u003e TRUTHY_STRINGS\u003dSet.of(\"true\",\"on\",\"yes\",\"1\");\n  private final KubernetesDiscoveryProperties properties;\n  public ServicePortSecureResolver(  KubernetesDiscoveryProperties properties){\n    this.properties\u003dproperties;\n  }\n  /** \n * \u003cp\u003e Returns true if any of the following conditions apply. \u003cp\u003e \u003cul\u003e \u003cli\u003eservice contains a label named \u0027secured\u0027 that is truthy\u003c/li\u003e \u003cli\u003eservice contains an annotation named \u0027secured\u0027 that is truthy\u003c/li\u003e \u003cli\u003ethe port is one of the known ports used for secure communication\u003c/li\u003e \u003c/ul\u003e\n */\n  public boolean resolve(  Input input){\n    String serviceName\u003dinput.serviceName();\n    ServicePortNameAndNumber portData\u003dinput.portData();\n    Integer portNumber\u003dportData.portNumber();\n    Optional\u003cString\u003e securedLabelValue\u003dOptional.ofNullable(input.serviceLabels().get(SECURED));\n    if (securedLabelValue.isPresent() \u0026\u0026 TRUTHY_STRINGS.contains(securedLabelValue.get())) {\n      logEntry(serviceName,portData.portNumber(),\"the service contains a true value for the \u0027secured\u0027 label\");\n      return true;\n    }\n    Optional\u003cString\u003e securedAnnotationValue\u003dOptional.ofNullable(input.serviceAnnotations().get(SECURED));\n    if (securedAnnotationValue.isPresent() \u0026\u0026 TRUTHY_STRINGS.contains(securedAnnotationValue.get())) {\n      logEntry(serviceName,portData.portNumber(),\"the service contains a true value for the \u0027secured\u0027 annotation\");\n      return true;\n    }\n    if (portNumber !\u003d null \u0026\u0026 properties.knownSecurePorts().contains(portData.portNumber())) {\n      logEntry(serviceName,portData.portNumber(),\"port is known to be a https port\");\n      return true;\n    }\n    if (\"https\".equalsIgnoreCase(input.portData().portName())) {\n      logEntry(serviceName,portData.portNumber(),\"port-name is \u0027https\u0027\");\n      return true;\n    }\n    return false;\n  }\n  private static void logEntry(  String serviceName,  Integer port,  String reason){\n    LOG.debug(() -\u003e \"Considering service with name: \" + serviceName + \" and port \"+ port+ \" to be secure since \"+ reason);\n  }\n  /** \n * @author wind57\n */\n  public record Input(  ServicePortNameAndNumber portData,  String serviceName,  Map\u003cString,String\u003e serviceLabels,  Map\u003cString,String\u003e serviceAnnotations){\n    public Input.ServicePortNameAndNumber portData;\n    String serviceName;\n    Map\u003cString,String\u003e serviceLabels;\n    Map\u003cString,String\u003e serviceAnnotations;\n{\n      this.portData\u003dportData;\n      this.serviceName\u003dserviceName;\n      this.serviceLabels\u003dserviceLabels \u003d\u003d null ? Map.of() : serviceLabels;\n      this.serviceAnnotations\u003dserviceAnnotations \u003d\u003d null ? Map.of() : serviceAnnotations;\n    }\n  }\n}\n",
        "abstract": "public final class ServicePortSecureResolver {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(ServicePortSecureResolver.class));\n  private static final Set\u003cString\u003e TRUTHY_STRINGS\u003dSet.of(\"true\",\"on\",\"yes\",\"1\");\n  private final KubernetesDiscoveryProperties properties;\n  public ServicePortSecureResolver(  KubernetesDiscoveryProperties properties);\n  /** \n * \u003cp\u003e Returns true if any of the following conditions apply. \u003cp\u003e \u003cul\u003e \u003cli\u003eservice contains a label named \u0027secured\u0027 that is truthy\u003c/li\u003e \u003cli\u003eservice contains an annotation named \u0027secured\u0027 that is truthy\u003c/li\u003e \u003cli\u003ethe port is one of the known ports used for secure communication\u003c/li\u003e \u003c/ul\u003e\n */\n  public boolean resolve(  Input input);\n  private static void logEntry(  String serviceName,  Integer port,  String reason);\n  /** \n * @author wind57\n */\n  public record Input(  ServicePortNameAndNumber portData,  String serviceName,  Map\u003cString,String\u003e serviceLabels,  Map\u003cString,String\u003e serviceAnnotations);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/DiscoveryClientUtils.java",
        "name": "DiscoveryClientUtils",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.DiscoveryClientUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic final class DiscoveryClientUtils {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(DiscoveryClientUtils.class));\n  private DiscoveryClientUtils(){\n    throw new AssertionError(\"no instance provided\");\n  }\n  /** \n * This adds the following metadata. \u003cpre\u003e - labels (if requested) - annotations (if requested) - ports (if requested) - namespace - service type \u003c/pre\u003e\n */\n  public static Map\u003cString,String\u003e serviceInstanceMetadata(  Map\u003cString,Integer\u003e portsData,  ServiceMetadata serviceMetadata,  KubernetesDiscoveryProperties properties){\n    Map\u003cString,String\u003e result\u003dnew HashMap\u003c\u003e();\n    KubernetesDiscoveryProperties.Metadata metadataProps\u003dproperties.metadata();\n    if (metadataProps.addLabels()) {\n      Map\u003cString,String\u003e labelMetadata\u003dkeysWithPrefix(serviceMetadata.labels(),metadataProps.labelsPrefix());\n      LOG.debug(() -\u003e \"Adding labels metadata: \" + labelMetadata + \" for serviceId: \"+ serviceMetadata.name());\n      result.putAll(labelMetadata);\n    }\n    if (metadataProps.addAnnotations()) {\n      Map\u003cString,String\u003e annotationMetadata\u003dkeysWithPrefix(serviceMetadata.annotations(),metadataProps.annotationsPrefix());\n      LOG.debug(() -\u003e \"Adding annotations metadata: \" + annotationMetadata + \" for serviceId: \"+ serviceMetadata.name());\n      result.putAll(annotationMetadata);\n    }\n    if (metadataProps.addPorts()) {\n      Map\u003cString,String\u003e portsDataValueAsString\u003dportsData.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey,en -\u003e Integer.toString(en.getValue())));\n      Map\u003cString,String\u003e portMetadata\u003dkeysWithPrefix(portsDataValueAsString,properties.metadata().portsPrefix());\n      if (!portMetadata.isEmpty()) {\n        LOG.debug(() -\u003e \"Adding port metadata: \" + portMetadata + \" for serviceId : \"+ serviceMetadata.name());\n      }\n      result.putAll(portMetadata);\n    }\n    result.put(NAMESPACE_METADATA_KEY,serviceMetadata.namespace());\n    result.put(SERVICE_TYPE,serviceMetadata.type());\n    return result;\n  }\n  public static ServicePortNameAndNumber endpointsPort(  Map\u003cString,Integer\u003e existingPorts,  ServiceMetadata serviceMetadata,  KubernetesDiscoveryProperties properties){\n    if (existingPorts.isEmpty()) {\n      LOG.debug(() -\u003e \"no ports found for service : \" + serviceMetadata.name() + \", will return zero\");\n      return new ServicePortNameAndNumber(0,\"http\");\n    }\n    if (existingPorts.size() \u003d\u003d 1) {\n      Map.Entry\u003cString,Integer\u003e single\u003dexistingPorts.entrySet().iterator().next();\n      LOG.debug(() -\u003e \"endpoint ports has a single entry, using port : \" + single.getValue());\n      return new ServicePortNameAndNumber(single.getValue(),single.getKey());\n    }\n else {\n      Optional\u003cServicePortNameAndNumber\u003e portData;\n      String primaryPortName\u003dprimaryPortName(properties,serviceMetadata.labels(),serviceMetadata.name());\n      portData\u003dfromMap(existingPorts,primaryPortName,\"found primary-port-name (with value: \u0027\" + primaryPortName + \"\u0027) via properties or service labels to match port\");\n      if (portData.isPresent()) {\n        return portData.get();\n      }\n      portData\u003dfromMap(existingPorts,HTTPS,\"found primary-port-name via \u0027https\u0027 to match port\");\n      if (portData.isPresent()) {\n        return portData.get();\n      }\n      portData\u003dfromMap(existingPorts,HTTP,\"found primary-port-name via \u0027http\u0027 to match port\");\n      if (portData.isPresent()) {\n        return portData.get();\n      }\n      logWarnings();\n      Map.Entry\u003cString,Integer\u003e first\u003dexistingPorts.entrySet().iterator().next();\n      return new ServicePortNameAndNumber(first.getValue(),first.getKey());\n    }\n  }\n  public static ServiceInstance serviceInstance(  @Nullable ServicePortSecureResolver servicePortSecureResolver,  ServiceMetadata serviceMetadata,  Supplier\u003cInstanceIdHostPodName\u003e instanceIdAndHost,  Function\u003cString,PodLabelsAndAnnotations\u003e podLabelsAndMetadata,  ServicePortNameAndNumber portData,  Map\u003cString,String\u003e serviceInstanceMetadata,  KubernetesDiscoveryProperties properties){\n    InstanceIdHostPodName data\u003dinstanceIdAndHost.get();\n    boolean secured;\n    if (servicePortSecureResolver \u003d\u003d null) {\n      secured\u003dfalse;\n    }\n else {\n      secured\u003dservicePortSecureResolver.resolve(new ServicePortSecureResolver.Input(portData,serviceMetadata.name(),serviceMetadata.labels(),serviceMetadata.annotations()));\n    }\n    Map\u003cString,Map\u003cString,String\u003e\u003e podMetadata\u003dpodMetadata(data.podName(),serviceInstanceMetadata,properties,podLabelsAndMetadata);\n    return new DefaultKubernetesServiceInstance(data.instanceId(),serviceMetadata.name(),data.host(),portData.portNumber(),serviceInstanceMetadata,secured,serviceMetadata.namespace(),null,podMetadata);\n  }\n  /** \n * take primary-port-name from service label \"PRIMARY_PORT_NAME_LABEL_KEY\" if it exists, otherwise from KubernetesDiscoveryProperties if it exists, otherwise null.\n */\n  static String primaryPortName(  KubernetesDiscoveryProperties properties,  Map\u003cString,String\u003e serviceLabels,  String serviceId){\n    String primaryPortNameFromProperties\u003dproperties.primaryPortName();\n    String primaryPortName\u003dOptional.ofNullable(Optional.ofNullable(serviceLabels).orElse(Map.of()).get(PRIMARY_PORT_NAME_LABEL_KEY)).orElse(primaryPortNameFromProperties);\n    if (primaryPortName \u003d\u003d null) {\n      LOG.debug(() -\u003e \"did not find a primary-port-name in neither properties nor service labels for service with ID : \" + serviceId);\n      return null;\n    }\n    LOG.debug(() -\u003e \"will use primaryPortName : \" + primaryPortName + \" for service with ID \u003d \"+ serviceId);\n    return primaryPortName;\n  }\n  static Map\u003cString,Map\u003cString,String\u003e\u003e podMetadata(  String podName,  Map\u003cString,String\u003e serviceMetadata,  KubernetesDiscoveryProperties properties,  Function\u003cString,PodLabelsAndAnnotations\u003e podLabelsAndMetadata){\n    if (!EXTERNAL_NAME.equals(serviceMetadata.get(SERVICE_TYPE))) {\n      if (properties.metadata().addPodLabels() || properties.metadata().addPodAnnotations()) {\n        LOG.debug(() -\u003e \"Pod labels/annotations were requested\");\n        if (podName !\u003d null) {\n          LOG.debug(() -\u003e \"getting labels/annotation for pod: \" + podName);\n          PodLabelsAndAnnotations both\u003dpodLabelsAndMetadata.apply(podName);\n          Map\u003cString,Map\u003cString,String\u003e\u003e result\u003dnew HashMap\u003c\u003e();\n          if (properties.metadata().addPodLabels() \u0026\u0026 !both.labels().isEmpty()) {\n            result.put(\"labels\",both.labels());\n          }\n          if (properties.metadata().addPodAnnotations() \u0026\u0026 !both.annotations().isEmpty()) {\n            result.put(\"annotations\",both.annotations());\n          }\n          LOG.debug(() -\u003e \"adding podMetadata : \" + result + \" from pod : \"+ podName);\n          return result;\n        }\n      }\n    }\n    return Map.of();\n  }\n  private static Optional\u003cServicePortNameAndNumber\u003e fromMap(  Map\u003cString,Integer\u003e existingPorts,  String key,  String message){\n    Integer fromPrimaryPortName\u003dexistingPorts.get(key);\n    if (fromPrimaryPortName \u003d\u003d null) {\n      LOG.debug(() -\u003e \"not \" + message);\n      return Optional.empty();\n    }\n else {\n      LOG.debug(() -\u003e message + \" : \" + fromPrimaryPortName);\n      return Optional.of(new ServicePortNameAndNumber(fromPrimaryPortName,key));\n    }\n  }\n  private static void logWarnings(){\n    LOG.warn(() -\u003e null);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic final class DiscoveryClientUtils {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(DiscoveryClientUtils.class));\n  private DiscoveryClientUtils();\n  /** \n * This adds the following metadata. \u003cpre\u003e - labels (if requested) - annotations (if requested) - ports (if requested) - namespace - service type \u003c/pre\u003e\n */\n  public static Map\u003cString,String\u003e serviceInstanceMetadata(  Map\u003cString,Integer\u003e portsData,  ServiceMetadata serviceMetadata,  KubernetesDiscoveryProperties properties);\n  public static ServicePortNameAndNumber endpointsPort(  Map\u003cString,Integer\u003e existingPorts,  ServiceMetadata serviceMetadata,  KubernetesDiscoveryProperties properties);\n  public static ServiceInstance serviceInstance(  @Nullable ServicePortSecureResolver servicePortSecureResolver,  ServiceMetadata serviceMetadata,  Supplier\u003cInstanceIdHostPodName\u003e instanceIdAndHost,  Function\u003cString,PodLabelsAndAnnotations\u003e podLabelsAndMetadata,  ServicePortNameAndNumber portData,  Map\u003cString,String\u003e serviceInstanceMetadata,  KubernetesDiscoveryProperties properties);\n  /** \n * take primary-port-name from service label \"PRIMARY_PORT_NAME_LABEL_KEY\" if it exists, otherwise from KubernetesDiscoveryProperties if it exists, otherwise null.\n */\n  static String primaryPortName(  KubernetesDiscoveryProperties properties,  Map\u003cString,String\u003e serviceLabels,  String serviceId);\n  static Map\u003cString,Map\u003cString,String\u003e\u003e podMetadata(  String podName,  Map\u003cString,String\u003e serviceMetadata,  KubernetesDiscoveryProperties properties,  Function\u003cString,PodLabelsAndAnnotations\u003e podLabelsAndMetadata);\n  private static Optional\u003cServicePortNameAndNumber\u003e fromMap(  Map\u003cString,Integer\u003e existingPorts,  String key,  String message);\n  private static void logWarnings();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/ConditionalOnSpringCloudKubernetesBlockingDiscovery.java",
        "name": "ConditionalOnSpringCloudKubernetesBlockingDiscovery",
        "modifiers": "@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.ConditionalOnSpringCloudKubernetesBlockingDiscovery",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides common conditionals to be used for blocking discovery.\n * @author wind57\n */\n@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public @interface ConditionalOnSpringCloudKubernetesBlockingDiscovery {}\n",
        "abstract": "/** \n * Provides common conditionals to be used for blocking discovery.\n * @author wind57\n */\n@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnDiscoveryEnabled @ConditionalOnKubernetesDiscoveryEnabled @ConditionalOnBlockingDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public @interface ConditionalOnSpringCloudKubernetesBlockingDiscovery {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/ConditionalOnKubernetesDiscoveryEnabled.java",
        "name": "ConditionalOnKubernetesDiscoveryEnabled",
        "modifiers": "@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.discovery.enabled\",matchIfMissing\u003dtrue) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.ConditionalOnKubernetesDiscoveryEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.discovery.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.discovery.enabled\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesDiscoveryEnabled {}\n",
        "abstract": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.discovery.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.discovery.enabled\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesDiscoveryEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer.java",
        "name": "ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.health.ReactiveHealthIndicator\") @ConditionalOnDiscoveryHealthIndicatorEnabled public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides common conditionals to be used for reactive discovery health initializer.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.health.ReactiveHealthIndicator\") @ConditionalOnDiscoveryHealthIndicatorEnabled public @interface ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer {}\n",
        "abstract": "/** \n * Provides common conditionals to be used for reactive discovery health initializer.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.health.ReactiveHealthIndicator\") @ConditionalOnDiscoveryHealthIndicatorEnabled public @interface ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/discovery/ConditionalOnSpringCloudKubernetesBlockingDiscoveryHealthInitializer.java",
        "name": "ConditionalOnSpringCloudKubernetesBlockingDiscoveryHealthInitializer",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.health.HealthIndicator\") @ConditionalOnDiscoveryHealthIndicatorEnabled public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.ConditionalOnSpringCloudKubernetesBlockingDiscoveryHealthInitializer",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides common conditionals to be used for blocking discovery health initializer.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.health.HealthIndicator\") @ConditionalOnDiscoveryHealthIndicatorEnabled public @interface ConditionalOnSpringCloudKubernetesBlockingDiscoveryHealthInitializer {}\n",
        "abstract": "/** \n * Provides common conditionals to be used for blocking discovery health initializer.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.health.HealthIndicator\") @ConditionalOnDiscoveryHealthIndicatorEnabled public @interface ConditionalOnSpringCloudKubernetesBlockingDiscoveryHealthInitializer {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/autoconfig/ConditionalOnKubernetesHealthIndicatorEnabled.java",
        "name": "ConditionalOnKubernetesHealthIndicatorEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.health.HealthIndicator\") @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.autoconfig.ConditionalOnKubernetesHealthIndicatorEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.health.HealthIndicator\") @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public @interface ConditionalOnKubernetesHealthIndicatorEnabled {}\n",
        "abstract": "/** \n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.health.HealthIndicator\") @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public @interface ConditionalOnKubernetesHealthIndicatorEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/KubernetesCommonsAutoConfiguration.java",
        "name": "KubernetesCommonsAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @EnableConfigurationProperties(KubernetesClientProperties.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.KubernetesCommonsAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @EnableConfigurationProperties(KubernetesClientProperties.class) public class KubernetesCommonsAutoConfiguration {\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @EnableConfigurationProperties(KubernetesClientProperties.class) public class KubernetesCommonsAutoConfiguration {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/ConditionalOnKubernetesSecretsEnabled.java",
        "name": "ConditionalOnKubernetesSecretsEnabled",
        "modifiers": "@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.secrets.enabled\",matchIfMissing\u003dtrue) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.ConditionalOnKubernetesSecretsEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.secrets.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.secrets.enabled\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesSecretsEnabled {}\n",
        "abstract": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.secrets.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.secrets.enabled\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesSecretsEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/leader/PodReadinessWatcher.java",
        "name": "PodReadinessWatcher",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.leader.PodReadinessWatcher",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic interface PodReadinessWatcher {\n  void start();\n  void stop();\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic interface PodReadinessWatcher {\n  void start();\n  void stop();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/leader/LeaderProperties.java",
        "name": "LeaderProperties",
        "modifiers": "@ConfigurationProperties(\"spring.cloud.kubernetes.leader\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.leader.LeaderProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Gytis Trikleris\n */\n@ConfigurationProperties(\"spring.cloud.kubernetes.leader\") public class LeaderProperties {\n  /** \n * Should leader election be enabled. Default: true\n */\n  private boolean enabled\u003dtrue;\n  /** \n * Should leader election be started automatically on startup. Default: true\n */\n  private boolean autoStartup\u003dtrue;\n  /** \n * Role for which leadership this candidate will compete.\n */\n  private String role;\n  /** \n * Kubernetes namespace where the leaders ConfigMap and candidates are located.\n */\n  private String namespace;\n  /** \n * Kubernetes ConfigMap where leaders information will be stored. Default: leaders\n */\n  private String configMapName\u003d\"leaders\";\n  /** \n * Leader id property prefix for the ConfigMap. Default: leader.id.\n */\n  private String leaderIdPrefix\u003d\"leader.id.\";\n  /** \n * Leadership status check period. Default: 60s\n */\n  private Duration updatePeriod\u003dDuration.ofMillis(60000);\n  /** \n * Enable/disable publishing events in case leadership acquisition fails. Default: false\n */\n  private boolean publishFailedEvents\u003dfalse;\n  /** \n * Enable/disable creating ConfigMap if it does not exist. Default: true\n */\n  private boolean createConfigMap\u003dtrue;\n  public boolean isEnabled(){\n    return enabled;\n  }\n  public void setEnabled(  boolean enabled){\n    this.enabled\u003denabled;\n  }\n  public boolean isAutoStartup(){\n    return autoStartup;\n  }\n  public void setAutoStartup(  boolean autoStartup){\n    this.autoStartup\u003dautoStartup;\n  }\n  public String getRole(){\n    return role;\n  }\n  public void setRole(  String role){\n    this.role\u003drole;\n  }\n  public String getNamespace(){\n    return namespace;\n  }\n  public void setNamespace(  String namespace){\n    this.namespace\u003dnamespace;\n  }\n  public String getNamespace(  String defaultValue){\n    if (namespace \u003d\u003d null || namespace.isEmpty()) {\n      return defaultValue;\n    }\n    return namespace;\n  }\n  public String getConfigMapName(){\n    return configMapName;\n  }\n  public void setConfigMapName(  String configMapName){\n    this.configMapName\u003dconfigMapName;\n  }\n  public String getLeaderIdPrefix(){\n    return leaderIdPrefix;\n  }\n  public void setLeaderIdPrefix(  String leaderIdPrefix){\n    this.leaderIdPrefix\u003dleaderIdPrefix;\n  }\n  public Duration getUpdatePeriod(){\n    return updatePeriod;\n  }\n  public void setUpdatePeriod(  Duration updatePeriod){\n    this.updatePeriod\u003dupdatePeriod;\n  }\n  public boolean isPublishFailedEvents(){\n    return publishFailedEvents;\n  }\n  public void setPublishFailedEvents(  boolean publishFailedEvents){\n    this.publishFailedEvents\u003dpublishFailedEvents;\n  }\n  public boolean isCreateConfigMap(){\n    return createConfigMap;\n  }\n  public void setCreateConfigMap(  boolean createConfigMap){\n    this.createConfigMap\u003dcreateConfigMap;\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\n@ConfigurationProperties(\"spring.cloud.kubernetes.leader\") public class LeaderProperties {\n  /** \n * Should leader election be enabled. Default: true\n */\n  private boolean enabled\u003dtrue;\n  /** \n * Should leader election be started automatically on startup. Default: true\n */\n  private boolean autoStartup\u003dtrue;\n  /** \n * Role for which leadership this candidate will compete.\n */\n  private String role;\n  /** \n * Kubernetes namespace where the leaders ConfigMap and candidates are located.\n */\n  private String namespace;\n  /** \n * Kubernetes ConfigMap where leaders information will be stored. Default: leaders\n */\n  private String configMapName\u003d\"leaders\";\n  /** \n * Leader id property prefix for the ConfigMap. Default: leader.id.\n */\n  private String leaderIdPrefix\u003d\"leader.id.\";\n  /** \n * Leadership status check period. Default: 60s\n */\n  private Duration updatePeriod\u003dDuration.ofMillis(60000);\n  /** \n * Enable/disable publishing events in case leadership acquisition fails. Default: false\n */\n  private boolean publishFailedEvents\u003dfalse;\n  /** \n * Enable/disable creating ConfigMap if it does not exist. Default: true\n */\n  private boolean createConfigMap\u003dtrue;\n  public boolean isEnabled();\n  public void setEnabled(  boolean enabled);\n  public boolean isAutoStartup();\n  public void setAutoStartup(  boolean autoStartup);\n  public String getRole();\n  public void setRole(  String role);\n  public String getNamespace();\n  public void setNamespace(  String namespace);\n  public String getNamespace(  String defaultValue);\n  public String getConfigMapName();\n  public void setConfigMapName(  String configMapName);\n  public String getLeaderIdPrefix();\n  public void setLeaderIdPrefix(  String leaderIdPrefix);\n  public Duration getUpdatePeriod();\n  public void setUpdatePeriod(  Duration updatePeriod);\n  public boolean isPublishFailedEvents();\n  public void setPublishFailedEvents(  boolean publishFailedEvents);\n  public boolean isCreateConfigMap();\n  public void setCreateConfigMap(  boolean createConfigMap);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/leader/LeadershipController.java",
        "name": "LeadershipController",
        "modifiers": "public abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.leader.LeadershipController",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic abstract class LeadershipController {\n  private static final Logger LOGGER\u003dLoggerFactory.getLogger(LeadershipController.class);\n  protected static final String PROVIDER_KEY\u003d\"provider\";\n  protected static final String PROVIDER\u003d\"spring-cloud-kubernetes\";\n  protected static final String KIND_KEY\u003d\"kind\";\n  protected static final String KIND\u003d\"leaders\";\n  protected Candidate candidate;\n  protected Leader localLeader;\n  protected LeaderProperties leaderProperties;\n  protected LeaderEventPublisher leaderEventPublisher;\n  protected PodReadinessWatcher leaderReadinessWatcher;\n  public LeadershipController(  Candidate candidate,  LeaderProperties leaderProperties,  LeaderEventPublisher leaderEventPublisher){\n    this.candidate\u003dcandidate;\n    this.leaderProperties\u003dleaderProperties;\n    this.leaderEventPublisher\u003dleaderEventPublisher;\n  }\n  public Optional\u003cLeader\u003e getLocalLeader(){\n    return Optional.ofNullable(this.localLeader);\n  }\n  public abstract void update();\n  public abstract void revoke();\n  protected String getLeaderKey(){\n    return this.leaderProperties.getLeaderIdPrefix() + this.candidate.getRole();\n  }\n  protected Map\u003cString,String\u003e getLeaderData(  Candidate candidate){\n    String leaderKey\u003dgetLeaderKey();\n    return Collections.singletonMap(leaderKey,candidate.getId());\n  }\n  protected Leader extractLeader(  Map\u003cString,String\u003e data){\n    if (data \u003d\u003d null) {\n      return null;\n    }\n    String leaderKey\u003dgetLeaderKey();\n    String leaderId\u003ddata.get(leaderKey);\n    if (!StringUtils.hasText(leaderId)) {\n      return null;\n    }\n    return new Leader(this.candidate.getRole(),leaderId);\n  }\n  protected void handleLeaderChange(  Leader newLeader){\n    if (Objects.equals(this.localLeader,newLeader)) {\n      LOGGER.debug(\"Leader is still \u0027{}\u0027\",this.localLeader);\n      return;\n    }\n    Leader oldLeader\u003dthis.localLeader;\n    this.localLeader\u003dnewLeader;\n    if (oldLeader !\u003d null \u0026\u0026 oldLeader.isCandidate(this.candidate)) {\n      notifyOnRevoked();\n    }\n else     if (newLeader !\u003d null \u0026\u0026 newLeader.isCandidate(this.candidate)) {\n      notifyOnGranted();\n    }\n    restartLeaderReadinessWatcher();\n    LOGGER.debug(\"New leader is \u0027{}\u0027\",this.localLeader);\n  }\n  protected void notifyOnGranted(){\n    LOGGER.debug(\"Leadership has been granted for \u0027{}\u0027\",this.candidate);\n    Context context\u003dnew LeaderContext(this.candidate,this);\n    this.leaderEventPublisher.publishOnGranted(this,context,this.candidate.getRole());\n    try {\n      this.candidate.onGranted(context);\n    }\n catch (    InterruptedException e) {\n      LOGGER.warn(e.getMessage());\n      Thread.currentThread().interrupt();\n    }\n  }\n  protected void notifyOnRevoked(){\n    LOGGER.debug(\"Leadership has been revoked for \u0027{}\u0027\",this.candidate);\n    Context context\u003dnew LeaderContext(this.candidate,this);\n    this.leaderEventPublisher.publishOnRevoked(this,context,this.candidate.getRole());\n    this.candidate.onRevoked(context);\n  }\n  protected void notifyOnFailedToAcquire(){\n    if (this.leaderProperties.isPublishFailedEvents()) {\n      Context context\u003dnew LeaderContext(this.candidate,this);\n      this.leaderEventPublisher.publishOnFailedToAcquire(this,context,this.candidate.getRole());\n    }\n  }\n  protected void restartLeaderReadinessWatcher(){\n    if (this.leaderReadinessWatcher !\u003d null) {\n      this.leaderReadinessWatcher.stop();\n      this.leaderReadinessWatcher\u003dnull;\n    }\n    if (this.localLeader !\u003d null \u0026\u0026 !this.localLeader.isCandidate(this.candidate)) {\n      this.leaderReadinessWatcher\u003dcreatePodReadinessWatcher(this.localLeader.getId());\n      this.leaderReadinessWatcher.start();\n    }\n  }\n  protected abstract PodReadinessWatcher createPodReadinessWatcher(  String localLeaderId);\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic abstract class LeadershipController {\n  private static final Logger LOGGER\u003dLoggerFactory.getLogger(LeadershipController.class);\n  protected static final String PROVIDER_KEY\u003d\"provider\";\n  protected static final String PROVIDER\u003d\"spring-cloud-kubernetes\";\n  protected static final String KIND_KEY\u003d\"kind\";\n  protected static final String KIND\u003d\"leaders\";\n  protected Candidate candidate;\n  protected Leader localLeader;\n  protected LeaderProperties leaderProperties;\n  protected LeaderEventPublisher leaderEventPublisher;\n  protected PodReadinessWatcher leaderReadinessWatcher;\n  public LeadershipController(  Candidate candidate,  LeaderProperties leaderProperties,  LeaderEventPublisher leaderEventPublisher);\n  public Optional\u003cLeader\u003e getLocalLeader();\n  public abstract void update();\n  public abstract void revoke();\n  protected String getLeaderKey();\n  protected Map\u003cString,String\u003e getLeaderData(  Candidate candidate);\n  protected Leader extractLeader(  Map\u003cString,String\u003e data);\n  protected void handleLeaderChange(  Leader newLeader);\n  protected void notifyOnGranted();\n  protected void notifyOnRevoked();\n  protected void notifyOnFailedToAcquire();\n  protected void restartLeaderReadinessWatcher();\n  protected abstract PodReadinessWatcher createPodReadinessWatcher(  String localLeaderId);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/leader/LeaderContext.java",
        "name": "LeaderContext",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.leader.LeaderContext",
        "extend": "",
        "implements": "Context",
        "raw": "/** \n * @author Gytis Trikleris\n */\npublic class LeaderContext implements Context {\n  private final Candidate candidate;\n  private final LeadershipController leadershipController;\n  public LeaderContext(  Candidate candidate,  LeadershipController leadershipController){\n    this.candidate\u003dcandidate;\n    this.leadershipController\u003dleadershipController;\n  }\n  @Override public boolean isLeader(){\n    return this.leadershipController.getLocalLeader().filter(l -\u003e l.isCandidate(this.candidate)).isPresent();\n  }\n  @Override public void yield(){\n    this.leadershipController.revoke();\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\npublic class LeaderContext implements Context {\n  private final Candidate candidate;\n  private final LeadershipController leadershipController;\n  public LeaderContext(  Candidate candidate,  LeadershipController leadershipController);\n  @Override public boolean isLeader();\n  @Override public void yield();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/leader/LeaderUtils.java",
        "name": "LeaderUtils",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.leader.LeaderUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic final class LeaderUtils {\n  private static final String HOSTNAME\u003d\"HOSTNAME\";\n  private LeaderUtils(){\n  }\n  public static String hostName() throws UnknownHostException {\n    String hostName\u003dEnvReader.getEnv(HOSTNAME);\n    if (StringUtils.hasText(hostName)) {\n      return hostName;\n    }\n else {\n      return InetAddress.getLocalHost().getHostName();\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic final class LeaderUtils {\n  private static final String HOSTNAME\u003d\"HOSTNAME\";\n  private LeaderUtils();\n  public static String hostName() throws UnknownHostException;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/leader/LeaderRecordWatcher.java",
        "name": "LeaderRecordWatcher",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.leader.LeaderRecordWatcher",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic interface LeaderRecordWatcher {\n  void start();\n  void stop();\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic interface LeaderRecordWatcher {\n  void start();\n  void stop();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/leader/LeaderInitiator.java",
        "name": "LeaderInitiator",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.leader.LeaderInitiator",
        "extend": "",
        "implements": "SmartLifecycle",
        "raw": "/** \n * @author Gytis Trikleris\n */\npublic class LeaderInitiator implements SmartLifecycle {\n  private static final Logger LOGGER\u003dLoggerFactory.getLogger(LeaderInitiator.class);\n  private final LeaderProperties leaderProperties;\n  private final LeadershipController leadershipController;\n  private final LeaderRecordWatcher leaderRecordWatcher;\n  private final PodReadinessWatcher hostPodWatcher;\n  private ScheduledExecutorService scheduledExecutorService;\n  private boolean isRunning;\n  public LeaderInitiator(  LeaderProperties leaderProperties,  LeadershipController leadershipController,  LeaderRecordWatcher leaderRecordWatcher,  PodReadinessWatcher hostPodWatcher){\n    this.leaderProperties\u003dleaderProperties;\n    this.leadershipController\u003dleadershipController;\n    this.leaderRecordWatcher\u003dleaderRecordWatcher;\n    this.hostPodWatcher\u003dhostPodWatcher;\n  }\n  @Override public boolean isAutoStartup(){\n    return this.leaderProperties.isAutoStartup();\n  }\n  @Override public void start(){\n    if (!isRunning()) {\n      LOGGER.debug(\"Leader initiator starting\");\n      this.leaderRecordWatcher.start();\n      this.hostPodWatcher.start();\n      this.scheduledExecutorService\u003dExecutors.newSingleThreadScheduledExecutor();\n      this.scheduledExecutorService.scheduleAtFixedRate(this.leadershipController::update,this.leaderProperties.getUpdatePeriod().toMillis(),this.leaderProperties.getUpdatePeriod().toMillis(),TimeUnit.MILLISECONDS);\n      this.isRunning\u003dtrue;\n    }\n  }\n  @Override public void stop(){\n    if (isRunning()) {\n      LOGGER.debug(\"Leader initiator stopping\");\n      this.scheduledExecutorService.shutdown();\n      this.scheduledExecutorService\u003dnull;\n      this.hostPodWatcher.stop();\n      this.leaderRecordWatcher.stop();\n      this.leadershipController.revoke();\n      this.isRunning\u003dfalse;\n    }\n  }\n  @Override public void stop(  Runnable callback){\n    stop();\n    callback.run();\n  }\n  @Override public boolean isRunning(){\n    return this.isRunning;\n  }\n  @Override public int getPhase(){\n    return 0;\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\npublic class LeaderInitiator implements SmartLifecycle {\n  private static final Logger LOGGER\u003dLoggerFactory.getLogger(LeaderInitiator.class);\n  private final LeaderProperties leaderProperties;\n  private final LeadershipController leadershipController;\n  private final LeaderRecordWatcher leaderRecordWatcher;\n  private final PodReadinessWatcher hostPodWatcher;\n  private ScheduledExecutorService scheduledExecutorService;\n  private boolean isRunning;\n  public LeaderInitiator(  LeaderProperties leaderProperties,  LeadershipController leadershipController,  LeaderRecordWatcher leaderRecordWatcher,  PodReadinessWatcher hostPodWatcher);\n  @Override public boolean isAutoStartup();\n  @Override public void start();\n  @Override public void stop();\n  @Override public void stop(  Runnable callback);\n  @Override public boolean isRunning();\n  @Override public int getPhase();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/leader/LeaderInfoContributor.java",
        "name": "LeaderInfoContributor",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.leader.LeaderInfoContributor",
        "extend": "",
        "implements": "InfoContributor",
        "raw": "public class LeaderInfoContributor implements InfoContributor {\n  private final LeadershipController leadershipController;\n  private final Candidate candidate;\n  public LeaderInfoContributor(  LeadershipController leadershipController,  Candidate candidate){\n    this.leadershipController\u003dleadershipController;\n    this.candidate\u003dcandidate;\n  }\n  @Override public void contribute(  Builder builder){\n    Map\u003cString,Object\u003e details\u003dnew HashMap\u003c\u003e();\n    leadershipController.getLocalLeader().ifPresentOrElse(leader -\u003e {\n      details.put(\"leaderId\",leader.getId());\n      details.put(\"role\",leader.getRole());\n      details.put(\"isLeader\",leader.isCandidate(candidate));\n    }\n,() -\u003e details.put(\"leaderId\",\"Unknown\"));\n    builder.withDetail(\"leaderElection\",details);\n  }\n}\n",
        "abstract": "public class LeaderInfoContributor implements InfoContributor {\n  private final LeadershipController leadershipController;\n  private final Candidate candidate;\n  public LeaderInfoContributor(  LeadershipController leadershipController,  Candidate candidate);\n  @Override public void contribute(  Builder builder);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/leader/Leader.java",
        "name": "Leader",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.leader.Leader",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Gytis Trikleris\n */\npublic class Leader {\n  private final String role;\n  private final String id;\n  public Leader(  String role,  String id){\n    this.role\u003drole;\n    this.id\u003did;\n  }\n  public String getRole(){\n    return this.role;\n  }\n  public String getId(){\n    return this.id;\n  }\n  public boolean isCandidate(  Candidate candidate){\n    if (candidate \u003d\u003d null) {\n      return false;\n    }\n    return Objects.equals(role,candidate.getRole()) \u0026\u0026 Objects.equals(id,candidate.getId());\n  }\n  @Override public boolean equals(  Object o){\n    if (this \u003d\u003d o) {\n      return true;\n    }\n    if (o \u003d\u003d null || getClass() !\u003d o.getClass()) {\n      return false;\n    }\n    Leader leader\u003d(Leader)o;\n    return Objects.equals(this.role,leader.role) \u0026\u0026 Objects.equals(this.id,leader.id);\n  }\n  @Override public int hashCode(){\n    return Objects.hash(this.role,this.id);\n  }\n  @Override public String toString(){\n    return String.format(\"Leader{role\u003d\u0027%s\u0027, id\u003d\u0027%s\u0027}\",this.role,this.id);\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\npublic class Leader {\n  private final String role;\n  private final String id;\n  public Leader(  String role,  String id);\n  public String getRole();\n  public String getId();\n  public boolean isCandidate(  Candidate candidate);\n  @Override public boolean equals(  Object o);\n  @Override public int hashCode();\n  @Override public String toString();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/EnvReader.java",
        "name": "EnvReader",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.EnvReader",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57a class that should be used instead of System::getEnv, uselfull for testing\n */\npublic final class EnvReader {\n  private EnvReader(){\n  }\n  public static String getEnv(  String property){\n    return System.getenv(property);\n  }\n}\n",
        "abstract": "/** \n * @author wind57a class that should be used instead of System::getEnv, uselfull for testing\n */\npublic final class EnvReader {\n  private EnvReader();\n  public static String getEnv(  String property);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/ConditionalOnKubernetesConfigMapsOrSecretsEnabled.java",
        "name": "ConditionalOnKubernetesConfigMapsOrSecretsEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnKubernetesConfigMapsOrSecretsEnabled.OnKubernetesConfigMapsOrSecretesEnabled.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.ConditionalOnKubernetesConfigMapsOrSecretsEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * {@link Conditional @Conditional} that matches when either or both of{@link ConditionalOnKubernetesConfigEnabled @ConditionalOnKubernetesConfigEnabled} and{@link ConditionalOnKubernetesSecretsEnabled @ConditionalOnKubernetesSecretsEnabled}.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnKubernetesConfigMapsOrSecretsEnabled.OnKubernetesConfigMapsOrSecretesEnabled.class) public @interface ConditionalOnKubernetesConfigMapsOrSecretsEnabled {class OnKubernetesConfigMapsOrSecretesEnabled extends AnyNestedCondition {\n  OnKubernetesConfigMapsOrSecretesEnabled(){\n    super(ConfigurationPhase.REGISTER_BEAN);\n  }\n@ConditionalOnKubernetesConfigEnabled static class OnConfigMapPropertiesRetryEnabled {\n  }\n@ConditionalOnKubernetesSecretsEnabled static class OnSecretsPropertiesRetryEnabled {\n  }\n}\n}\n",
        "abstract": "/** \n * {@link Conditional @Conditional} that matches when either or both of{@link ConditionalOnKubernetesConfigEnabled @ConditionalOnKubernetesConfigEnabled} and{@link ConditionalOnKubernetesSecretsEnabled @ConditionalOnKubernetesSecretsEnabled}.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnKubernetesConfigMapsOrSecretsEnabled.OnKubernetesConfigMapsOrSecretesEnabled.class) public @interface ConditionalOnKubernetesConfigMapsOrSecretsEnabled {class OnKubernetesConfigMapsOrSecretesEnabled extends AnyNestedCondition {\n  OnKubernetesConfigMapsOrSecretesEnabled(){\n    super(ConfigurationPhase.REGISTER_BEAN);\n  }\n@ConditionalOnKubernetesConfigEnabled static class OnConfigMapPropertiesRetryEnabled {\n  }\n@ConditionalOnKubernetesSecretsEnabled static class OnSecretsPropertiesRetryEnabled {\n  }\n}\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/ConditionalOnSanitizeSecrets.java",
        "name": "ConditionalOnSanitizeSecrets",
        "modifiers": "@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003dConditionalOnSanitizeSecrets.VALUE,matchIfMissing\u003dfalse) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.ConditionalOnSanitizeSecrets",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.sanitize.secrets\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003dConditionalOnSanitizeSecrets.VALUE,matchIfMissing\u003dfalse) public @interface ConditionalOnSanitizeSecrets {/** \n * Conditional value to use.\n */\nString VALUE\u003d\"spring.cloud.kubernetes.sanitize.secrets\";\n}\n",
        "abstract": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.sanitize.secrets\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.METHOD,ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(value\u003dConditionalOnSanitizeSecrets.VALUE,matchIfMissing\u003dfalse) public @interface ConditionalOnSanitizeSecrets {/** \n * Conditional value to use.\n */\nString VALUE\u003d\"spring.cloud.kubernetes.sanitize.secrets\";\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/profile/AbstractKubernetesProfileEnvironmentPostProcessor.java",
        "name": "AbstractKubernetesProfileEnvironmentPostProcessor",
        "modifiers": "public abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.profile.AbstractKubernetesProfileEnvironmentPostProcessor",
        "extend": "",
        "implements": "EnvironmentPostProcessor Ordered",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic abstract class AbstractKubernetesProfileEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {\n  private static final DeferredLog LOG\u003dnew DeferredLog();\n  private static final String NAMESPACE_PATH_PROPERTY\u003d\"spring.cloud.kubernetes.client.serviceAccountNamespacePath\";\n  protected static final String NAMESPACE_PROPERTY\u003d\"spring.cloud.kubernetes.client.namespace\";\n  private static final String PROPERTY_SOURCE_NAME\u003d\"KUBERNETES_NAMESPACE_PROPERTY_SOURCE\";\n  private static final int ORDER\u003dConfigDataEnvironmentPostProcessor.ORDER - 1;\n  /** \n * Profile name.\n */\n  public static final String KUBERNETES_PROFILE\u003d\"kubernetes\";\n  @Override public void postProcessEnvironment(  ConfigurableEnvironment environment,  SpringApplication application){\n    application.addInitializers(ctx -\u003e LOG.replayTo(AbstractKubernetesProfileEnvironmentPostProcessor.class));\n    if (CloudPlatform.KUBERNETES.isActive(environment)) {\n      addNamespaceFromServiceAccountFile(environment);\n      addKubernetesProfileIfMissing(environment);\n    }\n  }\n  protected abstract boolean isInsideKubernetes(  Environment environment);\n  private boolean hasKubernetesProfile(  Environment environment){\n    return Arrays.stream(environment.getActiveProfiles()).anyMatch(KUBERNETES_PROFILE::equalsIgnoreCase);\n  }\n  @Override public int getOrder(){\n    return ORDER;\n  }\n  private void addKubernetesProfileIfMissing(  ConfigurableEnvironment environment){\n    if (isInsideKubernetes(environment)) {\n      if (hasKubernetesProfile(environment)) {\n        LOG.debug(\"\u0027kubernetes\u0027 already in list of active profiles\");\n      }\n else {\n        LOG.debug(\"Adding \u0027kubernetes\u0027 to list of active profiles\");\n        environment.addActiveProfile(KUBERNETES_PROFILE);\n      }\n    }\n else {\n      LOG.warn(\"Not running inside kubernetes. Skipping \u0027kubernetes\u0027 profile activation.\");\n    }\n  }\n  private void addNamespaceFromServiceAccountFile(  ConfigurableEnvironment environment){\n    String serviceAccountNamespacePathString\u003denvironment.getProperty(NAMESPACE_PATH_PROPERTY,SERVICE_ACCOUNT_NAMESPACE_PATH);\n    String namespace\u003dKubernetesNamespaceProvider.getNamespaceFromServiceAccountFile(serviceAccountNamespacePathString);\n    if (StringUtils.hasText(namespace)) {\n      environment.getPropertySources().addLast(new MapPropertySource(PROPERTY_SOURCE_NAME,Collections.singletonMap(NAMESPACE_PROPERTY,namespace)));\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic abstract class AbstractKubernetesProfileEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {\n  private static final DeferredLog LOG\u003dnew DeferredLog();\n  private static final String NAMESPACE_PATH_PROPERTY\u003d\"spring.cloud.kubernetes.client.serviceAccountNamespacePath\";\n  protected static final String NAMESPACE_PROPERTY\u003d\"spring.cloud.kubernetes.client.namespace\";\n  private static final String PROPERTY_SOURCE_NAME\u003d\"KUBERNETES_NAMESPACE_PROPERTY_SOURCE\";\n  private static final int ORDER\u003dConfigDataEnvironmentPostProcessor.ORDER - 1;\n  /** \n * Profile name.\n */\n  public static final String KUBERNETES_PROFILE\u003d\"kubernetes\";\n  @Override public void postProcessEnvironment(  ConfigurableEnvironment environment,  SpringApplication application);\n  protected abstract boolean isInsideKubernetes(  Environment environment);\n  private boolean hasKubernetesProfile(  Environment environment);\n  @Override public int getOrder();\n  private void addKubernetesProfileIfMissing(  ConfigurableEnvironment environment);\n  private void addNamespaceFromServiceAccountFile(  ConfigurableEnvironment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/SecretsPropertySource.java",
        "name": "SecretsPropertySource",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.SecretsPropertySource",
        "extend": "MapPropertySource",
        "implements": "",
        "raw": "/** \n * Kubernetes property source for secrets.\n * @author l burgazzoli\n * @author Haytham Mohamed\n */\npublic class SecretsPropertySource extends MapPropertySource {\n  public SecretsPropertySource(  SourceData sourceData){\n    super(sourceData.sourceName(),sourceData.sourceData());\n  }\n  @Override public String toString(){\n    return getClass().getSimpleName() + \" {name\u003d\u0027\" + this.name+ \"\u0027}\";\n  }\n}\n",
        "abstract": "/** \n * Kubernetes property source for secrets.\n * @author l burgazzoli\n * @author Haytham Mohamed\n */\npublic class SecretsPropertySource extends MapPropertySource {\n  public SecretsPropertySource(  SourceData sourceData);\n  @Override public String toString();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/ConfigMapPropertySourceLocator.java",
        "name": "ConfigMapPropertySourceLocator",
        "modifiers": "public abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConfigMapPropertySourceLocator",
        "extend": "",
        "implements": "PropertySourceLocator",
        "raw": "/** \n * A  {@link PropertySourceLocator} that uses config maps.\n * @author Ioannis Canellos\n * @author Michael Moudatsos\n * @author Isik Erhan\n */\npublic abstract class ConfigMapPropertySourceLocator implements PropertySourceLocator {\n  private static final Log LOG\u003dLogFactory.getLog(ConfigMapPropertySourceLocator.class);\n  private final ConfigMapCache cache;\n  protected final ConfigMapConfigProperties properties;\n  /** \n * This constructor is deprecated, and we do not use it anymore internally. It will be removed in the next major release.\n */\n  @Deprecated(forRemoval\u003dtrue) public ConfigMapPropertySourceLocator(  ConfigMapConfigProperties properties){\n    this.properties\u003dproperties;\n    this.cache\u003dnew ConfigMapCache.NOOPCache();\n  }\n  public ConfigMapPropertySourceLocator(  ConfigMapConfigProperties properties,  ConfigMapCache cache){\n    this.properties\u003dproperties;\n    this.cache\u003dcache;\n  }\n  protected abstract MapPropertySource getMapPropertySource(  NormalizedSource normalizedSource,  ConfigurableEnvironment environment);\n  @Override public PropertySource\u003c?\u003e locate(  Environment environment){\n    if (environment instanceof ConfigurableEnvironment) {\n      CompositePropertySource composite\u003dnew CompositePropertySource(\"composite-configmap\");\n      if (this.properties.enableApi()) {\n        Set\u003cNormalizedSource\u003e sources\u003dnew LinkedHashSet\u003c\u003e(this.properties.determineSources(environment));\n        LOG.debug(\"Config Map normalized sources : \" + sources);\n        sources.forEach(s -\u003e composite.addFirstPropertySource(getMapPropertySource(s,env)));\n      }\n      addPropertySourcesFromPaths(environment,composite);\n      cache.discardAll();\n      return composite;\n    }\n    return null;\n  }\n  @Override public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment){\n    return PropertySourceLocator.super.locateCollection(environment);\n  }\n  private void addPropertySourcesFromPaths(  Environment environment,  CompositePropertySource composite){\n    Set\u003cString\u003e uniquePaths\u003dnew LinkedHashSet\u003c\u003e(properties.paths());\n    if (!uniquePaths.isEmpty()) {\n      LOG.warn(\"path support is deprecated and will be removed in a future release. Please use spring.config.import\");\n    }\n    LOG.debug(\"paths property sources : \" + uniquePaths);\n    uniquePaths.stream().map(Paths::get).filter(p -\u003e {\n      boolean exists\u003dFiles.exists(p);\n      if (!exists) {\n        LOG.warn(\"Configured input path: \" + p + \" will be ignored because it does not exist on the file system\");\n      }\n      return exists;\n    }\n).filter(p -\u003e {\n      boolean regular\u003dFiles.isRegularFile(p);\n      if (!regular) {\n        LOG.warn(\"Configured input path: \" + p + \" will be ignored because it is not a regular file\");\n      }\n      return regular;\n    }\n).toList().forEach(p -\u003e {\n      try {\n        String content\u003dnew String(Files.readAllBytes(p)).trim();\n        String filename\u003dp.toAbsolutePath().toString().toLowerCase();\n        if (filename.endsWith(\".properties\")) {\n          addPropertySourceIfNeeded(c -\u003e PROPERTIES_TO_MAP.apply(KEY_VALUE_TO_PROPERTIES.apply(c)),content,filename,composite);\n        }\n else         if (filename.endsWith(\".yml\") || filename.endsWith(\".yaml\")) {\n          addPropertySourceIfNeeded(c -\u003e PROPERTIES_TO_MAP.apply(yamlParserGenerator(environment).apply(c)),content,filename,composite);\n        }\n      }\n catch (      IOException e) {\n        LOG.warn(\"Error reading input file\",e);\n      }\n    }\n);\n  }\n  private void addPropertySourceIfNeeded(  Function\u003cString,Map\u003cString,Object\u003e\u003e contentToMapFunction,  String content,  String name,  CompositePropertySource composite){\n    Map\u003cString,Object\u003e map\u003dnew HashMap\u003c\u003e(contentToMapFunction.apply(content));\n    if (map.isEmpty()) {\n      LOG.warn(\"Property source: \" + name + \"will be ignored because no properties could be found\");\n    }\n else {\n      LOG.debug(\"will add file-based property source : \" + name);\n      composite.addFirstPropertySource(new MountConfigMapPropertySource(name,map));\n    }\n  }\n}\n",
        "abstract": "/** \n * A  {@link PropertySourceLocator} that uses config maps.\n * @author Ioannis Canellos\n * @author Michael Moudatsos\n * @author Isik Erhan\n */\npublic abstract class ConfigMapPropertySourceLocator implements PropertySourceLocator {\n  private static final Log LOG\u003dLogFactory.getLog(ConfigMapPropertySourceLocator.class);\n  private final ConfigMapCache cache;\n  protected final ConfigMapConfigProperties properties;\n  /** \n * This constructor is deprecated, and we do not use it anymore internally. It will be removed in the next major release.\n */\n  @Deprecated(forRemoval\u003dtrue) public ConfigMapPropertySourceLocator(  ConfigMapConfigProperties properties);\n  public ConfigMapPropertySourceLocator(  ConfigMapConfigProperties properties,  ConfigMapCache cache);\n  protected abstract MapPropertySource getMapPropertySource(  NormalizedSource normalizedSource,  ConfigurableEnvironment environment);\n  @Override public PropertySource\u003c?\u003e locate(  Environment environment);\n  @Override public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment);\n  private void addPropertySourcesFromPaths(  Environment environment,  CompositePropertySource composite);\n  private void addPropertySourceIfNeeded(  Function\u003cString,Map\u003cString,Object\u003e\u003e contentToMapFunction,  String content,  String name,  CompositePropertySource composite);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/NamedSourceData.java",
        "name": "NamedSourceData",
        "modifiers": "public abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.NamedSourceData",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57Base class when dealing with named sources that support profiles specific sources, prefix based properties and single file yaml/properties.\n */\npublic abstract class NamedSourceData {\n  public final SourceData compute(  String sourceName,  ConfigUtils.Prefix prefix,  String target,  boolean profileSources,  boolean failFast,  String namespace,  String[] activeProfiles){\n    LinkedHashSet\u003cString\u003e sourceNames\u003dnew LinkedHashSet\u003c\u003e();\n    sourceNames.add(sourceName);\n    MultipleSourcesContainer data\u003dMultipleSourcesContainer.empty();\n    try {\n      if (profileSources) {\n        for (        String activeProfile : activeProfiles) {\n          sourceNames.add(sourceName + \"-\" + activeProfile);\n        }\n      }\n      data\u003ddataSupplier(sourceNames);\n      if (data.names().isEmpty()) {\n        return new SourceData(ConfigUtils.sourceName(target,sourceName,namespace),Map.of());\n      }\n      if (prefix !\u003d ConfigUtils.Prefix.DEFAULT) {\n        String prefixToUse\u003dprefix.prefixProvider().get();\n        PrefixContext prefixContext\u003dnew PrefixContext(data.data(),prefixToUse,namespace,data.names());\n        return ConfigUtils.withPrefix(target,prefixContext);\n      }\n    }\n catch (    Exception e) {\n      onException(failFast,e);\n    }\n    String names\u003ddata.names().stream().sorted().collect(Collectors.joining(PROPERTY_SOURCE_NAME_SEPARATOR));\n    return new SourceData(generateSourceName(target,names,namespace,activeProfiles),data.data());\n  }\n  protected String generateSourceName(  String target,  String sourceName,  String namespace,  String[] activeProfiles){\n    return ConfigUtils.sourceName(target,sourceName,namespace);\n  }\n  /** \n * Implementation specific (fabric8 or k8s-native) way to get the data from then given source names.\n * @param sourceNames the ones that have been configured, LinkedHashSet in order otpreserve the order: non-profile source first and then the rest\n * @return an Entry that holds the names of the source that were found and their data\n */\n  public abstract MultipleSourcesContainer dataSupplier(  LinkedHashSet\u003cString\u003e sourceNames);\n}\n",
        "abstract": "/** \n * @author wind57Base class when dealing with named sources that support profiles specific sources, prefix based properties and single file yaml/properties.\n */\npublic abstract class NamedSourceData {\n  public final SourceData compute(  String sourceName,  ConfigUtils.Prefix prefix,  String target,  boolean profileSources,  boolean failFast,  String namespace,  String[] activeProfiles);\n  protected String generateSourceName(  String target,  String sourceName,  String namespace,  String[] activeProfiles);\n  /** \n * Implementation specific (fabric8 or k8s-native) way to get the data from then given source names.\n * @param sourceNames the ones that have been configured, LinkedHashSet in order otpreserve the order: non-profile source first and then the rest\n * @return an Entry that holds the names of the source that were found and their data\n */\n  public abstract MultipleSourcesContainer dataSupplier(  LinkedHashSet\u003cString\u003e sourceNames);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/ConditionalOnKubernetesConfigFailFastEnabled.java",
        "name": "ConditionalOnKubernetesConfigFailFastEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(prefix\u003dConfigMapConfigProperties.PREFIX,name\u003d\"fail-fast\",havingValue\u003d\"true\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConditionalOnKubernetesConfigFailFastEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.config.fail-fast\u003c/code\u003e.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(prefix\u003dConfigMapConfigProperties.PREFIX,name\u003d\"fail-fast\",havingValue\u003d\"true\") public @interface ConditionalOnKubernetesConfigFailFastEnabled {}\n",
        "abstract": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.config.fail-fast\u003c/code\u003e.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(prefix\u003dConfigMapConfigProperties.PREFIX,name\u003d\"fail-fast\",havingValue\u003d\"true\") public @interface ConditionalOnKubernetesConfigFailFastEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/LabeledConfigMapNormalizedSource.java",
        "name": "LabeledConfigMapNormalizedSource",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.LabeledConfigMapNormalizedSource",
        "extend": "NormalizedSource",
        "implements": "",
        "raw": "/** \n * A config map source that is based on labels.\n * @author wind57\n */\npublic final class LabeledConfigMapNormalizedSource extends NormalizedSource {\n  private final Map\u003cString,String\u003e labels;\n  private final ConfigUtils.Prefix prefix;\n  private final boolean includeProfileSpecificSources;\n  public LabeledConfigMapNormalizedSource(  String namespace,  Map\u003cString,String\u003e labels,  boolean failFast,  ConfigUtils.Prefix prefix,  boolean includeProfileSpecificSources){\n    super(null,namespace,failFast);\n    this.labels\u003dCollections.unmodifiableMap(Objects.requireNonNull(labels));\n    this.prefix\u003dObjects.requireNonNull(prefix);\n    this.includeProfileSpecificSources\u003dincludeProfileSpecificSources;\n  }\n  public LabeledConfigMapNormalizedSource(  String namespace,  Map\u003cString,String\u003e labels,  boolean failFast,  boolean includeProfileSpecificSources){\n    super(null,namespace,failFast);\n    this.labels\u003dCollections.unmodifiableMap(Objects.requireNonNull(labels));\n    this.prefix\u003dConfigUtils.Prefix.DEFAULT;\n    this.includeProfileSpecificSources\u003dincludeProfileSpecificSources;\n  }\n  /** \n * will return an immutable Map.\n */\n  public Map\u003cString,String\u003e labels(){\n    return labels;\n  }\n  public ConfigUtils.Prefix prefix(){\n    return prefix;\n  }\n  public boolean profileSpecificSources(){\n    return this.includeProfileSpecificSources;\n  }\n  @Override public NormalizedSourceType type(){\n    return NormalizedSourceType.LABELED_CONFIG_MAP;\n  }\n  @Override public String target(){\n    return \"configmap\";\n  }\n  @Override public String toString(){\n    return \"{ config map labels : \u0027\" + labels() + \"\u0027, namespace : \u0027\"+ namespace()+ \"\u0027\";\n  }\n  @Override public boolean equals(  Object o){\n    if (this \u003d\u003d o) {\n      return true;\n    }\n    if (o \u003d\u003d null || getClass() !\u003d o.getClass()) {\n      return false;\n    }\n    LabeledConfigMapNormalizedSource other\u003d(LabeledConfigMapNormalizedSource)o;\n    return Objects.equals(labels(),other.labels()) \u0026\u0026 Objects.equals(namespace(),other.namespace());\n  }\n  @Override public int hashCode(){\n    return Objects.hash(labels(),namespace());\n  }\n}\n",
        "abstract": "/** \n * A config map source that is based on labels.\n * @author wind57\n */\npublic final class LabeledConfigMapNormalizedSource extends NormalizedSource {\n  private final Map\u003cString,String\u003e labels;\n  private final ConfigUtils.Prefix prefix;\n  private final boolean includeProfileSpecificSources;\n  public LabeledConfigMapNormalizedSource(  String namespace,  Map\u003cString,String\u003e labels,  boolean failFast,  ConfigUtils.Prefix prefix,  boolean includeProfileSpecificSources);\n  public LabeledConfigMapNormalizedSource(  String namespace,  Map\u003cString,String\u003e labels,  boolean failFast,  boolean includeProfileSpecificSources);\n  /** \n * will return an immutable Map.\n */\n  public Map\u003cString,String\u003e labels();\n  public ConfigUtils.Prefix prefix();\n  public boolean profileSpecificSources();\n  @Override public NormalizedSourceType type();\n  @Override public String target();\n  @Override public String toString();\n  @Override public boolean equals(  Object o);\n  @Override public int hashCode();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/SecretsCache.java",
        "name": "SecretsCache",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.SecretsCache",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic interface SecretsCache {\n  /** \n * Discards all stored entries from the cache.\n */\n  void discardAll();\n  /** \n * an implementation that does nothing. In the next major release it will become absolute and must be removed.\n */\nclass NOOPCache implements SecretsCache {\n    @Override public void discardAll(){\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic interface SecretsCache {\n  /** \n * Discards all stored entries from the cache.\n */\n  void discardAll();\n  /** \n * an implementation that does nothing. In the next major release it will become absolute and must be removed.\n */\nclass NOOPCache implements SecretsCache {\n    @Override public void discardAll();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/PropertySourceUtils.java",
        "name": "PropertySourceUtils",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.PropertySourceUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Utility class to work with property sources.\n * @author Georgios Andrianakis\n * @author Michael Moudatsos\n */\npublic final class PropertySourceUtils {\n  private PropertySourceUtils(){\n    throw new IllegalStateException(\"Can\u0027t instantiate a utility class\");\n  }\n  /** \n * Function to convert a String to Properties.\n */\n  public static final Function\u003cString,Properties\u003e KEY_VALUE_TO_PROPERTIES\u003ds -\u003e {\n    Properties properties\u003dnew Properties();\n    try {\n      properties.load(new ByteArrayInputStream(s.getBytes()));\n      return properties;\n    }\n catch (    IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n;\n  /** \n * Function to convert Properties to a Map.\n */\n  public static final Function\u003cProperties,Map\u003cString,Object\u003e\u003e PROPERTIES_TO_MAP\u003dp -\u003e p.entrySet().stream().collect(Collectors.toMap(e -\u003e e.getKey().toString(),Map.Entry::getValue));\n  /** \n * Function to convert String into Properties with an environment.\n * @param environment Environment.\n * @return properties.\n */\n  public static Function\u003cString,Properties\u003e yamlParserGenerator(  Environment environment){\n    return s -\u003e {\n      YamlPropertiesFactoryBean yamlFactory\u003dnew YamlPropertiesFactoryBean();\n      yamlFactory.setDocumentMatchers(properties -\u003e {\n        if (environment !\u003d null) {\n          String profiles\u003dnull;\n          String activeOnProfile\u003dproperties.getProperty(SPRING_CONFIG_ACTIVATE_ON_PROFILE);\n          String springProfiles\u003dproperties.getProperty(SPRING_PROFILES);\n          if (activeOnProfile !\u003d null) {\n            profiles\u003dactiveOnProfile;\n          }\n else           if (springProfiles !\u003d null) {\n            profiles\u003dspringProfiles;\n          }\n          if (StringUtils.hasText(profiles)) {\n            return environment.acceptsProfiles(Profiles.of(profiles)) ? FOUND : NOT_FOUND;\n          }\n        }\n        return ABSTAIN;\n      }\n);\n      yamlFactory.setResources(new ByteArrayResource(s.getBytes(StandardCharsets.UTF_8)));\n      return yamlFactory.getObject();\n    }\n;\n  }\n  /** \n * returns a  {@link BinaryOperator} that unconditionally throws an{@link IllegalStateException}.\n * @param \u003c T \u003e type of the argument\n * @return a {@link BinaryOperator}\n */\n  public static \u003cT\u003eBinaryOperator\u003cT\u003e throwingMerger(){\n    return (left,right) -\u003e {\n      throw new IllegalStateException(\"Duplicate key \" + left);\n    }\n;\n  }\n}\n",
        "abstract": "/** \n * Utility class to work with property sources.\n * @author Georgios Andrianakis\n * @author Michael Moudatsos\n */\npublic final class PropertySourceUtils {\n  private PropertySourceUtils();\n  /** \n * Function to convert a String to Properties.\n */\n  public static final Function\u003cString,Properties\u003e KEY_VALUE_TO_PROPERTIES\u003ds -\u003e {\n    Properties properties\u003dnew Properties();\n    try {\n      properties.load(new ByteArrayInputStream(s.getBytes()));\n      return properties;\n    }\n catch (    IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n;\n  /** \n * Function to convert Properties to a Map.\n */\n  public static final Function\u003cProperties,Map\u003cString,Object\u003e\u003e PROPERTIES_TO_MAP\u003dp -\u003e p.entrySet().stream().collect(Collectors.toMap(e -\u003e e.getKey().toString(),Map.Entry::getValue));\n  /** \n * Function to convert String into Properties with an environment.\n * @param environment Environment.\n * @return properties.\n */\n  public static Function\u003cString,Properties\u003e yamlParserGenerator(  Environment environment);\n  /** \n * returns a  {@link BinaryOperator} that unconditionally throws an{@link IllegalStateException}.\n * @param \u003c T \u003e type of the argument\n * @return a {@link BinaryOperator}\n */\n  public static \u003cT\u003eBinaryOperator\u003cT\u003e throwingMerger();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/NamespaceResolutionFailedException.java",
        "name": "NamespaceResolutionFailedException",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.NamespaceResolutionFailedException",
        "extend": "RuntimeException",
        "implements": "",
        "raw": "/** \n * @author wind57Thrown when a namespace could not be resolved. Resolution of a namespace happens via user provided input, environment properties or directly from the underlying client, etc.\n */\npublic class NamespaceResolutionFailedException extends RuntimeException {\n  public NamespaceResolutionFailedException(  String message){\n    super(message);\n  }\n}\n",
        "abstract": "/** \n * @author wind57Thrown when a namespace could not be resolved. Resolution of a namespace happens via user provided input, environment properties or directly from the underlying client, etc.\n */\npublic class NamespaceResolutionFailedException extends RuntimeException {\n  public NamespaceResolutionFailedException(  String message);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/MountConfigMapPropertySource.java",
        "name": "MountConfigMapPropertySource",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.MountConfigMapPropertySource",
        "extend": "MapPropertySource",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic final class MountConfigMapPropertySource extends MapPropertySource {\n  public MountConfigMapPropertySource(  String name,  Map\u003cString,Object\u003e source){\n    super(name,source);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic final class MountConfigMapPropertySource extends MapPropertySource {\n  public MountConfigMapPropertySource(  String name,  Map\u003cString,Object\u003e source);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/KubernetesConfigDataResource.java",
        "name": "KubernetesConfigDataResource",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.KubernetesConfigDataResource",
        "extend": "ConfigDataResource",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesConfigDataResource extends ConfigDataResource {\n  private final KubernetesClientProperties properties;\n  private final ConfigMapConfigProperties configMapProperties;\n  private final SecretsConfigProperties secretsConfigProperties;\n  private final boolean optional;\n  private final Profiles profiles;\n  private Log log;\n  private Environment environment;\n  public KubernetesConfigDataResource(  KubernetesClientProperties properties,  ConfigMapConfigProperties configMapProperties,  SecretsConfigProperties secretsConfigProperties,  boolean optional,  Profiles profiles,  Environment environment){\n    this.properties\u003dproperties;\n    this.configMapProperties\u003dconfigMapProperties;\n    this.secretsConfigProperties\u003dsecretsConfigProperties;\n    this.optional\u003doptional;\n    this.profiles\u003dprofiles;\n    this.environment\u003denvironment;\n  }\n  public KubernetesClientProperties getProperties(){\n    return this.properties;\n  }\n  /** \n * ConfigMapConfigProperties that might be null.\n */\n  public ConfigMapConfigProperties getConfigMapProperties(){\n    return configMapProperties;\n  }\n  /** \n * SecretsConfigProperties that might be null.\n */\n  public SecretsConfigProperties getSecretsConfigProperties(){\n    return secretsConfigProperties;\n  }\n  public boolean isOptional(){\n    return this.optional;\n  }\n  public String getProfiles(){\n    return StringUtils.collectionToCommaDelimitedString(getAcceptedProfiles());\n  }\n  List\u003cString\u003e getAcceptedProfiles(){\n    return this.profiles.getAccepted();\n  }\n  public void setLog(  Log log){\n    this.log\u003dlog;\n  }\n  public Log getLog(){\n    return this.log;\n  }\n  public Environment getEnvironment(){\n    return environment;\n  }\n  public void setEnvironment(  Environment environment){\n    this.environment\u003denvironment;\n  }\n  @Override public boolean equals(  Object o){\n    if (this \u003d\u003d o) {\n      return true;\n    }\n    if (o \u003d\u003d null || getClass() !\u003d o.getClass()) {\n      return false;\n    }\n    KubernetesConfigDataResource that\u003d(KubernetesConfigDataResource)o;\n    return Objects.equals(this.properties,that.properties) \u0026\u0026 Objects.equals(this.optional,that.optional) \u0026\u0026 Objects.equals(this.profiles,that.profiles)\u0026\u0026 Objects.equals(this.configMapProperties,that.configMapProperties)\u0026\u0026 Objects.equals(this.secretsConfigProperties,that.secretsConfigProperties);\n  }\n  @Override public int hashCode(){\n    return Objects.hash(this.properties,this.optional,this.profiles,configMapProperties,secretsConfigProperties);\n  }\n  @Override public String toString(){\n    return new ToStringCreator(this).append(\"optional\",optional).append(\"profiles\",profiles.getAccepted()).toString();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesConfigDataResource extends ConfigDataResource {\n  private final KubernetesClientProperties properties;\n  private final ConfigMapConfigProperties configMapProperties;\n  private final SecretsConfigProperties secretsConfigProperties;\n  private final boolean optional;\n  private final Profiles profiles;\n  private Log log;\n  private Environment environment;\n  public KubernetesConfigDataResource(  KubernetesClientProperties properties,  ConfigMapConfigProperties configMapProperties,  SecretsConfigProperties secretsConfigProperties,  boolean optional,  Profiles profiles,  Environment environment);\n  public KubernetesClientProperties getProperties();\n  /** \n * ConfigMapConfigProperties that might be null.\n */\n  public ConfigMapConfigProperties getConfigMapProperties();\n  /** \n * SecretsConfigProperties that might be null.\n */\n  public SecretsConfigProperties getSecretsConfigProperties();\n  public boolean isOptional();\n  public String getProfiles();\n  List\u003cString\u003e getAcceptedProfiles();\n  public void setLog(  Log log);\n  public Log getLog();\n  public Environment getEnvironment();\n  public void setEnvironment(  Environment environment);\n  @Override public boolean equals(  Object o);\n  @Override public int hashCode();\n  @Override public String toString();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/ConditionalOnKubernetesConfigRetryDisabled.java",
        "name": "ConditionalOnKubernetesConfigRetryDisabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnKubernetesConfigRetryDisabled.OnConfigMapPropertiesRetryDisabled.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConditionalOnKubernetesConfigRetryDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * {@link Conditional @Conditional} that matches when at least one of Spring CloudKubernetes, Kubernetes ConfigMap property sources or Kubernetes ConfigMap property sources fail fast (thus retry) is disabled.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnKubernetesConfigRetryDisabled.OnConfigMapPropertiesRetryDisabled.class) public @interface ConditionalOnKubernetesConfigRetryDisabled {class OnConfigMapPropertiesRetryDisabled extends NoneNestedConditions {\n  OnConfigMapPropertiesRetryDisabled(){\n    super(ConfigurationPhase.REGISTER_BEAN);\n  }\n@ConditionalOnKubernetesConfigRetryEnabled static class OnConfigMapPropertiesRetryEnabled {\n  }\n}\n}\n",
        "abstract": "/** \n * {@link Conditional @Conditional} that matches when at least one of Spring CloudKubernetes, Kubernetes ConfigMap property sources or Kubernetes ConfigMap property sources fail fast (thus retry) is disabled.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnKubernetesConfigRetryDisabled.OnConfigMapPropertiesRetryDisabled.class) public @interface ConditionalOnKubernetesConfigRetryDisabled {class OnConfigMapPropertiesRetryDisabled extends NoneNestedConditions {\n  OnConfigMapPropertiesRetryDisabled(){\n    super(ConfigurationPhase.REGISTER_BEAN);\n  }\n@ConditionalOnKubernetesConfigRetryEnabled static class OnConfigMapPropertiesRetryEnabled {\n  }\n}\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/NamedSecretNormalizedSource.java",
        "name": "NamedSecretNormalizedSource",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.NamedSecretNormalizedSource",
        "extend": "NormalizedSource",
        "implements": "",
        "raw": "/** \n * A secret source that is based on name.\n * @author wind57\n */\npublic final class NamedSecretNormalizedSource extends NormalizedSource {\n  private final ConfigUtils.Prefix prefix;\n  private final boolean includeProfileSpecificSources;\n  private final boolean appendProfileToName;\n  public NamedSecretNormalizedSource(  String name,  String namespace,  boolean failFast,  ConfigUtils.Prefix prefix,  boolean includeProfileSpecificSources,  boolean appendProfileToName){\n    super(name,namespace,failFast);\n    this.prefix\u003dObjects.requireNonNull(prefix);\n    this.includeProfileSpecificSources\u003dincludeProfileSpecificSources;\n    this.appendProfileToName\u003dappendProfileToName;\n  }\n  public NamedSecretNormalizedSource(  String name,  String namespace,  boolean failFast,  boolean includeProfileSpecificSources){\n    this(name,namespace,failFast,ConfigUtils.Prefix.DEFAULT,includeProfileSpecificSources,false);\n  }\n  public NamedSecretNormalizedSource(  String name,  String namespace,  boolean failFast,  ConfigUtils.Prefix prefix,  boolean includeProfileSpecificSources){\n    this(name,namespace,failFast,prefix,includeProfileSpecificSources,false);\n  }\n  public boolean profileSpecificSources(){\n    return includeProfileSpecificSources;\n  }\n  /** \n * append or not the active profiles to the name of the generated source. At the moment this is true only for config server generated sources.\n */\n  public boolean appendProfileToName(){\n    return appendProfileToName;\n  }\n  public ConfigUtils.Prefix prefix(){\n    return prefix;\n  }\n  @Override public NormalizedSourceType type(){\n    return NormalizedSourceType.NAMED_SECRET;\n  }\n  @Override public String target(){\n    return \"secret\";\n  }\n  @Override public String toString(){\n    return \"{ secret name : \u0027\" + name() + \"\u0027, namespace : \u0027\"+ namespace()+ \"\u0027\";\n  }\n  @Override public boolean equals(  Object o){\n    if (this \u003d\u003d o) {\n      return true;\n    }\n    if (o \u003d\u003d null || getClass() !\u003d o.getClass()) {\n      return false;\n    }\n    NamedSecretNormalizedSource other\u003d(NamedSecretNormalizedSource)o;\n    return Objects.equals(name(),other.name()) \u0026\u0026 Objects.equals(namespace(),other.namespace());\n  }\n  @Override public int hashCode(){\n    return Objects.hash(name(),namespace());\n  }\n}\n",
        "abstract": "/** \n * A secret source that is based on name.\n * @author wind57\n */\npublic final class NamedSecretNormalizedSource extends NormalizedSource {\n  private final ConfigUtils.Prefix prefix;\n  private final boolean includeProfileSpecificSources;\n  private final boolean appendProfileToName;\n  public NamedSecretNormalizedSource(  String name,  String namespace,  boolean failFast,  ConfigUtils.Prefix prefix,  boolean includeProfileSpecificSources,  boolean appendProfileToName);\n  public NamedSecretNormalizedSource(  String name,  String namespace,  boolean failFast,  boolean includeProfileSpecificSources);\n  public NamedSecretNormalizedSource(  String name,  String namespace,  boolean failFast,  ConfigUtils.Prefix prefix,  boolean includeProfileSpecificSources);\n  public boolean profileSpecificSources();\n  /** \n * append or not the active profiles to the name of the generated source. At the moment this is true only for config server generated sources.\n */\n  public boolean appendProfileToName();\n  public ConfigUtils.Prefix prefix();\n  @Override public NormalizedSourceType type();\n  @Override public String target();\n  @Override public String toString();\n  @Override public boolean equals(  Object o);\n  @Override public int hashCode();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/Constants.java",
        "name": "Constants",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.Constants",
        "extend": "",
        "implements": "",
        "raw": "public final class Constants {\n  /** \n * Spring application name property.\n */\n  public static final String SPRING_APPLICATION_NAME\u003d\"spring.application.name\";\n  /** \n * Default application name.\n */\n  public static final String FALLBACK_APPLICATION_NAME\u003d\"application\";\n  /** \n * Property separator.\n */\n  public static final String PROPERTY_SOURCE_NAME_SEPARATOR\u003d\".\";\n  /** \n * Property for legacy profile specific configuration.\n */\n  public static final String SPRING_PROFILES\u003d\"spring.profiles\";\n  /** \n * Property for profile specific configuration.\n */\n  public static final String SPRING_CONFIG_ACTIVATE_ON_PROFILE\u003d\"spring.config.activate.on-profile\";\n  /** \n * application.yml property.\n */\n  public static final String APPLICATION_YML\u003d\"application.yml\";\n  /** \n * application.yaml property.\n */\n  public static final String APPLICATION_YAML\u003d\"application.yaml\";\n  /** \n * application.properties property.\n */\n  public static final String APPLICATION_PROPERTIES\u003d\"application.properties\";\n  /** \n * reload mode spring property.\n */\n  public static final String RELOAD_MODE\u003d\"spring.cloud.kubernetes.reload.mode\";\n  private Constants(){\n  }\n}\n",
        "abstract": "public final class Constants {\n  /** \n * Spring application name property.\n */\n  public static final String SPRING_APPLICATION_NAME\u003d\"spring.application.name\";\n  /** \n * Default application name.\n */\n  public static final String FALLBACK_APPLICATION_NAME\u003d\"application\";\n  /** \n * Property separator.\n */\n  public static final String PROPERTY_SOURCE_NAME_SEPARATOR\u003d\".\";\n  /** \n * Property for legacy profile specific configuration.\n */\n  public static final String SPRING_PROFILES\u003d\"spring.profiles\";\n  /** \n * Property for profile specific configuration.\n */\n  public static final String SPRING_CONFIG_ACTIVATE_ON_PROFILE\u003d\"spring.config.activate.on-profile\";\n  /** \n * application.yml property.\n */\n  public static final String APPLICATION_YML\u003d\"application.yml\";\n  /** \n * application.yaml property.\n */\n  public static final String APPLICATION_YAML\u003d\"application.yaml\";\n  /** \n * application.properties property.\n */\n  public static final String APPLICATION_PROPERTIES\u003d\"application.properties\";\n  /** \n * reload mode spring property.\n */\n  public static final String RELOAD_MODE\u003d\"spring.cloud.kubernetes.reload.mode\";\n  private Constants();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/LabeledSecretNormalizedSource.java",
        "name": "LabeledSecretNormalizedSource",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.LabeledSecretNormalizedSource",
        "extend": "NormalizedSource",
        "implements": "",
        "raw": "/** \n * A secret source that is based on labels.\n * @author wind57\n */\npublic final class LabeledSecretNormalizedSource extends NormalizedSource {\n  private final Map\u003cString,String\u003e labels;\n  private final ConfigUtils.Prefix prefix;\n  private final boolean includeProfileSpecificSources;\n  public LabeledSecretNormalizedSource(  String namespace,  Map\u003cString,String\u003e labels,  boolean failFast,  ConfigUtils.Prefix prefix,  boolean includeProfileSpecificSources){\n    super(null,namespace,failFast);\n    this.labels\u003dCollections.unmodifiableMap(Objects.requireNonNull(labels));\n    this.prefix\u003dObjects.requireNonNull(prefix);\n    this.includeProfileSpecificSources\u003dincludeProfileSpecificSources;\n  }\n  public LabeledSecretNormalizedSource(  String namespace,  Map\u003cString,String\u003e labels,  boolean failFast,  boolean includeProfileSpecificSources){\n    super(null,namespace,failFast);\n    this.labels\u003dCollections.unmodifiableMap(Objects.requireNonNull(labels));\n    this.prefix\u003dConfigUtils.Prefix.DEFAULT;\n    this.includeProfileSpecificSources\u003dincludeProfileSpecificSources;\n  }\n  /** \n * will return an immutable Map.\n */\n  public Map\u003cString,String\u003e labels(){\n    return labels;\n  }\n  public ConfigUtils.Prefix prefix(){\n    return prefix;\n  }\n  public boolean profileSpecificSources(){\n    return this.includeProfileSpecificSources;\n  }\n  @Override public NormalizedSourceType type(){\n    return NormalizedSourceType.LABELED_SECRET;\n  }\n  @Override public String target(){\n    return \"secret\";\n  }\n  @Override public String toString(){\n    return \"{ secret labels : \u0027\" + labels() + \"\u0027, namespace : \u0027\"+ namespace()+ \"\u0027\";\n  }\n  @Override public boolean equals(  Object o){\n    if (this \u003d\u003d o) {\n      return true;\n    }\n    if (o \u003d\u003d null || getClass() !\u003d o.getClass()) {\n      return false;\n    }\n    LabeledSecretNormalizedSource other\u003d(LabeledSecretNormalizedSource)o;\n    return Objects.equals(labels(),other.labels()) \u0026\u0026 Objects.equals(namespace(),other.namespace());\n  }\n  @Override public int hashCode(){\n    return Objects.hash(labels(),namespace());\n  }\n}\n",
        "abstract": "/** \n * A secret source that is based on labels.\n * @author wind57\n */\npublic final class LabeledSecretNormalizedSource extends NormalizedSource {\n  private final Map\u003cString,String\u003e labels;\n  private final ConfigUtils.Prefix prefix;\n  private final boolean includeProfileSpecificSources;\n  public LabeledSecretNormalizedSource(  String namespace,  Map\u003cString,String\u003e labels,  boolean failFast,  ConfigUtils.Prefix prefix,  boolean includeProfileSpecificSources);\n  public LabeledSecretNormalizedSource(  String namespace,  Map\u003cString,String\u003e labels,  boolean failFast,  boolean includeProfileSpecificSources);\n  /** \n * will return an immutable Map.\n */\n  public Map\u003cString,String\u003e labels();\n  public ConfigUtils.Prefix prefix();\n  public boolean profileSpecificSources();\n  @Override public NormalizedSourceType type();\n  @Override public String target();\n  @Override public String toString();\n  @Override public boolean equals(  Object o);\n  @Override public int hashCode();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/KubernetesBootstrapConfiguration.java",
        "name": "KubernetesBootstrapConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @EnableConfigurationProperties({ConfigMapConfigProperties.class,SecretsConfigProperties.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.KubernetesBootstrapConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @EnableConfigurationProperties({ConfigMapConfigProperties.class,SecretsConfigProperties.class}) public class KubernetesBootstrapConfiguration {\n@ConditionalOnKubernetesConfigOrSecretsRetryEnabled @ConditionalOnClass({Retryable.class,Aspect.class,AopAutoConfiguration.class}) @Configuration(proxyBeanMethods\u003dfalse) @EnableRetry(proxyTargetClass\u003dtrue) @Import(AopAutoConfiguration.class) public static class RetryConfiguration {\n    public static RetryOperationsInterceptor retryOperationsInterceptor(    RetryProperties retryProperties){\n      return RetryInterceptorBuilder.stateless().backOffOptions(retryProperties.initialInterval(),retryProperties.multiplier(),retryProperties.maxInterval()).maxAttempts(retryProperties.maxAttempts()).build();\n    }\n    @Bean @ConditionalOnKubernetesConfigRetryEnabled public RetryOperationsInterceptor kubernetesConfigRetryInterceptor(    ConfigMapConfigProperties configProperties){\n      return retryOperationsInterceptor(configProperties.retry());\n    }\n    @Bean(\"kubernetesConfigRetryInterceptor\") @ConditionalOnKubernetesConfigRetryDisabled public RetryOperationsInterceptor kubernetesConfigRetryInterceptorNoRetry(){\n      return RetryInterceptorBuilder.stateless().retryPolicy(new NeverRetryPolicy()).build();\n    }\n    @Bean @ConditionalOnKubernetesSecretsRetryEnabled public RetryOperationsInterceptor kubernetesSecretsRetryInterceptor(    SecretsConfigProperties configProperties){\n      return retryOperationsInterceptor(configProperties.retry());\n    }\n    @Bean(\"kubernetesSecretsRetryInterceptor\") @ConditionalOnKubernetesSecretsRetryDisabled public RetryOperationsInterceptor kubernetesSecretsRetryInterceptorNoRetry(){\n      return RetryInterceptorBuilder.stateless().retryPolicy(new NeverRetryPolicy()).build();\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @author Isik Erhan\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @EnableConfigurationProperties({ConfigMapConfigProperties.class,SecretsConfigProperties.class}) public class KubernetesBootstrapConfiguration {\n@ConditionalOnKubernetesConfigOrSecretsRetryEnabled @ConditionalOnClass({Retryable.class,Aspect.class,AopAutoConfiguration.class}) @Configuration(proxyBeanMethods\u003dfalse) @EnableRetry(proxyTargetClass\u003dtrue) @Import(AopAutoConfiguration.class) public static class RetryConfiguration {\n    public static RetryOperationsInterceptor retryOperationsInterceptor(    RetryProperties retryProperties);\n    @Bean @ConditionalOnKubernetesConfigRetryEnabled public RetryOperationsInterceptor kubernetesConfigRetryInterceptor(    ConfigMapConfigProperties configProperties);\n    @Bean(\"kubernetesConfigRetryInterceptor\") @ConditionalOnKubernetesConfigRetryDisabled public RetryOperationsInterceptor kubernetesConfigRetryInterceptorNoRetry();\n    @Bean @ConditionalOnKubernetesSecretsRetryEnabled public RetryOperationsInterceptor kubernetesSecretsRetryInterceptor(    SecretsConfigProperties configProperties);\n    @Bean(\"kubernetesSecretsRetryInterceptor\") @ConditionalOnKubernetesSecretsRetryDisabled public RetryOperationsInterceptor kubernetesSecretsRetryInterceptorNoRetry();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/ConditionalOnKubernetesConfigOrSecretsRetryEnabled.java",
        "name": "ConditionalOnKubernetesConfigOrSecretsRetryEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnKubernetesConfigOrSecretsRetryEnabled.OnKubernetesConfigPropertiesRetryEnabled.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConditionalOnKubernetesConfigOrSecretsRetryEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * {@link Conditional @Conditional} that matches when either or both of{@link ConditionalOnKubernetesConfigRetryEnabled @ConditionalOnKubernetesConfigRetryEnabled}and {@link ConditionalOnKubernetesSecretsRetryEnabled @ConditionalOnKubernetesSecretsRetryEnabled}.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnKubernetesConfigOrSecretsRetryEnabled.OnKubernetesConfigPropertiesRetryEnabled.class) public @interface ConditionalOnKubernetesConfigOrSecretsRetryEnabled {class OnKubernetesConfigPropertiesRetryEnabled extends AnyNestedCondition {\n  OnKubernetesConfigPropertiesRetryEnabled(){\n    super(ConfigurationPhase.REGISTER_BEAN);\n  }\n@ConditionalOnKubernetesConfigRetryEnabled static class OnConfigMapPropertiesRetryEnabled {\n  }\n@ConditionalOnKubernetesSecretsRetryEnabled static class OnSecretsPropertiesRetryEnabled {\n  }\n}\n}\n",
        "abstract": "/** \n * {@link Conditional @Conditional} that matches when either or both of{@link ConditionalOnKubernetesConfigRetryEnabled @ConditionalOnKubernetesConfigRetryEnabled}and {@link ConditionalOnKubernetesSecretsRetryEnabled @ConditionalOnKubernetesSecretsRetryEnabled}.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnKubernetesConfigOrSecretsRetryEnabled.OnKubernetesConfigPropertiesRetryEnabled.class) public @interface ConditionalOnKubernetesConfigOrSecretsRetryEnabled {class OnKubernetesConfigPropertiesRetryEnabled extends AnyNestedCondition {\n  OnKubernetesConfigPropertiesRetryEnabled(){\n    super(ConfigurationPhase.REGISTER_BEAN);\n  }\n@ConditionalOnKubernetesConfigRetryEnabled static class OnConfigMapPropertiesRetryEnabled {\n  }\n@ConditionalOnKubernetesSecretsRetryEnabled static class OnSecretsPropertiesRetryEnabled {\n  }\n}\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/ConfigUtils.java",
        "name": "ConfigUtils",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConfigUtils",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Utility class that works with configuration properties.\n * @author Ioannis Canellos\n */\npublic final class ConfigUtils {\n  private static final Log LOG\u003dLogFactory.getLog(ConfigUtils.class);\n  private static final BiPredicate\u003cString,String\u003e ENDS_WITH_PROFILE_AND_EXTENSION\u003d(sourceName,activeProfile) -\u003e sourceName.endsWith(\"-\" + activeProfile + \".yml\") || sourceName.endsWith(\"-\" + activeProfile + \".yaml\") || sourceName.endsWith(\"-\" + activeProfile + \".properties\");\n  private ConfigUtils(){\n  }\n  public static String getApplicationName(  Environment env,  String configName,  String configurationTarget){\n    if (!StringUtils.hasLength(configName)) {\n      LOG.debug(configurationTarget + \" name has not been set, taking it from property/env \" + SPRING_APPLICATION_NAME+ \" (default\u003d\"+ FALLBACK_APPLICATION_NAME+ \")\");\n      configName\u003denv.getProperty(SPRING_APPLICATION_NAME,FALLBACK_APPLICATION_NAME);\n    }\n    return configName;\n  }\n  /** \n * @param explicitPrefix value of\u0027spring.cloud.kubernetes.config|secrets.sources.explicitPrefix\u0027\n * @param useNameAsPrefix value of\u0027spring.cloud.kubernetes.config|secrets.sources.useNameAsPrefix\u0027\n * @param defaultUseNameAsPrefix value of\u0027spring.cloud.kubernetes.config|secrets.defaultUseNameAsPrefix\u0027\n * @param normalizedName either the name of\u0027spring.cloud.kubernetes.config|secrets.sources.name\u0027 or \u0027spring.cloud.kubernetes.config|secrets.name\u0027\n * @return prefix to use in normalized sources\n */\n  public static Prefix findPrefix(  String explicitPrefix,  Boolean useNameAsPrefix,  boolean defaultUseNameAsPrefix,  String normalizedName){\n    if (StringUtils.hasText(explicitPrefix)) {\n      Prefix.computeKnown(() -\u003e explicitPrefix);\n      return Prefix.KNOWN;\n    }\n    if (useNameAsPrefix !\u003d null) {\n      if (useNameAsPrefix) {\n        if (normalizedName \u003d\u003d null) {\n          return Prefix.DELAYED;\n        }\n        Prefix.computeKnown(() -\u003e normalizedName);\n        return Prefix.KNOWN;\n      }\n      return Prefix.DEFAULT;\n    }\n    if (defaultUseNameAsPrefix) {\n      if (normalizedName \u003d\u003d null) {\n        return Prefix.DELAYED;\n      }\n      Prefix.computeKnown(() -\u003e normalizedName);\n      return Prefix.KNOWN;\n    }\n    return Prefix.DEFAULT;\n  }\n  /** \n * @param defaultIncludeProfileSpecificSources value of\u0027spring.cloud.kubernetes.config.includeProfileSpecificSources\u0027\n * @param includeProfileSpecificSources value of\u0027spring.cloud.kubernetes.config.sources.includeProfileSpecificSources\u0027\n * @return useProfileNameAsPrefix to be used in normalized sources\n */\n  public static boolean includeProfileSpecificSources(  boolean defaultIncludeProfileSpecificSources,  Boolean includeProfileSpecificSources){\n    if (includeProfileSpecificSources !\u003d null) {\n      return includeProfileSpecificSources;\n    }\n    return defaultIncludeProfileSpecificSources;\n  }\n  /** \n * action to take when an Exception happens when dealing with a source.\n */\n  public static void onException(  boolean failFast,  Exception e){\n    if (failFast) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    LOG.warn(e.getMessage() + \". Ignoring.\",e);\n  }\n  public static SourceData withPrefix(  String target,  PrefixContext context){\n    Map\u003cString,Object\u003e withPrefix\u003dCollectionUtils.newHashMap(context.data().size());\n    context.data().forEach((key,value) -\u003e withPrefix.put(context.prefix() + \".\" + key,value));\n    String propertySourceTokens\u003dString.join(PROPERTY_SOURCE_NAME_SEPARATOR,context.propertySourceNames().stream().sorted().collect(Collectors.toCollection(LinkedHashSet::new)));\n    return new SourceData(sourceName(target,propertySourceTokens,context.namespace()),withPrefix);\n  }\n  public static String sourceName(  String target,  String applicationName,  String namespace){\n    return target + PROPERTY_SOURCE_NAME_SEPARATOR + applicationName+ PROPERTY_SOURCE_NAME_SEPARATOR+ namespace;\n  }\n  public static String sourceName(  String target,  String applicationName,  String namespace,  String[] profiles){\n    String name\u003dsourceName(target,applicationName,namespace);\n    if (profiles !\u003d null \u0026\u0026 profiles.length \u003e 0) {\n      name\u003dname + PROPERTY_SOURCE_NAME_SEPARATOR + StringUtils.arrayToDelimitedString(profiles,\"-\");\n    }\n    return name;\n  }\n  public static MultipleSourcesContainer processNamedData(  List\u003cStrippedSourceContainer\u003e strippedSources,  Environment environment,  LinkedHashSet\u003cString\u003e sourceNames,  String namespace,  boolean decode){\n    return processNamedData(strippedSources,environment,sourceNames,namespace,decode,true);\n  }\n  /** \n * transforms raw data from one or multiple sources into an entry of source names and flattened data that they all hold (potentially overriding entries without any defined order).\n */\n  public static MultipleSourcesContainer processNamedData(  List\u003cStrippedSourceContainer\u003e strippedSources,  Environment environment,  LinkedHashSet\u003cString\u003e sourceNames,  String namespace,  boolean decode,  boolean includeDefaultProfileData){\n    Map\u003cString,StrippedSourceContainer\u003e hashByName\u003dstrippedSources.stream().collect(Collectors.toMap(StrippedSourceContainer::name,Function.identity()));\n    LinkedHashSet\u003cString\u003e foundSourceNames\u003dnew LinkedHashSet\u003c\u003e();\n    Map\u003cString,Object\u003e data\u003dnew HashMap\u003c\u003e();\n    sourceNames.forEach(sourceName -\u003e {\n      StrippedSourceContainer stripped\u003dhashByName.get(sourceName);\n      if (stripped !\u003d null) {\n        LOG.debug(\"Found source with name : \u0027\" + sourceName + \" in namespace: \u0027\"+ namespace+ \"\u0027\");\n        foundSourceNames.add(sourceName);\n        Map\u003cString,String\u003e rawData\u003dstripped.data();\n        if (decode) {\n          rawData\u003ddecodeData(rawData);\n        }\n        if (processSource(includeDefaultProfileData,environment,sourceName,rawData)) {\n          data.putAll(SourceDataEntriesProcessor.processAllEntries(rawData \u003d\u003d null ? Map.of() : rawData,environment,includeDefaultProfileData));\n        }\n      }\n    }\n);\n    return new MultipleSourcesContainer(foundSourceNames,data);\n  }\n  static boolean processSource(  boolean includeDefaultProfileData,  Environment environment,  String sourceName,  Map\u003cString,String\u003e sourceRawData){\n    List\u003cString\u003e activeProfiles\u003dArrays.stream(environment.getActiveProfiles()).toList();\n    boolean emptyActiveProfiles\u003dactiveProfiles.isEmpty();\n    boolean profileBasedSourceName\u003dactiveProfiles.stream().anyMatch(activeProfile -\u003e sourceName.endsWith(\"-\" + activeProfile));\n    boolean defaultProfilePresent\u003dactiveProfiles.contains(\"default\");\n    return includeDefaultProfileData || emptyActiveProfiles || profileBasedSourceName|| defaultProfilePresent|| rawDataContainsProfileBasedSource(activeProfiles,sourceRawData).getAsBoolean();\n  }\n  static BooleanSupplier rawDataContainsProfileBasedSource(  List\u003cString\u003e activeProfiles,  Map\u003cString,String\u003e sourceRawData){\n    return () -\u003e Optional.ofNullable(sourceRawData).orElse(Map.of()).keySet().stream().anyMatch(keyName -\u003e activeProfiles.stream().anyMatch(activeProfile -\u003e ENDS_WITH_PROFILE_AND_EXTENSION.test(keyName,activeProfile)));\n  }\n  /** \n * transforms raw data from one or multiple sources into an entry of source names and flattened data that they all hold (potentially overriding entries without any defined order). This method first searches by labels, find the sources, then uses these names to find any profile based sources.\n */\n  public static MultipleSourcesContainer processLabeledData(  List\u003cStrippedSourceContainer\u003e containers,  Environment environment,  Map\u003cString,String\u003e labels,  String namespace,  Set\u003cString\u003e profiles,  boolean decode){\n    List\u003cStrippedSourceContainer\u003e byLabels\u003dcontainers.stream().filter(one -\u003e {\n      Map\u003cString,String\u003e sourceLabels\u003done.labels();\n      Map\u003cString,String\u003e labelsToSearchAgainst\u003dsourceLabels \u003d\u003d null ? Map.of() : sourceLabels;\n      return labelsToSearchAgainst.entrySet().containsAll((labels.entrySet()));\n    }\n).toList();\n    List\u003cString\u003e sourceNamesByLabelsWithProfile\u003dnew ArrayList\u003c\u003e();\n    if (profiles !\u003d null \u0026\u0026 !profiles.isEmpty()) {\n      for (      StrippedSourceContainer one : byLabels) {\n        for (        String profile : profiles) {\n          String name\u003done.name() + \"-\" + profile;\n          sourceNamesByLabelsWithProfile.add(name);\n        }\n      }\n    }\n    List\u003cStrippedSourceContainer\u003e byProfile\u003dcontainers.stream().filter(one -\u003e sourceNamesByLabelsWithProfile.contains(one.name())).toList();\n    List\u003cStrippedSourceContainer\u003e all\u003dnew ArrayList\u003c\u003e(byLabels.size() + byProfile.size());\n    all.addAll(byLabels);\n    all.addAll(byProfile);\n    LinkedHashSet\u003cString\u003e sourceNames\u003dnew LinkedHashSet\u003c\u003e();\n    Map\u003cString,Object\u003e result\u003dnew HashMap\u003c\u003e();\n    all.forEach(source -\u003e {\n      String foundSourceName\u003dsource.name();\n      LOG.debug(\"Loaded source with name : \u0027\" + foundSourceName + \" in namespace: \u0027\"+ namespace+ \"\u0027\");\n      sourceNames.add(foundSourceName);\n      Map\u003cString,String\u003e rawData\u003dsource.data();\n      if (decode) {\n        rawData\u003ddecodeData(rawData);\n      }\n      result.putAll(SourceDataEntriesProcessor.processAllEntries(rawData,environment));\n    }\n);\n    return new MultipleSourcesContainer(sourceNames,result);\n  }\n  private static Map\u003cString,String\u003e decodeData(  Map\u003cString,String\u003e data){\n    Map\u003cString,String\u003e result\u003dnew HashMap\u003c\u003e(CollectionUtils.newHashMap(data.size()));\n    data.forEach((key,value) -\u003e result.put(key,new String(Base64.getDecoder().decode(value)).trim()));\n    return result;\n  }\n  public static \u003cT\u003evoid registerSingle(  ConfigurableBootstrapContext bootstrapContext,  Class\u003cT\u003e cls,  T instance,  String name){\n    bootstrapContext.registerIfAbsent(cls,BootstrapRegistry.InstanceSupplier.of(instance));\n    bootstrapContext.addCloseListener(event -\u003e {\n      if (event.getApplicationContext().getBeanFactory().getSingleton(name) \u003d\u003d null) {\n        event.getApplicationContext().getBeanFactory().registerSingleton(name,event.getBootstrapContext().get(cls));\n      }\n    }\n);\n  }\n  /** \n * append prefix to the keys and return a new Map with the new values.\n */\n  public static Map\u003cString,String\u003e keysWithPrefix(  Map\u003cString,String\u003e map,  String prefix){\n    if (map \u003d\u003d null || map.isEmpty()) {\n      return Map.of();\n    }\n    if (!StringUtils.hasText(prefix)) {\n      return map;\n    }\n    Map\u003cString,String\u003e result\u003dCollectionUtils.newHashMap(map.size());\n    map.forEach((key,value) -\u003e result.put(prefix + key,value));\n    return result;\n  }\npublic static final class Prefix {\n    /** \n * prefix has not been provided.\n */\n    public static final Prefix DEFAULT\u003dnew Prefix(() -\u003e \"\",\"DEFAULT\");\n    /** \n * prefix has been enabled, but the actual value will be known later; the value for the prefix will be the name of the source. (this is the case for a prefix-enabled labeled source for example)\n */\n    public static final Prefix DELAYED\u003dnew Prefix(() -\u003e {\n      throw new IllegalArgumentException(\"prefix is delayed, needs to be taken elsewhere\");\n    }\n,\"DELAYED\");\n    /** \n * prefix is known at the callsite.\n */\n    public static Prefix KNOWN;\n    public Supplier\u003cString\u003e prefixProvider(){\n      return prefixProvider;\n    }\n    private final Supplier\u003cString\u003e prefixProvider;\n    private final String name;\n    private Prefix(    Supplier\u003cString\u003e prefixProvider,    String name){\n      this.prefixProvider\u003dprefixProvider;\n      this.name\u003dname;\n    }\n    private static void computeKnown(    Supplier\u003cString\u003e supplier){\n      KNOWN\u003dnew Prefix(supplier,\"KNOWN\");\n    }\n    public String toString(){\n      return new ToStringCreator(this).append(\"name\",name).toString();\n    }\n  }\n}\n",
        "abstract": "/** \n * Utility class that works with configuration properties.\n * @author Ioannis Canellos\n */\npublic final class ConfigUtils {\n  private static final Log LOG\u003dLogFactory.getLog(ConfigUtils.class);\n  private static final BiPredicate\u003cString,String\u003e ENDS_WITH_PROFILE_AND_EXTENSION\u003d(sourceName,activeProfile) -\u003e sourceName.endsWith(\"-\" + activeProfile + \".yml\") || sourceName.endsWith(\"-\" + activeProfile + \".yaml\") || sourceName.endsWith(\"-\" + activeProfile + \".properties\");\n  private ConfigUtils();\n  public static String getApplicationName(  Environment env,  String configName,  String configurationTarget);\n  /** \n * @param explicitPrefix value of\u0027spring.cloud.kubernetes.config|secrets.sources.explicitPrefix\u0027\n * @param useNameAsPrefix value of\u0027spring.cloud.kubernetes.config|secrets.sources.useNameAsPrefix\u0027\n * @param defaultUseNameAsPrefix value of\u0027spring.cloud.kubernetes.config|secrets.defaultUseNameAsPrefix\u0027\n * @param normalizedName either the name of\u0027spring.cloud.kubernetes.config|secrets.sources.name\u0027 or \u0027spring.cloud.kubernetes.config|secrets.name\u0027\n * @return prefix to use in normalized sources\n */\n  public static Prefix findPrefix(  String explicitPrefix,  Boolean useNameAsPrefix,  boolean defaultUseNameAsPrefix,  String normalizedName);\n  /** \n * @param defaultIncludeProfileSpecificSources value of\u0027spring.cloud.kubernetes.config.includeProfileSpecificSources\u0027\n * @param includeProfileSpecificSources value of\u0027spring.cloud.kubernetes.config.sources.includeProfileSpecificSources\u0027\n * @return useProfileNameAsPrefix to be used in normalized sources\n */\n  public static boolean includeProfileSpecificSources(  boolean defaultIncludeProfileSpecificSources,  Boolean includeProfileSpecificSources);\n  /** \n * action to take when an Exception happens when dealing with a source.\n */\n  public static void onException(  boolean failFast,  Exception e);\n  public static SourceData withPrefix(  String target,  PrefixContext context);\n  public static String sourceName(  String target,  String applicationName,  String namespace);\n  public static String sourceName(  String target,  String applicationName,  String namespace,  String[] profiles);\n  public static MultipleSourcesContainer processNamedData(  List\u003cStrippedSourceContainer\u003e strippedSources,  Environment environment,  LinkedHashSet\u003cString\u003e sourceNames,  String namespace,  boolean decode);\n  /** \n * transforms raw data from one or multiple sources into an entry of source names and flattened data that they all hold (potentially overriding entries without any defined order).\n */\n  public static MultipleSourcesContainer processNamedData(  List\u003cStrippedSourceContainer\u003e strippedSources,  Environment environment,  LinkedHashSet\u003cString\u003e sourceNames,  String namespace,  boolean decode,  boolean includeDefaultProfileData);\n  static boolean processSource(  boolean includeDefaultProfileData,  Environment environment,  String sourceName,  Map\u003cString,String\u003e sourceRawData);\n  static BooleanSupplier rawDataContainsProfileBasedSource(  List\u003cString\u003e activeProfiles,  Map\u003cString,String\u003e sourceRawData);\n  /** \n * transforms raw data from one or multiple sources into an entry of source names and flattened data that they all hold (potentially overriding entries without any defined order). This method first searches by labels, find the sources, then uses these names to find any profile based sources.\n */\n  public static MultipleSourcesContainer processLabeledData(  List\u003cStrippedSourceContainer\u003e containers,  Environment environment,  Map\u003cString,String\u003e labels,  String namespace,  Set\u003cString\u003e profiles,  boolean decode);\n  private static Map\u003cString,String\u003e decodeData(  Map\u003cString,String\u003e data);\n  public static \u003cT\u003evoid registerSingle(  ConfigurableBootstrapContext bootstrapContext,  Class\u003cT\u003e cls,  T instance,  String name);\n  /** \n * append prefix to the keys and return a new Map with the new values.\n */\n  public static Map\u003cString,String\u003e keysWithPrefix(  Map\u003cString,String\u003e map,  String prefix);\npublic static final class Prefix {\n    /** \n * prefix has not been provided.\n */\n    public static final Prefix DEFAULT\u003dnew Prefix(() -\u003e \"\",\"DEFAULT\");\n    /** \n * prefix has been enabled, but the actual value will be known later; the value for the prefix will be the name of the source. (this is the case for a prefix-enabled labeled source for example)\n */\n    public static final Prefix DELAYED\u003dnew Prefix(() -\u003e {\n      throw new IllegalArgumentException(\"prefix is delayed, needs to be taken elsewhere\");\n    }\n,\"DELAYED\");\n    /** \n * prefix is known at the callsite.\n */\n    public static Prefix KNOWN;\n    public Supplier\u003cString\u003e prefixProvider();\n    private final Supplier\u003cString\u003e prefixProvider;\n    private final String name;\n    private Prefix(    Supplier\u003cString\u003e prefixProvider,    String name);\n    private static void computeKnown(    Supplier\u003cString\u003e supplier);\n    public String toString();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/ConfigDataRetryableSecretsPropertySourceLocator.java",
        "name": "ConfigDataRetryableSecretsPropertySourceLocator",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConfigDataRetryableSecretsPropertySourceLocator",
        "extend": "SecretsPropertySourceLocator",
        "implements": "",
        "raw": "/** \n * SecretsPropertySourceLocator for when retry is enabled.\n * @author Ryan Baxter\n */\npublic class ConfigDataRetryableSecretsPropertySourceLocator extends SecretsPropertySourceLocator {\n  private final RetryTemplate retryTemplate;\n  private SecretsPropertySourceLocator secretsPropertySourceLocator;\n  /** \n * This constructor is deprecated, and we do not use it anymore internally. It will be removed in the next major release.\n */\n  @Deprecated(forRemoval\u003dtrue) public ConfigDataRetryableSecretsPropertySourceLocator(  SecretsPropertySourceLocator propertySourceLocator,  SecretsConfigProperties secretsConfigProperties){\n    super(secretsConfigProperties);\n    this.secretsPropertySourceLocator\u003dpropertySourceLocator;\n    this.retryTemplate\u003dRetryTemplate.builder().maxAttempts(properties.retry().maxAttempts()).exponentialBackoff(properties.retry().initialInterval(),properties.retry().multiplier(),properties.retry().maxInterval()).build();\n  }\n  public ConfigDataRetryableSecretsPropertySourceLocator(  SecretsPropertySourceLocator propertySourceLocator,  SecretsConfigProperties secretsConfigProperties,  SecretsCache cache){\n    super(secretsConfigProperties,cache);\n    this.secretsPropertySourceLocator\u003dpropertySourceLocator;\n    this.retryTemplate\u003dRetryTemplate.builder().maxAttempts(properties.retry().maxAttempts()).exponentialBackoff(properties.retry().initialInterval(),properties.retry().multiplier(),properties.retry().maxInterval()).build();\n  }\n  @Override public PropertySource\u003c?\u003e locate(  Environment environment){\n    return retryTemplate.execute(retryContext -\u003e secretsPropertySourceLocator.locate(environment));\n  }\n  @Override public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment){\n    return retryTemplate.execute(retryContext -\u003e secretsPropertySourceLocator.locateCollection(environment));\n  }\n  @Override protected SecretsPropertySource getPropertySource(  ConfigurableEnvironment environment,  NormalizedSource normalizedSource){\n    return this.secretsPropertySourceLocator.getPropertySource(environment,normalizedSource);\n  }\n  public SecretsPropertySourceLocator getSecretsPropertySourceLocator(){\n    return secretsPropertySourceLocator;\n  }\n  public void setSecretsPropertySourceLocator(  SecretsPropertySourceLocator secretsPropertySourceLocator){\n    this.secretsPropertySourceLocator\u003dsecretsPropertySourceLocator;\n  }\n}\n",
        "abstract": "/** \n * SecretsPropertySourceLocator for when retry is enabled.\n * @author Ryan Baxter\n */\npublic class ConfigDataRetryableSecretsPropertySourceLocator extends SecretsPropertySourceLocator {\n  private final RetryTemplate retryTemplate;\n  private SecretsPropertySourceLocator secretsPropertySourceLocator;\n  /** \n * This constructor is deprecated, and we do not use it anymore internally. It will be removed in the next major release.\n */\n  @Deprecated(forRemoval\u003dtrue) public ConfigDataRetryableSecretsPropertySourceLocator(  SecretsPropertySourceLocator propertySourceLocator,  SecretsConfigProperties secretsConfigProperties);\n  public ConfigDataRetryableSecretsPropertySourceLocator(  SecretsPropertySourceLocator propertySourceLocator,  SecretsConfigProperties secretsConfigProperties,  SecretsCache cache);\n  @Override public PropertySource\u003c?\u003e locate(  Environment environment);\n  @Override public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment);\n  @Override protected SecretsPropertySource getPropertySource(  ConfigurableEnvironment environment,  NormalizedSource normalizedSource);\n  public SecretsPropertySourceLocator getSecretsPropertySourceLocator();\n  public void setSecretsPropertySourceLocator(  SecretsPropertySourceLocator secretsPropertySourceLocator);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/LabeledSourceData.java",
        "name": "LabeledSourceData",
        "modifiers": "public abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.LabeledSourceData",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57Base class when dealing with labeled sources that support profiles specific sources, prefix based properties and single file yaml/properties.\n */\npublic abstract class LabeledSourceData {\n  public final SourceData compute(  Map\u003cString,String\u003e labels,  ConfigUtils.Prefix prefix,  String target,  boolean profileSources,  boolean failFast,  String namespace,  String[] activeProfiles){\n    MultipleSourcesContainer data\u003dMultipleSourcesContainer.empty();\n    try {\n      Set\u003cString\u003e profiles\u003dSet.of();\n      if (profileSources) {\n        profiles\u003dArrays.stream(activeProfiles).collect(Collectors.toSet());\n      }\n      data\u003ddataSupplier(labels,profiles);\n      if (data.names().isEmpty()) {\n        String names\u003dlabels.keySet().stream().sorted().collect(Collectors.joining(PROPERTY_SOURCE_NAME_SEPARATOR));\n        return SourceData.emptyRecord(ConfigUtils.sourceName(target,names,namespace));\n      }\n      if (prefix !\u003d ConfigUtils.Prefix.DEFAULT) {\n        String prefixToUse;\n        if (prefix \u003d\u003d ConfigUtils.Prefix.KNOWN) {\n          prefixToUse\u003dprefix.prefixProvider().get();\n        }\n else {\n          prefixToUse\u003ddata.names().stream().sorted().collect(Collectors.joining(PROPERTY_SOURCE_NAME_SEPARATOR));\n        }\n        PrefixContext prefixContext\u003dnew PrefixContext(data.data(),prefixToUse,namespace,data.names());\n        return ConfigUtils.withPrefix(target,prefixContext);\n      }\n    }\n catch (    Exception e) {\n      onException(failFast,e);\n    }\n    String names\u003ddata.names().stream().sorted().collect(Collectors.joining(PROPERTY_SOURCE_NAME_SEPARATOR));\n    return new SourceData(ConfigUtils.sourceName(target,names,namespace),data.data());\n  }\n  /** \n * Implementation specific (fabric8 or k8s-native) way to get the data from then given source names.\n * @param labels the ones that have been configured\n * @param profiles profiles to taken into account when gathering source data. Can beempty.\n * @return a container that holds the names of the source that were found and theirdata\n */\n  public abstract MultipleSourcesContainer dataSupplier(  Map\u003cString,String\u003e labels,  Set\u003cString\u003e profiles);\n}\n",
        "abstract": "/** \n * @author wind57Base class when dealing with labeled sources that support profiles specific sources, prefix based properties and single file yaml/properties.\n */\npublic abstract class LabeledSourceData {\n  public final SourceData compute(  Map\u003cString,String\u003e labels,  ConfigUtils.Prefix prefix,  String target,  boolean profileSources,  boolean failFast,  String namespace,  String[] activeProfiles);\n  /** \n * Implementation specific (fabric8 or k8s-native) way to get the data from then given source names.\n * @param labels the ones that have been configured\n * @param profiles profiles to taken into account when gathering source data. Can beempty.\n * @return a container that holds the names of the source that were found and theirdata\n */\n  public abstract MultipleSourcesContainer dataSupplier(  Map\u003cString,String\u003e labels,  Set\u003cString\u003e profiles);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/ConfigMapCache.java",
        "name": "ConfigMapCache",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConfigMapCache",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic interface ConfigMapCache {\n  /** \n * Discards all stored entries from the cache.\n */\n  void discardAll();\n  /** \n * an implementation that does nothing. In the next major release it will become absolute and must be removed.\n */\nclass NOOPCache implements ConfigMapCache {\n    @Override public void discardAll(){\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic interface ConfigMapCache {\n  /** \n * Discards all stored entries from the cache.\n */\n  void discardAll();\n  /** \n * an implementation that does nothing. In the next major release it will become absolute and must be removed.\n */\nclass NOOPCache implements ConfigMapCache {\n    @Override public void discardAll();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/SourceDataEntriesProcessor.java",
        "name": "SourceDataEntriesProcessor",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.SourceDataEntriesProcessor",
        "extend": "MapPropertySource",
        "implements": "",
        "raw": "/** \n * Processor that extracts data from an input, where input can be a single yaml/properties file.\n * @author Ioannis Canellos\n * @author Ali Shahbour\n * @author Michael Moudatsos\n */\npublic class SourceDataEntriesProcessor extends MapPropertySource {\n  private static final Log LOG\u003dLogFactory.getLog(SourceDataEntriesProcessor.class);\n  private static Predicate\u003cString\u003e ENDS_IN_EXTENSION\u003dx -\u003e x.endsWith(\".yml\") || x.endsWith(\".yaml\") || x.endsWith(\".properties\");\n  public SourceDataEntriesProcessor(  SourceData sourceData){\n    super(sourceData.sourceName(),sourceData.sourceData());\n  }\n  public static Map\u003cString,Object\u003e processAllEntries(  Map\u003cString,String\u003e input,  Environment environment){\n    return processAllEntries(input,environment,true);\n  }\n  public static Map\u003cString,Object\u003e processAllEntries(  Map\u003cString,String\u003e input,  Environment environment,  boolean includeDefaultProfileData){\n    Set\u003cMap.Entry\u003cString,String\u003e\u003e entrySet\u003dinput.entrySet();\n    if (entrySet.size() \u003d\u003d 1) {\n      Map.Entry\u003cString,String\u003e singleEntry\u003dentrySet.iterator().next();\n      String propertyName\u003dsingleEntry.getKey();\n      String propertyValue\u003dsingleEntry.getValue();\n      if (propertyName.endsWith(\".yml\") || propertyName.endsWith(\".yaml\")) {\n        LOG.debug(\"The single property with name: [\" + propertyName + \"] will be treated as a yaml file\");\n        return yamlParserGenerator(environment).andThen(PROPERTIES_TO_MAP).apply(propertyValue);\n      }\n else       if (propertyName.endsWith(\".properties\")) {\n        LOG.debug(\"The single property with name: [\" + propertyName + \"] will be treated as a properties file\");\n        return KEY_VALUE_TO_PROPERTIES.andThen(PROPERTIES_TO_MAP).apply(propertyValue);\n      }\n    }\n    return defaultProcessAllEntries(input,environment,includeDefaultProfileData);\n  }\n  static List\u003cMap.Entry\u003cString,String\u003e\u003e sorted(  Map\u003cString,String\u003e input,  Environment environment){\n    return sorted(input,environment,true);\n  }\n  /** \n * \u003cpre\u003e we want to sort entries coming from the k8s source in a specific way: 1. \"application.yaml/yml/properties\" have to come first (or the value from spring.application.name) 2. then profile specific entries, like \"application-dev.yaml\" 3. then plain properties \u003c/pre\u003e\n */\n  static List\u003cMap.Entry\u003cString,String\u003e\u003e sorted(  Map\u003cString,String\u003e rawData,  Environment environment,  boolean includeDefaultProfileData){\n    record;\n    WeightedEntry(Map.Entry \u003c String,String \u003e entry,weight);\n    String applicationName\u003dConfigUtils.getApplicationName(environment,\"\",\"\");\n    String[] activeProfiles\u003denvironment.getActiveProfiles();\n    boolean includeDataEntry\u003dincludeDefaultProfileData || Arrays.asList(environment.getActiveProfiles()).contains(\"default\");\n    List\u003cString\u003e orderedFileNames\u003dnew ArrayList\u003c\u003e();\n    if (includeDataEntry) {\n      orderedFileNames.add(applicationName);\n    }\n  }\n  private static Map\u003cString,Object\u003e defaultProcessAllEntries(  Map\u003cString,String\u003e input,  Environment environment,  boolean includeDefaultProfile){\n    List\u003cMap.Entry\u003cString,String\u003e\u003e sortedEntries\u003dsorted(input,environment,includeDefaultProfile);\n    Map\u003cString,Object\u003e result\u003dnew HashMap\u003c\u003e();\n    for (    Map.Entry\u003cString,String\u003e entry : sortedEntries) {\n      result.putAll(extractProperties(entry.getKey(),entry.getValue(),environment));\n    }\n    return result;\n  }\n  private static Map\u003cString,Object\u003e extractProperties(  String resourceName,  String content,  Environment environment){\n    if (resourceName.endsWith(\".yml\") || resourceName.endsWith(\".yaml\") || resourceName.endsWith(\".properties\")) {\n      if (resourceName.endsWith(\".properties\")) {\n        LOG.debug(\"entry : \" + resourceName + \" will be treated as a single properties file\");\n        return KEY_VALUE_TO_PROPERTIES.andThen(PROPERTIES_TO_MAP).apply(content);\n      }\n else {\n        LOG.debug(\"entry : \" + resourceName + \" will be treated as a single yml/yaml file\");\n        return yamlParserGenerator(environment).andThen(PROPERTIES_TO_MAP).apply(content);\n      }\n    }\n    return Collections.singletonMap(resourceName,content);\n  }\n}\n",
        "abstract": "/** \n * Processor that extracts data from an input, where input can be a single yaml/properties file.\n * @author Ioannis Canellos\n * @author Ali Shahbour\n * @author Michael Moudatsos\n */\npublic class SourceDataEntriesProcessor extends MapPropertySource {\n  private static final Log LOG\u003dLogFactory.getLog(SourceDataEntriesProcessor.class);\n  private static Predicate\u003cString\u003e ENDS_IN_EXTENSION\u003dx -\u003e x.endsWith(\".yml\") || x.endsWith(\".yaml\") || x.endsWith(\".properties\");\n  public SourceDataEntriesProcessor(  SourceData sourceData);\n  public static Map\u003cString,Object\u003e processAllEntries(  Map\u003cString,String\u003e input,  Environment environment);\n  public static Map\u003cString,Object\u003e processAllEntries(  Map\u003cString,String\u003e input,  Environment environment,  boolean includeDefaultProfileData);\n  static List\u003cMap.Entry\u003cString,String\u003e\u003e sorted(  Map\u003cString,String\u003e input,  Environment environment);\n  /** \n * \u003cpre\u003e we want to sort entries coming from the k8s source in a specific way: 1. \"application.yaml/yml/properties\" have to come first (or the value from spring.application.name) 2. then profile specific entries, like \"application-dev.yaml\" 3. then plain properties \u003c/pre\u003e\n */\n  static List\u003cMap.Entry\u003cString,String\u003e\u003e sorted(  Map\u003cString,String\u003e rawData,  Environment environment,  boolean includeDefaultProfileData);\n  private static Map\u003cString,Object\u003e defaultProcessAllEntries(  Map\u003cString,String\u003e input,  Environment environment,  boolean includeDefaultProfile);\n  private static Map\u003cString,Object\u003e extractProperties(  String resourceName,  String content,  Environment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/ConditionalOnKubernetesSecretsRetryDisabled.java",
        "name": "ConditionalOnKubernetesSecretsRetryDisabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnKubernetesSecretsRetryDisabled.OnSecretsPropertiesRetryDisabled.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConditionalOnKubernetesSecretsRetryDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * {@link Conditional @Conditional} that matches when at least one of Spring CloudKubernetes, Kubernetes Secret property sources or Kubernetes Secret property sources fail fast (thus retry) is disabled.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnKubernetesSecretsRetryDisabled.OnSecretsPropertiesRetryDisabled.class) public @interface ConditionalOnKubernetesSecretsRetryDisabled {class OnSecretsPropertiesRetryDisabled extends NoneNestedConditions {\n  OnSecretsPropertiesRetryDisabled(){\n    super(ConfigurationPhase.REGISTER_BEAN);\n  }\n@ConditionalOnKubernetesSecretsRetryEnabled static class OnSecretsPropertiesRetryEnabled {\n  }\n}\n}\n",
        "abstract": "/** \n * {@link Conditional @Conditional} that matches when at least one of Spring CloudKubernetes, Kubernetes Secret property sources or Kubernetes Secret property sources fail fast (thus retry) is disabled.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Conditional(ConditionalOnKubernetesSecretsRetryDisabled.OnSecretsPropertiesRetryDisabled.class) public @interface ConditionalOnKubernetesSecretsRetryDisabled {class OnSecretsPropertiesRetryDisabled extends NoneNestedConditions {\n  OnSecretsPropertiesRetryDisabled(){\n    super(ConfigurationPhase.REGISTER_BEAN);\n  }\n@ConditionalOnKubernetesSecretsRetryEnabled static class OnSecretsPropertiesRetryEnabled {\n  }\n}\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/KubernetesConfigServerInstanceProvider.java",
        "name": "KubernetesConfigServerInstanceProvider",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.KubernetesConfigServerInstanceProvider",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic interface KubernetesConfigServerInstanceProvider {\n  List\u003cServiceInstance\u003e getInstances(  String serviceId);\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic interface KubernetesConfigServerInstanceProvider {\n  List\u003cServiceInstance\u003e getInstances(  String serviceId);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/ConditionalOnKubernetesSecretsFailFastEnabled.java",
        "name": "ConditionalOnKubernetesSecretsFailFastEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(prefix\u003dSecretsConfigProperties.PREFIX,name\u003d\"fail-fast\",havingValue\u003d\"true\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConditionalOnKubernetesSecretsFailFastEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.secrets.fail-fast\u003c/code\u003e.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(prefix\u003dSecretsConfigProperties.PREFIX,name\u003d\"fail-fast\",havingValue\u003d\"true\") public @interface ConditionalOnKubernetesSecretsFailFastEnabled {}\n",
        "abstract": "/** \n * Provides a more succinct conditional \u003ccode\u003espring.cloud.kubernetes.secrets.fail-fast\u003c/code\u003e.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(prefix\u003dSecretsConfigProperties.PREFIX,name\u003d\"fail-fast\",havingValue\u003d\"true\") public @interface ConditionalOnKubernetesSecretsFailFastEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/KubernetesConfigDataLocationResolver.java",
        "name": "KubernetesConfigDataLocationResolver",
        "modifiers": "public abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.KubernetesConfigDataLocationResolver",
        "extend": "",
        "implements": "ConfigDataLocationResolver\u003cKubernetesConfigDataResource\u003e Ordered",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic abstract class KubernetesConfigDataLocationResolver implements ConfigDataLocationResolver\u003cKubernetesConfigDataResource\u003e, Ordered {\n  private static final boolean RETRY_IS_PRESENT\u003disPresent(\"org.springframework.retry.annotation.Retryable\",null);\n  private final Log log;\n  public KubernetesConfigDataLocationResolver(  DeferredLogFactory factory){\n    this.log\u003dfactory.getLog(KubernetesConfigDataLocationResolver.class);\n  }\n  protected final String getPrefix(){\n    return \"kubernetes:\";\n  }\n  @Override public final int getOrder(){\n    return -1;\n  }\n  @Override public final boolean isResolvable(  ConfigDataLocationResolverContext context,  ConfigDataLocation location){\n    return location.hasPrefix(getPrefix()) \u0026\u0026 (KUBERNETES.isEnforced(context.getBinder()) || KUBERNETES.isDetected(new StandardEnvironment()));\n  }\n  @Override public final List\u003cKubernetesConfigDataResource\u003e resolve(  ConfigDataLocationResolverContext context,  ConfigDataLocation location) throws ConfigDataLocationNotFoundException, ConfigDataResourceNotFoundException {\n    return Collections.emptyList();\n  }\n  @Override public final List\u003cKubernetesConfigDataResource\u003e resolveProfileSpecific(  ConfigDataLocationResolverContext resolverContext,  ConfigDataLocation location,  Profiles profiles) throws ConfigDataLocationNotFoundException {\n    PropertyHolder propertyHolder\u003dPropertyHolder.of(resolverContext);\n    KubernetesClientProperties clientProperties\u003dpropertyHolder.kubernetesClientProperties();\n    ConfigMapConfigProperties configMapProperties\u003dpropertyHolder.configMapConfigProperties();\n    SecretsConfigProperties secretsProperties\u003dpropertyHolder.secretsProperties();\n    registerProperties(resolverContext,clientProperties,configMapProperties,secretsProperties);\n    HashMap\u003cString,Object\u003e kubernetesConfigData\u003dnew HashMap\u003c\u003e();\n    kubernetesConfigData.put(\"spring.cloud.kubernetes.client.namespace\",clientProperties.namespace());\n    if (propertyHolder.applicationName() !\u003d null) {\n      kubernetesConfigData.put(\"spring.application.name\",propertyHolder.applicationName());\n    }\n    PropertySource\u003cMap\u003cString,Object\u003e\u003e propertySource\u003dnew MapPropertySource(\"kubernetesConfigData\",kubernetesConfigData);\n    ConfigurableEnvironment environment\u003dnew StandardEnvironment();\n    environment.getPropertySources().addLast(propertySource);\n    environment.setActiveProfiles(profiles.getAccepted().toArray(new String[0]));\n    KubernetesNamespaceProvider namespaceProvider\u003dkubernetesNamespaceProvider(environment);\n    registerBeans(resolverContext,location,profiles,propertyHolder,namespaceProvider);\n    KubernetesConfigDataResource resource\u003dnew KubernetesConfigDataResource(clientProperties,configMapProperties,secretsProperties,location.isOptional(),profiles,environment);\n    resource.setLog(log);\n    return List.of(resource);\n  }\n  protected abstract void registerBeans(  ConfigDataLocationResolverContext resolverContext,  ConfigDataLocation location,  Profiles profiles,  PropertyHolder propertyHolder,  KubernetesNamespaceProvider namespaceProvider);\n  protected final boolean isRetryEnabledForConfigMap(  ConfigMapConfigProperties configMapProperties){\n    return RETRY_IS_PRESENT \u0026\u0026 configMapProperties !\u003d null \u0026\u0026 configMapProperties.retry().enabled() \u0026\u0026 configMapProperties.failFast();\n  }\n  protected final boolean isRetryEnabledForSecrets(  SecretsConfigProperties secretsProperties){\n    return RETRY_IS_PRESENT \u0026\u0026 secretsProperties !\u003d null \u0026\u0026 secretsProperties.retry().enabled() \u0026\u0026 secretsProperties.failFast();\n  }\n  protected KubernetesNamespaceProvider kubernetesNamespaceProvider(  Environment environment){\n    return new KubernetesNamespaceProvider(environment);\n  }\n  private void registerProperties(  ConfigDataLocationResolverContext resolverContext,  KubernetesClientProperties clientProperties,  ConfigMapConfigProperties configMapProperties,  SecretsConfigProperties secretsProperties){\n    ConfigurableBootstrapContext bootstrapContext\u003dresolverContext.getBootstrapContext();\n    registerSingle(bootstrapContext,KubernetesClientProperties.class,clientProperties,\"configDataKubernetesClientProperties\");\n    if (configMapProperties !\u003d null) {\n      registerSingle(bootstrapContext,ConfigMapConfigProperties.class,configMapProperties,\"configDataConfigMapConfigProperties\");\n    }\n    if (secretsProperties !\u003d null) {\n      registerSingle(bootstrapContext,SecretsConfigProperties.class,secretsProperties,\"configDataSecretsConfigProperties\");\n    }\n  }\n  protected record PropertyHolder(  KubernetesClientProperties kubernetesClientProperties,  ConfigMapConfigProperties configMapConfigProperties,  SecretsConfigProperties secretsProperties,  String applicationName){\n    private static PropertyHolder of;\n    ConfigDataLocationResolverContext context;\n{\n      Binder binder\u003dcontext.getBinder();\n      String applicationName\u003dbinder.bind(\"spring.application.name\",String.class).orElse(null);\n      String namespace\u003dbinder.bind(\"spring.cloud.kubernetes.client.namespace\",String.class).orElse(binder.bind(\"kubernetes.namespace\",String.class).orElse(\"\"));\n      KubernetesClientProperties kubernetesClientProperties\u003dclientProperties(context,namespace);\n      ConfigMapAndSecrets both\u003dConfigMapAndSecrets.of(binder);\n      return new PropertyHolder(kubernetesClientProperties,both.configMapProperties(),both.secretsConfigProperties(),applicationName);\n    }\n    private static KubernetesClientProperties clientProperties;\n    ConfigDataLocationResolverContext context;\n    String namespace;\n{\n      KubernetesClientProperties kubernetesClientProperties;\n      if (context.getBootstrapContext().isRegistered(KubernetesClientProperties.class)) {\n        kubernetesClientProperties\u003dcontext.getBootstrapContext().get(KubernetesClientProperties.class).withNamespace(namespace);\n      }\n else {\n        kubernetesClientProperties\u003dcontext.getBinder().bindOrCreate(KubernetesClientProperties.PREFIX,Bindable.of(KubernetesClientProperties.class)).withNamespace(namespace);\n      }\n      return kubernetesClientProperties;\n    }\n  }\n  /** \n * holds ConfigMapConfigProperties and SecretsConfigProperties, both can be null if using such sources is disabled.\n */\n  private record ConfigMapAndSecrets(  ConfigMapConfigProperties configMapProperties,  SecretsConfigProperties secretsConfigProperties){\n    private static ConfigMapAndSecrets of;\n    Binder binder;\n{\n      boolean configEnabled\u003dbinder.bind(\"spring.cloud.kubernetes.config.enabled\",boolean.class).orElse(true);\n      boolean secretsEnabled\u003dbinder.bind(\"spring.cloud.kubernetes.secrets.enabled\",boolean.class).orElse(true);\n      ConfigMapConfigProperties configMapConfigProperties\u003dnull;\n      if (configEnabled) {\n        configMapConfigProperties\u003dbinder.bindOrCreate(ConfigMapConfigProperties.PREFIX,ConfigMapConfigProperties.class);\n      }\n      SecretsConfigProperties secretsProperties\u003dnull;\n      if (secretsEnabled) {\n        secretsProperties\u003dbinder.bindOrCreate(SecretsConfigProperties.PREFIX,SecretsConfigProperties.class);\n      }\n      return new ConfigMapAndSecrets(configMapConfigProperties,secretsProperties);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic abstract class KubernetesConfigDataLocationResolver implements ConfigDataLocationResolver\u003cKubernetesConfigDataResource\u003e, Ordered {\n  private static final boolean RETRY_IS_PRESENT\u003disPresent(\"org.springframework.retry.annotation.Retryable\",null);\n  private final Log log;\n  public KubernetesConfigDataLocationResolver(  DeferredLogFactory factory);\n  protected final String getPrefix();\n  @Override public final int getOrder();\n  @Override public final boolean isResolvable(  ConfigDataLocationResolverContext context,  ConfigDataLocation location);\n  @Override public final List\u003cKubernetesConfigDataResource\u003e resolve(  ConfigDataLocationResolverContext context,  ConfigDataLocation location) throws ConfigDataLocationNotFoundException, ConfigDataResourceNotFoundException;\n  @Override public final List\u003cKubernetesConfigDataResource\u003e resolveProfileSpecific(  ConfigDataLocationResolverContext resolverContext,  ConfigDataLocation location,  Profiles profiles) throws ConfigDataLocationNotFoundException;\n  protected abstract void registerBeans(  ConfigDataLocationResolverContext resolverContext,  ConfigDataLocation location,  Profiles profiles,  PropertyHolder propertyHolder,  KubernetesNamespaceProvider namespaceProvider);\n  protected final boolean isRetryEnabledForConfigMap(  ConfigMapConfigProperties configMapProperties);\n  protected final boolean isRetryEnabledForSecrets(  SecretsConfigProperties secretsProperties);\n  protected KubernetesNamespaceProvider kubernetesNamespaceProvider(  Environment environment);\n  private void registerProperties(  ConfigDataLocationResolverContext resolverContext,  KubernetesClientProperties clientProperties,  ConfigMapConfigProperties configMapProperties,  SecretsConfigProperties secretsProperties);\n  protected record PropertyHolder(  KubernetesClientProperties kubernetesClientProperties,  ConfigMapConfigProperties configMapConfigProperties,  SecretsConfigProperties secretsProperties,  String applicationName);\n  /** \n * holds ConfigMapConfigProperties and SecretsConfigProperties, both can be null if using such sources is disabled.\n */\n  private record ConfigMapAndSecrets(  ConfigMapConfigProperties configMapProperties,  SecretsConfigProperties secretsConfigProperties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/ConfigDataRetryableConfigMapPropertySourceLocator.java",
        "name": "ConfigDataRetryableConfigMapPropertySourceLocator",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConfigDataRetryableConfigMapPropertySourceLocator",
        "extend": "ConfigMapPropertySourceLocator",
        "implements": "",
        "raw": "/** \n * ConfigMapPropertySourceLocator for when retry is enabled.\n * @author Ryan Baxter\n */\npublic class ConfigDataRetryableConfigMapPropertySourceLocator extends ConfigMapPropertySourceLocator {\n  private final RetryTemplate retryTemplate;\n  private ConfigMapPropertySourceLocator configMapPropertySourceLocator;\n  /** \n * This constructor is deprecated, and we do not use it anymore internally. It will be removed in the next major release.\n */\n  @Deprecated(forRemoval\u003dtrue) public ConfigDataRetryableConfigMapPropertySourceLocator(  ConfigMapPropertySourceLocator configMapPropertySourceLocator,  ConfigMapConfigProperties properties){\n    super(properties);\n    this.configMapPropertySourceLocator\u003dconfigMapPropertySourceLocator;\n    this.retryTemplate\u003dRetryTemplate.builder().maxAttempts(properties.retry().maxAttempts()).exponentialBackoff(properties.retry().initialInterval(),properties.retry().multiplier(),properties.retry().maxInterval()).build();\n  }\n  public ConfigDataRetryableConfigMapPropertySourceLocator(  ConfigMapPropertySourceLocator configMapPropertySourceLocator,  ConfigMapConfigProperties properties,  ConfigMapCache cache){\n    super(properties,cache);\n    this.configMapPropertySourceLocator\u003dconfigMapPropertySourceLocator;\n    this.retryTemplate\u003dRetryTemplate.builder().maxAttempts(properties.retry().maxAttempts()).exponentialBackoff(properties.retry().initialInterval(),properties.retry().multiplier(),properties.retry().maxInterval()).build();\n  }\n  @Override protected MapPropertySource getMapPropertySource(  NormalizedSource normalizedSource,  ConfigurableEnvironment environment){\n    return configMapPropertySourceLocator.getMapPropertySource(normalizedSource,environment);\n  }\n  @Override public PropertySource\u003c?\u003e locate(  Environment environment){\n    return retryTemplate.execute(retryContext -\u003e configMapPropertySourceLocator.locate(environment));\n  }\n  @Override public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment){\n    return retryTemplate.execute(retryContext -\u003e configMapPropertySourceLocator.locateCollection(environment));\n  }\n  public void setConfigMapPropertySourceLocator(  ConfigMapPropertySourceLocator configMapPropertySourceLocator){\n    this.configMapPropertySourceLocator\u003dconfigMapPropertySourceLocator;\n  }\n  public ConfigMapPropertySourceLocator getConfigMapPropertySourceLocator(){\n    return configMapPropertySourceLocator;\n  }\n}\n",
        "abstract": "/** \n * ConfigMapPropertySourceLocator for when retry is enabled.\n * @author Ryan Baxter\n */\npublic class ConfigDataRetryableConfigMapPropertySourceLocator extends ConfigMapPropertySourceLocator {\n  private final RetryTemplate retryTemplate;\n  private ConfigMapPropertySourceLocator configMapPropertySourceLocator;\n  /** \n * This constructor is deprecated, and we do not use it anymore internally. It will be removed in the next major release.\n */\n  @Deprecated(forRemoval\u003dtrue) public ConfigDataRetryableConfigMapPropertySourceLocator(  ConfigMapPropertySourceLocator configMapPropertySourceLocator,  ConfigMapConfigProperties properties);\n  public ConfigDataRetryableConfigMapPropertySourceLocator(  ConfigMapPropertySourceLocator configMapPropertySourceLocator,  ConfigMapConfigProperties properties,  ConfigMapCache cache);\n  @Override protected MapPropertySource getMapPropertySource(  NormalizedSource normalizedSource,  ConfigurableEnvironment environment);\n  @Override public PropertySource\u003c?\u003e locate(  Environment environment);\n  @Override public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment);\n  public void setConfigMapPropertySourceLocator(  ConfigMapPropertySourceLocator configMapPropertySourceLocator);\n  public ConfigMapPropertySourceLocator getConfigMapPropertySourceLocator();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/SecretsPropertySourceLocator.java",
        "name": "SecretsPropertySourceLocator",
        "modifiers": "public abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.SecretsPropertySourceLocator",
        "extend": "",
        "implements": "PropertySourceLocator",
        "raw": "/** \n * Kubernetes  {@link PropertySourceLocator} for secrets.\n * @author l burgazzoli\n * @author Haytham Mohamed\n * @author wind57\n * @author Isik Erhan\n */\npublic abstract class SecretsPropertySourceLocator implements PropertySourceLocator {\n  private static final Log LOG\u003dLogFactory.getLog(SecretsPropertySourceLocator.class);\n  private final SecretsCache cache;\n  protected final SecretsConfigProperties properties;\n  /** \n * This constructor is deprecated, and we do not use it anymore internally. It will be removed in the next major release.\n */\n  @Deprecated(forRemoval\u003dtrue) public SecretsPropertySourceLocator(  SecretsConfigProperties properties){\n    this.properties\u003dproperties;\n    this.cache\u003dnew SecretsCache.NOOPCache();\n  }\n  public SecretsPropertySourceLocator(  SecretsConfigProperties properties,  SecretsCache cache){\n    this.properties\u003dproperties;\n    this.cache\u003dcache;\n  }\n  @Override public PropertySource\u003c?\u003e locate(  Environment environment){\n    if (environment instanceof ConfigurableEnvironment) {\n      List\u003cNormalizedSource\u003e sources\u003dthis.properties.determineSources(environment);\n      Set\u003cNormalizedSource\u003e uniqueSources\u003dnew HashSet\u003c\u003e(sources);\n      LOG.debug(\"Secrets normalized sources : \" + sources);\n      CompositePropertySource composite\u003dnew CompositePropertySource(\"composite-secrets\");\n      putPathConfig(composite);\n      if (this.properties.enableApi()) {\n        uniqueSources.forEach(s -\u003e composite.addPropertySource(getSecretsPropertySourceForSingleSecret(env,s)));\n      }\n      cache.discardAll();\n      return composite;\n    }\n    return null;\n  }\n  @Override public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment){\n    return PropertySourceLocator.super.locateCollection(environment);\n  }\n  private SecretsPropertySource getSecretsPropertySourceForSingleSecret(  ConfigurableEnvironment environment,  NormalizedSource normalizedSource){\n    return getPropertySource(environment,normalizedSource);\n  }\n  protected abstract SecretsPropertySource getPropertySource(  ConfigurableEnvironment environment,  NormalizedSource normalizedSource);\n  protected void putPathConfig(  CompositePropertySource composite){\n    if (!properties.paths().isEmpty()) {\n      LOG.warn(\"path support is deprecated and will be removed in a future release. Please use spring.config.import\");\n    }\n    this.properties.paths().stream().map(Paths::get).filter(Files::exists).flatMap(x -\u003e {\n      try {\n        return Files.walk(x);\n      }\n catch (      IOException e) {\n        LOG.warn(\"Error walking properties files\",e);\n        return null;\n      }\n    }\n).filter(Objects::nonNull).filter(Files::isRegularFile).collect(new SecretsPropertySourceCollector()).forEach(composite::addPropertySource);\n  }\n  /** \n * @author wind57\n */\nprivate static class SecretsPropertySourceCollector implements Collector\u003cPath,List\u003cSecretsPropertySource\u003e,List\u003cSecretsPropertySource\u003e\u003e {\n    @Override public Supplier\u003cList\u003cSecretsPropertySource\u003e\u003e supplier(){\n      return ArrayList::new;\n    }\n    @Override public BiConsumer\u003cList\u003cSecretsPropertySource\u003e,Path\u003e accumulator(){\n      return (list,filePath) -\u003e {\n        SecretsPropertySource source\u003dproperty(filePath);\n        if (source !\u003d null) {\n          list.add(source);\n        }\n      }\n;\n    }\n    @Override public BinaryOperator\u003cList\u003cSecretsPropertySource\u003e\u003e combiner(){\n      return (left,right) -\u003e {\n        left.addAll(right);\n        return left;\n      }\n;\n    }\n    @Override public Function\u003cList\u003cSecretsPropertySource\u003e,List\u003cSecretsPropertySource\u003e\u003e finisher(){\n      return Function.identity();\n    }\n    @Override public Set\u003cCharacteristics\u003e characteristics(){\n      return EnumSet.of(Characteristics.UNORDERED,Characteristics.IDENTITY_FINISH);\n    }\n    private SecretsPropertySource property(    Path filePath){\n      String fileName\u003dfilePath.getFileName().toString();\n      try {\n        String content\u003dnew String(Files.readAllBytes(filePath)).trim();\n        String sourceName\u003dfileName.toLowerCase();\n        SourceData sourceData\u003dnew SourceData(sourceName,Collections.singletonMap(fileName,content));\n        return new SecretsPropertySource(sourceData);\n      }\n catch (      IOException e) {\n        LOG.warn(\"Error reading properties file\",e);\n        return null;\n      }\n    }\n  }\n}\n",
        "abstract": "/** \n * Kubernetes  {@link PropertySourceLocator} for secrets.\n * @author l burgazzoli\n * @author Haytham Mohamed\n * @author wind57\n * @author Isik Erhan\n */\npublic abstract class SecretsPropertySourceLocator implements PropertySourceLocator {\n  private static final Log LOG\u003dLogFactory.getLog(SecretsPropertySourceLocator.class);\n  private final SecretsCache cache;\n  protected final SecretsConfigProperties properties;\n  /** \n * This constructor is deprecated, and we do not use it anymore internally. It will be removed in the next major release.\n */\n  @Deprecated(forRemoval\u003dtrue) public SecretsPropertySourceLocator(  SecretsConfigProperties properties);\n  public SecretsPropertySourceLocator(  SecretsConfigProperties properties,  SecretsCache cache);\n  @Override public PropertySource\u003c?\u003e locate(  Environment environment);\n  @Override public Collection\u003cPropertySource\u003c?\u003e\u003e locateCollection(  Environment environment);\n  private SecretsPropertySource getSecretsPropertySourceForSingleSecret(  ConfigurableEnvironment environment,  NormalizedSource normalizedSource);\n  protected abstract SecretsPropertySource getPropertySource(  ConfigurableEnvironment environment,  NormalizedSource normalizedSource);\n  protected void putPathConfig(  CompositePropertySource composite);\n  /** \n * @author wind57\n */\nprivate static class SecretsPropertySourceCollector implements Collector\u003cPath,List\u003cSecretsPropertySource\u003e,List\u003cSecretsPropertySource\u003e\u003e {\n    @Override public Supplier\u003cList\u003cSecretsPropertySource\u003e\u003e supplier();\n    @Override public BiConsumer\u003cList\u003cSecretsPropertySource\u003e,Path\u003e accumulator();\n    @Override public BinaryOperator\u003cList\u003cSecretsPropertySource\u003e\u003e combiner();\n    @Override public Function\u003cList\u003cSecretsPropertySource\u003e,List\u003cSecretsPropertySource\u003e\u003e finisher();\n    @Override public Set\u003cCharacteristics\u003e characteristics();\n    private SecretsPropertySource property(    Path filePath);\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/ConditionalOnKubernetesSecretsRetryEnabled.java",
        "name": "ConditionalOnKubernetesSecretsRetryEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesSecretsEnabled @ConditionalOnKubernetesSecretsFailFastEnabled @ConditionalOnProperty(prefix\u003dSecretsConfigProperties.PREFIX + \".retry\",name\u003d\"enabled\",havingValue\u003d\"true\",matchIfMissing\u003dtrue) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConditionalOnKubernetesSecretsRetryEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * {@link org.springframework.context.annotation.Conditional @Conditional} that onlymatches when Spring Cloud Kubernetes, Kubernetes secrets, Kubernetes secrets fail-fast and Kubernetes secrets retry are enabled.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesSecretsEnabled @ConditionalOnKubernetesSecretsFailFastEnabled @ConditionalOnProperty(prefix\u003dSecretsConfigProperties.PREFIX + \".retry\",name\u003d\"enabled\",havingValue\u003d\"true\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesSecretsRetryEnabled {}\n",
        "abstract": "/** \n * {@link org.springframework.context.annotation.Conditional @Conditional} that onlymatches when Spring Cloud Kubernetes, Kubernetes secrets, Kubernetes secrets fail-fast and Kubernetes secrets retry are enabled.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesSecretsEnabled @ConditionalOnKubernetesSecretsFailFastEnabled @ConditionalOnProperty(prefix\u003dSecretsConfigProperties.PREFIX + \".retry\",name\u003d\"enabled\",havingValue\u003d\"true\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesSecretsRetryEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/reload/ConfigReloadProperties.java",
        "name": "ReloadStrategy",
        "modifiers": "@ConfigurationProperties(prefix\u003d\"spring.cloud.kubernetes.reload\") public @DefaultValue(\"true\") @DefaultValue(\"REFRESH\") @DefaultValue(\"EVENT\") @DefaultValue(\"15000ms\") @DefaultValue @DefaultValue(\"2s\") public static public static final public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.ReloadStrategy",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Reload strategies.\n */\n@ConfigurationProperties(prefix\u003d\"spring.cloud.kubernetes.reload\") public @DefaultValue(\"true\") @DefaultValue(\"REFRESH\") @DefaultValue(\"EVENT\") @DefaultValue(\"15000ms\") @DefaultValue @DefaultValue(\"2s\") public static public static final public enum ReloadStrategy {/** \n * Fire a refresh of beans annotated with @ConfigurationProperties or @RefreshScope.\n */\nREFRESH, /** \n * Restarts the Spring ApplicationContext to apply the new configuration.\n */\nRESTART_CONTEXT, /** \n * Shuts down the Spring ApplicationContext to activate a restart of the container. Make sure that the lifecycle of all non-daemon threads is bound to the ApplicationContext and that a replication controller or replica set is configured to restart the pod.\n */\nSHUTDOWN}\n",
        "abstract": "/** \n * Reload strategies.\n */\n@ConfigurationProperties(prefix\u003d\"spring.cloud.kubernetes.reload\") public @DefaultValue(\"true\") @DefaultValue(\"REFRESH\") @DefaultValue(\"EVENT\") @DefaultValue(\"15000ms\") @DefaultValue @DefaultValue(\"2s\") public static public static final public enum ReloadStrategy {/** \n * Fire a refresh of beans annotated with @ConfigurationProperties or @RefreshScope.\n */\nREFRESH, /** \n * Restarts the Spring ApplicationContext to apply the new configuration.\n */\nRESTART_CONTEXT, /** \n * Shuts down the Spring ApplicationContext to activate a restart of the container. Make sure that the lifecycle of all non-daemon threads is bound to the ApplicationContext and that a replication controller or replica set is configured to restart the pod.\n */\nSHUTDOWN}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/reload/ConfigReloadProperties.java",
        "name": "ReloadDetectionMode",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.ReloadDetectionMode",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Reload detection modes.\n */\npublic enum ReloadDetectionMode {/** \n * Enables a polling task that retrieves periodically all external properties and fire a reload when they change.\n */\nPOLLING, /** \n * Listens to Kubernetes events and checks if a reload is needed when configmaps or secrets change.\n */\nEVENT}\n",
        "abstract": "/** \n * Reload detection modes.\n */\npublic enum ReloadDetectionMode {/** \n * Enables a polling task that retrieves periodically all external properties and fire a reload when they change.\n */\nPOLLING, /** \n * Listens to Kubernetes events and checks if a reload is needed when configmaps or secrets change.\n */\nEVENT}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/reload/PollingSecretsChangeDetector.java",
        "name": "PollingSecretsChangeDetector",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.PollingSecretsChangeDetector",
        "extend": "ConfigurationChangeDetector",
        "implements": "",
        "raw": "/** \n * A change detector that periodically retrieves secrets and fires a reload when something changes.\n * @author Nicola Ferraro\n * @author Haytham Mohamed\n * @author Kris Iyer\n */\npublic class PollingSecretsChangeDetector extends ConfigurationChangeDetector {\n  protected Log log\u003dLogFactory.getLog(getClass());\n  private final PropertySourceLocator propertySourceLocator;\n  private final Class\u003c? extends MapPropertySource\u003e propertySourceClass;\n  private final TaskScheduler taskExecutor;\n  private final long period;\n  private final boolean monitorSecrets;\n  public PollingSecretsChangeDetector(  AbstractEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  Class\u003c? extends MapPropertySource\u003e propertySourceClass,  PropertySourceLocator propertySourceLocator,  TaskScheduler taskExecutor){\n    super(environment,properties,strategy);\n    this.propertySourceLocator\u003dpropertySourceLocator;\n    this.propertySourceClass\u003dpropertySourceClass;\n    this.taskExecutor\u003dtaskExecutor;\n    this.period\u003dproperties.period().toMillis();\n    this.monitorSecrets\u003dproperties.monitoringSecrets();\n  }\n  @PostConstruct private void init(){\n    log.info(\"Kubernetes polling secrets change detector activated\");\n    PeriodicTrigger trigger\u003dnew PeriodicTrigger(Duration.ofMillis(period));\n    trigger.setInitialDelay(Duration.ofMillis(period));\n    taskExecutor.schedule(this::executeCycle,trigger);\n  }\n  private void executeCycle(){\n    boolean changedSecrets\u003dfalse;\n    if (monitorSecrets) {\n      log.debug(\"Polling for changes in secrets\");\n      List\u003cMapPropertySource\u003e currentSecretSources\u003dlocateMapPropertySources(this.propertySourceLocator,this.environment);\n      if (!currentSecretSources.isEmpty()) {\n        List\u003c? extends MapPropertySource\u003e propertySources\u003dfindPropertySources(propertySourceClass,environment);\n        changedSecrets\u003dchanged(currentSecretSources,propertySources);\n      }\n    }\n    if (changedSecrets) {\n      log.info(\"Detected change in secrets\");\n      reloadProperties();\n    }\n  }\n}\n",
        "abstract": "/** \n * A change detector that periodically retrieves secrets and fires a reload when something changes.\n * @author Nicola Ferraro\n * @author Haytham Mohamed\n * @author Kris Iyer\n */\npublic class PollingSecretsChangeDetector extends ConfigurationChangeDetector {\n  protected Log log\u003dLogFactory.getLog(getClass());\n  private final PropertySourceLocator propertySourceLocator;\n  private final Class\u003c? extends MapPropertySource\u003e propertySourceClass;\n  private final TaskScheduler taskExecutor;\n  private final long period;\n  private final boolean monitorSecrets;\n  public PollingSecretsChangeDetector(  AbstractEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  Class\u003c? extends MapPropertySource\u003e propertySourceClass,  PropertySourceLocator propertySourceLocator,  TaskScheduler taskExecutor);\n  @PostConstruct private void init();\n  private void executeCycle();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/reload/condition/ConditionalOnConfigMapsReloadEnabled.java",
        "name": "ConditionalOnConfigMapsReloadEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(name\u003d\"spring.cloud.kubernetes.reload.monitoring-configMaps\",havingValue\u003d\"true\",matchIfMissing\u003dtrue) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.condition.ConditionalOnConfigMapsReloadEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides a more succinct conditional for: \u003ccode\u003espring.cloud.kubernetes.reload.monitoring-configMaps\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(name\u003d\"spring.cloud.kubernetes.reload.monitoring-configMaps\",havingValue\u003d\"true\",matchIfMissing\u003dtrue) public @interface ConditionalOnConfigMapsReloadEnabled {}\n",
        "abstract": "/** \n * Provides a more succinct conditional for: \u003ccode\u003espring.cloud.kubernetes.reload.monitoring-configMaps\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(name\u003d\"spring.cloud.kubernetes.reload.monitoring-configMaps\",havingValue\u003d\"true\",matchIfMissing\u003dtrue) public @interface ConditionalOnConfigMapsReloadEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/reload/condition/EventReloadDetectionMode.java",
        "name": "EventReloadDetectionMode",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.condition.EventReloadDetectionMode",
        "extend": "",
        "implements": "Condition",
        "raw": "/** \n * A condition for Event ReloadDetectionMode and auto configuration.\n * @author Kris Iyer\n */\npublic final class EventReloadDetectionMode implements Condition {\n  @Override public boolean matches(  ConditionContext context,  AnnotatedTypeMetadata metadata){\n    Environment environment\u003dcontext.getEnvironment();\n    if (!environment.containsProperty(Constants.RELOAD_MODE)) {\n      return true;\n    }\n    return ConfigReloadProperties.ReloadDetectionMode.EVENT.name().equalsIgnoreCase(environment.getProperty(Constants.RELOAD_MODE));\n  }\n}\n",
        "abstract": "/** \n * A condition for Event ReloadDetectionMode and auto configuration.\n * @author Kris Iyer\n */\npublic final class EventReloadDetectionMode implements Condition {\n  @Override public boolean matches(  ConditionContext context,  AnnotatedTypeMetadata metadata);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/reload/condition/PollingReloadDetectionMode.java",
        "name": "PollingReloadDetectionMode",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.condition.PollingReloadDetectionMode",
        "extend": "",
        "implements": "Condition",
        "raw": "/** \n * A condition for Polling ReloadDetectionMode and auto configuration.\n * @author Kris Iyer\n */\npublic final class PollingReloadDetectionMode implements Condition {\n  @Override public boolean matches(  ConditionContext context,  AnnotatedTypeMetadata metadata){\n    Environment environment\u003dcontext.getEnvironment();\n    if (!environment.containsProperty(Constants.RELOAD_MODE)) {\n      return false;\n    }\n    return ConfigReloadProperties.ReloadDetectionMode.POLLING.name().equalsIgnoreCase(environment.getProperty(Constants.RELOAD_MODE));\n  }\n}\n",
        "abstract": "/** \n * A condition for Polling ReloadDetectionMode and auto configuration.\n * @author Kris Iyer\n */\npublic final class PollingReloadDetectionMode implements Condition {\n  @Override public boolean matches(  ConditionContext context,  AnnotatedTypeMetadata metadata);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/reload/condition/ConditionalOnKubernetesReloadEnabled.java",
        "name": "ConditionalOnKubernetesReloadEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(name\u003d\"spring.cloud.kubernetes.reload.enabled\",havingValue\u003d\"true\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.condition.ConditionalOnKubernetesReloadEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides a more succinct conditional for: \u003ccode\u003espring.cloud.kubernetes.reload.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(name\u003d\"spring.cloud.kubernetes.reload.enabled\",havingValue\u003d\"true\") public @interface ConditionalOnKubernetesReloadEnabled {}\n",
        "abstract": "/** \n * Provides a more succinct conditional for: \u003ccode\u003espring.cloud.kubernetes.reload.enabled\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(name\u003d\"spring.cloud.kubernetes.reload.enabled\",havingValue\u003d\"true\") public @interface ConditionalOnKubernetesReloadEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/reload/condition/ConditionalOnSecretsReloadEnabled.java",
        "name": "ConditionalOnSecretsReloadEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(name\u003d\"spring.cloud.kubernetes.reload.monitoring-secrets\",havingValue\u003d\"true\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.condition.ConditionalOnSecretsReloadEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Provides a more succinct conditional for: \u003ccode\u003espring.cloud.kubernetes.reload.monitoring-secrets\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(name\u003d\"spring.cloud.kubernetes.reload.monitoring-secrets\",havingValue\u003d\"true\") public @interface ConditionalOnSecretsReloadEnabled {}\n",
        "abstract": "/** \n * Provides a more succinct conditional for: \u003ccode\u003espring.cloud.kubernetes.reload.monitoring-secrets\u003c/code\u003e.\n * @author wind57\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnProperty(name\u003d\"spring.cloud.kubernetes.reload.monitoring-secrets\",havingValue\u003d\"true\") public @interface ConditionalOnSecretsReloadEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/reload/PollingConfigMapChangeDetector.java",
        "name": "PollingConfigMapChangeDetector",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.PollingConfigMapChangeDetector",
        "extend": "ConfigurationChangeDetector",
        "implements": "",
        "raw": "/** \n * A change detector that periodically retrieves configmaps and fire a reload when something changes.\n * @author Nicola Ferraro\n * @author Haytham Mohamed\n * @author Kris Iyer\n */\npublic class PollingConfigMapChangeDetector extends ConfigurationChangeDetector {\n  protected Log log\u003dLogFactory.getLog(getClass());\n  private final PropertySourceLocator propertySourceLocator;\n  private final Class\u003c? extends MapPropertySource\u003e propertySourceClass;\n  private final TaskScheduler taskExecutor;\n  private final long period;\n  private final boolean monitorConfigMaps;\n  public PollingConfigMapChangeDetector(  AbstractEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  Class\u003c? extends MapPropertySource\u003e propertySourceClass,  PropertySourceLocator propertySourceLocator,  TaskScheduler taskExecutor){\n    super(environment,properties,strategy);\n    this.propertySourceLocator\u003dpropertySourceLocator;\n    this.propertySourceClass\u003dpropertySourceClass;\n    this.taskExecutor\u003dtaskExecutor;\n    this.period\u003dproperties.period().toMillis();\n    this.monitorConfigMaps\u003dproperties.monitoringConfigMaps();\n  }\n  @PostConstruct private void init(){\n    log.info(\"Kubernetes polling configMap change detector activated\");\n    PeriodicTrigger trigger\u003dnew PeriodicTrigger(Duration.ofMillis(period));\n    trigger.setInitialDelay(Duration.ofMillis(period));\n    taskExecutor.schedule(this::executeCycle,trigger);\n  }\n  private void executeCycle(){\n    boolean changedConfigMap\u003dfalse;\n    if (monitorConfigMaps) {\n      log.debug(\"Polling for changes in config maps\");\n      List\u003c? extends MapPropertySource\u003e currentConfigMapSources\u003dfindPropertySources(propertySourceClass,environment);\n      if (!currentConfigMapSources.isEmpty()) {\n        changedConfigMap\u003dchanged(locateMapPropertySources(this.propertySourceLocator,this.environment),currentConfigMapSources);\n      }\n    }\n    if (changedConfigMap) {\n      log.info(\"Detected change in config maps\");\n      reloadProperties();\n    }\n  }\n}\n",
        "abstract": "/** \n * A change detector that periodically retrieves configmaps and fire a reload when something changes.\n * @author Nicola Ferraro\n * @author Haytham Mohamed\n * @author Kris Iyer\n */\npublic class PollingConfigMapChangeDetector extends ConfigurationChangeDetector {\n  protected Log log\u003dLogFactory.getLog(getClass());\n  private final PropertySourceLocator propertySourceLocator;\n  private final Class\u003c? extends MapPropertySource\u003e propertySourceClass;\n  private final TaskScheduler taskExecutor;\n  private final long period;\n  private final boolean monitorConfigMaps;\n  public PollingConfigMapChangeDetector(  AbstractEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy,  Class\u003c? extends MapPropertySource\u003e propertySourceClass,  PropertySourceLocator propertySourceLocator,  TaskScheduler taskExecutor);\n  @PostConstruct private void init();\n  private void executeCycle();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/reload/ConfigReloadAutoConfiguration.java",
        "name": "ConfigReloadAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesConfigMapsOrSecretsEnabled @ConditionalOnKubernetesReloadEnabled @ConditionalOnClass({EndpointAutoConfiguration.class,RestartEndpoint.class,ContextRefresher.class}) @AutoConfigureAfter({InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,RefreshAutoConfiguration.class}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.ConfigReloadAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesConfigMapsOrSecretsEnabled @ConditionalOnKubernetesReloadEnabled @ConditionalOnClass({EndpointAutoConfiguration.class,RestartEndpoint.class,ContextRefresher.class}) @AutoConfigureAfter({InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,RefreshAutoConfiguration.class}) public class ConfigReloadAutoConfiguration {\n  @Bean(\"springCloudKubernetesTaskScheduler\") @ConditionalOnMissingBean public TaskSchedulerWrapper\u003cTaskScheduler\u003e taskScheduler(){\n    ThreadPoolTaskScheduler threadPoolTaskScheduler\u003dnew ThreadPoolTaskScheduler();\n    threadPoolTaskScheduler.setThreadNamePrefix(\"spring-cloud-kubernetes-ThreadPoolTaskScheduler-\");\n    threadPoolTaskScheduler.setDaemon(true);\n    return new TaskSchedulerWrapper\u003c\u003e(threadPoolTaskScheduler);\n  }\n  @Bean @ConditionalOnMissingBean public ConfigurationUpdateStrategy configurationUpdateStrategy(  ConfigReloadProperties properties,  ConfigurableApplicationContext ctx,  Optional\u003cRestartEndpoint\u003e restarter,  ContextRefresher refresher){\n    String strategyName\u003dproperties.strategy().name();\ncase RESTART_CONTEXT:\n    }\n    private static void wait(    ConfigReloadProperties properties){\n      long waitMillis\u003dThreadLocalRandom.current().nextLong(properties.maxWaitForRestart().toMillis());\n      try {\n        Thread.sleep(waitMillis);\n      }\n catch (      InterruptedException ignored) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesConfigMapsOrSecretsEnabled @ConditionalOnKubernetesReloadEnabled @ConditionalOnClass({EndpointAutoConfiguration.class,RestartEndpoint.class,ContextRefresher.class}) @AutoConfigureAfter({InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,RefreshAutoConfiguration.class}) public class ConfigReloadAutoConfiguration {\n  @Bean(\"springCloudKubernetesTaskScheduler\") @ConditionalOnMissingBean public TaskSchedulerWrapper\u003cTaskScheduler\u003e taskScheduler();\n  @Bean @ConditionalOnMissingBean public ConfigurationUpdateStrategy configurationUpdateStrategy(  ConfigReloadProperties properties,  ConfigurableApplicationContext ctx,  Optional\u003cRestartEndpoint\u003e restarter,  ContextRefresher refresher);\n    private static void wait(    ConfigReloadProperties properties);\n  }\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/reload/ConfigurationChangeDetector.java",
        "name": "ConfigurationChangeDetector",
        "modifiers": "public abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.ConfigurationChangeDetector",
        "extend": "",
        "implements": "",
        "raw": "/** \n * This is the superclass of all beans that can listen to changes in the configuration and fire a reload.\n * @author Nicola Ferraro\n */\npublic abstract class ConfigurationChangeDetector {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(ConfigurationChangeDetector.class));\n  protected ConfigurableEnvironment environment;\n  protected ConfigReloadProperties properties;\n  protected ConfigurationUpdateStrategy strategy;\n  public ConfigurationChangeDetector(  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy){\n    this.environment\u003dObjects.requireNonNull(environment);\n    this.properties\u003dObjects.requireNonNull(properties);\n    this.strategy\u003dObjects.requireNonNull(strategy);\n  }\n  public void reloadProperties(){\n    LOG.info(() -\u003e \"Reloading using strategy: \" + this.strategy.name());\n    strategy.reloadProcedure().run();\n  }\n}\n",
        "abstract": "/** \n * This is the superclass of all beans that can listen to changes in the configuration and fire a reload.\n * @author Nicola Ferraro\n */\npublic abstract class ConfigurationChangeDetector {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(ConfigurationChangeDetector.class));\n  protected ConfigurableEnvironment environment;\n  protected ConfigReloadProperties properties;\n  protected ConfigurationUpdateStrategy strategy;\n  public ConfigurationChangeDetector(  ConfigurableEnvironment environment,  ConfigReloadProperties properties,  ConfigurationUpdateStrategy strategy);\n  public void reloadProperties();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/reload/ConfigReloadUtil.java",
        "name": "ConfigReloadUtil",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.ConfigReloadUtil",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic final class ConfigReloadUtil {\n  private ConfigReloadUtil(){\n  }\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(ConfigReloadUtil.class));\n  public static boolean reload(  String target,  String eventSourceType,  PropertySourceLocator locator,  ConfigurableEnvironment environment,  Class\u003c? extends MapPropertySource\u003e existingSourcesType){\n    LOG.debug(() -\u003e \"onEvent \" + target + \": \"+ eventSourceType);\n    List\u003c? extends MapPropertySource\u003e sourceFromK8s\u003dlocateMapPropertySources(locator,environment);\n    List\u003c? extends MapPropertySource\u003e existingSources\u003dfindPropertySources(existingSourcesType,environment);\n    boolean changed\u003dchanged(sourceFromK8s,existingSources);\n    if (changed) {\n      LOG.info(\"Detected change in config maps/secrets\");\n      return true;\n    }\n else {\n      LOG.debug(\"No change detected in config maps/secrets, reload will not happen\");\n    }\n    return false;\n  }\n  /** \n * @param \u003c S \u003e property source type\n * @param sourceClass class for which property sources will be found\n * @return finds all registered property sources of the given type\n */\n  public static \u003cS extends PropertySource\u003c?\u003e\u003eList\u003cS\u003e findPropertySources(  Class\u003cS\u003e sourceClass,  ConfigurableEnvironment environment){\n    List\u003cS\u003e managedSources\u003dnew ArrayList\u003c\u003e();\n    List\u003cPropertySource\u003c?\u003e\u003e sources\u003denvironment.getPropertySources().stream().collect(Collectors.toCollection(ArrayList::new));\n    LOG.debug(() -\u003e \"environment from findPropertySources: \" + environment);\n    LOG.debug(() -\u003e \"environment sources from findPropertySources : \" + sources);\n    while (!sources.isEmpty()) {\n      PropertySource\u003c?\u003e source\u003dsources.remove(0);\n      if (source instanceof CompositePropertySource) {\n        sources.addAll(comp.getPropertySources());\n      }\n else       if (sourceClass.isInstance(source)) {\n        managedSources.add(sourceClass.cast(source));\n      }\n else       if (source instanceof MountConfigMapPropertySource) {\n        managedSources.add((S)mountConfigMapPropertySource);\n      }\n else       if (source instanceof BootstrapPropertySource\u003c?\u003e) {\n        PropertySource\u003c?\u003e propertySource\u003dbootstrapPropertySource.getDelegate();\n        LOG.debug(() -\u003e \"bootstrap delegate class : \" + propertySource.getClass());\n        if (sourceClass.isInstance(propertySource)) {\n          sources.add(propertySource);\n        }\n else         if (propertySource instanceof MountConfigMapPropertySource) {\n          managedSources.add((S)mountConfigMapPropertySource);\n        }\n      }\n    }\n    LOG.debug(() -\u003e \"findPropertySources : \" + managedSources.stream().map(PropertySource::getName).toList());\n    return managedSources;\n  }\n  /** \n * Returns a list of MapPropertySource that correspond to the current state of the system. This only handles the PropertySource objects that are returned.\n * @param propertySourceLocator Spring\u0027s property source locator\n * @param environment Spring environment\n * @return a list of MapPropertySource that correspond to the current state of thesystem\n */\n  static List\u003cMapPropertySource\u003e locateMapPropertySources(  PropertySourceLocator propertySourceLocator,  ConfigurableEnvironment environment){\n    List\u003cMapPropertySource\u003e result\u003dnew ArrayList\u003c\u003e();\n    PropertySource\u003c?\u003e propertySource\u003dpropertySourceLocator.locate(environment);\n    if (propertySource instanceof MapPropertySource) {\n      result.add(mapPropertySource);\n    }\n else     if (propertySource instanceof CompositePropertySource) {\n      source.getPropertySources().forEach(x -\u003e {\n        if (x instanceof MapPropertySource) {\n          result.add(mapPropertySource);\n        }\n      }\n);\n    }\n else {\n      LOG.debug(() -\u003e \"Found property source that cannot be handled: \" + propertySource.getClass());\n    }\n    LOG.debug(() -\u003e \"environment from locateMapPropertySources : \" + environment);\n    LOG.debug(() -\u003e \"sources from locateMapPropertySources : \" + result);\n    return result;\n  }\n  static boolean changed(  List\u003c? extends MapPropertySource\u003e left,  List\u003c? extends MapPropertySource\u003e right){\n    if (left.size() !\u003d right.size()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"left size: \" + left.size());\n        left.forEach(item -\u003e LOG.debug(item.toString()));\n        LOG.debug(\"right size: \" + right.size());\n        right.forEach(item -\u003e LOG.debug(item.toString()));\n      }\n      LOG.warn(() -\u003e \"The current number of ConfigMap PropertySources does not match \" + \"the ones loaded from Kubernetes - No reload will take place\");\n      return false;\n    }\n    for (int i\u003d0; i \u003c left.size(); i++) {\n      MapPropertySource leftPropertySource\u003dleft.get(i);\n      MapPropertySource rightPropertySource\u003dright.get(i);\n      if (changed(leftPropertySource,rightPropertySource)) {\n        LOG.debug(() -\u003e \"found change in : \" + leftPropertySource);\n        return true;\n      }\n    }\n    LOG.debug(() -\u003e \"no changes found, reload will not happen\");\n    return false;\n  }\n  /** \n * Determines if two property sources are different.\n * @param left left map property sources\n * @param right right map property sources\n * @return {@code true} if source has changed\n */\n  static boolean changed(  MapPropertySource left,  MapPropertySource right){\n    if (left \u003d\u003d right) {\n      return false;\n    }\n    if (left \u003d\u003d null || right \u003d\u003d null) {\n      return true;\n    }\n    Map\u003cString,Object\u003e leftMap\u003dleft.getSource();\n    Map\u003cString,Object\u003e rightMap\u003dright.getSource();\n    return !Objects.equals(leftMap,rightMap);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic final class ConfigReloadUtil {\n  private ConfigReloadUtil();\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(ConfigReloadUtil.class));\n  public static boolean reload(  String target,  String eventSourceType,  PropertySourceLocator locator,  ConfigurableEnvironment environment,  Class\u003c? extends MapPropertySource\u003e existingSourcesType);\n  /** \n * @param \u003c S \u003e property source type\n * @param sourceClass class for which property sources will be found\n * @return finds all registered property sources of the given type\n */\n  public static \u003cS extends PropertySource\u003c?\u003e\u003eList\u003cS\u003e findPropertySources(  Class\u003cS\u003e sourceClass,  ConfigurableEnvironment environment);\n  /** \n * Returns a list of MapPropertySource that correspond to the current state of the system. This only handles the PropertySource objects that are returned.\n * @param propertySourceLocator Spring\u0027s property source locator\n * @param environment Spring environment\n * @return a list of MapPropertySource that correspond to the current state of thesystem\n */\n  static List\u003cMapPropertySource\u003e locateMapPropertySources(  PropertySourceLocator propertySourceLocator,  ConfigurableEnvironment environment);\n  static boolean changed(  List\u003c? extends MapPropertySource\u003e left,  List\u003c? extends MapPropertySource\u003e right);\n  /** \n * Determines if two property sources are different.\n * @param left left map property sources\n * @param right right map property sources\n * @return {@code true} if source has changed\n */\n  static boolean changed(  MapPropertySource left,  MapPropertySource right);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/reload/ConfigReloadPropertiesAutoConfiguration.java",
        "name": "ConfigReloadPropertiesAutoConfiguration",
        "modifiers": "@ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @EnableConfigurationProperties(ConfigReloadProperties.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.ConfigReloadPropertiesAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @EnableConfigurationProperties(ConfigReloadProperties.class) public class ConfigReloadPropertiesAutoConfiguration {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @EnableConfigurationProperties(ConfigReloadProperties.class) public class ConfigReloadPropertiesAutoConfiguration {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/NormalizedSourceType.java",
        "name": "NormalizedSourceType",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.NormalizedSourceType",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Defines the type of the normalized source.\n * @author wind57\n */\npublic enum NormalizedSourceType {/** \n * denotes the fact that this is a secret source based on name.\n */\nNAMED_SECRET, /** \n * denotes the fact that this is a secret source based on labels.\n */\nLABELED_SECRET, /** \n * denotes the fact that this is a config map source based on name.\n */\nNAMED_CONFIG_MAP, /** \n * denotes the fact that this is a config map source based on labels.\n */\nLABELED_CONFIG_MAP}\n",
        "abstract": "/** \n * Defines the type of the normalized source.\n * @author wind57\n */\npublic enum NormalizedSourceType {/** \n * denotes the fact that this is a secret source based on name.\n */\nNAMED_SECRET, /** \n * denotes the fact that this is a secret source based on labels.\n */\nLABELED_SECRET, /** \n * denotes the fact that this is a config map source based on name.\n */\nNAMED_CONFIG_MAP, /** \n * denotes the fact that this is a config map source based on labels.\n */\nLABELED_CONFIG_MAP}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/ConditionalOnKubernetesConfigRetryEnabled.java",
        "name": "ConditionalOnKubernetesConfigRetryEnabled",
        "modifiers": "@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesConfigEnabled @ConditionalOnKubernetesConfigFailFastEnabled @ConditionalOnProperty(prefix\u003dConfigMapConfigProperties.PREFIX + \".retry\",name\u003d\"enabled\",havingValue\u003d\"true\",matchIfMissing\u003dtrue) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConditionalOnKubernetesConfigRetryEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * {@link org.springframework.context.annotation.Conditional @Conditional} that onlymatches when Spring Cloud Kubernetes, Kubernetes config, Kubernetes config fail-fast and Kubernetes config retry are enabled.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesConfigEnabled @ConditionalOnKubernetesConfigFailFastEnabled @ConditionalOnProperty(prefix\u003dConfigMapConfigProperties.PREFIX + \".retry\",name\u003d\"enabled\",havingValue\u003d\"true\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesConfigRetryEnabled {}\n",
        "abstract": "/** \n * {@link org.springframework.context.annotation.Conditional @Conditional} that onlymatches when Spring Cloud Kubernetes, Kubernetes config, Kubernetes config fail-fast and Kubernetes config retry are enabled.\n * @author Isik Erhan\n */\n@Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesConfigEnabled @ConditionalOnKubernetesConfigFailFastEnabled @ConditionalOnProperty(prefix\u003dConfigMapConfigProperties.PREFIX + \".retry\",name\u003d\"enabled\",havingValue\u003d\"true\",matchIfMissing\u003dtrue) public @interface ConditionalOnKubernetesConfigRetryEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/KubernetesConfigDataLoader.java",
        "name": "KubernetesConfigDataLoader",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.KubernetesConfigDataLoader",
        "extend": "",
        "implements": "ConfigDataLoader\u003cKubernetesConfigDataResource\u003e Ordered",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesConfigDataLoader implements ConfigDataLoader\u003cKubernetesConfigDataResource\u003e, Ordered {\n  @Override public ConfigData load(  ConfigDataLoaderContext context,  KubernetesConfigDataResource resource) throws IOException, ConfigDataResourceNotFoundException {\n    List\u003cPropertySource\u003c?\u003e\u003e propertySources\u003dnew ArrayList\u003c\u003e(2);\n    ConfigurableBootstrapContext bootstrapContext\u003dcontext.getBootstrapContext();\n    Environment env\u003dresource.getEnvironment();\n    if (bootstrapContext.isRegistered(SecretsPropertySourceLocator.class)) {\n      propertySources.add(bootstrapContext.get(SecretsPropertySourceLocator.class).locate(env));\n    }\n    if (bootstrapContext.isRegistered(ConfigMapPropertySourceLocator.class)) {\n      propertySources.add(bootstrapContext.get(ConfigMapPropertySourceLocator.class).locate(env));\n    }\n    return new ConfigData(propertySources,propertySource -\u003e {\n      String propertySourceName\u003dpropertySource.getName();\n      List\u003cOption\u003e options\u003dnew ArrayList\u003c\u003e();\n      options.add(Option.IGNORE_IMPORTS);\n      options.add(Option.IGNORE_PROFILES);\n      for (      String profile : resource.getAcceptedProfiles()) {\n        if (propertySourceName.matches(\".*[-,]\" + profile + \".*\")) {\n          options.add(Option.PROFILE_SPECIFIC);\n        }\n      }\n      return ConfigData.Options.of(options.toArray(new Option[0]));\n    }\n);\n  }\n  @Override public int getOrder(){\n    return -1;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesConfigDataLoader implements ConfigDataLoader\u003cKubernetesConfigDataResource\u003e, Ordered {\n  @Override public ConfigData load(  ConfigDataLoaderContext context,  KubernetesConfigDataResource resource) throws IOException, ConfigDataResourceNotFoundException;\n  @Override public int getOrder();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/NormalizedSource.java",
        "name": "NormalizedSource",
        "modifiers": "abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.NormalizedSource",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Base class for Normalized Sources. It should contain all the \"normalized\" properties that users can specify, either explicitly or implicitly.\n * @author wind57\n */\nabstract class NormalizedSource {\n  permits NamedSecretNormalizedSource, LabeledSecretNormalizedSource, NamedConfigMapNormalizedSource, LabeledConfigMapNormalizedSource;\n{\n  }\n  private final String namespace;\n  private final String name;\n  private final boolean failFast;\n  protected NormalizedSource(  String name,  String namespace,  boolean failFast){\n    this.name\u003dname;\n    this.namespace\u003dnamespace;\n    this.failFast\u003dfailFast;\n  }\n  public final Optional\u003cString\u003e namespace(){\n    return Optional.ofNullable(this.namespace);\n  }\n  public final Optional\u003cString\u003e name(){\n    return Optional.ofNullable(this.name);\n  }\n  public final boolean failFast(){\n    return failFast;\n  }\n  /** \n * type of this normalized source. Callers are sensitive towards the actual type specified.\n */\n  public abstract NormalizedSourceType type();\n  public abstract String target();\n  public abstract String toString();\n  public abstract boolean equals(  Object o);\n  public abstract int hashCode();\n}\n",
        "abstract": "/** \n * Base class for Normalized Sources. It should contain all the \"normalized\" properties that users can specify, either explicitly or implicitly.\n * @author wind57\n */\nabstract class NormalizedSource {\n  permits NamedSecretNormalizedSource, LabeledSecretNormalizedSource, NamedConfigMapNormalizedSource, LabeledConfigMapNormalizedSource;\n{\n  }\n  private final String namespace;\n  private final String name;\n  private final boolean failFast;\n  protected NormalizedSource(  String name,  String namespace,  boolean failFast);\n  public final Optional\u003cString\u003e namespace();\n  public final Optional\u003cString\u003e name();\n  public final boolean failFast();\n  /** \n * type of this normalized source. Callers are sensitive towards the actual type specified.\n */\n  public abstract NormalizedSourceType type();\n  public abstract String target();\n  public abstract String toString();\n  public abstract boolean equals(  Object o);\n  public abstract int hashCode();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/ConditionalOnKubernetesAndConfigEnabled.java",
        "name": "ConditionalOnKubernetesAndConfigEnabled",
        "modifiers": "@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnKubernetesConfigEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConditionalOnKubernetesAndConfigEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Haytham Mohamed\n */\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnKubernetesConfigEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public @interface ConditionalOnKubernetesAndConfigEnabled {}\n",
        "abstract": "/** \n * @author Haytham Mohamed\n */\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ConditionalOnKubernetesConfigEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) public @interface ConditionalOnKubernetesAndConfigEnabled {}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/KubernetesConfigServerBootstrapper.java",
        "name": "KubernetesConfigServerBootstrapper",
        "modifiers": "public abstract",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.KubernetesConfigServerBootstrapper",
        "extend": "",
        "implements": "BootstrapRegistryInitializer",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic abstract class KubernetesConfigServerBootstrapper implements BootstrapRegistryInitializer {\n  public static boolean hasConfigServerInstanceProvider(){\n    return !ClassUtils.isPresent(\"org.springframework.cloud.config.client.ConfigServerInstanceProvider\",null);\n  }\n  public static KubernetesDiscoveryProperties createKubernetesDiscoveryProperties(  Binder binder,  BindHandler bindHandler){\n    return binder.bind(KubernetesDiscoveryProperties.PREFIX,Bindable.of(KubernetesDiscoveryProperties.class),bindHandler).orElseGet(() -\u003e KubernetesDiscoveryProperties.DEFAULT);\n  }\n  public static KubernetesDiscoveryProperties createKubernetesDiscoveryProperties(  BootstrapContext bootstrapContext){\n    PropertyResolver propertyResolver\u003dgetPropertyResolver(bootstrapContext);\n    return propertyResolver.resolveConfigurationProperties(KubernetesDiscoveryProperties.PREFIX,KubernetesDiscoveryProperties.class,() -\u003e KubernetesDiscoveryProperties.DEFAULT);\n  }\n  public static KubernetesClientProperties createKubernetesClientProperties(  Binder binder,  BindHandler bindHandler){\n    return binder.bindOrCreate(KubernetesClientProperties.PREFIX,Bindable.of(KubernetesClientProperties.class)).withNamespace(new KubernetesNamespaceProvider(binder,bindHandler).getNamespace());\n  }\n  public static KubernetesClientProperties createKubernetesClientProperties(  BootstrapContext bootstrapContext){\n    PropertyResolver propertyResolver\u003dgetPropertyResolver(bootstrapContext);\n    return getPropertyResolver(bootstrapContext).resolveOrCreateConfigurationProperties(KubernetesClientProperties.PREFIX,KubernetesClientProperties.class).withNamespace(propertyResolver.get(KubernetesNamespaceProvider.NAMESPACE_PROPERTY,String.class,null));\n  }\n  public static Boolean getDiscoveryEnabled(  Binder binder,  BindHandler bindHandler){\n    return binder.bind(ConfigClientProperties.CONFIG_DISCOVERY_ENABLED,Bindable.of(Boolean.class),bindHandler).orElse(false);\n  }\n  public static Boolean getDiscoveryEnabled(  BootstrapContext bootstrapContext){\n    return getPropertyResolver(bootstrapContext).get(ConfigClientProperties.CONFIG_DISCOVERY_ENABLED,Boolean.class,false);\n  }\n  protected static PropertyResolver getPropertyResolver(  BootstrapContext context){\n    return context.getOrElseSupply(ConfigServerConfigDataLocationResolver.PropertyResolver.class,() -\u003e new ConfigServerConfigDataLocationResolver.PropertyResolver(context.get(Binder.class),context.getOrElse(BindHandler.class,null)));\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic abstract class KubernetesConfigServerBootstrapper implements BootstrapRegistryInitializer {\n  public static boolean hasConfigServerInstanceProvider();\n  public static KubernetesDiscoveryProperties createKubernetesDiscoveryProperties(  Binder binder,  BindHandler bindHandler);\n  public static KubernetesDiscoveryProperties createKubernetesDiscoveryProperties(  BootstrapContext bootstrapContext);\n  public static KubernetesClientProperties createKubernetesClientProperties(  Binder binder,  BindHandler bindHandler);\n  public static KubernetesClientProperties createKubernetesClientProperties(  BootstrapContext bootstrapContext);\n  public static Boolean getDiscoveryEnabled(  Binder binder,  BindHandler bindHandler);\n  public static Boolean getDiscoveryEnabled(  BootstrapContext bootstrapContext);\n  protected static PropertyResolver getPropertyResolver(  BootstrapContext context);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/main/java/org/springframework/cloud/kubernetes/commons/config/NamedConfigMapNormalizedSource.java",
        "name": "NamedConfigMapNormalizedSource",
        "modifiers": "public final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.NamedConfigMapNormalizedSource",
        "extend": "NormalizedSource",
        "implements": "",
        "raw": "/** \n * A config map source that is based on name.\n * @author wind57\n */\npublic final class NamedConfigMapNormalizedSource extends NormalizedSource {\n  private final ConfigUtils.Prefix prefix;\n  private final boolean includeProfileSpecificSources;\n  private final boolean appendProfileToName;\n  public NamedConfigMapNormalizedSource(  String name,  String namespace,  boolean failFast,  ConfigUtils.Prefix prefix,  boolean includeProfileSpecificSources){\n    this(name,namespace,failFast,prefix,includeProfileSpecificSources,false);\n  }\n  public NamedConfigMapNormalizedSource(  String name,  String namespace,  boolean failFast,  boolean includeProfileSpecificSources){\n    this(name,namespace,failFast,ConfigUtils.Prefix.DEFAULT,includeProfileSpecificSources);\n  }\n  public NamedConfigMapNormalizedSource(  String name,  String namespace,  boolean failFast,  ConfigUtils.Prefix prefix,  boolean includeProfileSpecificSources,  boolean appendProfileToName){\n    super(name,namespace,failFast);\n    this.prefix\u003dObjects.requireNonNull(prefix);\n    this.includeProfileSpecificSources\u003dincludeProfileSpecificSources;\n    this.appendProfileToName\u003dappendProfileToName;\n  }\n  public ConfigUtils.Prefix prefix(){\n    return prefix;\n  }\n  public boolean profileSpecificSources(){\n    return includeProfileSpecificSources;\n  }\n  /** \n * append or not the active profiles to the name of the generated source. At the moment this is true only for config server generated sources.\n */\n  public boolean appendProfileToName(){\n    return appendProfileToName;\n  }\n  @Override public NormalizedSourceType type(){\n    return NormalizedSourceType.NAMED_CONFIG_MAP;\n  }\n  @Override public String target(){\n    return \"configmap\";\n  }\n  @Override public String toString(){\n    return \"{ config-map name : \u0027\" + name() + \"\u0027, namespace : \u0027\"+ namespace()+ \"\u0027, prefix : \u0027\"+ prefix()+ \"\u0027 }\";\n  }\n  @Override public boolean equals(  Object o){\n    if (this \u003d\u003d o) {\n      return true;\n    }\n    if (o \u003d\u003d null || getClass() !\u003d o.getClass()) {\n      return false;\n    }\n    NamedConfigMapNormalizedSource other\u003d(NamedConfigMapNormalizedSource)o;\n    return Objects.equals(this.name(),other.name()) \u0026\u0026 Objects.equals(this.namespace(),other.namespace());\n  }\n  @Override public int hashCode(){\n    return Objects.hash(name(),namespace());\n  }\n}\n",
        "abstract": "/** \n * A config map source that is based on name.\n * @author wind57\n */\npublic final class NamedConfigMapNormalizedSource extends NormalizedSource {\n  private final ConfigUtils.Prefix prefix;\n  private final boolean includeProfileSpecificSources;\n  private final boolean appendProfileToName;\n  public NamedConfigMapNormalizedSource(  String name,  String namespace,  boolean failFast,  ConfigUtils.Prefix prefix,  boolean includeProfileSpecificSources);\n  public NamedConfigMapNormalizedSource(  String name,  String namespace,  boolean failFast,  boolean includeProfileSpecificSources);\n  public NamedConfigMapNormalizedSource(  String name,  String namespace,  boolean failFast,  ConfigUtils.Prefix prefix,  boolean includeProfileSpecificSources,  boolean appendProfileToName);\n  public ConfigUtils.Prefix prefix();\n  public boolean profileSpecificSources();\n  /** \n * append or not the active profiles to the name of the generated source. At the moment this is true only for config server generated sources.\n */\n  public boolean appendProfileToName();\n  @Override public NormalizedSourceType type();\n  @Override public String target();\n  @Override public String toString();\n  @Override public boolean equals(  Object o);\n  @Override public int hashCode();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/KubernetesCommonsAutoConfigurationTests.java",
        "name": "KubernetesCommonsAutoConfigurationTests",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dKubernetesCommonsAutoConfigurationTests.App.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.password\u003dmypassword\",\"spring.cloud.kubernetes.client.proxy-password\u003dmyproxypassword\",\"spring.cloud.config.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.KubernetesCommonsAutoConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dKubernetesCommonsAutoConfigurationTests.App.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.password\u003dmypassword\",\"spring.cloud.kubernetes.client.proxy-password\u003dmyproxypassword\",\"spring.cloud.config.enabled\u003dfalse\"}) class KubernetesCommonsAutoConfigurationTests {\n  @Autowired ConfigurableApplicationContext context;\n  @Test void beansAreCreated(){\n    assertThat(context.getBeansOfType(KubernetesClientProperties.class)).hasSize(1);\n    KubernetesClientProperties properties\u003dcontext.getBeansOfType(KubernetesClientProperties.class).values().stream().findFirst().get();\n    assertThat(properties.password()).isEqualTo(\"mypassword\");\n    assertThat(properties.proxyPassword()).isEqualTo(\"myproxypassword\");\n  }\n@SpringBootApplication static class App {\n  }\n}\n",
        "abstract": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dKubernetesCommonsAutoConfigurationTests.App.class,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.password\u003dmypassword\",\"spring.cloud.kubernetes.client.proxy-password\u003dmyproxypassword\",\"spring.cloud.config.enabled\u003dfalse\"}) class KubernetesCommonsAutoConfigurationTests {\n  @Autowired ConfigurableApplicationContext context;\n  @Test void beansAreCreated();\n@SpringBootApplication static class App {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/LazilyInstantiateTest.java",
        "name": "LazilyInstantiateTest",
        "modifiers": "@ExtendWith(MockitoExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.LazilyInstantiateTest",
        "extend": "",
        "implements": "",
        "raw": "@ExtendWith(MockitoExtension.class) class LazilyInstantiateTest {\n  private static final String TAG\u003d\"excluded-from-before\";\n  private static final String SINGLETON\u003d\"singleton\";\n  @Mock private Supplier\u003cString\u003e mockSupplier;\n  @BeforeEach public void setUp(  TestInfo testInfo) throws Exception {\n    if (!testInfo.getTags().contains(TAG)) {\n      when(this.mockSupplier.get()).thenReturn(SINGLETON).thenThrow(new RuntimeException(\"Supplier was called more than once!\"));\n    }\n  }\n  @Tag(TAG) @Test void supplierNotCalledInLazyInstantiateFactoryMethod(){\n    LazilyInstantiate.using(this.mockSupplier);\n    verifyNoInteractions(this.mockSupplier);\n  }\n  @Test void factoryReturnsSingletonFromSupplier(){\n    LazilyInstantiate\u003cString\u003e lazyStringFactory\u003dLazilyInstantiate.using(this.mockSupplier);\n    String singletonString\u003dlazyStringFactory.get();\n    assertThat(singletonString).isEqualTo(SINGLETON);\n  }\n  @Test void factoryOnlyCallsSupplierOnce(){\n    LazilyInstantiate\u003cString\u003e lazyStringFactory\u003dLazilyInstantiate.using(this.mockSupplier);\n    lazyStringFactory.get();\n    lazyStringFactory.get();\n  }\n}\n",
        "abstract": "@ExtendWith(MockitoExtension.class) class LazilyInstantiateTest {\n  private static final String TAG\u003d\"excluded-from-before\";\n  private static final String SINGLETON\u003d\"singleton\";\n  @Mock private Supplier\u003cString\u003e mockSupplier;\n  @BeforeEach public void setUp(  TestInfo testInfo) throws Exception;\n  @Tag(TAG) @Test void supplierNotCalledInLazyInstantiateFactoryMethod();\n  @Test void factoryReturnsSingletonFromSupplier();\n  @Test void factoryOnlyCallsSupplierOnce();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/SanitizeTests.java",
        "name": "SanitizeTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.SanitizeTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass SanitizeTests {\n  private static final boolean SHOW_UNSANITIZED\u003dtrue;\n  private static final List\u003cSanitizingFunction\u003e SANITIZING_FUNCTIONS\u003dList.of(new KubernetesCommonsSanitizeAutoConfiguration().secretsPropertySourceSanitizingFunction());\n  @Test void bootstrapPropertySourceNotSecrets(){\n    BootstrapPropertySource\u003c?\u003e bootstrapPropertySource\u003dnew BootstrapPropertySource\u003c\u003e(new EnumerablePropertySource\u003c\u003e(\"enumerable\"){\n      @Override public String[] getPropertyNames(){\n        return new String[0];\n      }\n      @Override public Object getProperty(      String name){\n        return null;\n      }\n    }\n);\n    Sanitizer sanitizer\u003dnew Sanitizer(SANITIZING_FUNCTIONS);\n    SanitizableData sanitizableData\u003dnew SanitizableData(bootstrapPropertySource,\"secret\",\"xyz\");\n    Assertions.assertEquals(sanitizer.sanitize(sanitizableData,SHOW_UNSANITIZED),\"xyz\");\n  }\n  @Test void bootstrapPropertySourceSecrets(){\n    BootstrapPropertySource\u003c?\u003e bootstrapPropertySource\u003dnew BootstrapPropertySource\u003c\u003e(new SecretsPropertySource(new SourceData(\"secret-source\",Map.of())));\n    Sanitizer sanitizer\u003dnew Sanitizer(SANITIZING_FUNCTIONS);\n    SanitizableData sanitizableData\u003dnew SanitizableData(bootstrapPropertySource,\"secret\",\"xyz\");\n    Assertions.assertEquals(sanitizer.sanitize(sanitizableData,SHOW_UNSANITIZED),SANITIZED_VALUE);\n  }\n  @Test void notSecretsPropertySource(){\n    BootstrapPropertySource\u003c?\u003e bootstrapPropertySource\u003dnew BootstrapPropertySource\u003c\u003e(new MountConfigMapPropertySource(\"mount-source\",Map.of()));\n    Sanitizer sanitizer\u003dnew Sanitizer(SANITIZING_FUNCTIONS);\n    SanitizableData sanitizableData\u003dnew SanitizableData(bootstrapPropertySource,\"secret\",\"xyz\");\n    Assertions.assertEquals(sanitizer.sanitize(sanitizableData,SHOW_UNSANITIZED),\"xyz\");\n  }\n  @Test void secretsPropertySource(){\n    BootstrapPropertySource\u003c?\u003e bootstrapPropertySource\u003dnew BootstrapPropertySource\u003c\u003e(new SecretsPropertySource(new SourceData(\"secret-source\",Map.of())));\n    Sanitizer sanitizer\u003dnew Sanitizer(SANITIZING_FUNCTIONS);\n    SanitizableData sanitizableData\u003dnew SanitizableData(bootstrapPropertySource,\"secret\",\"xyz\");\n    Assertions.assertEquals(sanitizer.sanitize(sanitizableData,SHOW_UNSANITIZED),SANITIZED_VALUE);\n  }\n  @Test void compositeOneSecretOneMount(){\n    CompositePropertySource compositePropertySource\u003dnew CompositePropertySource(\"composite\");\n    compositePropertySource.addFirstPropertySource(new SecretsPropertySource(new SourceData(\"secret-source\",Map.of(\"secret\",\"xyz\"))));\n    compositePropertySource.addFirstPropertySource(new MountConfigMapPropertySource(\"mount-source\",Map.of(\"mount\",\"abc\")));\n    Sanitizer sanitizer\u003dnew Sanitizer(SANITIZING_FUNCTIONS);\n    SanitizableData sanitizableDataSecret\u003dnew SanitizableData(compositePropertySource,\"secret\",\"xyz\");\n    SanitizableData sanitizableDataMount\u003dnew SanitizableData(compositePropertySource,\"mount\",\"abc\");\n    Assertions.assertEquals(sanitizer.sanitize(sanitizableDataSecret,SHOW_UNSANITIZED),SANITIZED_VALUE);\n    Assertions.assertEquals(sanitizer.sanitize(sanitizableDataMount,SHOW_UNSANITIZED),\"abc\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass SanitizeTests {\n  private static final boolean SHOW_UNSANITIZED\u003dtrue;\n  private static final List\u003cSanitizingFunction\u003e SANITIZING_FUNCTIONS\u003dList.of(new KubernetesCommonsSanitizeAutoConfiguration().secretsPropertySourceSanitizingFunction());\n  @Test void bootstrapPropertySourceNotSecrets();\n  @Test void bootstrapPropertySourceSecrets();\n  @Test void notSecretsPropertySource();\n  @Test void secretsPropertySource();\n  @Test void compositeOneSecretOneMount();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/loadbalancer/KubernetesServiceInstanceMapperTests.java",
        "name": "KubernetesServiceInstanceMapperTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.loadbalancer.KubernetesServiceInstanceMapperTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesServiceInstanceMapperTests {\n  @Test void testCreateHostWithNamespace(){\n    String namespace\u003d\"customNamespace\";\n    String host\u003dKubernetesServiceInstanceMapper.createHost(\"serviceName\",namespace,\"clusterDomain\");\n    assertThat(host).isEqualTo(\"serviceName.customNamespace.svc.clusterDomain\");\n  }\n  @Test void testCreateHostWithEmptyNamespace(){\n    String host\u003dKubernetesServiceInstanceMapper.createHost(\"serviceName\",\"\",\"clusterDomain\");\n    assertThat(host).isEqualTo(\"serviceName.default.svc.clusterDomain\");\n  }\n  @Test void testCreateHostWithNullNamespace(){\n    String host\u003dKubernetesServiceInstanceMapper.createHost(\"serviceName\",null,\"clusterDomain\");\n    assertThat(host).isEqualTo(\"serviceName.default.svc.clusterDomain\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class KubernetesServiceInstanceMapperTests {\n  @Test void testCreateHostWithNamespace();\n  @Test void testCreateHostWithEmptyNamespace();\n  @Test void testCreateHostWithNullNamespace();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/loadbalancer/KubernetesLoadBalancerPropertiesTests.java",
        "name": "KubernetesLoadBalancerPropertiesTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.loadbalancer.KubernetesLoadBalancerPropertiesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesLoadBalancerPropertiesTests {\n  @Test void testBindingWhenNoPropertiesProvided(){\n    new ApplicationContextRunner().withUserConfiguration(KubernetesLoadBalancerPropertiesTests.Config.class).run(context -\u003e {\n      KubernetesLoadBalancerProperties props\u003dcontext.getBean(KubernetesLoadBalancerProperties.class);\n      assertThat(props).isNotNull();\n      assertThat(props.getEnabled()).isTrue();\n      assertThat(props.getMode()).isEqualTo(KubernetesLoadBalancerMode.POD);\n      assertThat(props.getClusterDomain()).isEqualTo(\"cluster.local\");\n      assertThat(props.getPortName()).isEqualTo(\"http\");\n    }\n);\n  }\n  @Test void testBindingWhenSomePropertiesProvided(){\n    new ApplicationContextRunner().withUserConfiguration(KubernetesLoadBalancerPropertiesTests.Config.class).withPropertyValues(\"spring.cloud.kubernetes.loadbalancer.enabled\u003dfalse\",\"spring.cloud.kubernetes.loadbalancer.mode\u003dSERVICE\",\"spring.cloud.kubernetes.loadbalancer.clusterDomain\u003dclusterDomain\",\"spring.cloud.kubernetes.loadbalancer.portName\u003dportName\").run(context -\u003e {\n      KubernetesLoadBalancerProperties props\u003dcontext.getBean(KubernetesLoadBalancerProperties.class);\n      assertThat(props).isNotNull();\n      assertThat(props.getEnabled()).isFalse();\n      assertThat(props.getMode()).isEqualTo(KubernetesLoadBalancerMode.SERVICE);\n      assertThat(props.getClusterDomain()).isEqualTo(\"clusterDomain\");\n      assertThat(props.getPortName()).isEqualTo(\"portName\");\n    }\n);\n  }\n@Configuration @EnableConfigurationProperties(KubernetesLoadBalancerProperties.class) static class Config {\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesLoadBalancerPropertiesTests {\n  @Test void testBindingWhenNoPropertiesProvided();\n  @Test void testBindingWhenSomePropertiesProvided();\n@Configuration @EnableConfigurationProperties(KubernetesLoadBalancerProperties.class) static class Config {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/KubernetesCommonsSanitizeAutoConfigurationTests.java",
        "name": "KubernetesCommonsSanitizeAutoConfigurationTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.KubernetesCommonsSanitizeAutoConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesCommonsSanitizeAutoConfigurationTests {\n  @Test void sanitizeSecretsNotEnabled(){\n    contextRunner(false,false).run(context -\u003e assertThat(context.getBeansOfType(SanitizingFunction.class)).isEmpty());\n  }\n  @Test void sanitizeSecretsEnabled(){\n    contextRunner(true,false).run(context -\u003e assertThat(context.getBeansOfType(SanitizingFunction.class)).hasSize(1));\n  }\n  @Test void sanitizeSecretsEnabledSanitizedClassNotPresent(){\n    contextRunner(true,true).run(context -\u003e assertThat(context.getBeansOfType(SanitizingFunction.class)).isEmpty());\n  }\n  private ApplicationContextRunner contextRunner(  boolean enableSanitizeSecrets,  boolean filterSanitizedDataClass){\n    ApplicationContextRunner contextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesCommonsSanitizeAutoConfiguration.class));\n    if (enableSanitizeSecrets) {\n      contextRunner\u003dcontextRunner.withPropertyValues(ConditionalOnSanitizeSecrets.VALUE + \"\u003dtrue\");\n    }\n    if (filterSanitizedDataClass) {\n      contextRunner\u003dcontextRunner.withClassLoader(new FilteredClassLoader(SanitizableData.class));\n    }\n    contextRunner\u003dcontextRunner.withPropertyValues(\"spring.main.cloud-platform\u003dKUBERNETES\");\n    return contextRunner;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesCommonsSanitizeAutoConfigurationTests {\n  @Test void sanitizeSecretsNotEnabled();\n  @Test void sanitizeSecretsEnabled();\n  @Test void sanitizeSecretsEnabledSanitizedClassNotPresent();\n  private ApplicationContextRunner contextRunner(  boolean enableSanitizeSecrets,  boolean filterSanitizedDataClass);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/KubernetesClientPropertiesTests.java",
        "name": "KubernetesClientPropertiesTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.KubernetesClientPropertiesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesClientPropertiesTests {\n  @Test void testDefaults(){\n    new ApplicationContextRunner().withUserConfiguration(Config.class).run(context -\u003e {\n      KubernetesClientProperties properties\u003dcontext.getBean(KubernetesClientProperties.class);\n      assertThat(properties).isNotNull();\n      assertThat(properties.trustCerts()).isNull();\n      assertThat(properties.masterUrl()).isNull();\n      assertThat(properties.apiVersion()).isNull();\n      assertThat(properties.namespace()).isNull();\n      assertThat(properties.caCertFile()).isNull();\n      assertThat(properties.caCertData()).isNull();\n      assertThat(properties.clientCertFile()).isNull();\n      assertThat(properties.clientCertData()).isNull();\n      assertThat(properties.clientKeyFile()).isNull();\n      assertThat(properties.clientKeyData()).isNull();\n      assertThat(properties.clientKeyAlgo()).isNull();\n      assertThat(properties.clientKeyPassphrase()).isNull();\n      assertThat(properties.username()).isNull();\n      assertThat(properties.password()).isNull();\n      assertThat(properties.watchReconnectInterval()).isNull();\n      assertThat(properties.watchReconnectLimit()).isNull();\n      assertThat(properties.connectionTimeout()).isNull();\n      assertThat(properties.requestTimeout()).isNull();\n      assertThat(properties.rollingTimeout()).isNull();\n      assertThat(properties.loggingInterval()).isNull();\n      assertThat(properties.httpProxy()).isNull();\n      assertThat(properties.httpsProxy()).isNull();\n      assertThat(properties.proxyUsername()).isNull();\n      assertThat(properties.proxyPassword()).isNull();\n      assertThat(properties.oauthToken()).isNull();\n      assertThat(properties.noProxy()).isNull();\n      assertThat(properties.serviceAccountNamespacePath()).isEqualTo(\"/var/run/secrets/kubernetes.io/serviceaccount/namespace\");\n      assertThat(properties.userAgent()).isEqualTo(\"Spring-Cloud-Kubernetes-Application\");\n    }\n);\n  }\n  @Test void testNonDefaults(){\n    new ApplicationContextRunner().withUserConfiguration(Config.class).withPropertyValues(\"spring.cloud.kubernetes.client.trust-certs\u003dtrue\",\"spring.cloud.kubernetes.client.master-url\u003dmaster-url\",\"spring.cloud.kubernetes.client.api-version\u003d1\",\"spring.cloud.kubernetes.client.namespace\u003dnamespace\",\"spring.cloud.kubernetes.client.ca-cert-file\u003dca-cert-file\",\"spring.cloud.kubernetes.client.ca-cert-data\u003dca-cert-data\",\"spring.cloud.kubernetes.client.client-cert-file\u003dclient-cert-file\",\"spring.cloud.kubernetes.client.client-cert-data\u003dclient-cert-data\",\"spring.cloud.kubernetes.client.client-key-file\u003dclient-key-file\",\"spring.cloud.kubernetes.client.client-key-data\u003dclient-key-data\",\"spring.cloud.kubernetes.client.client-key-algo\u003dclient-key-algo\",\"spring.cloud.kubernetes.client.client-key-passphrase\u003dclient-key-passphrase\",\"spring.cloud.kubernetes.client.username\u003dusername\",\"spring.cloud.kubernetes.client.password\u003dpassword\",\"spring.cloud.kubernetes.client.watch-reconnect-interval\u003d200ms\",\"spring.cloud.kubernetes.client.watch-reconnect-limit\u003d300ms\",\"spring.cloud.kubernetes.client.connection-timeout\u003d400ms\",\"spring.cloud.kubernetes.client.request-timeout\u003d500ms\",\"spring.cloud.kubernetes.client.rolling-timeout\u003d600ms\",\"spring.cloud.kubernetes.client.logging-interval\u003d700ms\",\"spring.cloud.kubernetes.client.http-proxy\u003dhttp-proxy\",\"spring.cloud.kubernetes.client.https-proxy\u003dhttps-proxy\",\"spring.cloud.kubernetes.client.proxy-username\u003dproxy-username\",\"spring.cloud.kubernetes.client.proxy-password\u003dproxy-password\",\"spring.cloud.kubernetes.client.oauth-token\u003doauth-token\",\"spring.cloud.kubernetes.client.no-proxy[0]\u003da\",\"spring.cloud.kubernetes.client.no-proxy[1]\u003db\",\"spring.cloud.kubernetes.client.service-account-namespace-path\u003dpath\",\"spring.cloud.kubernetes.client.user-agent\u003duser-agent\").run(context -\u003e {\n      KubernetesClientProperties properties\u003dcontext.getBean(KubernetesClientProperties.class);\n      assertThat(properties).isNotNull();\n      assertThat(properties.trustCerts()).isTrue();\n      assertThat(properties.masterUrl()).isEqualTo(\"master-url\");\n      assertThat(properties.apiVersion()).isEqualTo(\"1\");\n      assertThat(properties.namespace()).isEqualTo(\"namespace\");\n      assertThat(properties.caCertFile()).isEqualTo(\"ca-cert-file\");\n      assertThat(properties.caCertData()).isEqualTo(\"ca-cert-data\");\n      assertThat(properties.clientCertFile()).isEqualTo(\"client-cert-file\");\n      assertThat(properties.clientCertData()).isEqualTo(\"client-cert-data\");\n      assertThat(properties.clientKeyFile()).isEqualTo(\"client-key-file\");\n      assertThat(properties.clientKeyData()).isEqualTo(\"client-key-data\");\n      assertThat(properties.clientKeyAlgo()).isEqualTo(\"client-key-algo\");\n      assertThat(properties.clientKeyPassphrase()).isEqualTo(\"client-key-passphrase\");\n      assertThat(properties.username()).isEqualTo(\"username\");\n      assertThat(properties.password()).isEqualTo(\"password\");\n      assertThat(properties.watchReconnectInterval()).isEqualTo(Duration.ofMillis(200));\n      assertThat(properties.watchReconnectLimit()).isEqualTo(Duration.ofMillis(300));\n      assertThat(properties.connectionTimeout()).isEqualTo(Duration.ofMillis(400));\n      assertThat(properties.requestTimeout()).isEqualTo(Duration.ofMillis(500));\n      assertThat(properties.rollingTimeout()).isEqualTo(Duration.ofMillis(600));\n      assertThat(properties.loggingInterval()).isEqualTo(Duration.ofMillis(700));\n      assertThat(properties.httpProxy()).isEqualTo(\"http-proxy\");\n      assertThat(properties.httpsProxy()).isEqualTo(\"https-proxy\");\n      assertThat(properties.proxyUsername()).isEqualTo(\"proxy-username\");\n      assertThat(properties.proxyPassword()).isEqualTo(\"proxy-password\");\n      assertThat(properties.oauthToken()).isEqualTo(\"oauth-token\");\n      assertThat(properties.noProxy().length).isEqualTo(2);\n      assertThat(properties.noProxy()[0]).isEqualTo(\"a\");\n      assertThat(properties.noProxy()[1]).isEqualTo(\"b\");\n      assertThat(properties.serviceAccountNamespacePath()).isEqualTo(\"path\");\n      assertThat(properties.userAgent()).isEqualTo(\"user-agent\");\n    }\n);\n  }\n  @Test void testCopyWithNamespaceConstructor(){\n    new ApplicationContextRunner().withUserConfiguration(Config.class).withPropertyValues(\"spring.cloud.kubernetes.client.trust-certs\u003dtrue\",\"spring.cloud.kubernetes.client.master-url\u003dmaster-url\",\"spring.cloud.kubernetes.client.api-version\u003d1\",\"spring.cloud.kubernetes.client.namespace\u003dnamespace\",\"spring.cloud.kubernetes.client.ca-cert-file\u003dca-cert-file\",\"spring.cloud.kubernetes.client.ca-cert-data\u003dca-cert-data\",\"spring.cloud.kubernetes.client.client-cert-file\u003dclient-cert-file\",\"spring.cloud.kubernetes.client.client-cert-data\u003dclient-cert-data\",\"spring.cloud.kubernetes.client.client-key-file\u003dclient-key-file\",\"spring.cloud.kubernetes.client.client-key-data\u003dclient-key-data\",\"spring.cloud.kubernetes.client.client-key-algo\u003dclient-key-algo\",\"spring.cloud.kubernetes.client.client-key-passphrase\u003dclient-key-passphrase\",\"spring.cloud.kubernetes.client.username\u003dusername\",\"spring.cloud.kubernetes.client.password\u003dpassword\",\"spring.cloud.kubernetes.client.watch-reconnect-interval\u003d200ms\",\"spring.cloud.kubernetes.client.watch-reconnect-limit\u003d300ms\",\"spring.cloud.kubernetes.client.connection-timeout\u003d400ms\",\"spring.cloud.kubernetes.client.request-timeout\u003d500ms\",\"spring.cloud.kubernetes.client.rolling-timeout\u003d600ms\",\"spring.cloud.kubernetes.client.logging-interval\u003d700ms\",\"spring.cloud.kubernetes.client.http-proxy\u003dhttp-proxy\",\"spring.cloud.kubernetes.client.https-proxy\u003dhttps-proxy\",\"spring.cloud.kubernetes.client.proxy-username\u003dproxy-username\",\"spring.cloud.kubernetes.client.proxy-password\u003dproxy-password\",\"spring.cloud.kubernetes.client.oauth-token\u003doauth-token\",\"spring.cloud.kubernetes.client.no-proxy[0]\u003da\",\"spring.cloud.kubernetes.client.no-proxy[1]\u003db\",\"spring.cloud.kubernetes.client.service-account-namespace-path\u003dpath\",\"spring.cloud.kubernetes.client.user-agent\u003duser-agent\").run(context -\u003e {\n      KubernetesClientProperties properties\u003dcontext.getBean(KubernetesClientProperties.class).withNamespace(\"non-default\");\n      assertThat(properties).isNotNull();\n      assertThat(properties.trustCerts()).isTrue();\n      assertThat(properties.masterUrl()).isEqualTo(\"master-url\");\n      assertThat(properties.apiVersion()).isEqualTo(\"1\");\n      assertThat(properties.namespace()).isEqualTo(\"non-default\");\n      assertThat(properties.caCertFile()).isEqualTo(\"ca-cert-file\");\n      assertThat(properties.caCertData()).isEqualTo(\"ca-cert-data\");\n      assertThat(properties.clientCertFile()).isEqualTo(\"client-cert-file\");\n      assertThat(properties.clientCertData()).isEqualTo(\"client-cert-data\");\n      assertThat(properties.clientKeyFile()).isEqualTo(\"client-key-file\");\n      assertThat(properties.clientKeyData()).isEqualTo(\"client-key-data\");\n      assertThat(properties.clientKeyAlgo()).isEqualTo(\"client-key-algo\");\n      assertThat(properties.clientKeyPassphrase()).isEqualTo(\"client-key-passphrase\");\n      assertThat(properties.username()).isEqualTo(\"username\");\n      assertThat(properties.password()).isEqualTo(\"password\");\n      assertThat(properties.watchReconnectInterval()).isEqualTo(Duration.ofMillis(200));\n      assertThat(properties.watchReconnectLimit()).isEqualTo(Duration.ofMillis(300));\n      assertThat(properties.connectionTimeout()).isEqualTo(Duration.ofMillis(400));\n      assertThat(properties.requestTimeout()).isEqualTo(Duration.ofMillis(500));\n      assertThat(properties.rollingTimeout()).isEqualTo(Duration.ofMillis(600));\n      assertThat(properties.loggingInterval()).isEqualTo(Duration.ofMillis(700));\n      assertThat(properties.httpProxy()).isEqualTo(\"http-proxy\");\n      assertThat(properties.httpsProxy()).isEqualTo(\"https-proxy\");\n      assertThat(properties.proxyUsername()).isEqualTo(\"proxy-username\");\n      assertThat(properties.proxyPassword()).isEqualTo(\"proxy-password\");\n      assertThat(properties.oauthToken()).isEqualTo(\"oauth-token\");\n      assertThat(properties.noProxy().length).isEqualTo(2);\n      assertThat(properties.noProxy()[0]).isEqualTo(\"a\");\n      assertThat(properties.noProxy()[1]).isEqualTo(\"b\");\n      assertThat(properties.serviceAccountNamespacePath()).isEqualTo(\"path\");\n      assertThat(properties.userAgent()).isEqualTo(\"user-agent\");\n    }\n);\n  }\n@EnableConfigurationProperties(KubernetesClientProperties.class) @Configuration static class Config {\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesClientPropertiesTests {\n  @Test void testDefaults();\n  @Test void testNonDefaults();\n  @Test void testCopyWithNamespaceConstructor();\n@EnableConfigurationProperties(KubernetesClientProperties.class) @Configuration static class Config {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/discovery/ServicePortSecureResolverTest.java",
        "name": "ServicePortSecureResolverTest",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.ServicePortSecureResolverTest",
        "extend": "",
        "implements": "",
        "raw": "@ExtendWith(OutputCaptureExtension.class) class ServicePortSecureResolverTest {\n  private static final Map\u003cString,String\u003e SECURED_TRUE_MAP\u003dCollections.singletonMap(\"secured\",\"true\");\n  private static final Map\u003cString,String\u003e SECURED_1_MAP\u003dCollections.singletonMap(\"secured\",\"1\");\n  private static final Map\u003cString,String\u003e SECURED_YES_MAP\u003dCollections.singletonMap(\"secured\",\"yes\");\n  private static final Map\u003cString,String\u003e SECURED_ON_MAP\u003dCollections.singletonMap(\"secured\",\"on\");\n  private static final ServicePortSecureResolver.Input SECURED_TRUE\u003dnew ServicePortSecureResolver.Input(new ServicePortNameAndNumber(8080,\"http\"),\"dummy\",SECURED_TRUE_MAP,Collections.emptyMap());\n  private static final ServicePortSecureResolver.Input SECURED_1\u003dnew ServicePortSecureResolver.Input(new ServicePortNameAndNumber(1234,\"http\"),\"dummy\",SECURED_1_MAP,Collections.emptyMap());\n  private static final ServicePortSecureResolver.Input SECURED_YES\u003dnew ServicePortSecureResolver.Input(new ServicePortNameAndNumber(4321,\"http\"),\"dummy\",SECURED_YES_MAP,Collections.emptyMap());\n  private static final ServicePortSecureResolver.Input SECURED_ON\u003dnew ServicePortSecureResolver.Input(new ServicePortNameAndNumber(4321,\"http\"),\"dummy\",SECURED_ON_MAP,Collections.emptyMap());\n  @Test void testPortNumbersOnly(){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(443,8443,12345),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    ServicePortSecureResolver secureResolver\u003dnew ServicePortSecureResolver(properties);\n    assertThat(secureResolver.resolve(new Input(new ServicePortNameAndNumber(-1,\"http\"),\"dummy\",Map.of(),Map.of()))).isFalse();\n    assertThat(secureResolver.resolve(new Input(new ServicePortNameAndNumber(8080,\"http\"),\"dummy\",Map.of(),Map.of()))).isFalse();\n    assertThat(secureResolver.resolve(new Input(new ServicePortNameAndNumber(1234,\"http\"),\"dummy\",Map.of(),Map.of()))).isFalse();\n    assertThat(secureResolver.resolve(new Input(new ServicePortNameAndNumber(443,\"http\"),\"dummy\",Map.of(),Map.of()))).isTrue();\n    assertThat(secureResolver.resolve(new Input(new ServicePortNameAndNumber(8443,\"http\"),\"dummy\",Map.of(),Map.of()))).isTrue();\n    assertThat(secureResolver.resolve(new Input(new ServicePortNameAndNumber(12345,\"http\"),\"dummy\",Map.of(),Map.of()))).isTrue();\n  }\n  @Test void testLabelsAndAnnotations(){\n    ServicePortSecureResolver secureResolver\u003dnew ServicePortSecureResolver(KubernetesDiscoveryProperties.DEFAULT);\n    assertThat(secureResolver.resolve(SECURED_TRUE)).isTrue();\n    assertThat(secureResolver.resolve(SECURED_1)).isTrue();\n    assertThat(secureResolver.resolve(SECURED_YES)).isTrue();\n    assertThat(secureResolver.resolve(SECURED_ON)).isTrue();\n  }\n  @Test void testNoneConditionsMet(  CapturedOutput output){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(443,8443,12345),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    ServicePortSecureResolver secureResolver\u003dnew ServicePortSecureResolver(properties);\n    ServicePortNameAndNumber portData\u003dnew ServicePortNameAndNumber(8080,\"http\");\n    Input input\u003dnew Input(portData,\"dummy\",Map.of(),Map.of());\n    boolean result\u003dsecureResolver.resolve(input);\n    assertThat(result).isFalse();\n    assertThat(output.getOut()).isEmpty();\n  }\n  @Test void securedLabelPresentWrongValue(  CapturedOutput output){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    ServicePortSecureResolver secureResolver\u003dnew ServicePortSecureResolver(properties);\n    ServicePortNameAndNumber portData\u003dnew ServicePortNameAndNumber(8080,\"http\");\n    Input input\u003dnew Input(portData,\"dummy\",Map.of(\"secured\",\"right\"),Map.of());\n    boolean result\u003dsecureResolver.resolve(input);\n    assertThat(result).isFalse();\n    assertThat(output.getOut()).isEmpty();\n  }\n  @Test void securedLabelPresentCorrectValue(  CapturedOutput output){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    ServicePortSecureResolver secureResolver\u003dnew ServicePortSecureResolver(properties);\n    ServicePortNameAndNumber portData\u003dnew ServicePortNameAndNumber(8080,\"http\");\n    Input input\u003dnew Input(portData,\"dummy\",Map.of(\"secured\",\"true\"),Map.of());\n    boolean result\u003dsecureResolver.resolve(input);\n    assertThat(result).isTrue();\n    assertThat(output.getOut()).contains(\"Considering service with name: dummy and port 8080 to be secure since the service contains a true value for the \u0027secured\u0027 label\");\n  }\n  @Test void securedAnnotationPresentWrongValue(  CapturedOutput output){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    ServicePortSecureResolver secureResolver\u003dnew ServicePortSecureResolver(properties);\n    ServicePortNameAndNumber portData\u003dnew ServicePortNameAndNumber(8080,\"http\");\n    Input input\u003dnew Input(portData,\"dummy\",Map.of(),Map.of(\"secured\",\"right\"));\n    boolean result\u003dsecureResolver.resolve(input);\n    assertThat(result).isFalse();\n    assertThat(output.getOut()).isEmpty();\n  }\n  @Test void securedAnnotationPresentCorrectValue(  CapturedOutput output){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(443,8443),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    ServicePortSecureResolver secureResolver\u003dnew ServicePortSecureResolver(properties);\n    ServicePortNameAndNumber portData\u003dnew ServicePortNameAndNumber(8080,\"http\");\n    Input input\u003dnew Input(portData,\"dummy\",Map.of(),Map.of(\"secured\",\"true\"));\n    boolean result\u003dsecureResolver.resolve(input);\n    assertThat(result).isTrue();\n    assertThat(output.getOut()).contains(\"Considering service with name: dummy and port 8080 to be secure since the service contains a true value for the \u0027secured\u0027 annotation\");\n  }\n  @Test void knownPortsMatches(  CapturedOutput output){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(8080),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    ServicePortSecureResolver secureResolver\u003dnew ServicePortSecureResolver(properties);\n    ServicePortNameAndNumber portData\u003dnew ServicePortNameAndNumber(8080,\"http\");\n    Input input\u003dnew Input(portData,\"dummy\",Map.of(),Map.of());\n    boolean result\u003dsecureResolver.resolve(input);\n    assertThat(result).isTrue();\n    assertThat(output.getOut()).contains(\"Considering service with name: dummy and port 8080 to be secure since port is known to be a https port\");\n  }\n  @Test void noConditionsMatchButPortIsHttps(  CapturedOutput output){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(8081),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,true);\n    ServicePortSecureResolver secureResolver\u003dnew ServicePortSecureResolver(properties);\n    ServicePortNameAndNumber portData\u003dnew ServicePortNameAndNumber(8080,\"https\");\n    Input input\u003dnew Input(portData,\"dummy\",Map.of(),Map.of());\n    boolean result\u003dsecureResolver.resolve(input);\n    assertThat(result).isTrue();\n    assertThat(output.getOut()).contains(\"Considering service with name: dummy and port 8080 to be secure since port-name is \u0027https\u0027\");\n  }\n}\n",
        "abstract": "@ExtendWith(OutputCaptureExtension.class) class ServicePortSecureResolverTest {\n  private static final Map\u003cString,String\u003e SECURED_TRUE_MAP\u003dCollections.singletonMap(\"secured\",\"true\");\n  private static final Map\u003cString,String\u003e SECURED_1_MAP\u003dCollections.singletonMap(\"secured\",\"1\");\n  private static final Map\u003cString,String\u003e SECURED_YES_MAP\u003dCollections.singletonMap(\"secured\",\"yes\");\n  private static final Map\u003cString,String\u003e SECURED_ON_MAP\u003dCollections.singletonMap(\"secured\",\"on\");\n  private static final ServicePortSecureResolver.Input SECURED_TRUE\u003dnew ServicePortSecureResolver.Input(new ServicePortNameAndNumber(8080,\"http\"),\"dummy\",SECURED_TRUE_MAP,Collections.emptyMap());\n  private static final ServicePortSecureResolver.Input SECURED_1\u003dnew ServicePortSecureResolver.Input(new ServicePortNameAndNumber(1234,\"http\"),\"dummy\",SECURED_1_MAP,Collections.emptyMap());\n  private static final ServicePortSecureResolver.Input SECURED_YES\u003dnew ServicePortSecureResolver.Input(new ServicePortNameAndNumber(4321,\"http\"),\"dummy\",SECURED_YES_MAP,Collections.emptyMap());\n  private static final ServicePortSecureResolver.Input SECURED_ON\u003dnew ServicePortSecureResolver.Input(new ServicePortNameAndNumber(4321,\"http\"),\"dummy\",SECURED_ON_MAP,Collections.emptyMap());\n  @Test void testPortNumbersOnly();\n  @Test void testLabelsAndAnnotations();\n  @Test void testNoneConditionsMet(  CapturedOutput output);\n  @Test void securedLabelPresentWrongValue(  CapturedOutput output);\n  @Test void securedLabelPresentCorrectValue(  CapturedOutput output);\n  @Test void securedAnnotationPresentWrongValue(  CapturedOutput output);\n  @Test void securedAnnotationPresentCorrectValue(  CapturedOutput output);\n  @Test void knownPortsMatches(  CapturedOutput output);\n  @Test void noConditionsMatchButPortIsHttps(  CapturedOutput output);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/discovery/DiscoveryClientUtilsTests.java",
        "name": "DiscoveryClientUtilsTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.DiscoveryClientUtilsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class DiscoveryClientUtilsTests {\n  /** \n * \u003cpre\u003e - labels are not added - annotations are not added \u003c/pre\u003e\n */\n  @Test void testServiceMetadataEmpty(){\n    boolean addLabels\u003dfalse;\n    String labelsPrefix\u003d\"\";\n    boolean addAnnotations\u003dfalse;\n    String annotationsPrefix\u003d\"\";\n    boolean addPorts\u003dfalse;\n    String portsPrefix\u003d\"\";\n    String namespace\u003d\"default\";\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of();\n    Map\u003cString,String\u003e serviceAnnotations\u003dMap.of();\n    Map\u003cString,Integer\u003e portsData\u003dMap.of();\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(addLabels,labelsPrefix,addAnnotations,annotationsPrefix,addPorts,portsPrefix);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(\"my-service\",namespace,\"ClusterIP\",serviceLabels,serviceAnnotations);\n    Map\u003cString,String\u003e result\u003dserviceInstanceMetadata(portsData,serviceMetadata,properties);\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertEquals(result,Map.of(\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\"));\n  }\n  /** \n * \u003cpre\u003e - labels are not added, though they are not empty - annotations are not added, though they are not empty \u003c/pre\u003e\n */\n  @Test void testServiceMetadataNotEmptyNotTaken(){\n    boolean addLabels\u003dfalse;\n    String labelsPrefix\u003d\"\";\n    boolean addAnnotations\u003dfalse;\n    String annotationsPrefix\u003d\"\";\n    boolean addPorts\u003dfalse;\n    String portsPrefix\u003d\"\";\n    String namespace\u003d\"default\";\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"a\",\"1\");\n    Map\u003cString,String\u003e serviceAnnotations\u003dMap.of(\"b\",\"2\");\n    Map\u003cString,Integer\u003e portsData\u003dMap.of(\"c\",3);\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(addLabels,labelsPrefix,addAnnotations,annotationsPrefix,addPorts,portsPrefix);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(\"my-service\",namespace,\"ClusterIP\",serviceLabels,serviceAnnotations);\n    Map\u003cString,String\u003e result\u003dserviceInstanceMetadata(portsData,serviceMetadata,properties);\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertEquals(result,Map.of(\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\"));\n  }\n  /** \n * \u003cpre\u003e - labels are added without a prefix - annotations are not added \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddLabelsNoPrefix(  CapturedOutput output){\n    boolean addLabels\u003dtrue;\n    String labelsPrefix\u003d\"\";\n    boolean addAnnotations\u003dfalse;\n    String annotationsPrefix\u003d\"\";\n    boolean addPorts\u003dfalse;\n    String portsPrefix\u003d\"\";\n    String namespace\u003d\"default\";\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"a\",\"b\");\n    Map\u003cString,String\u003e serviceAnnotations\u003dMap.of(\"c\",\"2\");\n    Map\u003cString,Integer\u003e portsData\u003dMap.of(\"d\",3);\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(addLabels,labelsPrefix,addAnnotations,annotationsPrefix,addPorts,portsPrefix);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(\"my-service\",namespace,\"ClusterIP\",serviceLabels,serviceAnnotations);\n    Map\u003cString,String\u003e result\u003dserviceInstanceMetadata(portsData,serviceMetadata,properties);\n    Assertions.assertEquals(result.size(),3);\n    Assertions.assertEquals(result,Map.of(\"a\",\"b\",\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\"));\n    String labelsMetadata\u003dfilterOnK8sNamespaceAndType(result);\n    Assertions.assertTrue(output.getOut().contains(\"Adding labels metadata: \" + labelsMetadata + \" for serviceId: my-service\"));\n  }\n  /** \n * \u003cpre\u003e - labels are added with prefix - annotations are not added \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddLabelsWithPrefix(  CapturedOutput output){\n    boolean addLabels\u003dtrue;\n    String labelsPrefix\u003d\"prefix-\";\n    boolean addAnnotations\u003dfalse;\n    String annotationsPrefix\u003d\"\";\n    boolean addPorts\u003dfalse;\n    String portsPrefix\u003d\"\";\n    String namespace\u003d\"default\";\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"a\",\"b\",\"c\",\"d\");\n    Map\u003cString,String\u003e serviceAnnotations\u003dMap.of(\"c\",\"2\");\n    Map\u003cString,Integer\u003e portsData\u003dMap.of(\"d\",3);\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(addLabels,labelsPrefix,addAnnotations,annotationsPrefix,addPorts,portsPrefix);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(\"my-service\",namespace,\"ClusterIP\",serviceLabels,serviceAnnotations);\n    Map\u003cString,String\u003e result\u003dserviceInstanceMetadata(portsData,serviceMetadata,properties);\n    Assertions.assertEquals(result.size(),4);\n    Assertions.assertEquals(result,Map.of(\"prefix-a\",\"b\",\"prefix-c\",\"d\",\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\"));\n    String labelsMetadata\u003dfilterOnK8sNamespaceAndType(result);\n    Assertions.assertTrue(output.getOut().contains(\"Adding labels metadata: \" + labelsMetadata + \" for serviceId: my-service\"));\n  }\n  /** \n * \u003cpre\u003e - labels are not added - annotations are added without prefix \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddAnnotationsNoPrefix(  CapturedOutput output){\n    boolean addLabels\u003dfalse;\n    String labelsPrefix\u003d\"\";\n    boolean addAnnotations\u003dtrue;\n    String annotationsPrefix\u003d\"\";\n    boolean addPorts\u003dfalse;\n    String portsPrefix\u003d\"\";\n    String namespace\u003d\"default\";\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"a\",\"b\");\n    Map\u003cString,String\u003e serviceAnnotations\u003dMap.of(\"aa\",\"bb\");\n    Map\u003cString,Integer\u003e portsData\u003dMap.of(\"d\",3);\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(addLabels,labelsPrefix,addAnnotations,annotationsPrefix,addPorts,portsPrefix);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(\"my-service\",namespace,\"ClusterIP\",serviceLabels,serviceAnnotations);\n    Map\u003cString,String\u003e result\u003dserviceInstanceMetadata(portsData,serviceMetadata,properties);\n    Assertions.assertEquals(result.size(),3);\n    Assertions.assertEquals(result,Map.of(\"aa\",\"bb\",\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\"));\n    Assertions.assertTrue(output.getOut().contains(\"Adding annotations metadata: {aa\u003dbb} for serviceId: my-service\"));\n  }\n  /** \n * \u003cpre\u003e - labels are not added - annotations are added with prefix \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddAnnotationsWithPrefix(  CapturedOutput output){\n    boolean addLabels\u003dfalse;\n    String labelsPrefix\u003d\"\";\n    boolean addAnnotations\u003dtrue;\n    String annotationsPrefix\u003d\"prefix-\";\n    boolean addPorts\u003dfalse;\n    String portsPrefix\u003d\"\";\n    String namespace\u003d\"default\";\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"a\",\"b\");\n    Map\u003cString,String\u003e serviceAnnotations\u003dMap.of(\"aa\",\"bb\",\"cc\",\"dd\");\n    Map\u003cString,Integer\u003e portsData\u003dMap.of(\"d\",3);\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(addLabels,labelsPrefix,addAnnotations,annotationsPrefix,addPorts,portsPrefix);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(\"my-service\",namespace,\"ClusterIP\",serviceLabels,serviceAnnotations);\n    Map\u003cString,String\u003e result\u003dserviceInstanceMetadata(portsData,serviceMetadata,properties);\n    Assertions.assertEquals(result.size(),4);\n    Assertions.assertEquals(result,Map.of(\"prefix-aa\",\"bb\",\"prefix-cc\",\"dd\",\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\"));\n    String annotations\u003dfilterOnK8sNamespaceAndType(result);\n    Assertions.assertTrue(output.getOut().contains(\"Adding annotations metadata: \" + annotations + \" for serviceId: my-service\"));\n  }\n  /** \n * \u003cpre\u003e - labels are added with prefix - annotations are added with prefix \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddLabelsAndAnnotationsWithPrefix(  CapturedOutput output){\n    boolean addLabels\u003dtrue;\n    String labelsPrefix\u003d\"label-\";\n    boolean addAnnotations\u003dtrue;\n    String annotationsPrefix\u003d\"annotation-\";\n    boolean addPorts\u003dfalse;\n    String portsPrefix\u003d\"\";\n    String namespace\u003d\"default\";\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"a\",\"b\",\"c\",\"d\");\n    Map\u003cString,String\u003e serviceAnnotations\u003dMap.of(\"aa\",\"bb\",\"cc\",\"dd\");\n    Map\u003cString,Integer\u003e portsData\u003dMap.of(\"d\",3);\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(addLabels,labelsPrefix,addAnnotations,annotationsPrefix,addPorts,portsPrefix);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(\"my-service\",namespace,\"ClusterIP\",serviceLabels,serviceAnnotations);\n    Map\u003cString,String\u003e result\u003dserviceInstanceMetadata(portsData,serviceMetadata,properties);\n    Assertions.assertEquals(result.size(),6);\n    Assertions.assertEquals(result,Map.of(\"annotation-aa\",\"bb\",\"annotation-cc\",\"dd\",\"label-a\",\"b\",\"label-c\",\"d\",\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\"));\n    String labels\u003dresult.entrySet().stream().filter(en -\u003e en.getKey().contains(\"label\")).collect(Collectors.toMap(Map.Entry::getKey,Map.Entry::getValue)).toString();\n    String annotations\u003dresult.entrySet().stream().filter(en -\u003e en.getKey().contains(\"annotation\")).collect(Collectors.toMap(Map.Entry::getKey,Map.Entry::getValue)).toString();\n    Assertions.assertTrue(output.getOut().contains(\"Adding labels metadata: \" + labels + \" for serviceId: my-service\"));\n    Assertions.assertTrue(output.getOut().contains(\"Adding annotations metadata: \" + annotations + \" for serviceId: my-service\"));\n  }\n  /** \n * \u003cpre\u003e - ports without prefix are added \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddPortsWithoutPrefix(  CapturedOutput output){\n    boolean addLabels\u003dfalse;\n    String labelsPrefix\u003d\"\";\n    boolean addAnnotations\u003dfalse;\n    String annotationsPrefix\u003d\"prefix-\";\n    boolean addPorts\u003dtrue;\n    String portsPrefix\u003d\"\";\n    String namespace\u003d\"default\";\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"a\",\"b\");\n    Map\u003cString,String\u003e serviceAnnotations\u003dMap.of(\"aa\",\"bb\",\"cc\",\"dd\");\n    Map\u003cString,Integer\u003e portsData\u003dMap.of(\"https\",8080);\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(addLabels,labelsPrefix,addAnnotations,annotationsPrefix,addPorts,portsPrefix);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(\"my-service\",namespace,\"ClusterIP\",serviceLabels,serviceAnnotations);\n    Map\u003cString,String\u003e result\u003dserviceInstanceMetadata(portsData,serviceMetadata,properties);\n    Assertions.assertEquals(result.size(),3);\n    Assertions.assertEquals(result,Map.of(\"https\",\"8080\",\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\"));\n    Assertions.assertTrue(output.getOut().contains(\"Adding port metadata: {https\u003d8080} for serviceId : my-service\"));\n  }\n  /** \n * \u003cpre\u003e - ports without prefix are added \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddPortsWithPrefix(  CapturedOutput output){\n    boolean addLabels\u003dfalse;\n    String labelsPrefix\u003d\"\";\n    boolean addAnnotations\u003dfalse;\n    String annotationsPrefix\u003d\"prefix-\";\n    boolean addPorts\u003dtrue;\n    String portsPrefix\u003d\"prefix-\";\n    String namespace\u003d\"default\";\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(\"a\",\"b\");\n    Map\u003cString,String\u003e serviceAnnotations\u003dMap.of(\"aa\",\"bb\",\"cc\",\"dd\");\n    Map\u003cString,Integer\u003e portsData\u003dMap.of(\"http\",8081,\"https\",8080);\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(addLabels,labelsPrefix,addAnnotations,annotationsPrefix,addPorts,portsPrefix);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(\"my-service\",namespace,\"ClusterIP\",serviceLabels,serviceAnnotations);\n    Map\u003cString,String\u003e result\u003dserviceInstanceMetadata(portsData,serviceMetadata,properties);\n    Assertions.assertEquals(result.size(),4);\n    Assertions.assertEquals(result,Map.of(\"prefix-https\",\"8080\",\"prefix-http\",\"8081\",\"k8s_namespace\",\"default\",\"type\",\"ClusterIP\"));\n    Assertions.assertTrue(output.getOut().contains(\"Adding port metadata: {prefix-http\u003d8081, prefix-https\u003d8080} for serviceId : my-service\"));\n  }\n  /** \n * \u003cpre\u003e - properties do not have primary-port-name set - service labels do not have primary-port-name set As such null is returned. \u003c/pre\u003e\n */\n  @Test void testPrimaryPortNameNotFound(  CapturedOutput output){\n    KubernetesDiscoveryProperties properties\u003dKubernetesDiscoveryProperties.DEFAULT;\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of();\n    String result\u003dprimaryPortName(properties,serviceLabels,\"abc\");\n    Assertions.assertNull(result);\n    Assertions.assertTrue(output.getOut().contains(\"did not find a primary-port-name in neither properties nor service labels for service with ID : abc\"));\n  }\n  /** \n * \u003cpre\u003e - properties do have primary-port-name set to \"https\" - service labels do not have primary-port-name set As such \"https\" is returned. \u003c/pre\u003e\n */\n  @Test void testPrimaryPortNameFoundInProperties(  CapturedOutput output){\n    String primaryPortName\u003d\"https\";\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),primaryPortName,null,0,false);\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of();\n    String result\u003dprimaryPortName(properties,serviceLabels,\"abc\");\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result,primaryPortName);\n    Assertions.assertTrue(output.getOut().contains(\"will use primaryPortName : https for service with ID \u003d abc\"));\n  }\n  /** \n * \u003cpre\u003e - properties do not have primary-port-name set - service labels do have primary-port-name set to \"https\" As such \"https\" is returned. \u003c/pre\u003e\n */\n  @Test void testPrimaryPortNameFoundInLabels(  CapturedOutput output){\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(PRIMARY_PORT_NAME_LABEL_KEY,\"https\");\n    KubernetesDiscoveryProperties properties\u003dKubernetesDiscoveryProperties.DEFAULT;\n    String result\u003dprimaryPortName(properties,serviceLabels,\"abc\");\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result,\"https\");\n    Assertions.assertTrue(output.getOut().contains(\"will use primaryPortName : https for service with ID \u003d abc\"));\n  }\n  /** \n * \u003cpre\u003e - properties do have primary-port-name set to \"https\" - service labels do have primary-port-name set to \"http\" As such \"http\" is returned (labels win). \u003c/pre\u003e\n */\n  @Test void testPrimaryPortNameFoundInBothPropertiesAndLabels(  CapturedOutput output){\n    String primaryPortName\u003d\"https\";\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of(PRIMARY_PORT_NAME_LABEL_KEY,\"http\");\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),primaryPortName,null,0,false);\n    String result\u003dprimaryPortName(properties,serviceLabels,\"abc\");\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result,\"http\");\n    Assertions.assertTrue(output.getOut().contains(\"will use primaryPortName : http for service with ID \u003d abc\"));\n  }\n  /** \n * \u003cpre\u003e - EndpointSubset has no ports. \u003c/pre\u003e\n */\n  @Test void testEndpointsPortNoPorts(  CapturedOutput output){\n    String serviceId\u003d\"spring-k8s\";\n    KubernetesDiscoveryProperties properties\u003dKubernetesDiscoveryProperties.DEFAULT;\n    LinkedHashMap\u003cString,Integer\u003e endpointsPorts\u003dnew LinkedHashMap\u003c\u003e();\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of();\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(serviceId,\"default\",\"ClusterIP\",serviceLabels,Map.of());\n    ServicePortNameAndNumber portData\u003dendpointsPort(endpointsPorts,serviceMetadata,properties);\n    Assertions.assertEquals(portData.portNumber(),0);\n    Assertions.assertEquals(portData.portName(),\"http\");\n    Assertions.assertTrue(output.getOut().contains(\"no ports found for service : spring-k8s, will return zero\"));\n  }\n  /** \n * \u003cpre\u003e - EndpointSubset has a single entry in getPorts. \u003c/pre\u003e\n */\n  @Test void testEndpointsPortSinglePort(  CapturedOutput output){\n    String serviceId\u003d\"spring-k8s\";\n    KubernetesDiscoveryProperties properties\u003dKubernetesDiscoveryProperties.DEFAULT;\n    LinkedHashMap\u003cString,Integer\u003e endpointsPorts\u003dnew LinkedHashMap\u003c\u003e();\n    endpointsPorts.put(\"http\",8080);\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of();\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(serviceId,\"default\",\"ClusterIP\",serviceLabels,Map.of());\n    ServicePortNameAndNumber portData\u003dendpointsPort(endpointsPorts,serviceMetadata,properties);\n    Assertions.assertEquals(portData.portNumber(),8080);\n    Assertions.assertEquals(portData.portName(),\"http\");\n    Assertions.assertTrue(output.getOut().contains(\"endpoint ports has a single entry, using port : 8080\"));\n  }\n  /** \n * \u003cpre\u003e - primary-port-name is null. \u003c/pre\u003e\n */\n  @Test void testEndpointsPortNullPrimaryPortName(  CapturedOutput output){\n    String serviceId\u003d\"spring-k8s\";\n    KubernetesDiscoveryProperties properties\u003dKubernetesDiscoveryProperties.DEFAULT;\n    LinkedHashMap\u003cString,Integer\u003e endpointsPorts\u003dnew LinkedHashMap\u003c\u003e();\n    endpointsPorts.put(\"not-null\",8080);\n    endpointsPorts.put(\"not-http-or-https\",8081);\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of();\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(serviceId,\"default\",\"ClusterIP\",serviceLabels,Map.of());\n    ServicePortNameAndNumber portData\u003dendpointsPort(endpointsPorts,serviceMetadata,properties);\n    Assertions.assertEquals(portData.portNumber(),8080);\n    Assertions.assertEquals(portData.portName(),\"not-null\");\n    Assertions.assertTrue(output.getOut().contains(\"did not find a primary-port-name in neither properties nor service labels for service with ID : spring-k8s\"));\n    Assertions.assertTrue(output.getOut().contains(\"not found primary-port-name (with value: \u0027null\u0027) via properties or service labels\"));\n    Assertions.assertTrue(output.getOut().contains(\"not found primary-port-name via \u0027https\u0027 to match port\"));\n    Assertions.assertTrue(output.getOut().contains(\"not found primary-port-name via \u0027http\u0027 to match port\"));\n    Assertions.assertTrue(output.getOut().contains(null));\n  }\n  /** \n * \u003cpre\u003e - primary-port-name is \"three\", such a port name does not exist. \u003c/pre\u003e\n */\n  @Test void testEndpointsPortPrimaryPortNameIsPresentButNotFound(  CapturedOutput output){\n    String serviceId\u003d\"spring-k8s\";\n    String primaryPortName\u003d\"three\";\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),primaryPortName,null,0,false);\n    LinkedHashMap\u003cString,Integer\u003e endpointsPorts\u003dnew LinkedHashMap\u003c\u003e();\n    endpointsPorts.put(\"one\",8080);\n    endpointsPorts.put(\"two\",8081);\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of();\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(serviceId,\"default\",\"ClusterIP\",serviceLabels,Map.of());\n    ServicePortNameAndNumber portData\u003dendpointsPort(endpointsPorts,serviceMetadata,properties);\n    Assertions.assertEquals(portData.portNumber(),8080);\n    Assertions.assertEquals(portData.portName(),\"one\");\n    Assertions.assertTrue(output.getOut().contains(\"will use primaryPortName : three for service with ID \u003d spring-k8s\"));\n    Assertions.assertTrue(output.getOut().contains(\"not found primary-port-name (with value: \u0027three\u0027) via properties or service labels\"));\n    Assertions.assertTrue(output.getOut().contains(\"not found primary-port-name via \u0027https\u0027 to match port\"));\n    Assertions.assertTrue(output.getOut().contains(\"not found primary-port-name via \u0027http\u0027 to match port\"));\n    Assertions.assertTrue(output.getOut().contains(null));\n  }\n  /** \n * \u003cpre\u003e - primary-port-name is \"two\", such a port name exists and matches 8081 \u003c/pre\u003e\n */\n  @Test void testEndpointsPortPrimaryPortNameFound(  CapturedOutput output){\n    String serviceId\u003d\"spring-k8s\";\n    String primaryPortName\u003d\"two\";\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),primaryPortName,null,0,false);\n    LinkedHashMap\u003cString,Integer\u003e endpointsPorts\u003dnew LinkedHashMap\u003c\u003e();\n    endpointsPorts.put(\"one\",8080);\n    endpointsPorts.put(\"two\",8081);\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of();\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(serviceId,\"default\",\"ClusterIP\",serviceLabels,Map.of());\n    ServicePortNameAndNumber portData\u003dendpointsPort(endpointsPorts,serviceMetadata,properties);\n    Assertions.assertEquals(portData.portNumber(),8081);\n    Assertions.assertEquals(portData.portName(),\"two\");\n    Assertions.assertTrue(output.getOut().contains(\"will use primaryPortName : two for service with ID \u003d spring-k8s\"));\n    Assertions.assertTrue(output.getOut().contains(\"found primary-port-name (with value: \u0027two\u0027) via properties or service labels to match port : 8081\"));\n  }\n  /** \n * \u003cpre\u003e - primary-port-name is \"three\", such a port name does not exist. - https port exists and this one is returned \u003c/pre\u003e\n */\n  @Test void testEndpointsPortPrimaryPortHttps(  CapturedOutput output){\n    String serviceId\u003d\"spring-k8s\";\n    String primaryPortName\u003d\"three\";\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),primaryPortName,null,0,false,false);\n    LinkedHashMap\u003cString,Integer\u003e endpointsPorts\u003dnew LinkedHashMap\u003c\u003e();\n    endpointsPorts.put(\"one\",8080);\n    endpointsPorts.put(\"two\",8081);\n    endpointsPorts.put(\"https\",8082);\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of();\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(serviceId,\"default\",\"ClusterIP\",serviceLabels,Map.of());\n    ServicePortNameAndNumber portData\u003dendpointsPort(endpointsPorts,serviceMetadata,properties);\n    Assertions.assertEquals(portData.portNumber(),8082);\n    Assertions.assertEquals(portData.portName(),\"https\");\n    Assertions.assertTrue(output.getOut().contains(\"will use primaryPortName : three for service with ID \u003d spring-k8s\"));\n    Assertions.assertTrue(output.getOut().contains(\"not found primary-port-name (with value: \u0027three\u0027) via properties or service labels to match port\"));\n    Assertions.assertTrue(output.getOut().contains(\"found primary-port-name via \u0027https\u0027 to match port : 8082\"));\n  }\n  /** \n * \u003cpre\u003e - primary-port-name is \"three\", such a port name does not exist. - http port exists and this one is returned \u003c/pre\u003e\n */\n  @Test void testEndpointsPortPrimaryPortHttp(  CapturedOutput output){\n    String serviceId\u003d\"spring-k8s\";\n    String primaryPortName\u003d\"three\";\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,true,\"\",Set.of(),Map.of(),primaryPortName,null,0,false);\n    LinkedHashMap\u003cString,Integer\u003e endpointsPorts\u003dnew LinkedHashMap\u003c\u003e();\n    endpointsPorts.put(\"one\",8080);\n    endpointsPorts.put(\"two\",8081);\n    endpointsPorts.put(\"http\",8082);\n    Map\u003cString,String\u003e serviceLabels\u003dMap.of();\n    ServiceMetadata serviceMetadata\u003dnew ServiceMetadata(serviceId,\"default\",\"ClusterIP\",serviceLabels,Map.of());\n    ServicePortNameAndNumber portData\u003dendpointsPort(endpointsPorts,serviceMetadata,properties);\n    Assertions.assertEquals(portData.portNumber(),8082);\n    Assertions.assertEquals(portData.portName(),\"http\");\n    Assertions.assertTrue(output.getOut().contains(\"will use primaryPortName : three for service with ID \u003d spring-k8s\"));\n    Assertions.assertTrue(output.getOut().contains(\"not found primary-port-name (with value: \u0027three\u0027) via properties or service labels to match port\"));\n    Assertions.assertTrue(output.getOut().contains(\"found primary-port-name via \u0027http\u0027 to match port : 8082\"));\n  }\n  @Test void testServiceInstance(){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false);\n    ServicePortSecureResolver resolver\u003dnew ServicePortSecureResolver(properties);\n    ServicePortNameAndNumber portData\u003dnew ServicePortNameAndNumber(8080,\"http\");\n    ServiceMetadata forServiceInstance\u003dnew ServiceMetadata(\"my-service\",\"k8s\",\"ClusterIP\",Map.of(),Map.of());\n    InstanceIdHostPodName instanceIdHostPodName\u003dnew InstanceIdHostPodName(\"123\",\"127.0.0.1\",null);\n    Map\u003cString,String\u003e serviceMetadata\u003dMap.of(\"a\",\"b\");\n    ServiceInstance serviceInstance\u003dserviceInstance(resolver,forServiceInstance,() -\u003e instanceIdHostPodName,null,portData,serviceMetadata,properties);\n    Assertions.assertTrue(serviceInstance instanceof DefaultKubernetesServiceInstance);\n    DefaultKubernetesServiceInstance defaultInstance\u003d(DefaultKubernetesServiceInstance)serviceInstance;\n    Assertions.assertEquals(defaultInstance.getInstanceId(),\"123\");\n    Assertions.assertEquals(defaultInstance.getServiceId(),\"my-service\");\n    Assertions.assertEquals(defaultInstance.getHost(),\"127.0.0.1\");\n    Assertions.assertEquals(defaultInstance.getPort(),8080);\n    Assertions.assertFalse(defaultInstance.isSecure());\n    Assertions.assertEquals(defaultInstance.getUri().toASCIIString(),\"http://127.0.0.1:8080\");\n    Assertions.assertEquals(defaultInstance.getMetadata(),Map.of(\"a\",\"b\"));\n    Assertions.assertEquals(defaultInstance.getScheme(),\"http\");\n    Assertions.assertEquals(defaultInstance.getNamespace(),\"k8s\");\n    Assertions.assertNull(defaultInstance.getCluster());\n  }\n  @Test void testExternalNameServiceInstance(){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false);\n    ServicePortNameAndNumber portData\u003dnew ServicePortNameAndNumber(-1,\"http\");\n    ServiceMetadata forServiceInstance\u003dnew ServiceMetadata(\"my-service\",\"k8s\",\"ClusterIP\",Map.of(),Map.of());\n    InstanceIdHostPodName instanceIdHostPodName\u003dnew InstanceIdHostPodName(\"123\",\"spring.io\",null);\n    Map\u003cString,String\u003e serviceMetadata\u003dMap.of(\"a\",\"b\");\n    ServiceInstance serviceInstance\u003dserviceInstance(null,forServiceInstance,() -\u003e instanceIdHostPodName,null,portData,serviceMetadata,properties);\n    Assertions.assertTrue(serviceInstance instanceof DefaultKubernetesServiceInstance);\n    DefaultKubernetesServiceInstance defaultInstance\u003d(DefaultKubernetesServiceInstance)serviceInstance;\n    Assertions.assertEquals(defaultInstance.getInstanceId(),\"123\");\n    Assertions.assertEquals(defaultInstance.getServiceId(),\"my-service\");\n    Assertions.assertEquals(defaultInstance.getHost(),\"spring.io\");\n    Assertions.assertEquals(defaultInstance.getPort(),-1);\n    Assertions.assertFalse(defaultInstance.isSecure());\n    Assertions.assertEquals(defaultInstance.getUri().toASCIIString(),\"spring.io\");\n    Assertions.assertEquals(defaultInstance.getMetadata(),Map.of(\"a\",\"b\"));\n    Assertions.assertEquals(defaultInstance.getScheme(),\"http\");\n    Assertions.assertEquals(defaultInstance.getNamespace(),\"k8s\");\n    Assertions.assertNull(defaultInstance.getCluster());\n  }\n  /** \n * type is ExternalName, as such we do nothing.\n */\n  @Test void testPodMetadataExternalName(){\n    boolean addLabels\u003dfalse;\n    boolean addAnnotations\u003dfalse;\n    String podName\u003d\"pod-name\";\n    Map\u003cString,String\u003e serviceMetadata\u003dMap.of(\"type\",\"ExternalName\");\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,\"\",false,\"\",false,\"\",addLabels,addAnnotations);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    Function\u003cString,PodLabelsAndAnnotations\u003e podLabelsAndMetadata\u003dx -\u003e null;\n    Map\u003cString,Map\u003cString,String\u003e\u003e result\u003dpodMetadata(podName,serviceMetadata,properties,podLabelsAndMetadata);\n    Assertions.assertTrue(result.isEmpty());\n  }\n  /** \n * type is not ExternalName, but labels and annotations have not been requested. As such, we do nothing.\n */\n  @Test void testPodMetadataNotExternalNameLabelsNorAnnotationsIncluded(){\n    boolean addLabels\u003dfalse;\n    boolean addAnnotations\u003dfalse;\n    String podName\u003d\"pod-name\";\n    Map\u003cString,String\u003e serviceMetadata\u003dMap.of(\"type\",\"ClusterIP\");\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,\"\",false,\"\",false,\"\",addLabels,addAnnotations);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    Function\u003cString,PodLabelsAndAnnotations\u003e podLabelsAndMetadata\u003dx -\u003e null;\n    Map\u003cString,Map\u003cString,String\u003e\u003e result\u003dpodMetadata(podName,serviceMetadata,properties,podLabelsAndMetadata);\n    Assertions.assertTrue(result.isEmpty());\n  }\n  /** \n * \u003cpre\u003e - type is not ExternalName - labels and annotations have been requested - podName is null As such we do nothing. \u003c/pre\u003e\n */\n  @Test void testPodMetadataNotExternalNameLabelsAndAnnotationsIncludedPodNameNull(){\n    boolean addLabels\u003dtrue;\n    boolean addAnnotations\u003dtrue;\n    String podName\u003dnull;\n    Map\u003cString,String\u003e serviceMetadata\u003dMap.of(\"type\",\"ClusterIP\");\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,\"\",false,\"\",false,\"\",addLabels,addAnnotations);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    Function\u003cString,PodLabelsAndAnnotations\u003e podLabelsAndMetadata\u003dx -\u003e null;\n    Map\u003cString,Map\u003cString,String\u003e\u003e result\u003dpodMetadata(podName,serviceMetadata,properties,podLabelsAndMetadata);\n    Assertions.assertTrue(result.isEmpty());\n  }\n  /** \n * \u003cpre\u003e - type is not ExternalName - labels have been requested - labels are empty - podName is not null. As such we add empty labels to pod metadata. \u003c/pre\u003e\n */\n  @Test void testPodMetadataOnlyLabelsRequestedButAreEmpty(  CapturedOutput output){\n    boolean addLabels\u003dtrue;\n    boolean addAnnotations\u003dfalse;\n    String podName\u003d\"my-pod\";\n    Map\u003cString,String\u003e serviceMetadata\u003dMap.of(\"type\",\"ClusterIP\");\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,\"\",false,\"\",false,\"\",addLabels,addAnnotations);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    PodLabelsAndAnnotations both\u003dnew PodLabelsAndAnnotations(Map.of(),Map.of(\"c\",\"d\"));\n    Function\u003cString,PodLabelsAndAnnotations\u003e podLabelsAndMetadata\u003dx -\u003e both;\n    Map\u003cString,Map\u003cString,String\u003e\u003e result\u003dpodMetadata(podName,serviceMetadata,properties,podLabelsAndMetadata);\n    Assertions.assertTrue(result.isEmpty());\n    Assertions.assertTrue(output.getOut().contains(\"adding podMetadata : {} from pod : my-pod\"));\n  }\n  /** \n * \u003cpre\u003e - type is not ExternalName - labels have been requested - labels are not empty - podName is not null. As such we add non empty labels to pod metadata. \u003c/pre\u003e\n */\n  @Test void testPodMetadataOnlyLabelsRequestedAndAreNotEmpty(  CapturedOutput output){\n    boolean addLabels\u003dtrue;\n    boolean addAnnotations\u003dfalse;\n    String podName\u003d\"my-pod\";\n    Map\u003cString,String\u003e serviceMetadata\u003dMap.of(\"type\",\"ClusterIP\");\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,\"\",false,\"\",false,\"\",addLabels,addAnnotations);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    PodLabelsAndAnnotations both\u003dnew PodLabelsAndAnnotations(Map.of(\"a\",\"b\"),Map.of(\"c\",\"d\"));\n    Function\u003cString,PodLabelsAndAnnotations\u003e podLabelsAndMetadata\u003dx -\u003e both;\n    Map\u003cString,Map\u003cString,String\u003e\u003e result\u003dpodMetadata(podName,serviceMetadata,properties,podLabelsAndMetadata);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(\"labels\"),Map.of(\"a\",\"b\"));\n    Assertions.assertTrue(output.getOut().contains(\"adding podMetadata : {labels\u003d{a\u003db}} from pod : my-pod\"));\n  }\n  /** \n * \u003cpre\u003e - type is not ExternalName - annotation have been requested - annotation are empty - podName is not null. As such we add empty labels to pod metadata. \u003c/pre\u003e\n */\n  @Test void testPodMetadataOnlyAnnotationsRequestedButAreEmpty(  CapturedOutput output){\n    boolean addLabels\u003dfalse;\n    boolean addAnnotations\u003dtrue;\n    String podName\u003d\"my-pod\";\n    Map\u003cString,String\u003e serviceMetadata\u003dMap.of(\"type\",\"ClusterIP\");\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,\"\",false,\"\",false,\"\",addLabels,addAnnotations);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    PodLabelsAndAnnotations both\u003dnew PodLabelsAndAnnotations(Map.of(\"a\",\"b\"),Map.of());\n    Function\u003cString,PodLabelsAndAnnotations\u003e podLabelsAndMetadata\u003dx -\u003e both;\n    Map\u003cString,Map\u003cString,String\u003e\u003e result\u003dpodMetadata(podName,serviceMetadata,properties,podLabelsAndMetadata);\n    Assertions.assertTrue(result.isEmpty());\n    Assertions.assertTrue(output.getOut().contains(\"adding podMetadata : {} from pod : my-pod\"));\n  }\n  /** \n * \u003cpre\u003e - type is not ExternalName - annotations have been requested - annotation are not empty - podName is not null. As such we add non empty labels to pod metadata. \u003c/pre\u003e\n */\n  @Test void testPodMetadataOnlyAnnotationsRequestedAndAreNotEmpty(  CapturedOutput output){\n    boolean addLabels\u003dfalse;\n    boolean addAnnotations\u003dtrue;\n    String podName\u003d\"my-pod\";\n    Map\u003cString,String\u003e serviceMetadata\u003dMap.of(\"type\",\"ClusterIP\");\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,\"\",false,\"\",false,\"\",addLabels,addAnnotations);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    PodLabelsAndAnnotations both\u003dnew PodLabelsAndAnnotations(Map.of(\"a\",\"b\"),Map.of(\"c\",\"d\"));\n    Function\u003cString,PodLabelsAndAnnotations\u003e podLabelsAndMetadata\u003dx -\u003e both;\n    Map\u003cString,Map\u003cString,String\u003e\u003e result\u003dpodMetadata(podName,serviceMetadata,properties,podLabelsAndMetadata);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(\"annotations\"),Map.of(\"c\",\"d\"));\n    Assertions.assertTrue(output.getOut().contains(\"adding podMetadata : {annotations\u003d{c\u003dd}} from pod : my-pod\"));\n  }\n  /** \n * \u003cpre\u003e - type is not ExternalName - annotations have been requested - annotation are not empty - podName is not null. As such we add non empty labels to pod metadata. \u003c/pre\u003e\n */\n  @Test void testPodMetadataBothLabelsAndAnnotations(  CapturedOutput output){\n    boolean addLabels\u003dtrue;\n    boolean addAnnotations\u003dtrue;\n    String podName\u003d\"my-pod\";\n    Map\u003cString,String\u003e serviceMetadata\u003dMap.of(\"type\",\"ClusterIP\");\n    KubernetesDiscoveryProperties.Metadata metadata\u003dnew KubernetesDiscoveryProperties.Metadata(false,\"\",false,\"\",false,\"\",addLabels,addAnnotations);\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60L,false,\"\",Set.of(),Map.of(),\"\",metadata,0,false,false);\n    PodLabelsAndAnnotations both\u003dnew PodLabelsAndAnnotations(Map.of(\"a\",\"b\"),Map.of(\"c\",\"d\"));\n    Function\u003cString,PodLabelsAndAnnotations\u003e podLabelsAndMetadata\u003dx -\u003e both;\n    Map\u003cString,Map\u003cString,String\u003e\u003e result\u003dpodMetadata(podName,serviceMetadata,properties,podLabelsAndMetadata);\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertEquals(result.get(\"annotations\"),Map.of(\"c\",\"d\"));\n    Assertions.assertEquals(result.get(\"labels\"),Map.of(\"a\",\"b\"));\n    Assertions.assertTrue(output.getOut().contains(\"adding podMetadata : {annotations\u003d{c\u003dd}, labels\u003d{a\u003db}} from pod : my-pod\"));\n  }\n  private String filterOnK8sNamespaceAndType(  Map\u003cString,String\u003e result){\n    return result.entrySet().stream().filter(en -\u003e !en.getKey().contains(\"k8s_namespace\")).filter(en -\u003e !en.getKey().equals(\"type\")).collect(Collectors.toMap(Map.Entry::getKey,Map.Entry::getValue)).toString();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class DiscoveryClientUtilsTests {\n  /** \n * \u003cpre\u003e - labels are not added - annotations are not added \u003c/pre\u003e\n */\n  @Test void testServiceMetadataEmpty();\n  /** \n * \u003cpre\u003e - labels are not added, though they are not empty - annotations are not added, though they are not empty \u003c/pre\u003e\n */\n  @Test void testServiceMetadataNotEmptyNotTaken();\n  /** \n * \u003cpre\u003e - labels are added without a prefix - annotations are not added \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddLabelsNoPrefix(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - labels are added with prefix - annotations are not added \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddLabelsWithPrefix(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - labels are not added - annotations are added without prefix \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddAnnotationsNoPrefix(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - labels are not added - annotations are added with prefix \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddAnnotationsWithPrefix(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - labels are added with prefix - annotations are added with prefix \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddLabelsAndAnnotationsWithPrefix(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - ports without prefix are added \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddPortsWithoutPrefix(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - ports without prefix are added \u003c/pre\u003e\n */\n  @Test void testServiceMetadataAddPortsWithPrefix(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - properties do not have primary-port-name set - service labels do not have primary-port-name set As such null is returned. \u003c/pre\u003e\n */\n  @Test void testPrimaryPortNameNotFound(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - properties do have primary-port-name set to \"https\" - service labels do not have primary-port-name set As such \"https\" is returned. \u003c/pre\u003e\n */\n  @Test void testPrimaryPortNameFoundInProperties(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - properties do not have primary-port-name set - service labels do have primary-port-name set to \"https\" As such \"https\" is returned. \u003c/pre\u003e\n */\n  @Test void testPrimaryPortNameFoundInLabels(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - properties do have primary-port-name set to \"https\" - service labels do have primary-port-name set to \"http\" As such \"http\" is returned (labels win). \u003c/pre\u003e\n */\n  @Test void testPrimaryPortNameFoundInBothPropertiesAndLabels(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - EndpointSubset has no ports. \u003c/pre\u003e\n */\n  @Test void testEndpointsPortNoPorts(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - EndpointSubset has a single entry in getPorts. \u003c/pre\u003e\n */\n  @Test void testEndpointsPortSinglePort(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - primary-port-name is null. \u003c/pre\u003e\n */\n  @Test void testEndpointsPortNullPrimaryPortName(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - primary-port-name is \"three\", such a port name does not exist. \u003c/pre\u003e\n */\n  @Test void testEndpointsPortPrimaryPortNameIsPresentButNotFound(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - primary-port-name is \"two\", such a port name exists and matches 8081 \u003c/pre\u003e\n */\n  @Test void testEndpointsPortPrimaryPortNameFound(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - primary-port-name is \"three\", such a port name does not exist. - https port exists and this one is returned \u003c/pre\u003e\n */\n  @Test void testEndpointsPortPrimaryPortHttps(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - primary-port-name is \"three\", such a port name does not exist. - http port exists and this one is returned \u003c/pre\u003e\n */\n  @Test void testEndpointsPortPrimaryPortHttp(  CapturedOutput output);\n  @Test void testServiceInstance();\n  @Test void testExternalNameServiceInstance();\n  /** \n * type is ExternalName, as such we do nothing.\n */\n  @Test void testPodMetadataExternalName();\n  /** \n * type is not ExternalName, but labels and annotations have not been requested. As such, we do nothing.\n */\n  @Test void testPodMetadataNotExternalNameLabelsNorAnnotationsIncluded();\n  /** \n * \u003cpre\u003e - type is not ExternalName - labels and annotations have been requested - podName is null As such we do nothing. \u003c/pre\u003e\n */\n  @Test void testPodMetadataNotExternalNameLabelsAndAnnotationsIncludedPodNameNull();\n  /** \n * \u003cpre\u003e - type is not ExternalName - labels have been requested - labels are empty - podName is not null. As such we add empty labels to pod metadata. \u003c/pre\u003e\n */\n  @Test void testPodMetadataOnlyLabelsRequestedButAreEmpty(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - type is not ExternalName - labels have been requested - labels are not empty - podName is not null. As such we add non empty labels to pod metadata. \u003c/pre\u003e\n */\n  @Test void testPodMetadataOnlyLabelsRequestedAndAreNotEmpty(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - type is not ExternalName - annotation have been requested - annotation are empty - podName is not null. As such we add empty labels to pod metadata. \u003c/pre\u003e\n */\n  @Test void testPodMetadataOnlyAnnotationsRequestedButAreEmpty(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - type is not ExternalName - annotations have been requested - annotation are not empty - podName is not null. As such we add non empty labels to pod metadata. \u003c/pre\u003e\n */\n  @Test void testPodMetadataOnlyAnnotationsRequestedAndAreNotEmpty(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - type is not ExternalName - annotations have been requested - annotation are not empty - podName is not null. As such we add non empty labels to pod metadata. \u003c/pre\u003e\n */\n  @Test void testPodMetadataBothLabelsAndAnnotations(  CapturedOutput output);\n  private String filterOnK8sNamespaceAndType(  Map\u003cString,String\u003e result);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/discovery/KubernetesServiceInstanceTests.java",
        "name": "KubernetesServiceInstanceTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.KubernetesServiceInstanceTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesServiceInstanceTests {\n  @Test void testFirstConstructor(){\n    DefaultKubernetesServiceInstance instance\u003dnew DefaultKubernetesServiceInstance(\"instanceId\",\"serviceId\",\"host\",8080,Map.of(\"k8s_namespace\",\"spring-k8s\"),true);\n    assertThat(instance.getInstanceId()).isEqualTo(\"instanceId\");\n    assertThat(instance.getServiceId()).isEqualTo(\"serviceId\");\n    assertThat(instance.getHost()).isEqualTo(\"host\");\n    assertThat(instance.getPort()).isEqualTo(8080);\n    assertThat(instance.isSecure()).isTrue();\n    assertThat(instance.getUri()).isEqualTo(URI.create(\"https://host:8080\"));\n    assertThat(instance.getMetadata()).isEqualTo(Map.of(\"k8s_namespace\",\"spring-k8s\"));\n    assertThat(instance.getScheme()).isEqualTo(\"https\");\n    assertThat(instance.getNamespace()).isEqualTo(\"spring-k8s\");\n    assertThat(instance.getCluster()).isNull();\n    assertThat(instance.podMetadata()).isEqualTo(Map.of());\n  }\n  @Test void testSecondConstructor(){\n    DefaultKubernetesServiceInstance instance\u003dnew DefaultKubernetesServiceInstance(\"instanceId\",\"serviceId\",\"host\",8080,Map.of(\"a\",\"b\"),true,\"spring-k8s\",\"cluster\");\n    assertThat(instance.getInstanceId()).isEqualTo(\"instanceId\");\n    assertThat(instance.getServiceId()).isEqualTo(\"serviceId\");\n    assertThat(instance.getHost()).isEqualTo(\"host\");\n    assertThat(instance.getPort()).isEqualTo(8080);\n    assertThat(instance.isSecure()).isTrue();\n    assertThat(instance.getUri()).isEqualTo(URI.create(\"https://host:8080\"));\n    assertThat(instance.getMetadata()).isEqualTo(Map.of(\"a\",\"b\"));\n    assertThat(instance.getScheme()).isEqualTo(\"https\");\n    assertThat(instance.getNamespace()).isEqualTo(\"spring-k8s\");\n    assertThat(instance.getCluster()).isEqualTo(\"cluster\");\n    assertThat(instance.podMetadata()).isEqualTo(Map.of());\n  }\n  @Test void testThirdConstructor(){\n    DefaultKubernetesServiceInstance instance\u003dnew DefaultKubernetesServiceInstance(\"instanceId\",\"serviceId\",\"host\",8080,Map.of(\"a\",\"b\"),true,\"spring-k8s\",\"cluster\",Map.of(\"labels\",Map.of(\"a\",\"b\"),\"annotations\",Map.of(\"c\",\"d\")));\n    assertThat(instance.getInstanceId()).isEqualTo(\"instanceId\");\n    assertThat(instance.getServiceId()).isEqualTo(\"serviceId\");\n    assertThat(instance.getHost()).isEqualTo(\"host\");\n    assertThat(instance.getPort()).isEqualTo(8080);\n    assertThat(instance.isSecure()).isTrue();\n    assertThat(instance.getUri()).isEqualTo(URI.create(\"https://host:8080\"));\n    assertThat(instance.getMetadata()).isEqualTo(Map.of(\"a\",\"b\"));\n    assertThat(instance.getScheme()).isEqualTo(\"https\");\n    assertThat(instance.getNamespace()).isEqualTo(\"spring-k8s\");\n    assertThat(instance.getCluster()).isEqualTo(\"cluster\");\n    assertThat(instance.podMetadata()).isEqualTo(Map.of(\"labels\",Map.of(\"a\",\"b\"),\"annotations\",Map.of(\"c\",\"d\")));\n  }\n  @Test void schemeIsHttp(){\n    assertServiceInstance(false);\n  }\n  @Test void schemeIsHttps(){\n    assertServiceInstance(true);\n  }\n  private DefaultKubernetesServiceInstance assertServiceInstance(  boolean secure){\n    DefaultKubernetesServiceInstance instance\u003dnew DefaultKubernetesServiceInstance(\"123\",\"myservice\",\"1.2.3.4\",8080,Collections.emptyMap(),secure);\n    assertThat(instance.getInstanceId()).isEqualTo(\"123\");\n    assertThat(instance.getServiceId()).isEqualTo(\"myservice\");\n    assertThat(instance.getHost()).isEqualTo(\"1.2.3.4\");\n    assertThat(instance.getPort()).isEqualTo(8080);\n    assertThat(instance.isSecure()).isEqualTo(secure);\n    assertThat(instance.getScheme()).isEqualTo(secure ? \"https\" : \"http\");\n    return instance;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesServiceInstanceTests {\n  @Test void testFirstConstructor();\n  @Test void testSecondConstructor();\n  @Test void testThirdConstructor();\n  @Test void schemeIsHttp();\n  @Test void schemeIsHttps();\n  private DefaultKubernetesServiceInstance assertServiceInstance(  boolean secure);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/discovery/KubernetesDiscoveryPropertiesTests.java",
        "name": "KubernetesDiscoveryPropertiesTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.KubernetesDiscoveryPropertiesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryPropertiesTests {\n  @Test void testBindingWhenNoPropertiesProvided(){\n    new ApplicationContextRunner().withUserConfiguration(KubernetesDiscoveryPropertiesMetadataTests.Config.class).run(context -\u003e {\n      KubernetesDiscoveryProperties props\u003dcontext.getBean(KubernetesDiscoveryProperties.class);\n      assertThat(props).isNotNull();\n      assertThat(props.metadata().labelsPrefix()).isNull();\n      assertThat(props.metadata().addPorts()).isTrue();\n      assertThat(props.metadata().portsPrefix()).isEqualTo(\"port.\");\n      assertThat(props.enabled()).isTrue();\n      assertThat(props.allNamespaces()).isFalse();\n      assertThat(props.namespaces()).isEmpty();\n      assertThat(props.waitCacheReady()).isTrue();\n      assertThat(props.cacheLoadingTimeoutSeconds()).isEqualTo(60);\n      assertThat(props.includeNotReadyAddresses()).isFalse();\n      assertThat(props.filter()).isNull();\n      assertThat(props.knownSecurePorts()).isEqualTo(Set.of(443,8443));\n      assertThat(props.serviceLabels()).isEmpty();\n      assertThat(props.primaryPortName()).isNull();\n      assertThat(props.order()).isZero();\n      assertThat(props.useEndpointSlices()).isFalse();\n      assertThat(props.includeExternalNameServices()).isFalse();\n      assertThat(props.discoveryServerUrl()).isNull();\n    }\n);\n  }\n  @Test void testBindingWhenSomePropertiesProvided(){\n    new ApplicationContextRunner().withUserConfiguration(KubernetesDiscoveryPropertiesMetadataTests.Config.class).withPropertyValues(\"spring.cloud.kubernetes.discovery.filter\u003dsome-filter\",\"spring.cloud.kubernetes.discovery.knownSecurePorts[0]\u003d222\",\"spring.cloud.kubernetes.discovery.metadata.labelsPrefix\u003dlabelsPrefix\",\"spring.cloud.kubernetes.discovery.use-endpoint-slices\u003dtrue\",\"spring.cloud.kubernetes.discovery.namespaces[0]\u003dns1\",\"spring.cloud.kubernetes.discovery.namespaces[1]\u003dns2\",\"spring.cloud.kubernetes.discovery.include-external-name-services\u003dtrue\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://example\").run(context -\u003e {\n      KubernetesDiscoveryProperties props\u003dcontext.getBean(KubernetesDiscoveryProperties.class);\n      assertThat(props).isNotNull();\n      assertThat(props.metadata().labelsPrefix()).isEqualTo(\"labelsPrefix\");\n      assertThat(props.metadata().addPorts()).isTrue();\n      assertThat(props.metadata().portsPrefix()).isEqualTo(\"port.\");\n      assertThat(props.enabled()).isTrue();\n      assertThat(props.allNamespaces()).isFalse();\n      assertThat(props.namespaces()).containsExactlyInAnyOrder(\"ns1\",\"ns2\");\n      assertThat(props.waitCacheReady()).isTrue();\n      assertThat(props.cacheLoadingTimeoutSeconds()).isEqualTo(60);\n      assertThat(props.includeNotReadyAddresses()).isFalse();\n      assertThat(props.filter()).isEqualTo(\"some-filter\");\n      assertThat(props.knownSecurePorts()).isEqualTo(Set.of(222));\n      assertThat(props.serviceLabels()).isEmpty();\n      assertThat(props.primaryPortName()).isNull();\n      assertThat(props.order()).isZero();\n      assertThat(props.useEndpointSlices()).isTrue();\n      assertThat(props.includeExternalNameServices()).isTrue();\n      assertThat(props.discoveryServerUrl()).isEqualTo(\"http://example\");\n    }\n);\n  }\n  @Test void metadataSetToNotNull(){\n    new ApplicationContextRunner().withUserConfiguration(KubernetesDiscoveryPropertiesMetadataTests.Config.class).withPropertyValues(\"spring.cloud.kubernetes.discovery.filter\u003dsome-filter\").run(context -\u003e {\n      KubernetesDiscoveryProperties props\u003dcontext.getBean(KubernetesDiscoveryProperties.class);\n      assertThat(props).isNotNull();\n      assertThat(props.metadata().labelsPrefix()).isNull();\n      assertThat(props.metadata().addPorts()).isTrue();\n      assertThat(props.metadata().portsPrefix()).isEqualTo(\"port.\");\n    }\n);\n  }\n@Configuration @EnableConfigurationProperties(KubernetesDiscoveryProperties.class) static class Config {\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryPropertiesTests {\n  @Test void testBindingWhenNoPropertiesProvided();\n  @Test void testBindingWhenSomePropertiesProvided();\n  @Test void metadataSetToNotNull();\n@Configuration @EnableConfigurationProperties(KubernetesDiscoveryProperties.class) static class Config {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/discovery/KubernetesDiscoveryClientHealthIndicatorInitializerTests.java",
        "name": "KubernetesDiscoveryClientHealthIndicatorInitializerTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.KubernetesDiscoveryClientHealthIndicatorInitializerTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57Tests the {@link org.springframework.cloud.kubernetes.commons.discovery.KubernetesDiscoveryClientHealthIndicatorInitializer}with the fabric8 client.\n */\nclass KubernetesDiscoveryClientHealthIndicatorInitializerTests {\n  private static ApplicationEventPublisher publisher;\n  private static final Object POD\u003dMockito.mock(Object.class);\n  @AfterEach void afterEach(){\n    Mockito.reset(publisher,POD);\n  }\n  @Test @SuppressWarnings(\"unchecked\") void testInstanceRegistrationEventPublishedWhenInsideK8s(){\n    new ApplicationContextRunner().withUserConfiguration(InstanceRegistrationEventPublishedInsideK8sConfiguration.class).run(context -\u003e assertThat(context).hasSingleBean(PodUtils.class));\n    ArgumentCaptor\u003cInstanceRegisteredEvent\u003cRegisteredEventSource\u003e\u003e captor\u003dArgumentCaptor.forClass(InstanceRegisteredEvent.class);\n    Mockito.verify(publisher,Mockito.times(1)).publishEvent(captor.capture());\n    KubernetesDiscoveryClientHealthIndicatorInitializer.RegisteredEventSource source\u003d(KubernetesDiscoveryClientHealthIndicatorInitializer.RegisteredEventSource)captor.getValue().getSource();\n    assertThat(source.cloudPlatform()).isEqualTo(\"kubernetes\");\n    assertThat(source.inside()).isTrue();\n    assertThat(source.pod()).isSameAs(POD);\n  }\n  @Test @SuppressWarnings(\"unchecked\") void testInstanceRegistrationEventPublishedWhenOutsideK8s(){\n    new ApplicationContextRunner().withUserConfiguration(InstanceRegistrationEventPublishedOutsideK8sConfiguration.class).run(context -\u003e assertThat(context).hasSingleBean(PodUtils.class));\n    ArgumentCaptor\u003cInstanceRegisteredEvent\u003cRegisteredEventSource\u003e\u003e captor\u003dArgumentCaptor.forClass(InstanceRegisteredEvent.class);\n    Mockito.verify(publisher,Mockito.times(1)).publishEvent(captor.capture());\n    KubernetesDiscoveryClientHealthIndicatorInitializer.RegisteredEventSource source\u003d(KubernetesDiscoveryClientHealthIndicatorInitializer.RegisteredEventSource)captor.getValue().getSource();\n    assertThat(source.cloudPlatform()).isEqualTo(\"kubernetes\");\n    assertThat(source.inside()).isFalse();\n    assertThat(source.pod()).isNotNull();\n  }\n@Configuration static class InstanceRegistrationEventPublishedInsideK8sConfiguration {\n    @Bean @SuppressWarnings(\"unchecked\") PodUtils\u003cObject\u003e podUtils(){\n      PodUtils\u003cObject\u003e podUtils\u003dMockito.mock(PodUtils.class);\n      Mockito.when(podUtils.isInsideKubernetes()).thenReturn(true);\n      Mockito.when(podUtils.currentPod()).thenReturn(() -\u003e POD);\n      return podUtils;\n    }\n    @Bean @Primary ApplicationEventPublisher publisher(){\n      publisher\u003dMockito.mock(ApplicationEventPublisher.class);\n      return publisher;\n    }\n    @Bean KubernetesDiscoveryClientHealthIndicatorInitializer indicatorInitializer(    PodUtils\u003cObject\u003e podUtils,    ApplicationEventPublisher publisher){\n      return new KubernetesDiscoveryClientHealthIndicatorInitializer(podUtils,publisher);\n    }\n  }\n@Configuration static class InstanceRegistrationEventPublishedOutsideK8sConfiguration {\n    @Bean @SuppressWarnings(\"unchecked\") PodUtils\u003cObject\u003e podUtils(){\n      PodUtils\u003cObject\u003e podUtils\u003dMockito.mock(PodUtils.class);\n      Mockito.when(podUtils.isInsideKubernetes()).thenReturn(false);\n      Mockito.when(podUtils.currentPod()).thenReturn(() -\u003e POD);\n      return podUtils;\n    }\n    @Bean @Primary ApplicationEventPublisher publisher(){\n      publisher\u003dMockito.mock(ApplicationEventPublisher.class);\n      return publisher;\n    }\n    @Bean KubernetesDiscoveryClientHealthIndicatorInitializer indicatorInitializer(    PodUtils\u003cObject\u003e podUtils,    ApplicationEventPublisher publisher){\n      return new KubernetesDiscoveryClientHealthIndicatorInitializer(podUtils,publisher);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57Tests the {@link org.springframework.cloud.kubernetes.commons.discovery.KubernetesDiscoveryClientHealthIndicatorInitializer}with the fabric8 client.\n */\nclass KubernetesDiscoveryClientHealthIndicatorInitializerTests {\n  private static ApplicationEventPublisher publisher;\n  private static final Object POD\u003dMockito.mock(Object.class);\n  @AfterEach void afterEach();\n  @Test @SuppressWarnings(\"unchecked\") void testInstanceRegistrationEventPublishedWhenInsideK8s();\n  @Test @SuppressWarnings(\"unchecked\") void testInstanceRegistrationEventPublishedWhenOutsideK8s();\n@Configuration static class InstanceRegistrationEventPublishedInsideK8sConfiguration {\n    @Bean @SuppressWarnings(\"unchecked\") PodUtils\u003cObject\u003e podUtils();\n    @Bean @Primary ApplicationEventPublisher publisher();\n    @Bean KubernetesDiscoveryClientHealthIndicatorInitializer indicatorInitializer(    PodUtils\u003cObject\u003e podUtils,    ApplicationEventPublisher publisher);\n  }\n@Configuration static class InstanceRegistrationEventPublishedOutsideK8sConfiguration {\n    @Bean @SuppressWarnings(\"unchecked\") PodUtils\u003cObject\u003e podUtils();\n    @Bean @Primary ApplicationEventPublisher publisher();\n    @Bean KubernetesDiscoveryClientHealthIndicatorInitializer indicatorInitializer(    PodUtils\u003cObject\u003e podUtils,    ApplicationEventPublisher publisher);\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/discovery/KubernetesDiscoveryPropertiesMetadataTests.java",
        "name": "KubernetesDiscoveryPropertiesMetadataTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.discovery.KubernetesDiscoveryPropertiesMetadataTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryPropertiesMetadataTests {\n  @Test void testDefaultConstructor(){\n    Metadata m\u003dMetadata.DEFAULT;\n    assertThat(m.addLabels()).isTrue();\n    assertThat(m.labelsPrefix()).isNull();\n    assertThat(m.addAnnotations()).isTrue();\n    assertThat(m.annotationsPrefix()).isNull();\n    assertThat(m.addPorts()).isTrue();\n    assertThat(m.portsPrefix()).isEqualTo(\"port.\");\n    assertThat(m.addPodLabels()).isFalse();\n    assertThat(m.addPodAnnotations()).isFalse();\n  }\n  @Test void testSpringBindingFields(){\n    new ApplicationContextRunner().withUserConfiguration(Config.class).withPropertyValues(\"spring.cloud.kubernetes.discovery.metadata.labelsPrefix\u003dlabelsPrefix\",\"spring.cloud.kubernetes.discovery.metadata.add-pod-annotations\u003dtrue\",\"spring.cloud.kubernetes.discovery.metadata.add-pod-labels\u003dtrue\").run(context -\u003e {\n      KubernetesDiscoveryProperties props\u003dcontext.getBean(KubernetesDiscoveryProperties.class);\n      assertThat(props).isNotNull();\n      assertThat(props.metadata().labelsPrefix()).isEqualTo(\"labelsPrefix\");\n      assertThat(props.metadata().addPorts()).isTrue();\n      assertThat(props.metadata().portsPrefix()).isEqualTo(\"port.\");\n      assertThat(props.metadata().addPodLabels()).isTrue();\n      assertThat(props.metadata().addPodAnnotations()).isTrue();\n    }\n);\n  }\n@Configuration @EnableConfigurationProperties(KubernetesDiscoveryProperties.class) static class Config {\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryPropertiesMetadataTests {\n  @Test void testDefaultConstructor();\n  @Test void testSpringBindingFields();\n@Configuration @EnableConfigurationProperties(KubernetesDiscoveryProperties.class) static class Config {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/KubernetesNamespaceProviderTests.java",
        "name": "KubernetesNamespaceProviderTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.KubernetesNamespaceProviderTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass KubernetesNamespaceProviderTests {\n  private static final String PATH\u003d\"/some/path\";\n  private MockedStatic\u003cPaths\u003e paths;\n  @BeforeEach void before(){\n    paths\u003dMockito.mockStatic(Paths.class);\n  }\n  @AfterEach void after(){\n    paths.close();\n  }\n  @Test void getNamespace(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(NAMESPACE_PROPERTY,\"mynamespace\");\n    KubernetesNamespaceProvider p1\u003dnew KubernetesNamespaceProvider(environment);\n    assertThat(p1.getNamespace()).isEqualTo(\"mynamespace\");\n    paths.verify(() -\u003e Paths.get(PATH),times(0));\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass KubernetesNamespaceProviderTests {\n  private static final String PATH\u003d\"/some/path\";\n  private MockedStatic\u003cPaths\u003e paths;\n  @BeforeEach void before();\n  @AfterEach void after();\n  @Test void getNamespace();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/reload/ConfigReloadAutoConfigurationApplicationContextTests.java",
        "name": "ConfigReloadAutoConfigurationApplicationContextTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.reload.ConfigReloadAutoConfigurationApplicationContextTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass ConfigReloadAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  /** \n * no special properties provided.\n */\n  @Test void testDefault(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(TaskSchedulerWrapper.class));\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(ConfigurationUpdateStrategy.class));\n  }\n  /** \n * reload is disabled.\n */\n  @Test void testReloadDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e assertThat(context).doesNotHaveBean(TaskSchedulerWrapper.class));\n    applicationContextRunner.run(context -\u003e assertThat(context).doesNotHaveBean(ConfigurationUpdateStrategy.class));\n  }\n  /** \n * config maps support is enabled.\n */\n  @Test void testConfigMapsSupportEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.config.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(TaskSchedulerWrapper.class));\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(ConfigurationUpdateStrategy.class));\n  }\n  /** \n * secrets support is enabled.\n */\n  @Test void testSecretsSupportEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(TaskSchedulerWrapper.class));\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(ConfigurationUpdateStrategy.class));\n  }\n  /** \n * config maps and secrets support is enabled.\n */\n  @Test void testConfigMapsAndSecretsSupportEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.config.enabled\u003dtrue\",\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(TaskSchedulerWrapper.class));\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(ConfigurationUpdateStrategy.class));\n  }\n  /** \n * config maps and secrets support is disabled.\n */\n  @Test void testConfigMapsAndSecretsSupportDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e assertThat(context).doesNotHaveBean(TaskSchedulerWrapper.class));\n    applicationContextRunner.run(context -\u003e assertThat(context).doesNotHaveBean(ConfigurationUpdateStrategy.class));\n  }\n  /** \n * config maps support disabled and secrets support is enabled.\n */\n  @Test void testConfigMapsDisabledAndSecretsSupportEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(TaskSchedulerWrapper.class));\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(ConfigurationUpdateStrategy.class));\n  }\n  /** \n * config maps support enabled and secrets support is disable.\n */\n  @Test void testConfigMapsEnabledAndSecretsSupportDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.config.enabled\u003dtrue\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(TaskSchedulerWrapper.class));\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(ConfigurationUpdateStrategy.class));\n  }\n  private void setup(  String... properties){\n    applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(InfoEndpointAutoConfiguration.class,RefreshEndpointAutoConfiguration.class,ConfigReloadPropertiesAutoConfiguration.class,RefreshAutoConfiguration.class,ConfigReloadAutoConfiguration.class)).withUserConfiguration(RebinderConfig.class).withPropertyValues(properties);\n  }\n@TestConfiguration static class RebinderConfig {\n    @Bean ConfigurationPropertiesRebinder rebinder(){\n      return Mockito.mock(ConfigurationPropertiesRebinder.class);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass ConfigReloadAutoConfigurationApplicationContextTests {\n  private ApplicationContextRunner applicationContextRunner;\n  /** \n * no special properties provided.\n */\n  @Test void testDefault();\n  /** \n * reload is disabled.\n */\n  @Test void testReloadDisabled();\n  /** \n * config maps support is enabled.\n */\n  @Test void testConfigMapsSupportEnabled();\n  /** \n * secrets support is enabled.\n */\n  @Test void testSecretsSupportEnabled();\n  /** \n * config maps and secrets support is enabled.\n */\n  @Test void testConfigMapsAndSecretsSupportEnabled();\n  /** \n * config maps and secrets support is disabled.\n */\n  @Test void testConfigMapsAndSecretsSupportDisabled();\n  /** \n * config maps support disabled and secrets support is enabled.\n */\n  @Test void testConfigMapsDisabledAndSecretsSupportEnabled();\n  /** \n * config maps support enabled and secrets support is disable.\n */\n  @Test void testConfigMapsEnabledAndSecretsSupportDisabled();\n  private void setup(  String... properties);\n@TestConfiguration static class RebinderConfig {\n    @Bean ConfigurationPropertiesRebinder rebinder();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/leader/LeaderInfoContributorTests.java",
        "name": "LeaderInfoContributorTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.leader.LeaderInfoContributorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass LeaderInfoContributorTests {\n  @Test void testLeaderMissing(){\n    Candidate candidate\u003dnew DefaultCandidate(\"id\",\"role\");\n    LeaderProperties leaderProperties\u003dnew LeaderProperties();\n    LeaderEventPublisher leaderEventPublisher\u003dMockito.mock(LeaderEventPublisher.class);\n    LeadershipController leadershipController\u003dnew LeadershipControllerStub(candidate,leaderProperties,leaderEventPublisher);\n    LeaderInfoContributor leaderInfoContributor\u003dnew LeaderInfoContributor(leadershipController,candidate);\n    Info.Builder builder\u003dnew Info.Builder();\n    leaderInfoContributor.contribute(builder);\n    Assertions.assertEquals(builder.build().getDetails().get(\"leaderElection\"),Map.of(\"leaderId\",\"Unknown\"));\n  }\n  @Test void testLeaderPresentIsLeader(){\n    Candidate candidate\u003dnew DefaultCandidate(\"leaderId\",\"leaderRole\");\n    LeaderProperties leaderProperties\u003dnew LeaderProperties();\n    LeaderEventPublisher leaderEventPublisher\u003dMockito.mock(LeaderEventPublisher.class);\n    LeadershipController leadershipController\u003dnew LeadershipControllerStub(candidate,leaderProperties,leaderEventPublisher);\n    Leader leader\u003dnew Leader(\"leaderRole\",\"leaderId\");\n    leadershipController.handleLeaderChange(leader);\n    LeaderInfoContributor leaderInfoContributor\u003dnew LeaderInfoContributor(leadershipController,candidate);\n    Info.Builder builder\u003dnew Info.Builder();\n    leaderInfoContributor.contribute(builder);\n    Assertions.assertEquals(builder.build().getDetails().get(\"leaderElection\"),Map.of(\"role\",\"leaderRole\",\"isLeader\",true,\"leaderId\",\"leaderId\"));\n  }\n  @Test void testLeaderPresentIsNotLeader(){\n    Candidate candidate\u003dnew DefaultCandidate(\"leaderId\",\"notLeaderRole\");\n    LeaderProperties leaderProperties\u003dnew LeaderProperties();\n    LeaderEventPublisher leaderEventPublisher\u003dMockito.mock(LeaderEventPublisher.class);\n    LeadershipController leadershipController\u003dnew LeadershipControllerStub(candidate,leaderProperties,leaderEventPublisher);\n    Leader leader\u003dnew Leader(\"leaderRole\",\"leaderId\");\n    leadershipController.handleLeaderChange(leader);\n    LeaderInfoContributor leaderInfoContributor\u003dnew LeaderInfoContributor(leadershipController,candidate);\n    Info.Builder builder\u003dnew Info.Builder();\n    leaderInfoContributor.contribute(builder);\n    Assertions.assertEquals(builder.build().getDetails().get(\"leaderElection\"),Map.of(\"role\",\"leaderRole\",\"isLeader\",false,\"leaderId\",\"leaderId\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass LeaderInfoContributorTests {\n  @Test void testLeaderMissing();\n  @Test void testLeaderPresentIsLeader();\n  @Test void testLeaderPresentIsNotLeader();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/leader/LeaderUtilsTests.java",
        "name": "LeaderUtilsTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.leader.LeaderUtilsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass LeaderUtilsTests {\n  @Test void hostNameReadFromEnvProperty() throws UnknownHostException {\n    MockedStatic\u003cEnvReader\u003e envReaderMockedStatic\u003dMockito.mockStatic(EnvReader.class);\n    envReaderMockedStatic.when(() -\u003e EnvReader.getEnv(\"HOSTNAME\")).thenReturn(\"from-env\");\n    String hostname\u003dLeaderUtils.hostName();\n    Assertions.assertEquals(\"from-env\",hostname);\n    envReaderMockedStatic.close();\n  }\n  @Test void hostNameReadFromApiCall() throws UnknownHostException {\n    MockedStatic\u003cEnvReader\u003e envReaderMockedStatic\u003dMockito.mockStatic(EnvReader.class);\n    envReaderMockedStatic.when(() -\u003e EnvReader.getEnv(\"HOSTNAME\")).thenReturn(\"\");\n    MockedStatic\u003cInetAddress\u003e inet4AddressMockedStatic\u003dMockito.mockStatic(InetAddress.class);\n    InetAddress inetAddress\u003dMockito.mock(InetAddress.class);\n    Mockito.when(inetAddress.getHostName()).thenReturn(\"from-api-call\");\n    inet4AddressMockedStatic.when(InetAddress::getLocalHost).thenReturn(inetAddress);\n    String hostname\u003dLeaderUtils.hostName();\n    Assertions.assertEquals(\"from-api-call\",hostname);\n    envReaderMockedStatic.close();\n    inet4AddressMockedStatic.close();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass LeaderUtilsTests {\n  @Test void hostNameReadFromEnvProperty() throws UnknownHostException;\n  @Test void hostNameReadFromApiCall() throws UnknownHostException;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/leader/LeadershipControllerStub.java",
        "name": "LeadershipControllerStub",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.leader.LeadershipControllerStub",
        "extend": "LeadershipController",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nfinal class LeadershipControllerStub extends LeadershipController {\n  private Leader leader;\n  LeadershipControllerStub(  Candidate candidate,  LeaderProperties leaderProperties,  LeaderEventPublisher leaderEventPublisher){\n    super(candidate,leaderProperties,leaderEventPublisher);\n  }\n  @Override public void update(){\n  }\n  @Override public void revoke(){\n  }\n  @Override protected PodReadinessWatcher createPodReadinessWatcher(  String localLeaderId){\n    return null;\n  }\n  @Override protected void handleLeaderChange(  Leader leader){\n    this.leader\u003dleader;\n  }\n  @Override public Optional\u003cLeader\u003e getLocalLeader(){\n    return Optional.ofNullable(leader);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class LeadershipControllerStub extends LeadershipController {\n  private Leader leader;\n  LeadershipControllerStub(  Candidate candidate,  LeaderProperties leaderProperties,  LeaderEventPublisher leaderEventPublisher);\n  @Override public void update();\n  @Override public void revoke();\n  @Override protected PodReadinessWatcher createPodReadinessWatcher(  String localLeaderId);\n  @Override protected void handleLeaderChange(  Leader leader);\n  @Override public Optional\u003cLeader\u003e getLocalLeader();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/profile/KubernetesProfileEnvironmentPostProcessorTest.java",
        "name": "KubernetesProfileEnvironmentPostProcessorTest",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.profile.KubernetesProfileEnvironmentPostProcessorTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\npublic class KubernetesProfileEnvironmentPostProcessorTest {\n  private static final String FOUNT_IT\u003d\"foundIt\";\n  private static final String PATH\u003d\"/some/path\";\n  private MockedStatic\u003cPaths\u003e paths;\n  private MockedStatic\u003cFiles\u003e files;\n  private final SpringApplication springApplication\u003dMockito.mock(SpringApplication.class);\n  private final ConfigurableApplicationContext context\u003dnew AnnotationConfigApplicationContext();\n  private static final AbstractKubernetesProfileEnvironmentPostProcessor POST_PROCESSOR_INSIDE\u003dnew AbstractKubernetesProfileEnvironmentPostProcessor(){\n    @Override protected boolean isInsideKubernetes(    Environment environment){\n      return true;\n    }\n  }\n;\n  private static final AbstractKubernetesProfileEnvironmentPostProcessor POST_PROCESSOR_OUTSIDE\u003dnew AbstractKubernetesProfileEnvironmentPostProcessor(){\n    @Override protected boolean isInsideKubernetes(    Environment environment){\n      return false;\n    }\n  }\n;\n  @BeforeEach public void before(){\n    paths\u003dMockito.mockStatic(Paths.class);\n    files\u003dMockito.mockStatic(Files.class);\n  }\n  @AfterEach public void after(){\n    paths.close();\n    files.close();\n  }\n  /** \n * \u003cpre\u003e 1) not running on kubernetes \u003c/pre\u003e\n */\n  @Test public void testKubernetesDisabled(){\n    TestPropertySourceUtils.addInlinedPropertiesToEnvironment(context);\n    POST_PROCESSOR_INSIDE.postProcessEnvironment(context.getEnvironment(),springApplication);\n    assertKubernetesProfileNotPresent();\n    assertKubernetesPropertySourceNotPresent();\n  }\n  /** \n * \u003cpre\u003e 1) \"spring.main.cloud-platform\u003dKUBERNETES\" 2) \"spring.cloud.kubernetes.client.serviceAccountNamespacePath\" is present, but does not resolve to an actual File \u003c/pre\u003e\n */\n  @Test public void testKubernetesEnabledAndServiceAccountNamespacePathIsNotResolved(){\n    TestPropertySourceUtils.addInlinedPropertiesToEnvironment(context,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.serviceAccountNamespacePath\u003d\" + PATH);\n    serviceAccountFileResolved(false,PATH);\n    POST_PROCESSOR_INSIDE.postProcessEnvironment(context.getEnvironment(),springApplication);\n    assertKubernetesProfilePresent();\n    assertKubernetesPropertySourceNotPresent();\n  }\n  /** \n * \u003cpre\u003e 1) \"spring.main.cloud-platform\u003dKUBERNETES\" 2) \"spring.cloud.kubernetes.client.serviceAccountNamespacePath\" is present and resolves to an actual File \u003c/pre\u003e\n */\n  @Test public void testKubernetesEnabledAndServiceAccountNamespacePathIsResolved(){\n    TestPropertySourceUtils.addInlinedPropertiesToEnvironment(context,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.client.serviceAccountNamespacePath\u003d\" + PATH);\n    Path path\u003dserviceAccountFileResolved(true,PATH);\n    mockServiceAccountNamespace(path);\n    POST_PROCESSOR_INSIDE.postProcessEnvironment(context.getEnvironment(),springApplication);\n    assertKubernetesProfilePresent();\n    assertKubernetesPropertySourcePresent();\n  }\n  /** \n * \u003cpre\u003e 1) \"spring.main.cloud-platform\u003dKUBERNETES\" 2) \"spring.cloud.kubernetes.client.serviceAccountNamespacePath\" is not present, as such: 3) \"/var/run/secrets/kubernetes.io/serviceaccount/namespace\" is picked up, which is resolved and present \u003c/pre\u003e\n */\n  @Test public void testKubernetesEnabledAndServiceAccountNamespacePathIsResolvedViaDefaultLocation(){\n    TestPropertySourceUtils.addInlinedPropertiesToEnvironment(context,\"spring.main.cloud-platform\u003dKUBERNETES\");\n    Path path\u003dserviceAccountFileResolved(true,\"/var/run/secrets/kubernetes.io/serviceaccount/namespace\");\n    mockServiceAccountNamespace(path);\n    POST_PROCESSOR_INSIDE.postProcessEnvironment(context.getEnvironment(),springApplication);\n    assertKubernetesProfilePresent();\n    assertKubernetesPropertySourcePresent();\n  }\n  /** \n * \u003cpre\u003e 1) \"spring.main.cloud-platform\u003dKUBERNETES\" 2) isInsideKubernetes returns false 3) \"spring.cloud.kubernetes.client.serviceAccountNamespacePath\" is not present, as such: 4) \"/var/run/secrets/kubernetes.io/serviceaccount/namespace\" is picked up, which is resolved and present \u003c/pre\u003e\n */\n  @Test public void testOutsideKubernetes(){\n    TestPropertySourceUtils.addInlinedPropertiesToEnvironment(context,\"spring.main.cloud-platform\u003dKUBERNETES\");\n    Path path\u003dserviceAccountFileResolved(true,\"/var/run/secrets/kubernetes.io/serviceaccount/namespace\");\n    mockServiceAccountNamespace(path);\n    POST_PROCESSOR_OUTSIDE.postProcessEnvironment(context.getEnvironment(),springApplication);\n    assertKubernetesProfileNotPresent();\n    assertKubernetesPropertySourcePresent();\n  }\n  private void assertKubernetesProfileNotPresent(){\n    Assertions.assertFalse(kubernetesProfile().isPresent(),\"\u0027kubernetes\u0027 profile must not be present when not running in kubernetes\");\n  }\n  private void assertKubernetesProfilePresent(){\n    Assertions.assertTrue(kubernetesProfile().isPresent(),\"\u0027kubernetes\u0027 profile must be present when running in kubernetes\");\n  }\n  private void assertKubernetesPropertySourceNotPresent(){\n    Optional\u003cPropertySource\u003c?\u003e\u003e kubernetesPropertySource\u003dkubernetesPropertySource();\n    Assertions.assertFalse(kubernetesPropertySource.isPresent(),\"\u0027KUBERNETES_NAMESPACE_PROPERTY_SOURCE\u0027 source must not be present when not running on kubernetes\");\n  }\n  private void assertKubernetesPropertySourcePresent(){\n    Optional\u003cPropertySource\u003c?\u003e\u003e kubernetesPropertySource\u003dkubernetesPropertySource();\n    Assertions.assertTrue(kubernetesPropertySource.isPresent(),\"\u0027KUBERNETES_NAMESPACE_PROPERTY_SOURCE\u0027 source must be present when running on kubernetes\");\n    String property\u003d(String)kubernetesPropertySource.get().getProperty(\"spring.cloud.kubernetes.client.namespace\");\n    Assertions.assertEquals(property,FOUNT_IT,\"\u0027spring.cloud.kubernetes.client.namespace\u0027 must be set to \u0027foundIt\u0027\");\n  }\n  /** \n * \u003cpre\u003e 1) serviceAccountNamespace File is present or not 2) if the above is present, under what actualPath \u003c/pre\u003e\n */\n  private Path serviceAccountFileResolved(  boolean present,  String actualPath){\n    Path path\u003dMockito.mock(Path.class);\n    paths.when(() -\u003e Paths.get(actualPath)).thenReturn(path);\n    files.when(() -\u003e Files.isRegularFile(path)).thenReturn(present);\n    return path;\n  }\n  private void mockServiceAccountNamespace(  Path path){\n    files.when(() -\u003e Files.readAllBytes(path)).thenReturn(FOUNT_IT.getBytes());\n  }\n  private Optional\u003cString\u003e kubernetesProfile(){\n    return Arrays.stream(context.getEnvironment().getActiveProfiles()).filter(\"kubernetes\"::equals).findFirst();\n  }\n  private Optional\u003cPropertySource\u003c?\u003e\u003e kubernetesPropertySource(){\n    return context.getEnvironment().getPropertySources().stream().filter(x -\u003e \"KUBERNETES_NAMESPACE_PROPERTY_SOURCE\".equals(x.getName())).findAny();\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\npublic class KubernetesProfileEnvironmentPostProcessorTest {\n  private static final String FOUNT_IT\u003d\"foundIt\";\n  private static final String PATH\u003d\"/some/path\";\n  private MockedStatic\u003cPaths\u003e paths;\n  private MockedStatic\u003cFiles\u003e files;\n  private final SpringApplication springApplication\u003dMockito.mock(SpringApplication.class);\n  private final ConfigurableApplicationContext context\u003dnew AnnotationConfigApplicationContext();\n  private static final AbstractKubernetesProfileEnvironmentPostProcessor POST_PROCESSOR_INSIDE\u003dnew AbstractKubernetesProfileEnvironmentPostProcessor(){\n    @Override protected boolean isInsideKubernetes(    Environment environment);\n  }\n;\n  private static final AbstractKubernetesProfileEnvironmentPostProcessor POST_PROCESSOR_OUTSIDE\u003dnew AbstractKubernetesProfileEnvironmentPostProcessor(){\n    @Override protected boolean isInsideKubernetes(    Environment environment);\n  }\n;\n  @BeforeEach public void before();\n  @AfterEach public void after();\n  /** \n * \u003cpre\u003e 1) not running on kubernetes \u003c/pre\u003e\n */\n  @Test public void testKubernetesDisabled();\n  /** \n * \u003cpre\u003e 1) \"spring.main.cloud-platform\u003dKUBERNETES\" 2) \"spring.cloud.kubernetes.client.serviceAccountNamespacePath\" is present, but does not resolve to an actual File \u003c/pre\u003e\n */\n  @Test public void testKubernetesEnabledAndServiceAccountNamespacePathIsNotResolved();\n  /** \n * \u003cpre\u003e 1) \"spring.main.cloud-platform\u003dKUBERNETES\" 2) \"spring.cloud.kubernetes.client.serviceAccountNamespacePath\" is present and resolves to an actual File \u003c/pre\u003e\n */\n  @Test public void testKubernetesEnabledAndServiceAccountNamespacePathIsResolved();\n  /** \n * \u003cpre\u003e 1) \"spring.main.cloud-platform\u003dKUBERNETES\" 2) \"spring.cloud.kubernetes.client.serviceAccountNamespacePath\" is not present, as such: 3) \"/var/run/secrets/kubernetes.io/serviceaccount/namespace\" is picked up, which is resolved and present \u003c/pre\u003e\n */\n  @Test public void testKubernetesEnabledAndServiceAccountNamespacePathIsResolvedViaDefaultLocation();\n  /** \n * \u003cpre\u003e 1) \"spring.main.cloud-platform\u003dKUBERNETES\" 2) isInsideKubernetes returns false 3) \"spring.cloud.kubernetes.client.serviceAccountNamespacePath\" is not present, as such: 4) \"/var/run/secrets/kubernetes.io/serviceaccount/namespace\" is picked up, which is resolved and present \u003c/pre\u003e\n */\n  @Test public void testOutsideKubernetes();\n  private void assertKubernetesProfileNotPresent();\n  private void assertKubernetesProfilePresent();\n  private void assertKubernetesPropertySourceNotPresent();\n  private void assertKubernetesPropertySourcePresent();\n  /** \n * \u003cpre\u003e 1) serviceAccountNamespace File is present or not 2) if the above is present, under what actualPath \u003c/pre\u003e\n */\n  private Path serviceAccountFileResolved(  boolean present,  String actualPath);\n  private void mockServiceAccountNamespace(  Path path);\n  private Optional\u003cString\u003e kubernetesProfile();\n  private Optional\u003cPropertySource\u003c?\u003e\u003e kubernetesPropertySource();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/ConfigUtilsRawDataContainsProfileBasedSourceTests.java",
        "name": "ConfigUtilsRawDataContainsProfileBasedSourceTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConfigUtilsRawDataContainsProfileBasedSourceTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Class that is supposed to test only ConfigUtils::rawDataContainsProfileBasedSource\n * @author wind57\n */\nclass ConfigUtilsRawDataContainsProfileBasedSourceTests {\n  @Test void nullSourceRawData(){\n    List\u003cString\u003e activeProfiles\u003dList.of();\n    Map\u003cString,String\u003e rawData\u003dnull;\n    boolean result\u003dConfigUtils.rawDataContainsProfileBasedSource(activeProfiles,rawData).getAsBoolean();\n    Assertions.assertFalse(result);\n  }\n  @Test void sourceRawDataPresentEmptyActiveProfiles(){\n    List\u003cString\u003e activeProfiles\u003dList.of();\n    Map\u003cString,String\u003e rawData\u003dMap.of(\"account-k8s.yaml\",\"value\");\n    boolean result\u003dConfigUtils.rawDataContainsProfileBasedSource(activeProfiles,rawData).getAsBoolean();\n    Assertions.assertFalse(result);\n  }\n  @Test void plainValuesOnly(){\n    List\u003cString\u003e activeProfiles\u003dList.of(\"k8s\");\n    Map\u003cString,String\u003e rawData\u003dMap.of(\"account\",\"value\");\n    boolean result\u003dConfigUtils.rawDataContainsProfileBasedSource(activeProfiles,rawData).getAsBoolean();\n    Assertions.assertFalse(result);\n  }\n  @Test void noMatchInActiveProfiles(){\n    List\u003cString\u003e activeProfiles\u003dList.of(\"k8s\");\n    Map\u003cString,String\u003e rawData\u003dMap.of(\"account-dev.yml\",\"value\");\n    boolean result\u003dConfigUtils.rawDataContainsProfileBasedSource(activeProfiles,rawData).getAsBoolean();\n    Assertions.assertFalse(result);\n  }\n  @Test void matchInActiveProfilesWithYml(){\n    List\u003cString\u003e activeProfiles\u003dList.of(\"dev\");\n    Map\u003cString,String\u003e rawData\u003dMap.of(\"account-dev.yml\",\"value\");\n    boolean result\u003dConfigUtils.rawDataContainsProfileBasedSource(activeProfiles,rawData).getAsBoolean();\n    Assertions.assertTrue(result);\n  }\n  @Test void matchInActiveProfilesWithYaml(){\n    List\u003cString\u003e activeProfiles\u003dList.of(\"dev\",\"k8s\");\n    Map\u003cString,String\u003e rawData\u003dMap.of(\"account-dev.yaml\",\"value\");\n    boolean result\u003dConfigUtils.rawDataContainsProfileBasedSource(activeProfiles,rawData).getAsBoolean();\n    Assertions.assertTrue(result);\n  }\n  @Test void matchInActiveProfilesWithProperties(){\n    List\u003cString\u003e activeProfiles\u003dList.of(\"dev\",\"k8s\");\n    Map\u003cString,String\u003e rawData\u003dMap.of(\"account-dev.properties\",\"value\");\n    boolean result\u003dConfigUtils.rawDataContainsProfileBasedSource(activeProfiles,rawData).getAsBoolean();\n    Assertions.assertTrue(result);\n  }\n}\n",
        "abstract": "/** \n * Class that is supposed to test only ConfigUtils::rawDataContainsProfileBasedSource\n * @author wind57\n */\nclass ConfigUtilsRawDataContainsProfileBasedSourceTests {\n  @Test void nullSourceRawData();\n  @Test void sourceRawDataPresentEmptyActiveProfiles();\n  @Test void plainValuesOnly();\n  @Test void noMatchInActiveProfiles();\n  @Test void matchInActiveProfilesWithYml();\n  @Test void matchInActiveProfilesWithYaml();\n  @Test void matchInActiveProfilesWithProperties();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/SourceDataEntriesProcessorOrderedPropertiesTests.java",
        "name": "SourceDataEntriesProcessorOrderedPropertiesTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.SourceDataEntriesProcessorOrderedPropertiesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass SourceDataEntriesProcessorOrderedPropertiesTests {\n  /** \n * \u003cpre\u003e - a single property is present \u003c/pre\u003e\n */\n  @Test void testSingleNonFileProperty(){\n    Map\u003cString,String\u003e map\u003dnew LinkedHashMap\u003c\u003e();\n    map.put(\"my-key\",\"my-value\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    Map\u003cString,Object\u003e result\u003dSourceDataEntriesProcessor.processAllEntries(map,mockEnvironment);\n    Assertions.assertEquals(Map.of(\"my-key\",\"my-value\"),result);\n  }\n  /** \n * \u003cpre\u003e - a single property from a properties file \u003c/pre\u003e\n */\n  @Test void testSingleFileProperty(){\n    Map\u003cString,String\u003e map\u003dnew LinkedHashMap\u003c\u003e();\n    map.put(\"application.properties\",\"my-key\u003dfrom-app\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    Map\u003cString,Object\u003e result\u003dSourceDataEntriesProcessor.processAllEntries(map,mockEnvironment);\n    Assertions.assertEquals(Map.of(\"my-key\",\"from-app\"),result);\n  }\n  /** \n * \u003cpre\u003e - application.properties contains: { firstKey\u003dfirstFromProperties secondKey\u003dsecondFromProperties } - a single property exists : {firstKey \u003d abc} - This proves that the property overrides the value from \"application.properties\". \u003c/pre\u003e\n */\n  @Test void testThree(){\n    Map\u003cString,String\u003e map\u003dnew LinkedHashMap\u003c\u003e();\n    map.put(\"application.properties\",null);\n    map.put(\"firstKey\",\"abc\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    Map\u003cString,Object\u003e result\u003dSourceDataEntriesProcessor.processAllEntries(map,mockEnvironment);\n    Assertions.assertEquals(Map.of(\"firstKey\",\"abc\",\"secondKey\",\"secondFromProperties\"),result);\n  }\n  /** \n * \u003cpre\u003e - application.properties contains: { firstKey\u003dfirstFromProperties secondKey\u003dsecondFromProperties thirdKey\u003dthirdFromProperties } - application-dev.properties contains: { firstKey\u003dfirstFromDevProperties secondKey\u003dsecondFromDevProperties } - a single property exists : {firstKey \u003d abc} - This proves that profile specific properties override non-profile and plain properties override everything. \u003c/pre\u003e\n */\n  @Test void testFour(){\n    Map\u003cString,String\u003e map\u003dnew LinkedHashMap\u003c\u003e();\n    map.put(\"application.properties\",null);\n    map.put(\"application-dev.properties\",null);\n    map.put(\"firstKey\",\"abc\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setActiveProfiles(\"dev\");\n    Map\u003cString,Object\u003e result\u003dSourceDataEntriesProcessor.processAllEntries(map,mockEnvironment);\n    Assertions.assertEquals(Map.of(\"firstKey\",\"abc\",\"secondKey\",\"secondFromDevProperties\",\"thirdKey\",\"thirdFromProperties\"),result);\n  }\n  /** \n * \u003cpre\u003e - application.properties contains: { firstKey\u003dfirstFromProperties secondKey\u003dsecondFromProperties thirdKey\u003dthirdFromProperties } - application-dev.properties contains: { firstKey\u003dfirstFromDevProperties secondKey\u003dsecondFromDevProperties } - a single property exists : {firstKey \u003d abc} - This proves that profile specific properties override non-profile and plain properties override everything. It also proves that non-active profile properties are ignored. \u003c/pre\u003e\n */\n  @Test void testFive(){\n    Map\u003cString,String\u003e map\u003dnew LinkedHashMap\u003c\u003e();\n    map.put(\"application.properties\",null);\n    map.put(\"application-dev.properties\",null);\n    map.put(\"application-k8s.properties\",null);\n    map.put(\"firstKey\",\"abc\");\n    map.put(\"fourthKey\",\"def\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setActiveProfiles(\"dev\");\n    Map\u003cString,Object\u003e result\u003dSourceDataEntriesProcessor.processAllEntries(map,mockEnvironment);\n    Assertions.assertEquals(Map.of(\"firstKey\",\"abc\",\"secondKey\",\"secondFromDevProperties\",\"thirdKey\",\"thirdFromProperties\",\"fourthKey\",\"def\"),result);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass SourceDataEntriesProcessorOrderedPropertiesTests {\n  /** \n * \u003cpre\u003e - a single property is present \u003c/pre\u003e\n */\n  @Test void testSingleNonFileProperty();\n  /** \n * \u003cpre\u003e - a single property from a properties file \u003c/pre\u003e\n */\n  @Test void testSingleFileProperty();\n  /** \n * \u003cpre\u003e - application.properties contains: { firstKey\u003dfirstFromProperties secondKey\u003dsecondFromProperties } - a single property exists : {firstKey \u003d abc} - This proves that the property overrides the value from \"application.properties\". \u003c/pre\u003e\n */\n  @Test void testThree();\n  /** \n * \u003cpre\u003e - application.properties contains: { firstKey\u003dfirstFromProperties secondKey\u003dsecondFromProperties thirdKey\u003dthirdFromProperties } - application-dev.properties contains: { firstKey\u003dfirstFromDevProperties secondKey\u003dsecondFromDevProperties } - a single property exists : {firstKey \u003d abc} - This proves that profile specific properties override non-profile and plain properties override everything. \u003c/pre\u003e\n */\n  @Test void testFour();\n  /** \n * \u003cpre\u003e - application.properties contains: { firstKey\u003dfirstFromProperties secondKey\u003dsecondFromProperties thirdKey\u003dthirdFromProperties } - application-dev.properties contains: { firstKey\u003dfirstFromDevProperties secondKey\u003dsecondFromDevProperties } - a single property exists : {firstKey \u003d abc} - This proves that profile specific properties override non-profile and plain properties override everything. It also proves that non-active profile properties are ignored. \u003c/pre\u003e\n */\n  @Test void testFive();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/ConfigUtilsProcessSourceTests.java",
        "name": "ConfigUtilsProcessSourceTests",
        "modifiers": "@ExtendWith(OutputCaptureExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConfigUtilsProcessSourceTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * Class that is supposed to test only ConfigUtils::processSource and ConfigUtils::processNamedData.\n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class ConfigUtilsProcessSourceTests {\n  /** \n * \u003cpre\u003e - includeDefaultProfileData         \u003d true - emptyActiveProfiles               \u003d does not matter - profileBasedSourceName            \u003d does not matter - defaultProfilePresent             \u003d does not matter - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e Since \u0027includeDefaultProfileData\u003dtrue\u0027, all other arguments are irrelevant and method must return \u0027true\u0027.\n */\n  @Test void testProcessSourceOne(){\n    boolean includeDefaultProfileData\u003dtrue;\n    Environment environment\u003dnew MockEnvironment();\n    String sourceName\u003d\"account\";\n    Map\u003cString,String\u003e sourceRawData\u003dMap.of();\n    boolean result\u003dConfigUtils.processSource(includeDefaultProfileData,environment,sourceName,sourceRawData);\n    Assertions.assertTrue(result);\n  }\n  /** \n * this case is not very \"interesting\" because \u0027includeDefaultProfileData \u003d true\u0027 which denotes a request not from config server; and such cases are tested in various other tests, before we fixed: https://github.com/spring-cloud/spring-cloud-kubernetes/pull/1600\n */\n  @Test void testProcessNamedDataOne(){\n    List\u003cStrippedSourceContainer\u003e strippedSources\u003dList.of(new StrippedSourceContainer(Map.of(),\"configmap-a\",Map.of(\"one\",\"1\")));\n    Environment environment\u003dnew MockEnvironment();\n    LinkedHashSet\u003cString\u003e sourceNames\u003dnew LinkedHashSet\u003c\u003e(List.of(\"configmap-a\"));\n    String namespace\u003d\"namespace-a\";\n    boolean decode\u003dfalse;\n    boolean includeDefaultProfileData\u003dtrue;\n    MultipleSourcesContainer result\u003dConfigUtils.processNamedData(strippedSources,environment,sourceNames,namespace,decode,includeDefaultProfileData);\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.names().toString(),\"[configmap-a]\");\n    Assertions.assertEquals(result.data(),Map.of(\"one\",\"1\"));\n  }\n  /** \n * \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d false - defaultProfilePresent             \u003d true - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e Since \u0027defaultProfilePresent\u003dtrue\u0027, this method must return \u0027true\u0027.\n */\n  @Test void testProcessSourceTwo(){\n    boolean includeDefaultProfileData\u003dfalse;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"default\");\n    String sourceName\u003d\"account\";\n    Map\u003cString,String\u003e sourceRawData\u003dMap.of();\n    boolean result\u003dConfigUtils.processSource(includeDefaultProfileData,environment,sourceName,sourceRawData);\n    Assertions.assertTrue(result);\n  }\n  /** \n * \u003cpre\u003e - request is coming from config server - activeProfile \u003d [\u0027default\u0027] - sourceName \u003d \u0027account\u0027 \u003c/pre\u003e As such the above will generate: \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d false - defaultProfilePresent             \u003d true - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e In this case, three types of properties will be read from the source: \u003cpre\u003e - all simple properties - all nested ones (yaml/yml/properties themselves) that match \"${SOURCE_NAME}.{EXTENSION}\" (in our case \u0027account.properties\u0027) - all nested ones (yaml/yml/properties themselves) that match \"${SOURCE_NAME}-${ACTIVE_PROFILE}.{EXTENSION}\" (in our case \u0027account-default.properties\u0027) - there are strict sorting rules if both of the above are matched \u003c/pre\u003e\n */\n  @Test void testProcessNamedDataTwo(  CapturedOutput output){\n    Map\u003cString,String\u003e sourceRawData\u003dMap.of(\"one\",\"1\",\"two\",\"2\",\"account-default.properties\",\"five\u003d5\",\"account.properties\",\"one\u003d11\\nthree\u003d3\",\"account-k8s.properties\",\"one\u003d22\\nfour\u003d4\");\n    String sourceName\u003d\"account\";\n    List\u003cStrippedSourceContainer\u003e strippedSources\u003dList.of(new StrippedSourceContainer(Map.of(),sourceName,sourceRawData));\n    MockEnvironment environment\u003dnew MockEnvironment().withProperty(\"spring.application.name\",sourceName);\n    environment.setActiveProfiles(\"default\");\n    LinkedHashSet\u003cString\u003e sourceNames\u003dnew LinkedHashSet\u003c\u003e(List.of(sourceName));\n    String namespace\u003d\"namespace-a\";\n    boolean decode\u003dfalse;\n    boolean includeDefaultProfileData\u003dfalse;\n    MultipleSourcesContainer result\u003dConfigUtils.processNamedData(strippedSources,environment,sourceNames,namespace,decode,includeDefaultProfileData);\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.names().toString(),\"[account]\");\n    Assertions.assertEquals(result.data(),Map.of(\"one\",\"1\",\"two\",\"2\",\"three\",\"3\",\"five\",\"5\"));\n    Assertions.assertTrue(output.getOut().contains(\"entry : account-k8s.properties will be skipped\"));\n  }\n  /** \n * \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d true - defaultProfilePresent             \u003d false - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e Since \u0027profileBasedSourceName\u003dtrue\u0027, this method must return \u0027true\u0027.\n */\n  @Test void testProcessSourceThree(){\n    boolean includeDefaultProfileData\u003dfalse;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"default\");\n    String sourceName\u003d\"account-default\";\n    Map\u003cString,String\u003e sourceRawData\u003dMap.of();\n    boolean result\u003dConfigUtils.processSource(includeDefaultProfileData,environment,sourceName,sourceRawData);\n    Assertions.assertTrue(result);\n  }\n  /** \n * \u003cpre\u003e - request is coming from config server - activeProfile \u003d [\u0027default\u0027] - sourceName \u003d \u0027account-default\u0027 \u003c/pre\u003e As such the above will generate: \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d true - defaultProfilePresent             \u003d does not matter - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e In this case, three types of properties will be read from the source: \u003cpre\u003e - all simple properties - all nested ones (yaml/yml/properties themselves) that match \"${SOURCE_NAME}.{EXTENSION}\" (in our case \u0027account.properties\u0027) - all nested ones (yaml/yml/properties themselves) that match \"${SOURCE_NAME}-${ACTIVE_PROFILE}.{EXTENSION}\" (in our case \u0027account-default.properties\u0027) - there are strict sorting rules if both of the above are matched \u003c/pre\u003e\n */\n  @Test void testProcessNamedDataThree(  CapturedOutput output){\n    Map\u003cString,String\u003e sourceRawData\u003dMap.of(\"one\",\"1\",\"two\",\"2\",\"account.properties\",\"one\u003d11\\nthree\u003d3\",\"account-default.properties\",\"one\u003d111\\nfive\u003d5\",\"account-k8s.properties\",\"one\u003d22\\nfour\u003d4\");\n    String sourceName\u003d\"account-default\";\n    List\u003cStrippedSourceContainer\u003e strippedSources\u003dList.of(new StrippedSourceContainer(Map.of(),sourceName,sourceRawData));\n    MockEnvironment environment\u003dnew MockEnvironment().withProperty(\"spring.application.name\",\"account\");\n    environment.setActiveProfiles(\"default\");\n    LinkedHashSet\u003cString\u003e sourceNames\u003dnew LinkedHashSet\u003c\u003e(List.of(sourceName));\n    String namespace\u003d\"namespace-a\";\n    boolean decode\u003dfalse;\n    boolean includeDefaultProfileData\u003dfalse;\n    MultipleSourcesContainer result\u003dConfigUtils.processNamedData(strippedSources,environment,sourceNames,namespace,decode,includeDefaultProfileData);\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.names().toString(),\"[account-default]\");\n    Assertions.assertEquals(result.data(),Map.of(\"one\",\"1\",\"two\",\"2\",\"three\",\"3\",\"five\",\"5\"));\n    Assertions.assertTrue(output.getOut().contains(\"entry : account-k8s.properties will be skipped\"));\n  }\n  /** \n * \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d false - defaultProfilePresent             \u003d false - rawDataContainsProfileBasedSource \u003d false \u003c/pre\u003e\n */\n  @Test void testProcessSourceFour(){\n    boolean includeDefaultProfileData\u003dfalse;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    String sourceName\u003d\"account\";\n    Map\u003cString,String\u003e sourceRawData\u003dMap.of(\"one\",\"1\");\n    boolean result\u003dConfigUtils.processSource(includeDefaultProfileData,environment,sourceName,sourceRawData);\n    Assertions.assertFalse(result);\n  }\n  /** \n * \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d false - defaultProfilePresent             \u003d false - rawDataContainsProfileBasedSource \u003d true \u003c/pre\u003e\n */\n  @Test void testProcessSourceFive(){\n    boolean includeDefaultProfileData\u003dfalse;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    String sourceName\u003d\"account\";\n    Map\u003cString,String\u003e sourceRawData\u003dMap.of(\"one\",\"1\",\"account-k8s.properties\",\"one\u003d11\");\n    boolean result\u003dConfigUtils.processSource(includeDefaultProfileData,environment,sourceName,sourceRawData);\n    Assertions.assertTrue(result);\n  }\n  /** \n * \u003cpre\u003e - request is coming from config server - activeProfile \u003d [\u0027k8s\u0027] - sourceName \u003d \u0027account\u0027 - rawData inside the source has an entry : \u0027account-k8s.properties\u0027 \u003c/pre\u003e As such the above will generate: \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d false - defaultProfilePresent             \u003d false - rawDataContainsProfileBasedSource \u003d true \u003c/pre\u003e In this case, only one type of source data will be read \u003cpre\u003e - \"${SOURCE_NAME}-${ACTIVE_PROFILE}.{EXTENSION}\" \u003c/pre\u003e\n */\n  @Test void testProcessNamedDataFive(  CapturedOutput output){\n    Map\u003cString,String\u003e sourceRawData\u003dMap.of(\"one\",\"1\",\"account.properties\",\"one\u003d11\\ntwo\u003d2\",\"account-default.properties\",\"one\u003d111\\nthree\u003d3\",\"account-k8s.properties\",\"one\u003d1111\\nfour\u003d4\");\n    String sourceName\u003d\"account\";\n    List\u003cStrippedSourceContainer\u003e strippedSources\u003dList.of(new StrippedSourceContainer(Map.of(),sourceName,sourceRawData));\n    MockEnvironment environment\u003dnew MockEnvironment().withProperty(\"spring.application.name\",sourceName);\n    environment.setActiveProfiles(\"k8s\");\n    LinkedHashSet\u003cString\u003e sourceNames\u003dnew LinkedHashSet\u003c\u003e(List.of(sourceName));\n    String namespace\u003d\"namespace-a\";\n    boolean decode\u003dfalse;\n    boolean includeDefaultProfileData\u003dfalse;\n    MultipleSourcesContainer result\u003dConfigUtils.processNamedData(strippedSources,environment,sourceNames,namespace,decode,includeDefaultProfileData);\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.names().toString(),\"[account]\");\n    Assertions.assertEquals(result.data(),Map.of(\"one\",\"1111\",\"four\",\"4\"));\n    Assertions.assertTrue(output.getOut().contains(\"entry : account.properties will be skipped\"));\n    Assertions.assertTrue(output.getOut().contains(\"entry : account-default.properties will be skipped\"));\n  }\n  /** \n * \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d true - defaultProfilePresent             \u003d does not matter - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e\n */\n  @Test void testProcessSourceSix(){\n    boolean includeDefaultProfileData\u003dfalse;\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setActiveProfiles(\"k8s\");\n    String sourceName\u003d\"account-k8s\";\n    Map\u003cString,String\u003e sourceRawData\u003dMap.of(\"one\",\"1\",\"account-k8s.properties\",\"one\u003d11\");\n    boolean result\u003dConfigUtils.processSource(includeDefaultProfileData,environment,sourceName,sourceRawData);\n    Assertions.assertTrue(result);\n  }\n  /** \n * \u003cpre\u003e - request is coming from config server - activeProfile \u003d [\u0027k8s\u0027] - sourceName \u003d \u0027account-k8s\u0027 \u003c/pre\u003e As such the above will generate: \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d true - defaultProfilePresent             \u003d does not matter - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e In this case, a few types of data will be read: \u003cpre\u003e - all simple properties - all nested ones (yaml/yml/properties themselves) that match \"${SOURCE_NAME}.{EXTENSION}\" (in our case \u0027account.properties\u0027) - all nested ones (yaml/yml/properties themselves) that match \"${SOURCE_NAME}-${ACTIVE_PROFILE}.{EXTENSION}\" (in our case \u0027account-k8s.properties\u0027) - there are strict sorting rules if both of the above are matched \u003c/pre\u003e\n */\n  @Test void testProcessNamedDataSix(  CapturedOutput output){\n    Map\u003cString,String\u003e sourceRawData\u003dMap.of(\"one\",\"1\",\"two\",\"2\",\"account.properties\",\"one\u003d11\\nthree\u003d3\",\"account-default.properties\",\"one\u003d111\\nfour\u003d4\",\"account-k8s.properties\",\"one\u003d1111\\nfive\u003d5\",\"account-prod.properties\",\"six\u003d6\");\n    String sourceName\u003d\"account-k8s\";\n    List\u003cStrippedSourceContainer\u003e strippedSources\u003dList.of(new StrippedSourceContainer(Map.of(),sourceName,sourceRawData));\n    MockEnvironment environment\u003dnew MockEnvironment().withProperty(\"spring.application.name\",\"account\");\n    environment.setActiveProfiles(\"k8s\");\n    LinkedHashSet\u003cString\u003e sourceNames\u003dnew LinkedHashSet\u003c\u003e(List.of(sourceName));\n    String namespace\u003d\"namespace-a\";\n    boolean decode\u003dfalse;\n    boolean includeDefaultProfileData\u003dfalse;\n    MultipleSourcesContainer result\u003dConfigUtils.processNamedData(strippedSources,environment,sourceNames,namespace,decode,includeDefaultProfileData);\n    Assertions.assertNotNull(result);\n    Assertions.assertEquals(result.names().toString(),\"[account-k8s]\");\n    Assertions.assertEquals(result.data(),Map.of(\"one\",\"1111\",\"five\",\"5\"));\n    Assertions.assertTrue(output.getOut().contains(\"entry : account-prod.properties will be skipped\"));\n    Assertions.assertTrue(output.getOut().contains(\"entry : account.properties will be skipped\"));\n    Assertions.assertTrue(output.getOut().contains(\"entry : account-default.properties will be skipped\"));\n  }\n}\n",
        "abstract": "/** \n * Class that is supposed to test only ConfigUtils::processSource and ConfigUtils::processNamedData.\n * @author wind57\n */\n@ExtendWith(OutputCaptureExtension.class) class ConfigUtilsProcessSourceTests {\n  /** \n * \u003cpre\u003e - includeDefaultProfileData         \u003d true - emptyActiveProfiles               \u003d does not matter - profileBasedSourceName            \u003d does not matter - defaultProfilePresent             \u003d does not matter - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e Since \u0027includeDefaultProfileData\u003dtrue\u0027, all other arguments are irrelevant and method must return \u0027true\u0027.\n */\n  @Test void testProcessSourceOne();\n  /** \n * this case is not very \"interesting\" because \u0027includeDefaultProfileData \u003d true\u0027 which denotes a request not from config server; and such cases are tested in various other tests, before we fixed: https://github.com/spring-cloud/spring-cloud-kubernetes/pull/1600\n */\n  @Test void testProcessNamedDataOne();\n  /** \n * \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d false - defaultProfilePresent             \u003d true - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e Since \u0027defaultProfilePresent\u003dtrue\u0027, this method must return \u0027true\u0027.\n */\n  @Test void testProcessSourceTwo();\n  /** \n * \u003cpre\u003e - request is coming from config server - activeProfile \u003d [\u0027default\u0027] - sourceName \u003d \u0027account\u0027 \u003c/pre\u003e As such the above will generate: \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d false - defaultProfilePresent             \u003d true - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e In this case, three types of properties will be read from the source: \u003cpre\u003e - all simple properties - all nested ones (yaml/yml/properties themselves) that match \"${SOURCE_NAME}.{EXTENSION}\" (in our case \u0027account.properties\u0027) - all nested ones (yaml/yml/properties themselves) that match \"${SOURCE_NAME}-${ACTIVE_PROFILE}.{EXTENSION}\" (in our case \u0027account-default.properties\u0027) - there are strict sorting rules if both of the above are matched \u003c/pre\u003e\n */\n  @Test void testProcessNamedDataTwo(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d true - defaultProfilePresent             \u003d false - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e Since \u0027profileBasedSourceName\u003dtrue\u0027, this method must return \u0027true\u0027.\n */\n  @Test void testProcessSourceThree();\n  /** \n * \u003cpre\u003e - request is coming from config server - activeProfile \u003d [\u0027default\u0027] - sourceName \u003d \u0027account-default\u0027 \u003c/pre\u003e As such the above will generate: \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d true - defaultProfilePresent             \u003d does not matter - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e In this case, three types of properties will be read from the source: \u003cpre\u003e - all simple properties - all nested ones (yaml/yml/properties themselves) that match \"${SOURCE_NAME}.{EXTENSION}\" (in our case \u0027account.properties\u0027) - all nested ones (yaml/yml/properties themselves) that match \"${SOURCE_NAME}-${ACTIVE_PROFILE}.{EXTENSION}\" (in our case \u0027account-default.properties\u0027) - there are strict sorting rules if both of the above are matched \u003c/pre\u003e\n */\n  @Test void testProcessNamedDataThree(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d false - defaultProfilePresent             \u003d false - rawDataContainsProfileBasedSource \u003d false \u003c/pre\u003e\n */\n  @Test void testProcessSourceFour();\n  /** \n * \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d false - defaultProfilePresent             \u003d false - rawDataContainsProfileBasedSource \u003d true \u003c/pre\u003e\n */\n  @Test void testProcessSourceFive();\n  /** \n * \u003cpre\u003e - request is coming from config server - activeProfile \u003d [\u0027k8s\u0027] - sourceName \u003d \u0027account\u0027 - rawData inside the source has an entry : \u0027account-k8s.properties\u0027 \u003c/pre\u003e As such the above will generate: \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d false - defaultProfilePresent             \u003d false - rawDataContainsProfileBasedSource \u003d true \u003c/pre\u003e In this case, only one type of source data will be read \u003cpre\u003e - \"${SOURCE_NAME}-${ACTIVE_PROFILE}.{EXTENSION}\" \u003c/pre\u003e\n */\n  @Test void testProcessNamedDataFive(  CapturedOutput output);\n  /** \n * \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d true - defaultProfilePresent             \u003d does not matter - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e\n */\n  @Test void testProcessSourceSix();\n  /** \n * \u003cpre\u003e - request is coming from config server - activeProfile \u003d [\u0027k8s\u0027] - sourceName \u003d \u0027account-k8s\u0027 \u003c/pre\u003e As such the above will generate: \u003cpre\u003e - includeDefaultProfileData         \u003d false - emptyActiveProfiles               \u003d false - profileBasedSourceName            \u003d true - defaultProfilePresent             \u003d does not matter - rawDataContainsProfileBasedSource \u003d does not matter \u003c/pre\u003e In this case, a few types of data will be read: \u003cpre\u003e - all simple properties - all nested ones (yaml/yml/properties themselves) that match \"${SOURCE_NAME}.{EXTENSION}\" (in our case \u0027account.properties\u0027) - all nested ones (yaml/yml/properties themselves) that match \"${SOURCE_NAME}-${ACTIVE_PROFILE}.{EXTENSION}\" (in our case \u0027account-k8s.properties\u0027) - there are strict sorting rules if both of the above are matched \u003c/pre\u003e\n */\n  @Test void testProcessNamedDataSix(  CapturedOutput output);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/ConfigMapConfigPropertiesTests.java",
        "name": "ConfigMapConfigPropertiesTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConfigMapConfigPropertiesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass ConfigMapConfigPropertiesTests {\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: name: config-map-a namespace: spring-k8s \u003c/pre\u003e a config as above will result in a NormalizedSource where prefix is empty\n */\n  @Test void testUseNameAsPrefixUnsetEmptySources(){\n    ConfigMapConfigProperties properties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(),Map.of(),true,\"config-map-a\",\"spring-k8s\",false,false,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),1,\"empty sources must generate a List with a single NormalizedSource\");\n    Assertions.assertSame(((NamedConfigMapNormalizedSource)sources.get(0)).prefix(),ConfigUtils.Prefix.DEFAULT,\"empty sources must generate a List with a single NormalizedSource, where prefix is empty\");\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: useNameAsPrefix: true name: config-map-a namespace: spring-k8s \u003c/pre\u003e a config as above will result in a NormalizedSource where prefix is empty, even if \"useNameAsPrefix: true\", because sources are empty\n */\n  @Test void testUseNameAsPrefixSetEmptySources(){\n    ConfigMapConfigProperties properties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(),Map.of(),true,\"config-map-a\",\"spring-k8s\",true,false,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),1,\"empty sources must generate a List with a single NormalizedSource\");\n    Assertions.assertSame(((NamedConfigMapNormalizedSource)sources.get(0)).prefix(),ConfigUtils.Prefix.DEFAULT,\"empty sources must generate a List with a single NormalizedSource, where prefix is empty,\" + \"no matter of \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u0027 value\");\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: useNameAsPrefix: true namespace: spring-k8s sources: - name: config-map-one \u003c/pre\u003e a config as above will result in a NormalizedSource where prefix will be equal to the config map name\n */\n  @Test void testUseNameAsPrefixUnsetNonEmptySources(){\n    ConfigMapConfigProperties.Source one\u003dnew ConfigMapConfigProperties.Source(\"config-map-one\",null,Collections.emptyMap(),null,null,null);\n    ConfigMapConfigProperties properties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(one),Map.of(),true,\"config-map-a\",\"spring-k8s\",true,false,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),1,\"a single NormalizedSource is expected\");\n    Assertions.assertEquals(((NamedConfigMapNormalizedSource)sources.get(0)).prefix().prefixProvider().get(),\"config-map-one\");\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: useNameAsPrefix: true namespace: spring-k8s sources: - name: config-map-one useNameAsPrefix: false - name: config-map-two useNameAsPrefix: true - name: config-map-three \u003c/pre\u003e this test proves that \u0027spring.cloud.kubernetes.config.sources[].useNameAsPrefix\u0027 will override \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u0027. For the last entry in sources, since there is no explicit \u0027useNameAsPrefix\u0027, the one from \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u0027 will be taken.\n */\n  @Test void testUseNameAsPrefixSetNonEmptySources(){\n    ConfigMapConfigProperties.Source one\u003dnew ConfigMapConfigProperties.Source(\"config-map-one\",null,Collections.emptyMap(),null,false,null);\n    ConfigMapConfigProperties.Source two\u003dnew ConfigMapConfigProperties.Source(\"config-map-two\",null,Collections.emptyMap(),null,true,null);\n    ConfigMapConfigProperties.Source three\u003dnew ConfigMapConfigProperties.Source(\"config-map-three\",null,Collections.emptyMap(),null,true,null);\n    ConfigMapConfigProperties properties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(one,two,three),Map.of(),true,\"config-map-a\",\"spring-k8s\",true,false,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),3,\"3 NormalizedSources are expected\");\n    Assertions.assertSame(((NamedConfigMapNormalizedSource)sources.get(0)).prefix(),ConfigUtils.Prefix.DEFAULT);\n    Assertions.assertEquals(((NamedConfigMapNormalizedSource)sources.get(1)).prefix().prefixProvider().get(),\"config-map-two\");\n    Assertions.assertEquals(((NamedConfigMapNormalizedSource)sources.get(2)).prefix().prefixProvider().get(),\"config-map-three\");\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: useNameAsPrefix: false namespace: spring-k8s sources: - name: config-map-one useNameAsPrefix: false explicitPrefix: one - name: config-map-two useNameAsPrefix: true explicitPrefix: two - name: config-map-three explicitPrefix: three - name: config-map-four \u003c/pre\u003e\n */\n  @Test void testMultipleCases(){\n    ConfigMapConfigProperties.Source one\u003dnew ConfigMapConfigProperties.Source(\"config-map-one\",null,Collections.emptyMap(),\"one\",false,null);\n    ConfigMapConfigProperties.Source two\u003dnew ConfigMapConfigProperties.Source(\"config-map-two\",null,Collections.emptyMap(),\"two\",true,null);\n    ConfigMapConfigProperties.Source three\u003dnew ConfigMapConfigProperties.Source(\"config-map-three\",null,Collections.emptyMap(),\"three\",false,null);\n    ConfigMapConfigProperties.Source four\u003dnew ConfigMapConfigProperties.Source(null,\"config-map-four\",Collections.emptyMap(),null,false,null);\n    ConfigMapConfigProperties properties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(one,two,three,four),Map.of(),true,\"config-map-a\",\"spring-k8s\",true,false,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),4,\"4 NormalizedSources are expected\");\n    Assertions.assertEquals(((NamedConfigMapNormalizedSource)sources.get(0)).prefix().prefixProvider().get(),\"one\");\n    Assertions.assertEquals(((NamedConfigMapNormalizedSource)sources.get(1)).prefix().prefixProvider().get(),\"two\");\n    Assertions.assertEquals(((NamedConfigMapNormalizedSource)sources.get(2)).prefix().prefixProvider().get(),\"three\");\n    Assertions.assertSame(((NamedConfigMapNormalizedSource)sources.get(3)).prefix(),ConfigUtils.Prefix.DEFAULT);\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: name: config-map-a namespace: spring-k8s \u003c/pre\u003e a config as above will result in a NormalizedSource where includeProfileSpecificSources will be true (this test proves that the change we added is not a breaking change for the already existing functionality)\n */\n  @Test void testUseIncludeProfileSpecificSourcesNoChanges(){\n    ConfigMapConfigProperties properties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(),Map.of(),true,\"config-map-a\",\"spring-k8s\",false,true,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),1,\"empty sources must generate a List with a single NormalizedSource\");\n    Assertions.assertTrue(((NamedConfigMapNormalizedSource)sources.get(0)).profileSpecificSources());\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: includeProfileSpecificSources: false name: config-map-a namespace: spring-k8s \u003c/pre\u003e a config as above will result in a NormalizedSource where includeProfileSpecificSources will be false. Even if we did not define any sources explicitly, one will still be created, by default. That one might \"flatMap\" into multiple other, because of multiple profiles. As such this setting still matters and must be propagated to the normalized source.\n */\n  @Test void testUseIncludeProfileSpecificSourcesDefaultChanged(){\n    ConfigMapConfigProperties properties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(),Map.of(),true,\"config-map-a\",\"spring-k8s\",false,false,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),1,\"empty sources must generate a List with a single NormalizedSource\");\n    Assertions.assertFalse(((NamedConfigMapNormalizedSource)sources.get(0)).profileSpecificSources());\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: includeProfileSpecificSources: false name: config-map-a namespace: spring-k8s sources: - name: one includeProfileSpecificSources: true - name: two - name: three includeProfileSpecificSources: false \u003c/pre\u003e \u003cpre\u003e source \"one\" will have \"includeProfileSpecificSources \u003d true\". source \"two\" will have \"includeProfileSpecificSources \u003d false\". source \"three\" will have \"includeProfileSpecificSources \u003d false\". \u003c/pre\u003e\n */\n  @Test void testUseIncludeProfileSpecificSourcesDefaultChangedSourceOverride(){\n    ConfigMapConfigProperties.Source one\u003dnew ConfigMapConfigProperties.Source(\"config-map-one\",null,Collections.emptyMap(),\"one\",null,true);\n    ConfigMapConfigProperties.Source two\u003dnew ConfigMapConfigProperties.Source(\"config-map-two\",null,Collections.emptyMap(),null,false,null);\n    ConfigMapConfigProperties.Source three\u003dnew ConfigMapConfigProperties.Source(\"config-map-three\",null,Collections.emptyMap(),null,null,false);\n    ConfigMapConfigProperties properties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(one,two,three),Map.of(),true,\"config-map-a\",\"spring-k8s\",false,false,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),3);\n    Assertions.assertTrue(((NamedConfigMapNormalizedSource)sources.get(0)).profileSpecificSources());\n    Assertions.assertFalse(((NamedConfigMapNormalizedSource)sources.get(1)).profileSpecificSources());\n    Assertions.assertFalse(((NamedConfigMapNormalizedSource)sources.get(2)).profileSpecificSources());\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: useNameAsPrefix: false namespace: spring-k8s includeProfileSpecificSources: false sources: - labels: - name: first-label value: configmap-one useNameAsPrefix: false explicitPrefix: one - labels: - name: second-label value: configmap-two includeProfileSpecificSources: true useNameAsPrefix: true explicitPrefix: two - labels: - name: third-label value: configmap-three explicitPrefix: three - labels: - name: fourth-label value: configmap-four \u003c/pre\u003e\n */\n  @Test void testLabelsMultipleCases(){\n    ConfigMapConfigProperties.Source one\u003dnew ConfigMapConfigProperties.Source(null,null,Map.of(\"first-label\",\"configmap-one\"),\"one\",false,null);\n    ConfigMapConfigProperties.Source two\u003dnew ConfigMapConfigProperties.Source(null,null,Map.of(\"second-label\",\"configmap-two\"),\"two\",true,true);\n    ConfigMapConfigProperties.Source three\u003dnew ConfigMapConfigProperties.Source(null,null,Map.of(\"third-label\",\"configmap-three\"),\"three\",null,null);\n    ConfigMapConfigProperties.Source four\u003dnew ConfigMapConfigProperties.Source(null,null,Map.of(\"fourth-label\",\"configmap-four\"),null,null,null);\n    ConfigMapConfigProperties properties\u003dnew ConfigMapConfigProperties(true,List.of(),List.of(one,two,three,four),Map.of(),true,\"config-map-a\",\"spring-k8s\",false,false,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),8,\"4 NormalizedSources are expected\");\n    LabeledConfigMapNormalizedSource labeled1\u003d(LabeledConfigMapNormalizedSource)sources.get(1);\n    Assertions.assertEquals(labeled1.prefix().prefixProvider().get(),\"one\");\n    Assertions.assertFalse(labeled1.profileSpecificSources());\n    LabeledConfigMapNormalizedSource labeled3\u003d(LabeledConfigMapNormalizedSource)sources.get(3);\n    Assertions.assertEquals(labeled3.prefix().prefixProvider().get(),\"two\");\n    Assertions.assertTrue(labeled3.profileSpecificSources());\n    LabeledConfigMapNormalizedSource labeled5\u003d(LabeledConfigMapNormalizedSource)sources.get(5);\n    Assertions.assertEquals(labeled5.prefix().prefixProvider().get(),\"three\");\n    Assertions.assertFalse(labeled5.profileSpecificSources());\n    LabeledConfigMapNormalizedSource labeled7\u003d(LabeledConfigMapNormalizedSource)sources.get(7);\n    Assertions.assertSame(labeled7.prefix(),ConfigUtils.Prefix.DEFAULT);\n    Assertions.assertFalse(labeled7.profileSpecificSources());\n    Set\u003cNormalizedSource\u003e set\u003dnew LinkedHashSet\u003c\u003e(sources);\n    Assertions.assertEquals(5,set.size());\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass ConfigMapConfigPropertiesTests {\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: name: config-map-a namespace: spring-k8s \u003c/pre\u003e a config as above will result in a NormalizedSource where prefix is empty\n */\n  @Test void testUseNameAsPrefixUnsetEmptySources();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: useNameAsPrefix: true name: config-map-a namespace: spring-k8s \u003c/pre\u003e a config as above will result in a NormalizedSource where prefix is empty, even if \"useNameAsPrefix: true\", because sources are empty\n */\n  @Test void testUseNameAsPrefixSetEmptySources();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: useNameAsPrefix: true namespace: spring-k8s sources: - name: config-map-one \u003c/pre\u003e a config as above will result in a NormalizedSource where prefix will be equal to the config map name\n */\n  @Test void testUseNameAsPrefixUnsetNonEmptySources();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: useNameAsPrefix: true namespace: spring-k8s sources: - name: config-map-one useNameAsPrefix: false - name: config-map-two useNameAsPrefix: true - name: config-map-three \u003c/pre\u003e this test proves that \u0027spring.cloud.kubernetes.config.sources[].useNameAsPrefix\u0027 will override \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u0027. For the last entry in sources, since there is no explicit \u0027useNameAsPrefix\u0027, the one from \u0027spring.cloud.kubernetes.config.useNameAsPrefix\u0027 will be taken.\n */\n  @Test void testUseNameAsPrefixSetNonEmptySources();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: useNameAsPrefix: false namespace: spring-k8s sources: - name: config-map-one useNameAsPrefix: false explicitPrefix: one - name: config-map-two useNameAsPrefix: true explicitPrefix: two - name: config-map-three explicitPrefix: three - name: config-map-four \u003c/pre\u003e\n */\n  @Test void testMultipleCases();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: name: config-map-a namespace: spring-k8s \u003c/pre\u003e a config as above will result in a NormalizedSource where includeProfileSpecificSources will be true (this test proves that the change we added is not a breaking change for the already existing functionality)\n */\n  @Test void testUseIncludeProfileSpecificSourcesNoChanges();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: includeProfileSpecificSources: false name: config-map-a namespace: spring-k8s \u003c/pre\u003e a config as above will result in a NormalizedSource where includeProfileSpecificSources will be false. Even if we did not define any sources explicitly, one will still be created, by default. That one might \"flatMap\" into multiple other, because of multiple profiles. As such this setting still matters and must be propagated to the normalized source.\n */\n  @Test void testUseIncludeProfileSpecificSourcesDefaultChanged();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: includeProfileSpecificSources: false name: config-map-a namespace: spring-k8s sources: - name: one includeProfileSpecificSources: true - name: two - name: three includeProfileSpecificSources: false \u003c/pre\u003e \u003cpre\u003e source \"one\" will have \"includeProfileSpecificSources \u003d true\". source \"two\" will have \"includeProfileSpecificSources \u003d false\". source \"three\" will have \"includeProfileSpecificSources \u003d false\". \u003c/pre\u003e\n */\n  @Test void testUseIncludeProfileSpecificSourcesDefaultChangedSourceOverride();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: useNameAsPrefix: false namespace: spring-k8s includeProfileSpecificSources: false sources: - labels: - name: first-label value: configmap-one useNameAsPrefix: false explicitPrefix: one - labels: - name: second-label value: configmap-two includeProfileSpecificSources: true useNameAsPrefix: true explicitPrefix: two - labels: - name: third-label value: configmap-three explicitPrefix: three - labels: - name: fourth-label value: configmap-four \u003c/pre\u003e\n */\n  @Test void testLabelsMultipleCases();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/SecretsConfigPropertiesTests.java",
        "name": "SecretsConfigPropertiesTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.SecretsConfigPropertiesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass SecretsConfigPropertiesTests {\n  /** \n * the case when labels are empty\n */\n  @Test void emptySourcesSecretName(){\n    SecretsConfigProperties properties\u003dnew SecretsConfigProperties(false,Map.of(),List.of(),List.of(),true,null,\"namespace\",false,true,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e source\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(source.size(),1);\n    Assertions.assertTrue(source.get(0) instanceof NamedSecretNormalizedSource);\n    Assertions.assertTrue(source.get(0).name().isPresent());\n    Assertions.assertEquals(source.get(0).name().get(),\"application\");\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: sources: - name : one labels: one: \"1\" - labels: two: 2 - labels: three: 3 \u003c/pre\u003e proves what there are 5 normalized sources after calling normalize method and put the result in a Set.\n */\n  @Test void multipleSources(){\n    SecretsConfigProperties.Source one\u003dnew SecretsConfigProperties.Source(\"one\",\"spring-k8s\",Map.of(\"one\",\"1\"),null,false,false);\n    SecretsConfigProperties.Source two\u003dnew SecretsConfigProperties.Source(null,\"spring-k8s\",Map.of(\"two\",\"2\"),null,false,false);\n    SecretsConfigProperties.Source three\u003dnew SecretsConfigProperties.Source(null,\"spring-k8s\",Map.of(\"three\",\"3\"),null,false,false);\n    SecretsConfigProperties properties\u003dnew SecretsConfigProperties(false,Map.of(),List.of(),List.of(one,two,three),true,null,\"namespace\",false,true,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e result\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(result.size(),6);\n    Set\u003cNormalizedSource\u003e resultAsSet\u003dnew LinkedHashSet\u003c\u003e(result);\n    Assertions.assertEquals(resultAsSet.size(),5);\n    Iterator\u003cNormalizedSource\u003e iterator\u003dresultAsSet.iterator();\n    NormalizedSource oneResult\u003diterator.next();\n    Assertions.assertEquals(oneResult.name().get(),\"one\");\n    NormalizedSource twoResult\u003diterator.next();\n    Assertions.assertEquals(((LabeledSecretNormalizedSource)twoResult).labels(),Collections.singletonMap(\"one\",\"1\"));\n    NormalizedSource threeResult\u003diterator.next();\n    Assertions.assertEquals(threeResult.name().get(),\"application\");\n    NormalizedSource fourResult\u003diterator.next();\n    Assertions.assertEquals(((LabeledSecretNormalizedSource)fourResult).labels(),Collections.singletonMap(\"two\",\"2\"));\n    NormalizedSource fiveResult\u003diterator.next();\n    Assertions.assertEquals(((LabeledSecretNormalizedSource)fiveResult).labels(),Collections.singletonMap(\"three\",\"3\"));\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: name: secret-a namespace: spring-k8s \u003c/pre\u003e a config as above will result in a NormalizedSource where prefix is empty\n */\n  @Test void testUseNameAsPrefixUnsetEmptySources(){\n    SecretsConfigProperties properties\u003dnew SecretsConfigProperties(false,Map.of(),List.of(),List.of(),true,\"secret-a\",\"namespace\",false,true,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),1,\"empty sources must generate a List with a single NormalizedSource\");\n    Assertions.assertSame(((NamedSecretNormalizedSource)sources.get(0)).prefix(),ConfigUtils.Prefix.DEFAULT);\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: useNameAsPrefix: true name: secret-a namespace: spring-k8s \u003c/pre\u003e a config as above will result in a NormalizedSource where prefix is empty, even if \"useNameAsPrefix: true\", because sources are empty\n */\n  @Test void testUseNameAsPrefixSetEmptySources(){\n    SecretsConfigProperties properties\u003dnew SecretsConfigProperties(false,Map.of(),List.of(),List.of(),true,\"secret-a\",\"namespace\",true,true,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),1,\"empty sources must generate a List with a single NormalizedSource\");\n    Assertions.assertSame(((NamedSecretNormalizedSource)sources.get(0)).prefix(),ConfigUtils.Prefix.DEFAULT,\"empty sources must generate a List with a single NormalizedSource, where prefix is unset,\" + \"no matter of \u0027spring.cloud.kubernetes.secret.useNameAsPrefix\u0027 value\");\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: useNameAsPrefix: true namespace: spring-k8s sources: - name: secret-one \u003c/pre\u003e a config as above will result in a NormalizedSource where prefix will be equal to the secret name\n */\n  @Test void testUseNameAsPrefixUnsetNonEmptySources(){\n    SecretsConfigProperties.Source one\u003dnew SecretsConfigProperties.Source(\"secret-one\",\"spring-k8s\",Map.of(),null,true,false);\n    SecretsConfigProperties properties\u003dnew SecretsConfigProperties(false,Map.of(),List.of(),List.of(one),true,\"secret-one\",null,false,true,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),1,\"a single NormalizedSource is expected\");\n    Assertions.assertEquals(((NamedSecretNormalizedSource)sources.get(0)).prefix().prefixProvider().get(),\"secret-one\");\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: useNameAsPrefix: true namespace: spring-k8s sources: - name: secret-one useNameAsPrefix: false - name: secret-two useNameAsPrefix: true - name: secret-three \u003c/pre\u003e this test proves that \u0027spring.cloud.kubernetes.secrets.sources[].useNameAsPrefix\u0027 will override \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u0027. For the last entry in sources, since there is no explicit \u0027useNameAsPrefix\u0027, the one from \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u0027 will be taken.\n */\n  @Test void testUseNameAsPrefixSetNonEmptySources(){\n    SecretsConfigProperties.Source one\u003dnew SecretsConfigProperties.Source(\"secret-one\",\"spring-k8s\",Map.of(),null,false,false);\n    SecretsConfigProperties.Source two\u003dnew SecretsConfigProperties.Source(\"secret-two\",\"spring-k8s\",Map.of(),null,true,false);\n    SecretsConfigProperties.Source three\u003dnew SecretsConfigProperties.Source(\"secret-three\",\"spring-k8s\",Map.of(),null,true,false);\n    SecretsConfigProperties properties\u003dnew SecretsConfigProperties(false,Map.of(),List.of(),List.of(one,two,three),true,\"secret-one\",null,false,true,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),3,\"3 NormalizedSources are expected\");\n    Assertions.assertSame(((NamedSecretNormalizedSource)sources.get(0)).prefix(),ConfigUtils.Prefix.DEFAULT);\n    Assertions.assertEquals(((NamedSecretNormalizedSource)sources.get(1)).prefix().prefixProvider().get(),\"secret-two\");\n    Assertions.assertEquals(((NamedSecretNormalizedSource)sources.get(2)).prefix().prefixProvider().get(),\"secret-three\");\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: useNameAsPrefix: false namespace: spring-k8s sources: - name: secret-one useNameAsPrefix: false explicitPrefix: one - name: secret-two useNameAsPrefix: true explicitPrefix: two - name: secret-three explicitPrefix: three - name: secret-four \u003c/pre\u003e\n */\n  @Test void testMultipleCases(){\n    SecretsConfigProperties.Source one\u003dnew SecretsConfigProperties.Source(\"secret-one\",\"spring-k8s\",Map.of(),\"one\",false,false);\n    SecretsConfigProperties.Source two\u003dnew SecretsConfigProperties.Source(\"secret-two\",\"spring-k8s\",Map.of(),\"two\",true,false);\n    SecretsConfigProperties.Source three\u003dnew SecretsConfigProperties.Source(\"secret-three\",\"spring-k8s\",Map.of(),\"three\",false,false);\n    SecretsConfigProperties.Source four\u003dnew SecretsConfigProperties.Source(\"secret-four\",\"spring-k8s\",Map.of(),null,false,false);\n    SecretsConfigProperties properties\u003dnew SecretsConfigProperties(false,Map.of(),List.of(),List.of(one,two,three,four),true,\"secret-one\",\"spring-k8s\",false,false,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),4,\"4 NormalizedSources are expected\");\n    Assertions.assertEquals(((NamedSecretNormalizedSource)sources.get(0)).prefix().prefixProvider().get(),\"one\");\n    Assertions.assertEquals(((NamedSecretNormalizedSource)sources.get(1)).prefix().prefixProvider().get(),\"two\");\n    Assertions.assertEquals(((NamedSecretNormalizedSource)sources.get(2)).prefix().prefixProvider().get(),\"three\");\n    Assertions.assertSame(((NamedSecretNormalizedSource)sources.get(3)).prefix(),ConfigUtils.Prefix.DEFAULT);\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: useNameAsPrefix: false namespace: spring-k8s includeProfileSpecificSources: false sources: - labels: - name: first-label value: secret-one useNameAsPrefix: false explicitPrefix: one - labels: - name: second-label value: secret-two includeProfileSpecificSources: true useNameAsPrefix: true explicitPrefix: two - labels: - name: third-label value: secret-three explicitPrefix: three - labels: - name: fourth-label value: secret-four \u003c/pre\u003e\n */\n  @Test void testLabelsMultipleCases(){\n    SecretsConfigProperties.Source one\u003dnew SecretsConfigProperties.Source(null,\"spring-k8s\",Map.of(\"first-label\",\"secret-one\"),\"one\",false,false);\n    SecretsConfigProperties.Source two\u003dnew SecretsConfigProperties.Source(null,\"spring-k8s\",Map.of(\"second-label\",\"secret-two\"),\"two\",true,true);\n    SecretsConfigProperties.Source three\u003dnew SecretsConfigProperties.Source(null,\"spring-k8s\",Map.of(\"third-label\",\"secret-three\"),\"three\",false,false);\n    SecretsConfigProperties.Source four\u003dnew SecretsConfigProperties.Source(null,\"spring-k8s\",Map.of(\"fourth-label\",\"secret-four\"),null,false,false);\n    SecretsConfigProperties properties\u003dnew SecretsConfigProperties(false,Map.of(),List.of(),List.of(one,two,three,four),false,null,\"spring-k8s\",false,false,false,RetryProperties.DEFAULT);\n    List\u003cNormalizedSource\u003e sources\u003dproperties.determineSources(new MockEnvironment());\n    Assertions.assertEquals(sources.size(),8,\"4 NormalizedSources are expected\");\n    LabeledSecretNormalizedSource labeled1\u003d(LabeledSecretNormalizedSource)sources.get(1);\n    Assertions.assertEquals(labeled1.prefix().prefixProvider().get(),\"one\");\n    Assertions.assertFalse(labeled1.profileSpecificSources());\n    LabeledSecretNormalizedSource labeled3\u003d(LabeledSecretNormalizedSource)sources.get(3);\n    Assertions.assertEquals(labeled3.prefix().prefixProvider().get(),\"two\");\n    Assertions.assertTrue(labeled3.profileSpecificSources());\n    LabeledSecretNormalizedSource labeled5\u003d(LabeledSecretNormalizedSource)sources.get(5);\n    Assertions.assertEquals(labeled5.prefix().prefixProvider().get(),\"three\");\n    Assertions.assertFalse(labeled5.profileSpecificSources());\n    LabeledSecretNormalizedSource labeled7\u003d(LabeledSecretNormalizedSource)sources.get(7);\n    Assertions.assertSame(labeled7.prefix(),ConfigUtils.Prefix.DEFAULT);\n    Assertions.assertFalse(labeled7.profileSpecificSources());\n    Set\u003cNormalizedSource\u003e set\u003dnew LinkedHashSet\u003c\u003e(sources);\n    Assertions.assertEquals(5,set.size());\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass SecretsConfigPropertiesTests {\n  /** \n * the case when labels are empty\n */\n  @Test void emptySourcesSecretName();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: sources: - name : one labels: one: \"1\" - labels: two: 2 - labels: three: 3 \u003c/pre\u003e proves what there are 5 normalized sources after calling normalize method and put the result in a Set.\n */\n  @Test void multipleSources();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: name: secret-a namespace: spring-k8s \u003c/pre\u003e a config as above will result in a NormalizedSource where prefix is empty\n */\n  @Test void testUseNameAsPrefixUnsetEmptySources();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: useNameAsPrefix: true name: secret-a namespace: spring-k8s \u003c/pre\u003e a config as above will result in a NormalizedSource where prefix is empty, even if \"useNameAsPrefix: true\", because sources are empty\n */\n  @Test void testUseNameAsPrefixSetEmptySources();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: useNameAsPrefix: true namespace: spring-k8s sources: - name: secret-one \u003c/pre\u003e a config as above will result in a NormalizedSource where prefix will be equal to the secret name\n */\n  @Test void testUseNameAsPrefixUnsetNonEmptySources();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: useNameAsPrefix: true namespace: spring-k8s sources: - name: secret-one useNameAsPrefix: false - name: secret-two useNameAsPrefix: true - name: secret-three \u003c/pre\u003e this test proves that \u0027spring.cloud.kubernetes.secrets.sources[].useNameAsPrefix\u0027 will override \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u0027. For the last entry in sources, since there is no explicit \u0027useNameAsPrefix\u0027, the one from \u0027spring.cloud.kubernetes.secrets.useNameAsPrefix\u0027 will be taken.\n */\n  @Test void testUseNameAsPrefixSetNonEmptySources();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: useNameAsPrefix: false namespace: spring-k8s sources: - name: secret-one useNameAsPrefix: false explicitPrefix: one - name: secret-two useNameAsPrefix: true explicitPrefix: two - name: secret-three explicitPrefix: three - name: secret-four \u003c/pre\u003e\n */\n  @Test void testMultipleCases();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: secrets: useNameAsPrefix: false namespace: spring-k8s includeProfileSpecificSources: false sources: - labels: - name: first-label value: secret-one useNameAsPrefix: false explicitPrefix: one - labels: - name: second-label value: secret-two includeProfileSpecificSources: true useNameAsPrefix: true explicitPrefix: two - labels: - name: third-label value: secret-three explicitPrefix: three - labels: - name: fourth-label value: secret-four \u003c/pre\u003e\n */\n  @Test void testLabelsMultipleCases();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/NamedSecretNormalizedSourceTests.java",
        "name": "NamedSecretNormalizedSourceTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.NamedSecretNormalizedSourceTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass NamedSecretNormalizedSourceTests {\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"prefix\",false,false,\"prefix\");\n  @Test void testEqualsAndHashCode(){\n    NamedSecretNormalizedSource left\u003dnew NamedSecretNormalizedSource(\"name\",\"namespace\",false,false);\n    NamedSecretNormalizedSource right\u003dnew NamedSecretNormalizedSource(\"name\",\"namespace\",true,false);\n    Assertions.assertEquals(left.hashCode(),right.hashCode());\n    Assertions.assertEquals(left,right);\n  }\n  @Test void testType(){\n    NamedSecretNormalizedSource source\u003dnew NamedSecretNormalizedSource(\"name\",\"namespace\",false,false);\n    Assertions.assertSame(source.type(),NormalizedSourceType.NAMED_SECRET);\n  }\n  @Test void testTarget(){\n    NamedSecretNormalizedSource source\u003dnew NamedSecretNormalizedSource(\"name\",\"namespace\",false,false);\n    Assertions.assertEquals(source.target(),\"secret\");\n  }\n  @Test void testConstructorFields(){\n    NamedSecretNormalizedSource source\u003dnew NamedSecretNormalizedSource(\"name\",\"namespace\",false,PREFIX,true);\n    Assertions.assertEquals(source.name().get(),\"name\");\n    Assertions.assertEquals(source.namespace().get(),\"namespace\");\n    Assertions.assertFalse(source.failFast());\n    Assertions.assertSame(PREFIX,source.prefix());\n    Assertions.assertTrue(source.profileSpecificSources());\n  }\n  @Test void testConstructorWithoutPrefixFields(){\n    NamedSecretNormalizedSource source\u003dnew NamedSecretNormalizedSource(\"name\",\"namespace\",true,true);\n    Assertions.assertEquals(source.name().get(),\"name\");\n    Assertions.assertEquals(source.namespace().get(),\"namespace\");\n    Assertions.assertTrue(source.failFast());\n    Assertions.assertSame(ConfigUtils.Prefix.DEFAULT,source.prefix());\n    Assertions.assertTrue(source.profileSpecificSources());\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass NamedSecretNormalizedSourceTests {\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"prefix\",false,false,\"prefix\");\n  @Test void testEqualsAndHashCode();\n  @Test void testType();\n  @Test void testTarget();\n  @Test void testConstructorFields();\n  @Test void testConstructorWithoutPrefixFields();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/LabeledConfigMapNormalizedSourceTests.java",
        "name": "LabeledConfigMapNormalizedSourceTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.LabeledConfigMapNormalizedSourceTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass LabeledConfigMapNormalizedSourceTests {\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"prefix\",false,false,\"prefix\");\n  @Test void testEqualsAndHashCode(){\n    LabeledConfigMapNormalizedSource left\u003dnew LabeledConfigMapNormalizedSource(\"name\",Map.of(\"key\",\"value\"),false,false);\n    LabeledConfigMapNormalizedSource right\u003dnew LabeledConfigMapNormalizedSource(\"name\",Map.of(\"key\",\"value\"),true,false);\n    Assertions.assertEquals(left.hashCode(),right.hashCode());\n    Assertions.assertEquals(left,right);\n  }\n  @Test void testType(){\n    LabeledConfigMapNormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(\"name\",Map.of(\"key\",\"value\"),false,false);\n    Assertions.assertSame(source.type(),NormalizedSourceType.LABELED_CONFIG_MAP);\n  }\n  @Test void testTarget(){\n    LabeledConfigMapNormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(\"name\",Map.of(\"key\",\"value\"),false,false);\n    Assertions.assertEquals(source.target(),\"configmap\");\n  }\n  @Test void testConstructorFields(){\n    LabeledConfigMapNormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(\"namespace\",Map.of(\"key\",\"value\"),false,PREFIX,true);\n    Assertions.assertEquals(source.labels(),Map.of(\"key\",\"value\"));\n    Assertions.assertEquals(source.namespace().get(),\"namespace\");\n    Assertions.assertFalse(source.failFast());\n    Assertions.assertSame(PREFIX,source.prefix());\n    Assertions.assertTrue(source.profileSpecificSources());\n  }\n  @Test void testConstructorWithoutPrefixFields(){\n    LabeledConfigMapNormalizedSource source\u003dnew LabeledConfigMapNormalizedSource(\"namespace\",Map.of(\"key\",\"value\"),true,true);\n    Assertions.assertEquals(source.labels(),Map.of(\"key\",\"value\"));\n    Assertions.assertEquals(source.namespace().get(),\"namespace\");\n    Assertions.assertTrue(source.failFast());\n    Assertions.assertSame(ConfigUtils.Prefix.DEFAULT,source.prefix());\n    Assertions.assertTrue(source.profileSpecificSources());\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass LabeledConfigMapNormalizedSourceTests {\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"prefix\",false,false,\"prefix\");\n  @Test void testEqualsAndHashCode();\n  @Test void testType();\n  @Test void testTarget();\n  @Test void testConstructorFields();\n  @Test void testConstructorWithoutPrefixFields();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/SourceDataEntriesProcessorSortedTests.java",
        "name": "SourceDataEntriesProcessorSortedTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.SourceDataEntriesProcessorSortedTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass SourceDataEntriesProcessorSortedTests {\n  @Test void testSingleNonFileProperty(){\n    Map\u003cString,String\u003e k8sSource\u003dnew LinkedHashMap\u003c\u003e();\n    k8sSource.put(\"simple-property\",\"value\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    List\u003cMap.Entry\u003cString,String\u003e\u003e result\u003dSourceDataEntriesProcessor.sorted(k8sSource,mockEnvironment);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getKey(),\"simple-property\");\n    Assertions.assertEquals(result.get(0).getValue(),\"value\");\n  }\n  @Test void testTwoNonFileProperties(){\n    Map\u003cString,String\u003e k8sSource\u003dnew LinkedHashMap\u003c\u003e();\n    k8sSource.put(\"one\",\"1\");\n    k8sSource.put(\"two\",\"2\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    List\u003cMap.Entry\u003cString,String\u003e\u003e result\u003dSourceDataEntriesProcessor.sorted(k8sSource,mockEnvironment);\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertEquals(result.get(0).getKey(),\"one\");\n    Assertions.assertEquals(result.get(0).getValue(),\"1\");\n    Assertions.assertEquals(result.get(1).getKey(),\"two\");\n    Assertions.assertEquals(result.get(1).getValue(),\"2\");\n  }\n  @Test void testSingleFileProperty(){\n    Map\u003cString,String\u003e k8sSource\u003dnew LinkedHashMap\u003c\u003e();\n    k8sSource.put(\"application.properties\",\"key\u003dvalue\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    List\u003cMap.Entry\u003cString,String\u003e\u003e result\u003dSourceDataEntriesProcessor.sorted(k8sSource,mockEnvironment);\n    Assertions.assertEquals(result.size(),1);\n    Assertions.assertEquals(result.get(0).getKey(),\"application.properties\");\n    Assertions.assertEquals(result.get(0).getValue(),\"key\u003dvalue\");\n  }\n  @Test void testApplicationAndSimpleProperty(){\n    Map\u003cString,String\u003e k8sSource\u003dnew LinkedHashMap\u003c\u003e();\n    k8sSource.put(\"application.properties\",\"key\u003dvalue\");\n    k8sSource.put(\"simple\",\"other_value\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    List\u003cMap.Entry\u003cString,String\u003e\u003e result\u003dSourceDataEntriesProcessor.sorted(k8sSource,mockEnvironment);\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertEquals(result.get(0).getKey(),\"application.properties\");\n    Assertions.assertEquals(result.get(0).getValue(),\"key\u003dvalue\");\n    Assertions.assertEquals(result.get(1).getKey(),\"simple\");\n    Assertions.assertEquals(result.get(1).getValue(),\"other_value\");\n  }\n  @Test void testSimplePropertyAndApplication(){\n    Map\u003cString,String\u003e k8sSource\u003dnew LinkedHashMap\u003c\u003e();\n    k8sSource.put(\"simple\",\"other_value\");\n    k8sSource.put(\"application.properties\",\"key\u003dvalue\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    List\u003cMap.Entry\u003cString,String\u003e\u003e result\u003dSourceDataEntriesProcessor.sorted(k8sSource,mockEnvironment);\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertEquals(result.get(0).getKey(),\"application.properties\");\n    Assertions.assertEquals(result.get(0).getValue(),\"key\u003dvalue\");\n    Assertions.assertEquals(result.get(1).getKey(),\"simple\");\n    Assertions.assertEquals(result.get(1).getValue(),\"other_value\");\n  }\n  @Test void testSimplePropertyAndTwoApplications(){\n    Map\u003cString,String\u003e k8sSource\u003dnew LinkedHashMap\u003c\u003e();\n    k8sSource.put(\"simple\",\"other_value\");\n    k8sSource.put(\"application.properties\",\"key\u003dvalue\");\n    k8sSource.put(\"application-dev.properties\",\"key-dev\u003dvalue-dev\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setActiveProfiles(\"dev\");\n    List\u003cMap.Entry\u003cString,String\u003e\u003e result\u003dSourceDataEntriesProcessor.sorted(k8sSource,mockEnvironment);\n    Assertions.assertEquals(result.size(),3);\n    Assertions.assertEquals(result.get(0).getKey(),\"application.properties\");\n    Assertions.assertEquals(result.get(0).getValue(),\"key\u003dvalue\");\n    Assertions.assertEquals(result.get(1).getKey(),\"application-dev.properties\");\n    Assertions.assertEquals(result.get(1).getValue(),\"key-dev\u003dvalue-dev\");\n    Assertions.assertEquals(result.get(2).getKey(),\"simple\");\n    Assertions.assertEquals(result.get(2).getValue(),\"other_value\");\n  }\n  @Test void testSimplePropertyAndTwoApplicationsDoNotIncludeDefaultProfile(){\n    Map\u003cString,String\u003e k8sSource\u003dnew LinkedHashMap\u003c\u003e();\n    k8sSource.put(\"simple\",\"other_value\");\n    k8sSource.put(\"application.properties\",\"key\u003dvalue\");\n    k8sSource.put(\"application-dev.properties\",\"key-dev\u003dvalue-dev\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setActiveProfiles(\"dev\");\n    List\u003cMap.Entry\u003cString,String\u003e\u003e result\u003dSourceDataEntriesProcessor.sorted(k8sSource,mockEnvironment,false);\n    Assertions.assertEquals(1,result.size());\n    Assertions.assertEquals(result.get(0).getKey(),\"application-dev.properties\");\n    Assertions.assertEquals(result.get(0).getValue(),\"key-dev\u003dvalue-dev\");\n  }\n  @Test void testComplex(){\n    Map\u003cString,String\u003e k8sSource\u003dnew LinkedHashMap\u003c\u003e();\n    k8sSource.put(\"simple\",\"other_value\");\n    k8sSource.put(\"second-simple\",\"second_other_value\");\n    k8sSource.put(\"application.properties\",\"key\u003dvalue\");\n    k8sSource.put(\"application-dev.properties\",\"key-dev\u003dvalue-dev\");\n    k8sSource.put(\"application-k8s.properties\",\"key-k8s\u003dvalue-k8s\");\n    k8sSource.put(\"ignored.properties\",\"key-ignored\u003dvalue-ignored\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setActiveProfiles(\"k8s\");\n    List\u003cMap.Entry\u003cString,String\u003e\u003e result\u003dSourceDataEntriesProcessor.sorted(k8sSource,mockEnvironment);\n    Assertions.assertEquals(result.size(),4);\n    Assertions.assertEquals(result.get(0).getKey(),\"application.properties\");\n    Assertions.assertEquals(result.get(0).getValue(),\"key\u003dvalue\");\n    Assertions.assertEquals(result.get(1).getKey(),\"application-k8s.properties\");\n    Assertions.assertEquals(result.get(1).getValue(),\"key-k8s\u003dvalue-k8s\");\n    Assertions.assertEquals(result.get(2).getKey(),\"simple\");\n    Assertions.assertEquals(result.get(2).getValue(),\"other_value\");\n    Assertions.assertEquals(result.get(3).getKey(),\"second-simple\");\n    Assertions.assertEquals(result.get(3).getValue(),\"second_other_value\");\n  }\n  @Test void testComplexWithNonDefaultApplicationName(){\n    Map\u003cString,String\u003e k8sSource\u003dnew LinkedHashMap\u003c\u003e();\n    k8sSource.put(\"simple\",\"other_value\");\n    k8sSource.put(\"second-simple\",\"second_other_value\");\n    k8sSource.put(\"application.properties\",\"key\u003dvalue\");\n    k8sSource.put(\"application-dev.properties\",\"key-dev\u003dvalue-dev\");\n    k8sSource.put(\"application-k8s.properties\",\"key-k8s\u003dvalue-k8s\");\n    k8sSource.put(\"ignored.properties\",\"key-ignored\u003dvalue-ignored\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setProperty(\"spring.application.name\",\"sorted\");\n    mockEnvironment.setActiveProfiles(\"k8s\");\n    List\u003cMap.Entry\u003cString,String\u003e\u003e result\u003dSourceDataEntriesProcessor.sorted(k8sSource,mockEnvironment);\n    Assertions.assertEquals(result.size(),2);\n    Assertions.assertEquals(result.get(0).getKey(),\"simple\");\n    Assertions.assertEquals(result.get(0).getValue(),\"other_value\");\n    Assertions.assertEquals(result.get(1).getKey(),\"second-simple\");\n    Assertions.assertEquals(result.get(1).getValue(),\"second_other_value\");\n  }\n  @Test void testComplexWithNonDefaultApplicationNameMoreMatches(){\n    Map\u003cString,String\u003e k8sSource\u003dnew LinkedHashMap\u003c\u003e();\n    k8sSource.put(\"simple\",\"other_value\");\n    k8sSource.put(\"second-simple\",\"second_other_value\");\n    k8sSource.put(\"sorted.properties\",\"key\u003dvalue\");\n    k8sSource.put(\"application-dev.properties\",\"key-dev\u003dvalue-dev\");\n    k8sSource.put(\"sorted-k8s.properties\",\"key-k8s\u003dvalue-k8s\");\n    k8sSource.put(\"ignored.properties\",\"key-ignored\u003dvalue-ignored\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setProperty(\"spring.application.name\",\"sorted\");\n    mockEnvironment.setActiveProfiles(\"k8s\");\n    List\u003cMap.Entry\u003cString,String\u003e\u003e result\u003dSourceDataEntriesProcessor.sorted(k8sSource,mockEnvironment);\n    Assertions.assertEquals(result.size(),4);\n    Assertions.assertEquals(result.get(0).getKey(),\"sorted.properties\");\n    Assertions.assertEquals(result.get(0).getValue(),\"key\u003dvalue\");\n    Assertions.assertEquals(result.get(1).getKey(),\"sorted-k8s.properties\");\n    Assertions.assertEquals(result.get(1).getValue(),\"key-k8s\u003dvalue-k8s\");\n    Assertions.assertEquals(result.get(2).getKey(),\"simple\");\n    Assertions.assertEquals(result.get(2).getValue(),\"other_value\");\n    Assertions.assertEquals(result.get(3).getKey(),\"second-simple\");\n    Assertions.assertEquals(result.get(3).getValue(),\"second_other_value\");\n  }\n  @Test void testProfileBasedOnly(){\n    Map\u003cString,String\u003e k8sSource\u003dnew LinkedHashMap\u003c\u003e();\n    k8sSource.put(\"simple\",\"other_value\");\n    k8sSource.put(\"second-simple\",\"second_other_value\");\n    k8sSource.put(\"sorted-k8s.properties\",\"key-k8s\u003dvalue-k8s\");\n    k8sSource.put(\"ignored.properties\",\"key-ignored\u003dvalue-ignored\");\n    MockEnvironment mockEnvironment\u003dnew MockEnvironment();\n    mockEnvironment.setProperty(\"spring.application.name\",\"sorted\");\n    mockEnvironment.setActiveProfiles(\"k8s\");\n    List\u003cMap.Entry\u003cString,String\u003e\u003e result\u003dSourceDataEntriesProcessor.sorted(k8sSource,mockEnvironment);\n    Assertions.assertEquals(result.size(),3);\n    Assertions.assertEquals(result.get(0).getKey(),\"sorted-k8s.properties\");\n    Assertions.assertEquals(result.get(0).getValue(),\"key-k8s\u003dvalue-k8s\");\n    Assertions.assertEquals(result.get(1).getKey(),\"simple\");\n    Assertions.assertEquals(result.get(1).getValue(),\"other_value\");\n    Assertions.assertEquals(result.get(2).getKey(),\"second-simple\");\n    Assertions.assertEquals(result.get(2).getValue(),\"second_other_value\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass SourceDataEntriesProcessorSortedTests {\n  @Test void testSingleNonFileProperty();\n  @Test void testTwoNonFileProperties();\n  @Test void testSingleFileProperty();\n  @Test void testApplicationAndSimpleProperty();\n  @Test void testSimplePropertyAndApplication();\n  @Test void testSimplePropertyAndTwoApplications();\n  @Test void testSimplePropertyAndTwoApplicationsDoNotIncludeDefaultProfile();\n  @Test void testComplex();\n  @Test void testComplexWithNonDefaultApplicationName();\n  @Test void testComplexWithNonDefaultApplicationNameMoreMatches();\n  @Test void testProfileBasedOnly();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/bootstrap/FailFastEnabledWithoutSpringRetryOnClasspath.java",
        "name": "FailFastEnabledWithoutSpringRetryOnClasspath",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.bootstrap.FailFastEnabledWithoutSpringRetryOnClasspath",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\nclass FailFastEnabledWithoutSpringRetryOnClasspath {\n  private final ApplicationContextRunner contextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesBootstrapConfiguration.class)).withClassLoader(new FilteredClassLoader(Retryable.class,Aspect.class,AopAutoConfiguration.class));\n  @Test void shouldNotDefineRetryBeansWhenConfigMapFailFastEnabled(){\n    contextRunner.withPropertyValues(\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\").run(context -\u003e assertThat(context.getBeansOfType(RetryOperationsInterceptor.class)).isEmpty());\n  }\n  @Test void shouldNotDefineRetryBeansWhenSecretsFailFastEnabled(){\n    contextRunner.withPropertyValues(\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\").run(context -\u003e assertThat(context.getBeansOfType(RetryOperationsInterceptor.class)).isEmpty());\n  }\n  @Test void shouldNotDefineRetryBeansWhenConfigMapAndSecretsFailFastEnabled(){\n    contextRunner.withPropertyValues(\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\").run(context -\u003e assertThat(context.getBeansOfType(RetryOperationsInterceptor.class)).isEmpty());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\nclass FailFastEnabledWithoutSpringRetryOnClasspath {\n  private final ApplicationContextRunner contextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesBootstrapConfiguration.class)).withClassLoader(new FilteredClassLoader(Retryable.class,Aspect.class,AopAutoConfiguration.class));\n  @Test void shouldNotDefineRetryBeansWhenConfigMapFailFastEnabled();\n  @Test void shouldNotDefineRetryBeansWhenSecretsFailFastEnabled();\n  @Test void shouldNotDefineRetryBeansWhenConfigMapAndSecretsFailFastEnabled();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/bootstrap/SecretsFailFastEnabledWithCustomRetryConfiguration.java",
        "name": "SecretsFailFastEnabledWithCustomRetryConfiguration",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.max-attempts\u003d3\",\"spring.cloud.kubernetes.secrets.retry.initial-interval\u003d1500\",\"spring.cloud.kubernetes.secrets.retry.max-interval\u003d3000\",\"spring.cloud.kubernetes.secrets.retry.multiplier\u003d1.5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.bootstrap.SecretsFailFastEnabledWithCustomRetryConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.max-attempts\u003d3\",\"spring.cloud.kubernetes.secrets.retry.initial-interval\u003d1500\",\"spring.cloud.kubernetes.secrets.retry.max-interval\u003d3000\",\"spring.cloud.kubernetes.secrets.retry.multiplier\u003d1.5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"}) class SecretsFailFastEnabledWithCustomRetryConfiguration {\n  @Autowired private SecretsConfigProperties secretsConfigProperties;\n  @Test void retryConfigurationShouldBeCustomized(){\n    RetryProperties retryProperties\u003dsecretsConfigProperties.retry();\n    assertThat(retryProperties.maxAttempts()).isEqualTo(3);\n    assertThat(retryProperties.initialInterval()).isEqualTo(1500L);\n    assertThat(retryProperties.maxInterval()).isEqualTo(3000L);\n    assertThat(retryProperties.multiplier()).isEqualTo(1.5D);\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.max-attempts\u003d3\",\"spring.cloud.kubernetes.secrets.retry.initial-interval\u003d1500\",\"spring.cloud.kubernetes.secrets.retry.max-interval\u003d3000\",\"spring.cloud.kubernetes.secrets.retry.multiplier\u003d1.5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"}) class SecretsFailFastEnabledWithCustomRetryConfiguration {\n  @Autowired private SecretsConfigProperties secretsConfigProperties;\n  @Test void retryConfigurationShouldBeCustomized();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/bootstrap/ConfigFailFastEnabled.java",
        "name": "ConfigFailFastEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.bootstrap.ConfigFailFastEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"}) class ConfigFailFastEnabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Autowired private ConfigMapConfigProperties configMapConfigProperties;\n  @Test void shouldDefineRequiredBeans(){\n    Map\u003cString,RetryOperationsInterceptor\u003e retryInterceptors\u003dcontext.getBeansOfType(RetryOperationsInterceptor.class);\n    assertThat(retryInterceptors.containsKey(\"kubernetesConfigRetryInterceptor\")).isTrue();\n    assertThat(retryInterceptors.containsKey(\"kubernetesSecretsRetryInterceptor\")).isTrue();\n  }\n  @Test void retryConfigurationShouldBeDefault(){\n    RetryProperties retryProperties\u003dconfigMapConfigProperties.retry();\n    RetryProperties defaultRetryProperties\u003dRetryProperties.DEFAULT;\n    assertThat(retryProperties.maxAttempts()).isEqualTo(defaultRetryProperties.maxAttempts());\n    assertThat(retryProperties.initialInterval()).isEqualTo(defaultRetryProperties.initialInterval());\n    assertThat(retryProperties.maxInterval()).isEqualTo(defaultRetryProperties.maxInterval());\n    assertThat(retryProperties.multiplier()).isEqualTo(defaultRetryProperties.multiplier());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"}) class ConfigFailFastEnabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Autowired private ConfigMapConfigProperties configMapConfigProperties;\n  @Test void shouldDefineRequiredBeans();\n  @Test void retryConfigurationShouldBeDefault();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/bootstrap/FailFastDisabled.java",
        "name": "FailFastDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.config.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.bootstrap.FailFastDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.config.enabled\u003dfalse\"}) class FailFastDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void shouldNotDefineRetryBeans(){\n    assertThat(context.getBeansOfType(RetryOperationsInterceptor.class)).isEmpty();\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.config.enabled\u003dfalse\"}) class FailFastDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void shouldNotDefineRetryBeans();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/bootstrap/SecretsFailFastEnabledButRetryDisabled.java",
        "name": "SecretsFailFastEnabledButRetryDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.config.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.bootstrap.SecretsFailFastEnabledButRetryDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.config.enabled\u003dfalse\"}) class SecretsFailFastEnabledButRetryDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void shouldNotDefineRetryBeans(){\n    assertThat(context.getBeansOfType(RetryOperationsInterceptor.class)).isEmpty();\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\",\"spring.cloud.config.enabled\u003dfalse\"}) class SecretsFailFastEnabledButRetryDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void shouldNotDefineRetryBeans();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/bootstrap/ConfigAndSecretsFailFastEnabledWithDefaultRetryConfiguration.java",
        "name": "ConfigAndSecretsFailFastEnabledWithDefaultRetryConfiguration",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.bootstrap.ConfigAndSecretsFailFastEnabledWithDefaultRetryConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"}) class ConfigAndSecretsFailFastEnabledWithDefaultRetryConfiguration {\n  @Autowired private ConfigurableApplicationContext context;\n  @Autowired private ConfigMapConfigProperties configMapConfigProperties;\n  @Autowired private SecretsConfigProperties secretsConfigProperties;\n  @Test void shouldDefineRequiredBeans(){\n    Map\u003cString,RetryOperationsInterceptor\u003e retryInterceptors\u003dcontext.getBeansOfType(RetryOperationsInterceptor.class);\n    assertThat(retryInterceptors.containsKey(\"kubernetesConfigRetryInterceptor\")).isTrue();\n    assertThat(retryInterceptors.containsKey(\"kubernetesSecretsRetryInterceptor\")).isTrue();\n  }\n  @Test void retryConfigurationShouldBeDefault(){\n    RetryProperties defaultRetryProperties\u003dRetryProperties.DEFAULT;\n    RetryProperties configMapRetryProperties\u003dconfigMapConfigProperties.retry();\n    assertThat(configMapRetryProperties.maxAttempts()).isEqualTo(defaultRetryProperties.maxAttempts());\n    assertThat(configMapRetryProperties.initialInterval()).isEqualTo(defaultRetryProperties.initialInterval());\n    assertThat(configMapRetryProperties.maxInterval()).isEqualTo(defaultRetryProperties.maxInterval());\n    assertThat(configMapRetryProperties.multiplier()).isEqualTo(defaultRetryProperties.multiplier());\n    RetryProperties secretsRetryProperties\u003dsecretsConfigProperties.retry();\n    assertThat(secretsRetryProperties.maxAttempts()).isEqualTo(defaultRetryProperties.maxAttempts());\n    assertThat(secretsRetryProperties.initialInterval()).isEqualTo(defaultRetryProperties.initialInterval());\n    assertThat(secretsRetryProperties.maxInterval()).isEqualTo(defaultRetryProperties.maxInterval());\n    assertThat(secretsRetryProperties.multiplier()).isEqualTo(defaultRetryProperties.multiplier());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"}) class ConfigAndSecretsFailFastEnabledWithDefaultRetryConfiguration {\n  @Autowired private ConfigurableApplicationContext context;\n  @Autowired private ConfigMapConfigProperties configMapConfigProperties;\n  @Autowired private SecretsConfigProperties secretsConfigProperties;\n  @Test void shouldDefineRequiredBeans();\n  @Test void retryConfigurationShouldBeDefault();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/bootstrap/SecretsFailFastEnabled.java",
        "name": "SecretsFailFastEnabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.bootstrap.SecretsFailFastEnabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"}) class SecretsFailFastEnabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Autowired private SecretsConfigProperties secretsConfigProperties;\n  @Test void shouldDefineRequiredBeans(){\n    Map\u003cString,RetryOperationsInterceptor\u003e retryInterceptors\u003dcontext.getBeansOfType(RetryOperationsInterceptor.class);\n    assertThat(retryInterceptors.containsKey(\"kubernetesConfigRetryInterceptor\")).isTrue();\n    assertThat(retryInterceptors.containsKey(\"kubernetesSecretsRetryInterceptor\")).isTrue();\n  }\n  @Test void retryConfigurationShouldBeDefault(){\n    RetryProperties retryProperties\u003dsecretsConfigProperties.retry();\n    RetryProperties defaultRetryProperties\u003dRetryProperties.DEFAULT;\n    assertThat(retryProperties.maxAttempts()).isEqualTo(defaultRetryProperties.maxAttempts());\n    assertThat(retryProperties.initialInterval()).isEqualTo(defaultRetryProperties.initialInterval());\n    assertThat(retryProperties.maxInterval()).isEqualTo(defaultRetryProperties.maxInterval());\n    assertThat(retryProperties.multiplier()).isEqualTo(defaultRetryProperties.multiplier());\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"}) class SecretsFailFastEnabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Autowired private SecretsConfigProperties secretsConfigProperties;\n  @Test void shouldDefineRequiredBeans();\n  @Test void retryConfigurationShouldBeDefault();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/bootstrap/ConfigFailFastEnabledWithCustomRetryConfiguration.java",
        "name": "ConfigFailFastEnabledWithCustomRetryConfiguration",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d3\",\"spring.cloud.kubernetes.config.retry.initial-interval\u003d1500\",\"spring.cloud.kubernetes.config.retry.max-interval\u003d3000\",\"spring.cloud.kubernetes.config.retry.multiplier\u003d1.5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.bootstrap.ConfigFailFastEnabledWithCustomRetryConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d3\",\"spring.cloud.kubernetes.config.retry.initial-interval\u003d1500\",\"spring.cloud.kubernetes.config.retry.max-interval\u003d3000\",\"spring.cloud.kubernetes.config.retry.multiplier\u003d1.5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"}) class ConfigFailFastEnabledWithCustomRetryConfiguration {\n  @Autowired private ConfigMapConfigProperties configMapConfigProperties;\n  @Test void retryConfigurationShouldBeCustomized(){\n    RetryProperties retryProperties\u003dconfigMapConfigProperties.retry();\n    assertThat(retryProperties.maxAttempts()).isEqualTo(3);\n    assertThat(retryProperties.initialInterval()).isEqualTo(1500L);\n    assertThat(retryProperties.maxInterval()).isEqualTo(3000L);\n    assertThat(retryProperties.multiplier()).isEqualTo(1.5D);\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d3\",\"spring.cloud.kubernetes.config.retry.initial-interval\u003d1500\",\"spring.cloud.kubernetes.config.retry.max-interval\u003d3000\",\"spring.cloud.kubernetes.config.retry.multiplier\u003d1.5\",\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\"}) class ConfigFailFastEnabledWithCustomRetryConfiguration {\n  @Autowired private ConfigMapConfigProperties configMapConfigProperties;\n  @Test void retryConfigurationShouldBeCustomized();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/bootstrap/ConfigFailFastEnabledButRetryDisabled.java",
        "name": "ConfigFailFastEnabledButRetryDisabled",
        "modifiers": "@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.config.enabled\u003dfalse\"})",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.bootstrap.ConfigFailFastEnabledButRetryDisabled",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.config.enabled\u003dfalse\"}) class ConfigFailFastEnabledButRetryDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void shouldNotDefineRetryBeans(){\n    assertThat(context.getBeansOfType(RetryOperationsInterceptor.class)).isEmpty();\n  }\n}\n",
        "abstract": "/** \n * @author Isik Erhan\n */\n@SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.NONE,classes\u003dApp.class,properties\u003d{\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\",\"spring.cloud.config.enabled\u003dfalse\"}) class ConfigFailFastEnabledButRetryDisabled {\n  @Autowired private ConfigurableApplicationContext context;\n  @Test void shouldNotDefineRetryBeans();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/KubernetesConfigDataLocationResolverTests.java",
        "name": "KubernetesConfigDataLocationResolverTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.KubernetesConfigDataLocationResolverTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesConfigDataLocationResolverTests {\n  private static final DeferredLogFactory FACTORY\u003dSupplier::get;\n  private static final KubernetesConfigDataLocationResolver NOOP_RESOLVER\u003dnew KubernetesConfigDataLocationResolver(FACTORY){\n    @Override protected void registerBeans(    ConfigDataLocationResolverContext resolverContext,    ConfigDataLocation location,    Profiles profiles,    PropertyHolder propertyHolder,    KubernetesNamespaceProvider namespaceProvider){\n    }\n  }\n;\n  private static final ConfigDataLocationResolverContext RESOLVER_CONTEXT\u003dMockito.mock(ConfigDataLocationResolverContext.class);\n  @Test void testGetPrefix(){\n    Assertions.assertEquals(\"kubernetes:\",NOOP_RESOLVER.getPrefix());\n  }\n  /** \n * method returns true via \u0027KUBERNETES.isEnforced(context.getBinder())\u0027\n */\n  @Test void testIsResolvableTrue(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.main.cloud-platform\",\"KUBERNETES\");\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    boolean result\u003dNOOP_RESOLVER.isResolvable(RESOLVER_CONTEXT,configDataLocation);\n    Assertions.assertTrue(result);\n  }\n  @Test void testIsResolvableFalse(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    boolean result\u003dNOOP_RESOLVER.isResolvable(RESOLVER_CONTEXT,configDataLocation);\n    Assertions.assertFalse(result);\n  }\n  @Test void testResolve(){\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    List\u003cKubernetesConfigDataResource\u003e result\u003dNOOP_RESOLVER.resolve(RESOLVER_CONTEXT,configDataLocation);\n    Assertions.assertEquals(0,result.size());\n  }\n  /** \n * \u003cpre\u003e a test that only looks at 3 properties: - application name - namespace (via \u0027spring.cloud.kubernetes.client.namespace\u0027) - KubernetesClientProperties (created via bindOrCreate) \u003c/pre\u003e\n */\n  @Test void testResolveProfileSpecificOne(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.application.name\",\"k8s-app-name\");\n    environment.setProperty(\"spring.cloud.kubernetes.client.namespace\",\"non-default-namespace\");\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(new DefaultBootstrapContext());\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    List\u003cKubernetesConfigDataResource\u003e result\u003dNOOP_RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertEquals(1,result.size());\n    Assertions.assertEquals(\"k8s-app-name\",result.get(0).getEnvironment().getRequiredProperty(\"spring.application.name\"));\n    Assertions.assertEquals(\"non-default-namespace\",result.get(0).getEnvironment().getRequiredProperty(\"spring.cloud.kubernetes.client.namespace\"));\n    Assertions.assertEquals(\"Spring-Cloud-Kubernetes-Application\",result.get(0).getProperties().userAgent());\n    Assertions.assertEquals(\"non-default-namespace\",result.get(0).getProperties().namespace());\n  }\n  /** \n * \u003cpre\u003e a test that only looks at 3 properties: - application name - namespace (via \u0027kubernetes.namespace\u0027) - KubernetesClientProperties (bind from bootstrap context) \u003c/pre\u003e\n */\n  @Test void testResolveProfileSpecificTwo(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.application.name\",\"k8s-app-name\");\n    environment.setProperty(\"kubernetes.namespace\",\"non-default-namespace\");\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    DefaultBootstrapContext context\u003dnew DefaultBootstrapContext();\n    KubernetesClientProperties properties\u003dnew KubernetesClientProperties(null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"user-agent\");\n    context.register(KubernetesClientProperties.class,BootstrapRegistry.InstanceSupplier.of(properties));\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(context);\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    List\u003cKubernetesConfigDataResource\u003e result\u003dNOOP_RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertEquals(1,result.size());\n    Assertions.assertEquals(\"k8s-app-name\",result.get(0).getEnvironment().getRequiredProperty(\"spring.application.name\"));\n    Assertions.assertEquals(\"non-default-namespace\",result.get(0).getEnvironment().getRequiredProperty(\"spring.cloud.kubernetes.client.namespace\"));\n    Assertions.assertEquals(\"user-agent\",result.get(0).getProperties().userAgent());\n    Assertions.assertEquals(\"non-default-namespace\",result.get(0).getProperties().namespace());\n  }\n  /** \n * test that asserts that we registered 3 property classes via \u0027registerProperties\u0027\n */\n  @Test void testResolveProfileSpecificThree(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(new DefaultBootstrapContext());\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    NOOP_RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    KubernetesClientProperties kubernetesClientProperties\u003dRESOLVER_CONTEXT.getBootstrapContext().get(KubernetesClientProperties.class);\n    ConfigMapConfigProperties configMapConfigProperties\u003dRESOLVER_CONTEXT.getBootstrapContext().get(ConfigMapConfigProperties.class);\n    SecretsConfigProperties secretsConfigProperties\u003dRESOLVER_CONTEXT.getBootstrapContext().get(SecretsConfigProperties.class);\n    Assertions.assertNotNull(kubernetesClientProperties);\n    Assertions.assertNotNull(configMapConfigProperties);\n    Assertions.assertNotNull(secretsConfigProperties);\n  }\n  /** \n * test that asserts that we registered 1 property class via \u0027registerProperties\u0027 The other two are disabled, on purpose.\n */\n  @Test void testResolveProfileSpecificFour(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.config.enabled\",\"false\");\n    environment.setProperty(\"spring.cloud.kubernetes.secrets.enabled\",\"false\");\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(new DefaultBootstrapContext());\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    NOOP_RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    ConfigMapConfigProperties one\u003dnew ConfigMapConfigProperties(false,List.of(),List.of(),Map.of(),false,null,null,false,false,false,null);\n    SecretsConfigProperties two\u003dnew SecretsConfigProperties(false,Map.of(),List.of(),List.of(),false,null,null,false,false,false,null);\n    KubernetesClientProperties kubernetesClientProperties\u003dRESOLVER_CONTEXT.getBootstrapContext().get(KubernetesClientProperties.class);\n    ConfigMapConfigProperties configMapConfigProperties\u003dRESOLVER_CONTEXT.getBootstrapContext().getOrElse(ConfigMapConfigProperties.class,one);\n    SecretsConfigProperties secretsConfigProperties\u003dRESOLVER_CONTEXT.getBootstrapContext().getOrElse(SecretsConfigProperties.class,two);\n    Assertions.assertNotNull(kubernetesClientProperties);\n    Assertions.assertSame(one,configMapConfigProperties);\n    Assertions.assertSame(two,secretsConfigProperties);\n  }\n  /** \n * test that proves that ConfigMapConfigProperties and SecretsConfigProperties are created with @Default values\n */\n  @Test void testResolveProfileSpecificFive(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(new DefaultBootstrapContext());\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    List\u003cKubernetesConfigDataResource\u003e result\u003dNOOP_RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertTrue(result.get(0).getConfigMapProperties().enableApi());\n    Assertions.assertTrue(result.get(0).getSecretsConfigProperties().enabled());\n  }\n  /** \n * test that proves that ConfigMapConfigProperties and SecretsConfigProperties are bind with existing properties\n */\n  @Test void testResolveProfileSpecificSix(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    environment.setProperty(\"spring.cloud.kubernetes.config.enable-api\",\"false\");\n    environment.setProperty(\"spring.cloud.kubernetes.secrets.paths[0]\",\"a\");\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(new DefaultBootstrapContext());\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    List\u003cKubernetesConfigDataResource\u003e result\u003dNOOP_RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertFalse(result.get(0).getConfigMapProperties().enableApi());\n    Assertions.assertTrue(result.get(0).getConfigMapProperties().enabled());\n    Assertions.assertEquals(\"a\",result.get(0).getSecretsConfigProperties().paths().get(0));\n    Assertions.assertTrue(result.get(0).getSecretsConfigProperties().includeProfileSpecificSources());\n  }\n  @Test void testIsOptional(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(new DefaultBootstrapContext());\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    List\u003cKubernetesConfigDataResource\u003e result\u003dNOOP_RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertFalse(result.get(0).isOptional());\n  }\n  @Test void testProfiles(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    ConfigurationPropertySources.attach(environment);\n    Binder binder\u003dnew Binder(ConfigurationPropertySources.get(environment));\n    Mockito.when(RESOLVER_CONTEXT.getBinder()).thenReturn(binder);\n    Mockito.when(RESOLVER_CONTEXT.getBootstrapContext()).thenReturn(new DefaultBootstrapContext());\n    Profiles profiles\u003dMockito.mock(Profiles.class);\n    Mockito.when(profiles.getAccepted()).thenReturn(List.of(\"a\",\"b\"));\n    ConfigDataLocation configDataLocation\u003dConfigDataLocation.of(\"kubernetes:abc\");\n    List\u003cKubernetesConfigDataResource\u003e result\u003dNOOP_RESOLVER.resolveProfileSpecific(RESOLVER_CONTEXT,configDataLocation,profiles);\n    Assertions.assertEquals(List.of(\"a\",\"b\"),Arrays.stream(result.get(0).getEnvironment().getActiveProfiles()).toList());\n    Assertions.assertEquals(\"a,b\",result.get(0).getProfiles());\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesConfigDataLocationResolverTests {\n  private static final DeferredLogFactory FACTORY\u003dSupplier::get;\n  private static final KubernetesConfigDataLocationResolver NOOP_RESOLVER\u003dnew KubernetesConfigDataLocationResolver(FACTORY){\n    @Override protected void registerBeans(    ConfigDataLocationResolverContext resolverContext,    ConfigDataLocation location,    Profiles profiles,    PropertyHolder propertyHolder,    KubernetesNamespaceProvider namespaceProvider);\n  }\n;\n  private static final ConfigDataLocationResolverContext RESOLVER_CONTEXT\u003dMockito.mock(ConfigDataLocationResolverContext.class);\n  @Test void testGetPrefix();\n  /** \n * method returns true via \u0027KUBERNETES.isEnforced(context.getBinder())\u0027\n */\n  @Test void testIsResolvableTrue();\n  @Test void testIsResolvableFalse();\n  @Test void testResolve();\n  /** \n * \u003cpre\u003e a test that only looks at 3 properties: - application name - namespace (via \u0027spring.cloud.kubernetes.client.namespace\u0027) - KubernetesClientProperties (created via bindOrCreate) \u003c/pre\u003e\n */\n  @Test void testResolveProfileSpecificOne();\n  /** \n * \u003cpre\u003e a test that only looks at 3 properties: - application name - namespace (via \u0027kubernetes.namespace\u0027) - KubernetesClientProperties (bind from bootstrap context) \u003c/pre\u003e\n */\n  @Test void testResolveProfileSpecificTwo();\n  /** \n * test that asserts that we registered 3 property classes via \u0027registerProperties\u0027\n */\n  @Test void testResolveProfileSpecificThree();\n  /** \n * test that asserts that we registered 1 property class via \u0027registerProperties\u0027 The other two are disabled, on purpose.\n */\n  @Test void testResolveProfileSpecificFour();\n  /** \n * test that proves that ConfigMapConfigProperties and SecretsConfigProperties are created with @Default values\n */\n  @Test void testResolveProfileSpecificFive();\n  /** \n * test that proves that ConfigMapConfigProperties and SecretsConfigProperties are bind with existing properties\n */\n  @Test void testResolveProfileSpecificSix();\n  @Test void testIsOptional();\n  @Test void testProfiles();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/App.java",
        "name": "App",
        "modifiers": "@SpringBootApplication public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.App",
        "extend": "",
        "implements": "",
        "raw": "@SpringBootApplication public class App {\n}\n",
        "abstract": "@SpringBootApplication public class App {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/SourceDataEntriesProcessorTests.java",
        "name": "SourceDataEntriesProcessorTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.SourceDataEntriesProcessorTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass SourceDataEntriesProcessorTests {\n  @Test void testSingleYml(){\n    Map\u003cString,Object\u003e result\u003dSourceDataEntriesProcessor.processAllEntries(Map.of(\"one.yml\",\"key: \\n value\"),new MockEnvironment());\n    Assertions.assertEquals(1,result.size());\n    Assertions.assertEquals(\"value\",result.get(\"key\"));\n  }\n  @Test void testSingleYaml(){\n    Map\u003cString,Object\u003e result\u003dSourceDataEntriesProcessor.processAllEntries(Map.of(\"one.yaml\",\"key: \\n value\"),new MockEnvironment());\n    Assertions.assertEquals(1,result.size());\n    Assertions.assertEquals(\"value\",result.get(\"key\"));\n  }\n  @Test void testSingleProperties(){\n    Map\u003cString,Object\u003e result\u003dSourceDataEntriesProcessor.processAllEntries(Map.of(\"one.properties\",\"key\u003dvalue\"),new MockEnvironment());\n    Assertions.assertEquals(1,result.size());\n    Assertions.assertEquals(\"value\",result.get(\"key\"));\n  }\n  /** \n * \u003cpre\u003e two properties present, none are file treated \u003c/pre\u003e\n */\n  @Test void twoEntriesNoneFileTreated(){\n    Map.Entry\u003cString,String\u003e one\u003dMap.entry(\"one\",\"1\");\n    Map.Entry\u003cString,String\u003e two\u003dMap.entry(\"two\",\"2\");\n    Map\u003cString,String\u003e map\u003dMap.ofEntries(one,two);\n    Map\u003cString,Object\u003e result\u003dSourceDataEntriesProcessor.processAllEntries(map,new MockEnvironment());\n    Assertions.assertEquals(2,result.size());\n    Assertions.assertEquals(\"1\",result.get(\"one\"));\n    Assertions.assertEquals(\"2\",result.get(\"two\"));\n  }\n  /** \n * \u003cpre\u003e - two properties present, none are file treated. - even if there is a application.yaml, it is not taken since it is !\u003d spring.application.name \u003c/pre\u003e\n */\n  @Test void twoEntriesOneIsYamlButNotTaken(){\n    Map.Entry\u003cString,String\u003e one\u003dMap.entry(\"one\",\"1\");\n    Map.Entry\u003cString,String\u003e myName\u003dMap.entry(\"my-name.yaml\",\"color: \\n blue\");\n    Map\u003cString,String\u003e map\u003dMap.ofEntries(one,myName);\n    Map\u003cString,Object\u003e result\u003dSourceDataEntriesProcessor.processAllEntries(map,new MockEnvironment());\n    Assertions.assertEquals(1,result.size());\n    Assertions.assertEquals(\"1\",result.get(\"one\"));\n  }\n  /** \n * \u003cpre\u003e - two properties present, both taken. - second one is treated as a file, since it\u0027s name matches \"spring.application.name\" \u003c/pre\u003e\n */\n  @Test void twoEntriesBothTaken(){\n    Map.Entry\u003cString,String\u003e one\u003dMap.entry(\"one\",\"1\");\n    Map.Entry\u003cString,String\u003e application\u003dMap.entry(\"application.yaml\",\"color: \\n blue\");\n    Map\u003cString,String\u003e map\u003dMap.ofEntries(one,application);\n    Map\u003cString,Object\u003e result\u003dSourceDataEntriesProcessor.processAllEntries(map,new MockEnvironment());\n    Assertions.assertEquals(2,result.size());\n    Assertions.assertEquals(\"1\",result.get(\"one\"));\n    Assertions.assertEquals(\"blue\",result.get(\"color\"));\n  }\n  /** \n * \u003cpre\u003e - three properties present, all taken. - second one is treated as a file, since it\u0027s name matches \"spring.application.name\" - third one is taken since it matches one active profile \u003c/pre\u003e\n */\n  @Test void threeEntriesAllTaken(){\n    Map.Entry\u003cString,String\u003e one\u003dMap.entry(\"one\",\"1\");\n    Map.Entry\u003cString,String\u003e application\u003dMap.entry(\"application.properties\",\"color\u003dblue\");\n    Map.Entry\u003cString,String\u003e applicationDev\u003dMap.entry(\"application-dev.properties\",\"fit\u003dsport\");\n    Map\u003cString,String\u003e map\u003dMap.ofEntries(one,application,applicationDev);\n    MockEnvironment env\u003dnew MockEnvironment();\n    env.setActiveProfiles(\"dev\");\n    Map\u003cString,Object\u003e result\u003dSourceDataEntriesProcessor.processAllEntries(map,env);\n    Assertions.assertEquals(3,result.size());\n    Assertions.assertEquals(\"1\",result.get(\"one\"));\n    Assertions.assertEquals(\"blue\",result.get(\"color\"));\n    Assertions.assertEquals(\"sport\",result.get(\"fit\"));\n  }\n  /** \n * \u003cpre\u003e - five properties present, four are taken - second one is treated as a file, since it\u0027s name matches \"spring.application.name\" - third one is taken since it matches one active profile - fourth one is taken since it matches one active profile \u003c/pre\u003e\n */\n  @Test void fiveEntriesFourTaken(){\n    Map.Entry\u003cString,String\u003e one\u003dMap.entry(\"one\",\"1\");\n    Map.Entry\u003cString,String\u003e jacket\u003dMap.entry(\"jacket.properties\",\"name\u003djacket\");\n    Map.Entry\u003cString,String\u003e jacketFit\u003dMap.entry(\"jacket-fit.properties\",\"fit\u003dsport\");\n    Map.Entry\u003cString,String\u003e jacketColor\u003dMap.entry(\"jacket-color.properties\",\"color\u003dblack\");\n    Map.Entry\u003cString,String\u003e jacketSeason\u003dMap.entry(\"jacket-season.properties\",\"season\u003dsummer\");\n    Map\u003cString,String\u003e map\u003dMap.ofEntries(one,jacket,jacketFit,jacketColor,jacketSeason);\n    MockEnvironment env\u003dnew MockEnvironment();\n    env.setProperty(\"spring.application.name\",\"jacket\");\n    env.setActiveProfiles(\"fit\",\"color\");\n    Map\u003cString,Object\u003e result\u003dSourceDataEntriesProcessor.processAllEntries(map,env);\n    Assertions.assertEquals(4,result.size());\n    Assertions.assertEquals(\"1\",result.get(\"one\"));\n    Assertions.assertEquals(\"jacket\",result.get(\"name\"));\n    Assertions.assertEquals(\"sport\",result.get(\"fit\"));\n    Assertions.assertEquals(\"black\",result.get(\"color\"));\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass SourceDataEntriesProcessorTests {\n  @Test void testSingleYml();\n  @Test void testSingleYaml();\n  @Test void testSingleProperties();\n  /** \n * \u003cpre\u003e two properties present, none are file treated \u003c/pre\u003e\n */\n  @Test void twoEntriesNoneFileTreated();\n  /** \n * \u003cpre\u003e - two properties present, none are file treated. - even if there is a application.yaml, it is not taken since it is !\u003d spring.application.name \u003c/pre\u003e\n */\n  @Test void twoEntriesOneIsYamlButNotTaken();\n  /** \n * \u003cpre\u003e - two properties present, both taken. - second one is treated as a file, since it\u0027s name matches \"spring.application.name\" \u003c/pre\u003e\n */\n  @Test void twoEntriesBothTaken();\n  /** \n * \u003cpre\u003e - three properties present, all taken. - second one is treated as a file, since it\u0027s name matches \"spring.application.name\" - third one is taken since it matches one active profile \u003c/pre\u003e\n */\n  @Test void threeEntriesAllTaken();\n  /** \n * \u003cpre\u003e - five properties present, four are taken - second one is treated as a file, since it\u0027s name matches \"spring.application.name\" - third one is taken since it matches one active profile - fourth one is taken since it matches one active profile \u003c/pre\u003e\n */\n  @Test void fiveEntriesFourTaken();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/ConfigReloadPropertiesTests.java",
        "name": "ConfigReloadPropertiesTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConfigReloadPropertiesTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57Tests binding, since we moved from a class to a record\n */\nclass ConfigReloadPropertiesTests {\n  @Test void testDefaults(){\n    new ApplicationContextRunner().withUserConfiguration(Config.class).run(context -\u003e {\n      ConfigReloadProperties properties\u003dcontext.getBean(ConfigReloadProperties.class);\n      Assertions.assertNotNull(properties);\n      Assertions.assertFalse(properties.enabled());\n      Assertions.assertTrue(properties.monitoringConfigMaps());\n      Assertions.assertFalse(properties.monitoringSecrets());\n      Assertions.assertEquals(ConfigReloadProperties.ReloadStrategy.REFRESH,properties.strategy());\n      Assertions.assertEquals(ConfigReloadProperties.ReloadDetectionMode.EVENT,properties.mode());\n      Assertions.assertEquals(Duration.ofMillis(15000),properties.period());\n      Assertions.assertTrue(properties.namespaces().isEmpty());\n      Assertions.assertEquals(Duration.ofSeconds(2),properties.maxWaitForRestart());\n    }\n);\n  }\n  @Test void testNonDefaults(){\n    new ApplicationContextRunner().withUserConfiguration(Config.class).withPropertyValues(\"spring.cloud.kubernetes.reload.enabled\u003dtrue\",\"spring.cloud.kubernetes.reload.monitoring-config-maps\u003dfalse\",\"spring.cloud.kubernetes.reload.monitoring-secrets\u003dtrue\",\"spring.cloud.kubernetes.reload.strategy\u003dSHUTDOWN\",\"spring.cloud.kubernetes.reload.mode\u003dPOLLING\",\"spring.cloud.kubernetes.reload.period\u003d1000ms\",\"spring.cloud.kubernetes.reload.namespaces[0]\u003da\",\"spring.cloud.kubernetes.reload.namespaces[1]\u003db\",\"spring.cloud.kubernetes.reload.max-wait-for-restart\u003d5s\").run(context -\u003e {\n      ConfigReloadProperties properties\u003dcontext.getBean(ConfigReloadProperties.class);\n      Assertions.assertNotNull(properties);\n      Assertions.assertTrue(properties.enabled());\n      Assertions.assertFalse(properties.monitoringConfigMaps());\n      Assertions.assertTrue(properties.monitoringSecrets());\n      Assertions.assertEquals(ConfigReloadProperties.ReloadStrategy.SHUTDOWN,properties.strategy());\n      Assertions.assertEquals(ConfigReloadProperties.ReloadDetectionMode.POLLING,properties.mode());\n      Assertions.assertEquals(Duration.ofMillis(1000),properties.period());\n      Assertions.assertEquals(Set.of(\"a\",\"b\"),properties.namespaces());\n      Assertions.assertEquals(Duration.ofSeconds(5),properties.maxWaitForRestart());\n    }\n);\n  }\n@Configuration @EnableConfigurationProperties(ConfigReloadProperties.class) static class Config {\n  }\n}\n",
        "abstract": "/** \n * @author wind57Tests binding, since we moved from a class to a record\n */\nclass ConfigReloadPropertiesTests {\n  @Test void testDefaults();\n  @Test void testNonDefaults();\n@Configuration @EnableConfigurationProperties(ConfigReloadProperties.class) static class Config {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/reload/condition/PollingReloadDetectionModeTest.java",
        "name": "PollingReloadDetectionModeTest",
        "modifiers": "@ExtendWith(MockitoExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.condition.PollingReloadDetectionModeTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ExtendWith(MockitoExtension.class) class PollingReloadDetectionModeTest {\n  private static final String RELOAD_PROPERTY\u003d\"spring.cloud.kubernetes.reload.mode\";\n  private final PollingReloadDetectionMode underTest\u003dnew PollingReloadDetectionMode();\n  @Mock private ConditionContext context;\n  @Mock private Environment environment;\n  @Mock private AnnotatedTypeMetadata metadata;\n  @Test void testNull(){\n    Mockito.when(context.getEnvironment()).thenReturn(environment);\n    Mockito.when(environment.containsProperty(RELOAD_PROPERTY)).thenReturn(true);\n    Mockito.when(environment.getProperty(RELOAD_PROPERTY)).thenReturn(null);\n    boolean matches\u003dunderTest.matches(context,metadata);\n    Assertions.assertFalse(matches);\n  }\n  @Test void testDoesNotContain(){\n    Mockito.when(context.getEnvironment()).thenReturn(environment);\n    Mockito.when(environment.containsProperty(RELOAD_PROPERTY)).thenReturn(false);\n    boolean matches\u003dunderTest.matches(context,metadata);\n    Assertions.assertFalse(matches);\n  }\n  @Test void testMatchesCase(){\n    Mockito.when(context.getEnvironment()).thenReturn(environment);\n    Mockito.when(environment.containsProperty(RELOAD_PROPERTY)).thenReturn(true);\n    Mockito.when(environment.getProperty(RELOAD_PROPERTY)).thenReturn(\"POLLING\");\n    boolean matches\u003dunderTest.matches(context,metadata);\n    Assertions.assertTrue(matches);\n  }\n  @Test void testMatchesIgnoreCase(){\n    Mockito.when(context.getEnvironment()).thenReturn(environment);\n    Mockito.when(environment.containsProperty(RELOAD_PROPERTY)).thenReturn(true);\n    Mockito.when(environment.getProperty(RELOAD_PROPERTY)).thenReturn(\"PoLLiNG\");\n    boolean matches\u003dunderTest.matches(context,metadata);\n    Assertions.assertTrue(matches);\n  }\n  @Test void testNoMatch(){\n    Mockito.when(context.getEnvironment()).thenReturn(environment);\n    Mockito.when(environment.containsProperty(RELOAD_PROPERTY)).thenReturn(true);\n    Mockito.when(environment.getProperty(RELOAD_PROPERTY)).thenReturn(\"not-POLLING\");\n    boolean matches\u003dunderTest.matches(context,metadata);\n    Assertions.assertFalse(matches);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ExtendWith(MockitoExtension.class) class PollingReloadDetectionModeTest {\n  private static final String RELOAD_PROPERTY\u003d\"spring.cloud.kubernetes.reload.mode\";\n  private final PollingReloadDetectionMode underTest\u003dnew PollingReloadDetectionMode();\n  @Mock private ConditionContext context;\n  @Mock private Environment environment;\n  @Mock private AnnotatedTypeMetadata metadata;\n  @Test void testNull();\n  @Test void testDoesNotContain();\n  @Test void testMatchesCase();\n  @Test void testMatchesIgnoreCase();\n  @Test void testNoMatch();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/reload/condition/EventReloadDetectionModeTest.java",
        "name": "EventReloadDetectionModeTest",
        "modifiers": "@ExtendWith(MockitoExtension.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.condition.EventReloadDetectionModeTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@ExtendWith(MockitoExtension.class) class EventReloadDetectionModeTest {\n  private static final String RELOAD_PROPERTY\u003d\"spring.cloud.kubernetes.reload.mode\";\n  private final EventReloadDetectionMode underTest\u003dnew EventReloadDetectionMode();\n  @Mock private ConditionContext context;\n  @Mock private Environment environment;\n  @Mock private AnnotatedTypeMetadata metadata;\n  @Test void testNull(){\n    Mockito.when(context.getEnvironment()).thenReturn(environment);\n    Mockito.when(environment.containsProperty(RELOAD_PROPERTY)).thenReturn(true);\n    Mockito.when(environment.getProperty(RELOAD_PROPERTY)).thenReturn(null);\n    boolean matches\u003dunderTest.matches(context,metadata);\n    Assertions.assertFalse(matches);\n  }\n  @Test void testDoesNotContain(){\n    Mockito.when(context.getEnvironment()).thenReturn(environment);\n    Mockito.when(environment.containsProperty(RELOAD_PROPERTY)).thenReturn(false);\n    boolean matches\u003dunderTest.matches(context,metadata);\n    Assertions.assertTrue(matches);\n  }\n  @Test void testMatchesCase(){\n    Mockito.when(context.getEnvironment()).thenReturn(environment);\n    Mockito.when(environment.containsProperty(RELOAD_PROPERTY)).thenReturn(true);\n    Mockito.when(environment.getProperty(RELOAD_PROPERTY)).thenReturn(\"EVENT\");\n    boolean matches\u003dunderTest.matches(context,metadata);\n    Assertions.assertTrue(matches);\n  }\n  @Test void testMatchesIgnoreCase(){\n    Mockito.when(context.getEnvironment()).thenReturn(environment);\n    Mockito.when(environment.containsProperty(RELOAD_PROPERTY)).thenReturn(true);\n    Mockito.when(environment.getProperty(RELOAD_PROPERTY)).thenReturn(\"eVeNt\");\n    boolean matches\u003dunderTest.matches(context,metadata);\n    Assertions.assertTrue(matches);\n  }\n  @Test void testNoMatch(){\n    Mockito.when(context.getEnvironment()).thenReturn(environment);\n    Mockito.when(environment.containsProperty(RELOAD_PROPERTY)).thenReturn(true);\n    Mockito.when(environment.getProperty(RELOAD_PROPERTY)).thenReturn(\"not-eVeNt\");\n    boolean matches\u003dunderTest.matches(context,metadata);\n    Assertions.assertFalse(matches);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@ExtendWith(MockitoExtension.class) class EventReloadDetectionModeTest {\n  private static final String RELOAD_PROPERTY\u003d\"spring.cloud.kubernetes.reload.mode\";\n  private final EventReloadDetectionMode underTest\u003dnew EventReloadDetectionMode();\n  @Mock private ConditionContext context;\n  @Mock private Environment environment;\n  @Mock private AnnotatedTypeMetadata metadata;\n  @Test void testNull();\n  @Test void testDoesNotContain();\n  @Test void testMatchesCase();\n  @Test void testMatchesIgnoreCase();\n  @Test void testNoMatch();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/reload/ConfigReloadUtilTests.java",
        "name": "ConfigReloadUtilTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.reload.ConfigReloadUtilTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass ConfigReloadUtilTests {\n  @Test void testChangedTwoNulls(){\n    boolean changed\u003dConfigReloadUtil.changed(null,(MapPropertySource)null);\n    assertThat(changed).isFalse();\n  }\n  @Test void testChangedLeftNullRightNonNull(){\n    MapPropertySource right\u003dnew MapPropertySource(\"rightNonNull\",Collections.emptyMap());\n    boolean changed\u003dConfigReloadUtil.changed(null,right);\n    assertThat(changed).isTrue();\n  }\n  @Test void testChangedLeftNonNullRightNull(){\n    MapPropertySource left\u003dnew MapPropertySource(\"leftNonNull\",Collections.emptyMap());\n    boolean changed\u003dConfigReloadUtil.changed(left,null);\n    assertThat(changed).isTrue();\n  }\n  @Test void testChangedEqualMaps(){\n    Object value\u003dnew Object();\n    Map\u003cString,Object\u003e leftMap\u003dnew HashMap\u003c\u003e();\n    leftMap.put(\"key\",value);\n    Map\u003cString,Object\u003e rightMap\u003dnew HashMap\u003c\u003e();\n    rightMap.put(\"key\",value);\n    MapPropertySource left\u003dnew MapPropertySource(\"left\",leftMap);\n    MapPropertySource right\u003dnew MapPropertySource(\"right\",rightMap);\n    boolean changed\u003dConfigReloadUtil.changed(left,right);\n    assertThat(changed).isFalse();\n  }\n  @Test void testChangedNonEqualMaps(){\n    Object value\u003dnew Object();\n    Map\u003cString,Object\u003e leftMap\u003dnew HashMap\u003c\u003e();\n    leftMap.put(\"key\",value);\n    leftMap.put(\"anotherKey\",value);\n    Map\u003cString,Object\u003e rightMap\u003dnew HashMap\u003c\u003e();\n    rightMap.put(\"key\",value);\n    MapPropertySource left\u003dnew MapPropertySource(\"left\",leftMap);\n    MapPropertySource right\u003dnew MapPropertySource(\"right\",rightMap);\n    boolean changed\u003dConfigReloadUtil.changed(left,right);\n    assertThat(changed).isTrue();\n  }\n  @Test void testChangedListsDifferentSizes(){\n    List\u003cMapPropertySource\u003e left\u003dCollections.singletonList(new MapPropertySource(\"one\",Collections.emptyMap()));\n    List\u003cMapPropertySource\u003e right\u003dCollections.emptyList();\n    boolean changed\u003dConfigReloadUtil.changed(left,right);\n    assertThat(changed).isFalse();\n  }\n  @Test void testChangedListSameSizesButNotEqual(){\n    Object value\u003dnew Object();\n    Map\u003cString,Object\u003e leftMap\u003dnew HashMap\u003c\u003e();\n    leftMap.put(\"key\",value);\n    Map\u003cString,Object\u003e rightMap\u003dnew HashMap\u003c\u003e();\n    leftMap.put(\"anotherKey\",value);\n    List\u003cMapPropertySource\u003e left\u003dCollections.singletonList(new MapPropertySource(\"one\",leftMap));\n    List\u003cMapPropertySource\u003e right\u003dCollections.singletonList(new MapPropertySource(\"two\",rightMap));\n    boolean changed\u003dConfigReloadUtil.changed(left,right);\n    assertThat(changed).isTrue();\n  }\n  @Test void testChangedListSameSizesEqual(){\n    Object value\u003dnew Object();\n    Map\u003cString,Object\u003e leftMap\u003dnew HashMap\u003c\u003e();\n    leftMap.put(\"key\",value);\n    Map\u003cString,Object\u003e rightMap\u003dnew HashMap\u003c\u003e();\n    leftMap.put(\"key\",value);\n    List\u003cMapPropertySource\u003e left\u003dCollections.singletonList(new MapPropertySource(\"one\",leftMap));\n    List\u003cMapPropertySource\u003e right\u003dCollections.singletonList(new MapPropertySource(\"two\",rightMap));\n    boolean changed\u003dConfigReloadUtil.changed(left,right);\n    assertThat(changed).isTrue();\n  }\n  @Test void testFindPropertySources(){\n    MockEnvironment environment\u003dnew MockEnvironment();\n    MutablePropertySources propertySources\u003denvironment.getPropertySources();\n    propertySources.addFirst(new OneComposite());\n    propertySources.addFirst(new PlainPropertySource(\"plain\"));\n    propertySources.addFirst(new OneBootstrap(new EnumerablePropertySource\u003c\u003e(\"enumerable\"){\n      @Override public String[] getPropertyNames(){\n        return new String[0];\n      }\n      @Override public Object getProperty(      String name){\n        return null;\n      }\n    }\n));\n    propertySources.addFirst(new MountConfigMapPropertySource(\"mounted\",Map.of(\"a\",\"b\")));\n    List\u003c? extends PropertySource\u003e result\u003dConfigReloadUtil.findPropertySources(PlainPropertySource.class,environment);\n    Assertions.assertEquals(4,result.size());\n    Assertions.assertEquals(\"b\",result.get(0).getProperty(\"a\"));\n    Assertions.assertEquals(\"plain\",result.get(1).getProperty(\"\"));\n    Assertions.assertEquals(\"from-bootstrap\",result.get(2).getProperty(\"\"));\n    Assertions.assertEquals(\"from-inner-two-composite\",result.get(3).getProperty(\"\"));\n  }\nprivate static final class OneComposite extends CompositePropertySource {\n    private OneComposite(){\n      super(\"one\");\n    }\n    @Override public Collection\u003cPropertySource\u003c?\u003e\u003e getPropertySources(){\n      return List.of(new TwoComposite());\n    }\n  }\nprivate static final class TwoComposite extends CompositePropertySource {\n    private TwoComposite(){\n      super(\"two\");\n    }\n    @Override public Collection\u003cPropertySource\u003c?\u003e\u003e getPropertySources(){\n      return List.of(new PlainPropertySource(\"from-inner-two-composite\"));\n    }\n  }\nprivate static final class PlainPropertySource extends PropertySource\u003cString\u003e {\n    private PlainPropertySource(    String name){\n      super(name);\n    }\n    @Override public Object getProperty(    String name){\n      return this.name;\n    }\n  }\nprivate static final class OneBootstrap extends BootstrapPropertySource\u003cString\u003e {\n    private OneBootstrap(    EnumerablePropertySource\u003cString\u003e delegate){\n      super(delegate);\n    }\n    @Override public PropertySource\u003cString\u003e getDelegate(){\n      return new PlainPropertySource(\"from-bootstrap\");\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass ConfigReloadUtilTests {\n  @Test void testChangedTwoNulls();\n  @Test void testChangedLeftNullRightNonNull();\n  @Test void testChangedLeftNonNullRightNull();\n  @Test void testChangedEqualMaps();\n  @Test void testChangedNonEqualMaps();\n  @Test void testChangedListsDifferentSizes();\n  @Test void testChangedListSameSizesButNotEqual();\n  @Test void testChangedListSameSizesEqual();\n  @Test void testFindPropertySources();\nprivate static final class OneComposite extends CompositePropertySource {\n    private OneComposite();\n    @Override public Collection\u003cPropertySource\u003c?\u003e\u003e getPropertySources();\n  }\nprivate static final class TwoComposite extends CompositePropertySource {\n    private TwoComposite();\n    @Override public Collection\u003cPropertySource\u003c?\u003e\u003e getPropertySources();\n  }\nprivate static final class PlainPropertySource extends PropertySource\u003cString\u003e {\n    private PlainPropertySource(    String name);\n    @Override public Object getProperty(    String name);\n  }\nprivate static final class OneBootstrap extends BootstrapPropertySource\u003cString\u003e {\n    private OneBootstrap(    EnumerablePropertySource\u003cString\u003e delegate);\n    @Override public PropertySource\u003cString\u003e getDelegate();\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/ConfigMapConfigPropertiesBindingTests.java",
        "name": "ConfigMapConfigPropertiesBindingTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConfigMapConfigPropertiesBindingTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57tests that prove that binding works. We need these because we moved to a record for configuration properties.\n */\nclass ConfigMapConfigPropertiesBindingTests {\n  @Test void testWithDefaults(){\n    new ApplicationContextRunner().withUserConfiguration(Config.class).run(context -\u003e {\n      ConfigMapConfigProperties props\u003dcontext.getBean(ConfigMapConfigProperties.class);\n      Assertions.assertNotNull(props);\n      Assertions.assertTrue(props.enableApi());\n      Assertions.assertTrue(props.paths().isEmpty());\n      Assertions.assertTrue(props.sources().isEmpty());\n      Assertions.assertTrue(props.labels().isEmpty());\n      Assertions.assertTrue(props.enabled());\n      Assertions.assertNull(props.name());\n      Assertions.assertNull(props.namespace());\n      Assertions.assertFalse(props.useNameAsPrefix());\n      Assertions.assertTrue(props.includeProfileSpecificSources());\n      Assertions.assertFalse(props.failFast());\n      Assertions.assertNotNull(props.retry());\n      Assertions.assertEquals(props.retry().initialInterval(),1000L);\n      Assertions.assertEquals(props.retry().multiplier(),1.1D);\n      Assertions.assertEquals(props.retry().maxInterval(),2000L);\n      Assertions.assertEquals(props.retry().maxAttempts(),6);\n      Assertions.assertTrue(props.retry().enabled());\n    }\n);\n  }\n  @Test void testWithNonDefaults(){\n    new ApplicationContextRunner().withUserConfiguration(Config.class).withPropertyValues(\"spring.cloud.kubernetes.config.enableApi\u003dfalse\",\"spring.cloud.kubernetes.config.paths[0]\u003da\",\"spring.cloud.kubernetes.config.paths[1]\u003db\",\"spring.cloud.kubernetes.config.sources[0].name\u003dsource-a\",\"spring.cloud.kubernetes.config.sources[0].namespace\u003dsource-namespace-a\",\"spring.cloud.kubernetes.config.sources[0].labels.key\u003dsource-value\",\"spring.cloud.kubernetes.config.sources[0].explicit-prefix\u003dsource-prefix\",\"spring.cloud.kubernetes.config.sources[0].use-name-as-prefix\u003dtrue\",\"spring.cloud.kubernetes.config.sources[0].include-profile-specific-sources\u003dtrue\",\"spring.cloud.kubernetes.config.labels.label-a\u003dlabel-a\",\"spring.cloud.kubernetes.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.config.name\u003dname\",\"spring.cloud.kubernetes.config.namespace\u003dnamespace\",\"spring.cloud.kubernetes.config.use-name-as-prefix\u003dtrue\",\"spring.cloud.kubernetes.config.include-profile-specific-sources\u003dtrue\",\"spring.cloud.kubernetes.config.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.config.retry.initial-interval\u003d1\",\"spring.cloud.kubernetes.config.retry.multiplier\u003d1.2\",\"spring.cloud.kubernetes.config.retry.max-interval\u003d3\",\"spring.cloud.kubernetes.config.retry.max-attempts\u003d4\",\"spring.cloud.kubernetes.config.retry.enabled\u003dfalse\").run(context -\u003e {\n      ConfigMapConfigProperties props\u003dcontext.getBean(ConfigMapConfigProperties.class);\n      Assertions.assertNotNull(props);\n      Assertions.assertFalse(props.enableApi());\n      Assertions.assertEquals(props.paths().size(),2);\n      Assertions.assertEquals(props.paths().get(0),\"a\");\n      Assertions.assertEquals(props.paths().get(1),\"b\");\n      Assertions.assertEquals(props.sources().size(),1);\n      ConfigMapConfigProperties.Source source\u003dprops.sources().get(0);\n      Assertions.assertEquals(source.name(),\"source-a\");\n      Assertions.assertEquals(source.namespace(),\"source-namespace-a\");\n      Assertions.assertEquals(source.labels().size(),1);\n      Assertions.assertEquals(source.labels().get(\"key\"),\"source-value\");\n      Assertions.assertEquals(source.explicitPrefix(),\"source-prefix\");\n      Assertions.assertTrue(source.useNameAsPrefix());\n      Assertions.assertTrue(source.includeProfileSpecificSources());\n      Assertions.assertEquals(props.labels().size(),1);\n      Assertions.assertEquals(props.labels().get(\"label-a\"),\"label-a\");\n      Assertions.assertFalse(props.enabled());\n      Assertions.assertEquals(props.name(),\"name\");\n      Assertions.assertEquals(props.namespace(),\"namespace\");\n      Assertions.assertTrue(props.useNameAsPrefix());\n      Assertions.assertTrue(props.includeProfileSpecificSources());\n      Assertions.assertTrue(props.failFast());\n      RetryProperties retryProperties\u003dprops.retry();\n      Assertions.assertNotNull(retryProperties);\n      Assertions.assertEquals(retryProperties.initialInterval(),1);\n      Assertions.assertEquals(retryProperties.multiplier(),1.2);\n      Assertions.assertEquals(retryProperties.maxInterval(),3);\n      Assertions.assertFalse(retryProperties.enabled());\n    }\n);\n  }\n@Configuration @EnableConfigurationProperties(ConfigMapConfigProperties.class) static class Config {\n  }\n}\n",
        "abstract": "/** \n * @author wind57tests that prove that binding works. We need these because we moved to a record for configuration properties.\n */\nclass ConfigMapConfigPropertiesBindingTests {\n  @Test void testWithDefaults();\n  @Test void testWithNonDefaults();\n@Configuration @EnableConfigurationProperties(ConfigMapConfigProperties.class) static class Config {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/SourceDataTests.java",
        "name": "SourceDataTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.SourceDataTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass SourceDataTests {\n  @Test void testEmpty(){\n    Assertions.assertEquals(SourceData.emptyRecord(\"name\").sourceData().size(),0);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass SourceDataTests {\n  @Test void testEmpty();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/PropertySourceUtilsTest.java",
        "name": "PropertySourceUtilsTest",
        "modifiers": "@ExtendWith(MockitoExtension.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.PropertySourceUtilsTest",
        "extend": "",
        "implements": "",
        "raw": "@ExtendWith(MockitoExtension.class) public class PropertySourceUtilsTest {\n  @Mock private Environment environment;\n  @Test void yamlParserGenerator_noProfile(){\n    Function\u003cString,Properties\u003e function\u003dPropertySourceUtils.yamlParserGenerator(environment);\n    Properties properties\u003dfunction.apply(\"spring:\\n  application:\\n    name: myTestApp\\n\");\n    assertThat(properties.getProperty(\"spring.application.name\")).isEqualTo(\"myTestApp\");\n    assertThat(properties.getProperty(\"spring.profiles\")).isNull();\n    assertThat(properties.getProperty(\"spring.config.activate.on-profile\")).isNull();\n  }\n  @Test void yamlParserGenerator_simpleProperties(){\n    Function\u003cString,Properties\u003e function\u003dPropertySourceUtils.yamlParserGenerator(environment);\n    Properties properties\u003dfunction.apply(\"propA: A\\npropB: B\");\n    assertThat(properties.getProperty(\"propA\")).isEqualTo(\"A\");\n    assertThat(properties.getProperty(\"propB\")).isEqualTo(\"B\");\n    assertThat(properties.getProperty(\"spring.config.activate.on-profile\")).isNull();\n  }\n  @Test void yamlParserGenerator_springProfiles_matchProfile(){\n    willReturn(Boolean.TRUE).given(environment).acceptsProfiles(any(Profiles.class));\n    Function\u003cString,Properties\u003e function\u003dPropertySourceUtils.yamlParserGenerator(environment);\n    Properties properties\u003dfunction.apply(\"spring:\\n  application:\\n    name: myTestApp\\n---\\nspring:\\n  profiles: dummy\\n  application:\\n    name: myDummyApp\");\n    assertThat(properties.getProperty(\"spring.application.name\")).isEqualTo(\"myDummyApp\");\n    assertThat(properties.getProperty(\"spring.profiles\")).isEqualTo(\"dummy\");\n    assertThat(properties.getProperty(\"spring.config.activate.on-profile\")).isNull();\n  }\n  @Test void yamlParserGenerator_springProfiles_mismatchProfile(){\n    willReturn(Boolean.FALSE).given(environment).acceptsProfiles(any(Profiles.class));\n    Function\u003cString,Properties\u003e function\u003dPropertySourceUtils.yamlParserGenerator(environment);\n    Properties properties\u003dfunction.apply(\"spring:\\n  application:\\n    name: myTestApp\\n---\\nspring:\\n  profiles: dummy\\n  application:\\n    name: myDummyApp\");\n    assertThat(properties.getProperty(\"spring.application.name\")).isEqualTo(\"myTestApp\");\n    assertThat(properties.getProperty(\"spring.profiles\")).isNull();\n    assertThat(properties.getProperty(\"spring.config.activate.on-profile\")).isNull();\n  }\n  @Test void yamlParserGenerator_springConfigActivateOnProfile_matchProfile(){\n    willReturn(Boolean.TRUE).given(environment).acceptsProfiles(any(Profiles.class));\n    Function\u003cString,Properties\u003e function\u003dPropertySourceUtils.yamlParserGenerator(environment);\n    Properties properties\u003dfunction.apply(\"spring:\\n  application:\\n    name: myTestApp\\n---\\nspring:\\n  config:\\n    activate:\\n      on-profile: dummy\\n  application:\\n    name: myDummyApp\");\n    assertThat(properties.getProperty(\"spring.application.name\")).isEqualTo(\"myDummyApp\");\n    assertThat(properties.getProperty(\"spring.profiles\")).isNull();\n    assertThat(properties.getProperty(\"spring.config.activate.on-profile\")).isEqualTo(\"dummy\");\n  }\n  @Test void yamlParserGenerator_springConfigActivateOnProfile_mismatchProfile(){\n    willReturn(Boolean.FALSE).given(environment).acceptsProfiles(any(Profiles.class));\n    Function\u003cString,Properties\u003e function\u003dPropertySourceUtils.yamlParserGenerator(environment);\n    Properties properties\u003dfunction.apply(\"spring:\\n  application:\\n    name: myTestApp\\n---\\nspring:\\n  config:\\n    activate:\\n      on-profile: dummy\\n  application:\\n    name: myDummyApp\");\n    assertThat(properties.getProperty(\"spring.application.name\")).isEqualTo(\"myTestApp\");\n    assertThat(properties.getProperty(\"spring.profiles\")).isNull();\n    assertThat(properties.getProperty(\"spring.config.activate.on-profile\")).isNull();\n  }\n  @Test void keyValueToProperties_noEntryPresent(){\n    Properties properties\u003dPropertySourceUtils.KEY_VALUE_TO_PROPERTIES.apply(\"\");\n    assertThat(properties).isNotNull();\n  }\n  @Test void keyValueToProperties_oneEntry(){\n    Properties properties\u003dPropertySourceUtils.KEY_VALUE_TO_PROPERTIES.apply(\"a\u003db\");\n    assertThat(properties).isNotNull();\n    assertThat(properties.getProperty(\"a\")).isEqualTo(\"b\");\n  }\n  @Test void propertiesToMap_empty(){\n    Map\u003cString,Object\u003e result\u003dPropertySourceUtils.PROPERTIES_TO_MAP.apply(new Properties());\n    assertThat(result).isNotNull();\n    assertThat(result).isEmpty();\n  }\n  @Test void propertiesToMap_oneEntry(){\n    Properties properties\u003dPropertySourceUtils.KEY_VALUE_TO_PROPERTIES.apply(\"a\u003db\");\n    Map\u003cString,Object\u003e result\u003dPropertySourceUtils.PROPERTIES_TO_MAP.apply(properties);\n    assertThat(result).isNotNull();\n    assertThat(result.get(\"a\")).isEqualTo(\"b\");\n  }\n  @Test void propertiesToMap_sameKey(){\n    Properties properties\u003dPropertySourceUtils.KEY_VALUE_TO_PROPERTIES.apply(\"a\u003db\\na\u003dc\");\n    Map\u003cString,Object\u003e result\u003dPropertySourceUtils.PROPERTIES_TO_MAP.apply(properties);\n    assertThat(result).isNotNull();\n    assertThat(result.get(\"a\")).isEqualTo(\"c\");\n  }\n}\n",
        "abstract": "@ExtendWith(MockitoExtension.class) public class PropertySourceUtilsTest {\n  @Mock private Environment environment;\n  @Test void yamlParserGenerator_noProfile();\n  @Test void yamlParserGenerator_simpleProperties();\n  @Test void yamlParserGenerator_springProfiles_matchProfile();\n  @Test void yamlParserGenerator_springProfiles_mismatchProfile();\n  @Test void yamlParserGenerator_springConfigActivateOnProfile_matchProfile();\n  @Test void yamlParserGenerator_springConfigActivateOnProfile_mismatchProfile();\n  @Test void keyValueToProperties_noEntryPresent();\n  @Test void keyValueToProperties_oneEntry();\n  @Test void propertiesToMap_empty();\n  @Test void propertiesToMap_oneEntry();\n  @Test void propertiesToMap_sameKey();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/KubernetesConfigDataLoaderTests.java",
        "name": "KubernetesConfigDataLoaderTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.KubernetesConfigDataLoaderTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesConfigDataLoaderTests {\n  private static final ConfigDataLoaderContext CONTEXT\u003dmock(ConfigDataLoaderContext.class);\n  private static final DefaultBootstrapContext BOOTSTRAP_CONTEXT_NO_REGISTRATIONS\u003dnew DefaultBootstrapContext();\n  private static final DefaultBootstrapContext BOOTSTRAP_CONTEXT_BOTH_REGISTRATIONS\u003dnew DefaultBootstrapContext();\n  private static final Profiles PROFILES\u003dmock(Profiles.class);\n  private static final ConfigurableEnvironment ENVIRONMENT\u003dnew MockEnvironment();\n  private static final KubernetesConfigDataResource EMPTY_RESOURCE\u003dnew KubernetesConfigDataResource(null,null,null,false,PROFILES,ENVIRONMENT);\n  /** \n * we do not override this method in our implementation, so it should report true for any arguments.\n */\n  @Test void testIsLoadable(){\n    KubernetesConfigDataLoader loader\u003dnew KubernetesConfigDataLoader();\n    Assertions.assertTrue(loader.isLoadable(null,null));\n  }\n  /** \n * neither ConfigMapPropertySourceLocator nor SecretsPropertySourceLocator is registered in bootstrap context. There are no profiles either, as such PROFILE_SPECIFIC option is not present.\n */\n  @Test void testNeitherIsRegisteredNoProfiles() throws IOException {\n    when(CONTEXT.getBootstrapContext()).thenReturn(BOOTSTRAP_CONTEXT_NO_REGISTRATIONS);\n    KubernetesConfigDataLoader loader\u003dnew KubernetesConfigDataLoader();\n    ConfigData configData\u003dloader.load(CONTEXT,EMPTY_RESOURCE);\n    MockPropertySource propertySource\u003dnew MockPropertySource(\"k8s\");\n    Assertions.assertNotNull(configData);\n    Assertions.assertEquals(0,configData.getPropertySources().size());\n    ConfigData.Options options\u003dconfigData.getOptions(propertySource);\n    Assertions.assertNotNull(options);\n    Assertions.assertTrue(options.contains(ConfigData.Option.IGNORE_IMPORTS));\n    Assertions.assertTrue(options.contains(ConfigData.Option.IGNORE_PROFILES));\n    Assertions.assertFalse(options.contains(ConfigData.Option.PROFILE_SPECIFIC));\n  }\n  /** \n * neither ConfigMapPropertySourceLocator nor SecretsPropertySourceLocator is registered in bootstrap context. \"dev\" profile is accepted, as such PROFILE_SPECIFIC option is present.\n */\n  @Test void testNeitherIsRegisteredDevProfilePresent() throws IOException {\n    when(CONTEXT.getBootstrapContext()).thenReturn(BOOTSTRAP_CONTEXT_NO_REGISTRATIONS);\n    when(PROFILES.getAccepted()).thenReturn(List.of(\"dev\"));\n    KubernetesConfigDataLoader loader\u003dnew KubernetesConfigDataLoader();\n    ConfigData configData\u003dloader.load(CONTEXT,EMPTY_RESOURCE);\n    MockPropertySource propertySource\u003dnew MockPropertySource(\"k8s-dev\");\n    Assertions.assertNotNull(configData);\n    Assertions.assertEquals(0,configData.getPropertySources().size());\n    ConfigData.Options options\u003dconfigData.getOptions(propertySource);\n    Assertions.assertNotNull(options);\n    Assertions.assertTrue(options.contains(ConfigData.Option.IGNORE_IMPORTS));\n    Assertions.assertTrue(options.contains(ConfigData.Option.IGNORE_PROFILES));\n    Assertions.assertTrue(options.contains(ConfigData.Option.PROFILE_SPECIFIC));\n  }\n  /** \n * both ConfigMapPropertySourceLocator and SecretsPropertySourceLocator are registered in bootstrap context.\n */\n  @SuppressWarnings({\"raw\",\"unchecked\"}) @Test void testBothRegistered() throws IOException {\n    PropertySource configMapPropertySource\u003dnew MockPropertySource(\"k8s-config-map\");\n    PropertySource secretsPropertySource\u003dnew MockPropertySource(\"k8s-secrets\");\n    ConfigMapPropertySourceLocator configMapPropertySourceLocator\u003dmock(ConfigMapPropertySourceLocator.class);\n    SecretsPropertySourceLocator secretsPropertySourceLocator\u003dmock(SecretsPropertySourceLocator.class);\n    when(CONTEXT.getBootstrapContext()).thenReturn(BOOTSTRAP_CONTEXT_BOTH_REGISTRATIONS);\n    when(configMapPropertySourceLocator.locate(ENVIRONMENT)).thenReturn(configMapPropertySource);\n    when(secretsPropertySourceLocator.locate(ENVIRONMENT)).thenReturn(secretsPropertySource);\n    BOOTSTRAP_CONTEXT_BOTH_REGISTRATIONS.register(ConfigMapPropertySourceLocator.class,BootstrapRegistry.InstanceSupplier.of(configMapPropertySourceLocator));\n    BOOTSTRAP_CONTEXT_BOTH_REGISTRATIONS.register(SecretsPropertySourceLocator.class,BootstrapRegistry.InstanceSupplier.of(secretsPropertySourceLocator));\n    KubernetesConfigDataLoader loader\u003dnew KubernetesConfigDataLoader();\n    ConfigData configData\u003dloader.load(CONTEXT,EMPTY_RESOURCE);\n    Assertions.assertNotNull(configData);\n    Assertions.assertEquals(2,configData.getPropertySources().size());\n    Assertions.assertEquals(\"k8s-secrets\",configData.getPropertySources().get(0).getName());\n    Assertions.assertEquals(\"k8s-config-map\",configData.getPropertySources().get(1).getName());\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesConfigDataLoaderTests {\n  private static final ConfigDataLoaderContext CONTEXT\u003dmock(ConfigDataLoaderContext.class);\n  private static final DefaultBootstrapContext BOOTSTRAP_CONTEXT_NO_REGISTRATIONS\u003dnew DefaultBootstrapContext();\n  private static final DefaultBootstrapContext BOOTSTRAP_CONTEXT_BOTH_REGISTRATIONS\u003dnew DefaultBootstrapContext();\n  private static final Profiles PROFILES\u003dmock(Profiles.class);\n  private static final ConfigurableEnvironment ENVIRONMENT\u003dnew MockEnvironment();\n  private static final KubernetesConfigDataResource EMPTY_RESOURCE\u003dnew KubernetesConfigDataResource(null,null,null,false,PROFILES,ENVIRONMENT);\n  /** \n * we do not override this method in our implementation, so it should report true for any arguments.\n */\n  @Test void testIsLoadable();\n  /** \n * neither ConfigMapPropertySourceLocator nor SecretsPropertySourceLocator is registered in bootstrap context. There are no profiles either, as such PROFILE_SPECIFIC option is not present.\n */\n  @Test void testNeitherIsRegisteredNoProfiles() throws IOException;\n  /** \n * neither ConfigMapPropertySourceLocator nor SecretsPropertySourceLocator is registered in bootstrap context. \"dev\" profile is accepted, as such PROFILE_SPECIFIC option is present.\n */\n  @Test void testNeitherIsRegisteredDevProfilePresent() throws IOException;\n  /** \n * both ConfigMapPropertySourceLocator and SecretsPropertySourceLocator are registered in bootstrap context.\n */\n  @SuppressWarnings({\"raw\",\"unchecked\"}) @Test void testBothRegistered() throws IOException;\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/NamedConfigMapNormalizedSourceTests.java",
        "name": "NamedConfigMapNormalizedSourceTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.NamedConfigMapNormalizedSourceTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass NamedConfigMapNormalizedSourceTests {\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"prefix\",false,false,\"prefix\");\n  @Test void testEqualsAndHashCode(){\n    ConfigUtils.Prefix knownLeft\u003dConfigUtils.findPrefix(\"prefix\",false,false,\"some\");\n    ConfigUtils.Prefix knownRight\u003dConfigUtils.findPrefix(\"prefix\",false,false,\"non-equal-prefix\");\n    NamedConfigMapNormalizedSource left\u003dnew NamedConfigMapNormalizedSource(\"name\",\"namespace\",false,knownLeft,true);\n    NamedConfigMapNormalizedSource right\u003dnew NamedConfigMapNormalizedSource(\"name\",\"namespace\",true,knownRight,false);\n    Assertions.assertEquals(left.hashCode(),right.hashCode());\n    Assertions.assertEquals(left,right);\n  }\n  @Test void testType(){\n    NamedConfigMapNormalizedSource one\u003dnew NamedConfigMapNormalizedSource(\"name\",\"namespace\",false,PREFIX,true);\n    Assertions.assertSame(one.type(),NormalizedSourceType.NAMED_CONFIG_MAP);\n  }\n  @Test void testTarget(){\n    NamedConfigMapNormalizedSource one\u003dnew NamedConfigMapNormalizedSource(\"name\",\"namespace\",false,PREFIX,true);\n    Assertions.assertEquals(one.target(),\"configmap\");\n  }\n  @Test void testConstructorFields(){\n    NamedConfigMapNormalizedSource one\u003dnew NamedConfigMapNormalizedSource(\"name\",\"namespace\",false,PREFIX,true);\n    Assertions.assertEquals(one.name().get(),\"name\");\n    Assertions.assertEquals(one.namespace().get(),\"namespace\");\n    Assertions.assertFalse(one.failFast());\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass NamedConfigMapNormalizedSourceTests {\n  private static final ConfigUtils.Prefix PREFIX\u003dConfigUtils.findPrefix(\"prefix\",false,false,\"prefix\");\n  @Test void testEqualsAndHashCode();\n  @Test void testType();\n  @Test void testTarget();\n  @Test void testConstructorFields();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/SecretsConfigPropertiesBindingTests.java",
        "name": "SecretsConfigPropertiesBindingTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.SecretsConfigPropertiesBindingTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57tests that prove that binding works. We need these because we moved to a record for configuration properties.\n */\nclass SecretsConfigPropertiesBindingTests {\n  @Test void testWithDefaults(){\n    new ApplicationContextRunner().withUserConfiguration(Config.class).run(context -\u003e {\n      SecretsConfigProperties props\u003dcontext.getBean(SecretsConfigProperties.class);\n      Assertions.assertNotNull(props);\n      Assertions.assertFalse(props.enableApi());\n      Assertions.assertTrue(props.paths().isEmpty());\n      Assertions.assertTrue(props.sources().isEmpty());\n      Assertions.assertTrue(props.labels().isEmpty());\n      Assertions.assertTrue(props.enabled());\n      Assertions.assertNull(props.name());\n      Assertions.assertNull(props.namespace());\n      Assertions.assertFalse(props.useNameAsPrefix());\n      Assertions.assertTrue(props.includeProfileSpecificSources());\n      Assertions.assertFalse(props.failFast());\n      Assertions.assertNotNull(props.retry());\n      Assertions.assertEquals(props.retry().initialInterval(),1000L);\n      Assertions.assertEquals(props.retry().multiplier(),1.1D);\n      Assertions.assertEquals(props.retry().maxInterval(),2000L);\n      Assertions.assertEquals(props.retry().maxAttempts(),6);\n      Assertions.assertTrue(props.retry().enabled());\n    }\n);\n  }\n  @Test void testWithNonDefaults(){\n    new ApplicationContextRunner().withUserConfiguration(Config.class).withPropertyValues(\"spring.cloud.kubernetes.secrets.enableApi\u003dfalse\",\"spring.cloud.kubernetes.secrets.paths[0]\u003da\",\"spring.cloud.kubernetes.secrets.paths[1]\u003db\",\"spring.cloud.kubernetes.secrets.sources[0].name\u003dsource-a\",\"spring.cloud.kubernetes.secrets.sources[0].namespace\u003dsource-namespace-a\",\"spring.cloud.kubernetes.secrets.sources[0].labels.key\u003dsource-value\",\"spring.cloud.kubernetes.secrets.sources[0].explicit-prefix\u003dsource-prefix\",\"spring.cloud.kubernetes.secrets.sources[0].use-name-as-prefix\u003dtrue\",\"spring.cloud.kubernetes.secrets.sources[0].include-profile-specific-sources\u003dtrue\",\"spring.cloud.kubernetes.secrets.labels.label-a\u003dlabel-a\",\"spring.cloud.kubernetes.secrets.enabled\u003dfalse\",\"spring.cloud.kubernetes.secrets.name\u003dname\",\"spring.cloud.kubernetes.secrets.namespace\u003dnamespace\",\"spring.cloud.kubernetes.secrets.use-name-as-prefix\u003dtrue\",\"spring.cloud.kubernetes.secrets.include-profile-specific-sources\u003dtrue\",\"spring.cloud.kubernetes.secrets.fail-fast\u003dtrue\",\"spring.cloud.kubernetes.secrets.retry.initial-interval\u003d1\",\"spring.cloud.kubernetes.secrets.retry.multiplier\u003d1.2\",\"spring.cloud.kubernetes.secrets.retry.max-interval\u003d3\",\"spring.cloud.kubernetes.secrets.retry.max-attempts\u003d4\",\"spring.cloud.kubernetes.secrets.retry.enabled\u003dfalse\").run(context -\u003e {\n      SecretsConfigProperties props\u003dcontext.getBean(SecretsConfigProperties.class);\n      Assertions.assertNotNull(props);\n      Assertions.assertFalse(props.enableApi());\n      Assertions.assertEquals(props.paths().size(),2);\n      Assertions.assertEquals(props.paths().get(0),\"a\");\n      Assertions.assertEquals(props.paths().get(1),\"b\");\n      Assertions.assertEquals(props.sources().size(),1);\n      SecretsConfigProperties.Source source\u003dprops.sources().get(0);\n      Assertions.assertEquals(source.name(),\"source-a\");\n      Assertions.assertEquals(source.namespace(),\"source-namespace-a\");\n      Assertions.assertEquals(source.labels().size(),1);\n      Assertions.assertEquals(source.labels().get(\"key\"),\"source-value\");\n      Assertions.assertEquals(source.explicitPrefix(),\"source-prefix\");\n      Assertions.assertTrue(source.useNameAsPrefix());\n      Assertions.assertTrue(source.includeProfileSpecificSources());\n      Assertions.assertEquals(props.labels().size(),1);\n      Assertions.assertEquals(props.labels().get(\"label-a\"),\"label-a\");\n      Assertions.assertFalse(props.enabled());\n      Assertions.assertEquals(props.name(),\"name\");\n      Assertions.assertEquals(props.namespace(),\"namespace\");\n      Assertions.assertTrue(props.useNameAsPrefix());\n      Assertions.assertTrue(props.includeProfileSpecificSources());\n      Assertions.assertTrue(props.failFast());\n      RetryProperties retryProperties\u003dprops.retry();\n      Assertions.assertNotNull(retryProperties);\n      Assertions.assertEquals(retryProperties.initialInterval(),1);\n      Assertions.assertEquals(retryProperties.multiplier(),1.2);\n      Assertions.assertEquals(retryProperties.maxInterval(),3);\n      Assertions.assertFalse(retryProperties.enabled());\n    }\n);\n  }\n@Configuration @EnableConfigurationProperties(SecretsConfigProperties.class) static class Config {\n  }\n}\n",
        "abstract": "/** \n * @author wind57tests that prove that binding works. We need these because we moved to a record for configuration properties.\n */\nclass SecretsConfigPropertiesBindingTests {\n  @Test void testWithDefaults();\n  @Test void testWithNonDefaults();\n@Configuration @EnableConfigurationProperties(SecretsConfigProperties.class) static class Config {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/ConfigUtilsTests.java",
        "name": "ConfigUtilsTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.ConfigUtilsTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass ConfigUtilsTests {\n  @Test void testExplicitPrefixSet(){\n    ConfigUtils.Prefix result\u003dConfigUtils.findPrefix(\"explicitPrefix\",null,false,\"irrelevant\");\n    Assertions.assertSame(result,ConfigUtils.Prefix.KNOWN);\n    Assertions.assertEquals(result.prefixProvider().get(),\"explicitPrefix\");\n  }\n  @Test void testUseNameAsPrefixTrue(){\n    ConfigUtils.Prefix result\u003dConfigUtils.findPrefix(\"\",Boolean.TRUE,false,\"name-to-use\");\n    Assertions.assertSame(result,ConfigUtils.Prefix.KNOWN);\n    Assertions.assertEquals(result.prefixProvider().get(),\"name-to-use\");\n  }\n  @Test void testUseNameAsPrefixFalse(){\n    ConfigUtils.Prefix result\u003dConfigUtils.findPrefix(\"\",Boolean.FALSE,false,\"name-not-to-use\");\n    Assertions.assertSame(result,ConfigUtils.Prefix.DEFAULT);\n  }\n  @Test void testDefaultUseNameAsPrefixTrue(){\n    ConfigUtils.Prefix result\u003dConfigUtils.findPrefix(\"\",null,true,\"name-to-use\");\n    Assertions.assertSame(result,ConfigUtils.Prefix.KNOWN);\n    Assertions.assertEquals(result.prefixProvider().get(),\"name-to-use\");\n  }\n  @Test void testNoMatch(){\n    ConfigUtils.Prefix result\u003dConfigUtils.findPrefix(\"\",null,false,\"name-not-to-use\");\n    Assertions.assertSame(result,ConfigUtils.Prefix.DEFAULT);\n  }\n  @Test void testUnsetEmpty(){\n    ConfigUtils.Prefix result\u003dConfigUtils.findPrefix(\"\",null,false,\"name-not-to-use\");\n    Assertions.assertSame(result,ConfigUtils.Prefix.DEFAULT);\n    String expected\u003dAssertions.assertDoesNotThrow(() -\u003e result.prefixProvider().get());\n    Assertions.assertEquals(\"\",expected);\n  }\n  @Test void testDelayed(){\n    ConfigUtils.Prefix result\u003dConfigUtils.findPrefix(null,true,false,null);\n    Assertions.assertSame(result,ConfigUtils.Prefix.DELAYED);\n    IllegalArgumentException ex\u003dAssertions.assertThrows(IllegalArgumentException.class,() -\u003e result.prefixProvider().get());\n    Assertions.assertEquals(\"prefix is delayed, needs to be taken elsewhere\",ex.getMessage());\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: includeProfileSpecificSources: true \u003c/pre\u003e above will generate \"true\" for a normalized source\n */\n  @Test void testUseIncludeProfileSpecificSourcesOnlyDefaultSet(){\n    Assertions.assertTrue(ConfigUtils.includeProfileSpecificSources(true,null));\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: includeProfileSpecificSources: true \u003c/pre\u003e above will generate \"false\" for a normalized source\n */\n  @Test void testUseIncludeProfileSpecificSourcesOnlyDefaultNotSet(){\n    Assertions.assertFalse(ConfigUtils.includeProfileSpecificSources(false,null));\n  }\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: includeProfileSpecificSources: true sources: - name: one includeProfileSpecificSources: false \u003c/pre\u003e above will generate \"false\" for a normalized source\n */\n  @Test void testUseIncludeProfileSpecificSourcesSourcesOverridesDefault(){\n    Assertions.assertFalse(ConfigUtils.includeProfileSpecificSources(true,false));\n  }\n  @Test void testWithPrefix(){\n    PrefixContext context\u003dnew PrefixContext(Map.of(\"a\",\"b\",\"c\",\"d\"),\"prefix\",\"namespace\",Set.of(\"name1\",\"name2\"));\n    SourceData result\u003dConfigUtils.withPrefix(\"configmap\",context);\n    Assertions.assertEquals(result.sourceName(),\"configmap.name1.name2.namespace\");\n    Assertions.assertEquals(result.sourceData().get(\"prefix.a\"),\"b\");\n    Assertions.assertEquals(result.sourceData().get(\"prefix.c\"),\"d\");\n  }\n  @Test void testWithPrefixSortedName(){\n    PrefixContext context\u003dnew PrefixContext(Map.of(\"a\",\"b\",\"c\",\"d\"),\"prefix\",\"namespace\",Set.of(\"namec\",\"namea\",\"nameb\"));\n    SourceData result\u003dConfigUtils.withPrefix(\"configmap\",context);\n    Assertions.assertEquals(result.sourceName(),\"configmap.namea.nameb.namec.namespace\");\n    Assertions.assertEquals(result.sourceData().get(\"prefix.a\"),\"b\");\n    Assertions.assertEquals(result.sourceData().get(\"prefix.c\"),\"d\");\n  }\n  /** \n * \u003cpre\u003e - we have configmap-one with an application.yaml with two properties propA \u003d A, prop \u003d B - we have configmap-one-kubernetes with an application.yaml with two properties propA \u003d AA, probC \u003d C As a result we should get three properties as output. \u003c/pre\u003e\n */\n  @Test void testMerge(){\n    StrippedSourceContainer configMapOne\u003dnew StrippedSourceContainer(Map.of(),\"configmap-one\",Map.of(\"application.yaml\",\"propA: A\\npropB: B\"));\n    StrippedSourceContainer configMapOneK8s\u003dnew StrippedSourceContainer(Map.of(),\"configmap-one-kubernetes\",Map.of(\"application.yaml\",\"propA: AA\\npropC: C\"));\n    LinkedHashSet\u003cString\u003e sourceNames\u003dStream.of(\"configmap-one\",\"configmap-one-kubernetes\").collect(Collectors.toCollection(LinkedHashSet::new));\n    MultipleSourcesContainer result\u003dConfigUtils.processNamedData(List.of(configMapOne,configMapOneK8s),new MockEnvironment(),sourceNames,\"default\",false);\n    Assertions.assertEquals(result.data().size(),3);\n    Assertions.assertEquals(result.data().get(\"propA\"),\"AA\");\n    Assertions.assertEquals(result.data().get(\"propB\"),\"B\");\n    Assertions.assertEquals(result.data().get(\"propC\"),\"C\");\n  }\n  @Test void testKeysWithPrefixNullMap(){\n    Map\u003cString,String\u003e result\u003dConfigUtils.keysWithPrefix(null,\"\");\n    Assertions.assertTrue(result.isEmpty());\n  }\n  @Test void testKeysWithPrefixEmptyMap(){\n    Map\u003cString,String\u003e result\u003dConfigUtils.keysWithPrefix(Map.of(),\"\");\n    Assertions.assertTrue(result.isEmpty());\n  }\n  @Test void testKeysWithPrefixEmptyPrefix(){\n    Map\u003cString,String\u003e result\u003dConfigUtils.keysWithPrefix(Map.of(\"a\",\"b\"),\"\");\n    Assertions.assertFalse(result.isEmpty());\n    Assertions.assertEquals(Map.of(\"a\",\"b\"),result);\n  }\n  @Test void testKeysWithPrefixNonEmptyPrefix(){\n    Map\u003cString,String\u003e result\u003dConfigUtils.keysWithPrefix(Map.of(\"a\",\"b\",\"c\",\"d\"),\"prefix-\");\n    Assertions.assertFalse(result.isEmpty());\n    Assertions.assertEquals(Map.of(\"prefix-a\",\"b\",\"prefix-c\",\"d\"),result);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass ConfigUtilsTests {\n  @Test void testExplicitPrefixSet();\n  @Test void testUseNameAsPrefixTrue();\n  @Test void testUseNameAsPrefixFalse();\n  @Test void testDefaultUseNameAsPrefixTrue();\n  @Test void testNoMatch();\n  @Test void testUnsetEmpty();\n  @Test void testDelayed();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: includeProfileSpecificSources: true \u003c/pre\u003e above will generate \"true\" for a normalized source\n */\n  @Test void testUseIncludeProfileSpecificSourcesOnlyDefaultSet();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: includeProfileSpecificSources: true \u003c/pre\u003e above will generate \"false\" for a normalized source\n */\n  @Test void testUseIncludeProfileSpecificSourcesOnlyDefaultNotSet();\n  /** \n * \u003cpre\u003e spring: cloud: kubernetes: config: includeProfileSpecificSources: true sources: - name: one includeProfileSpecificSources: false \u003c/pre\u003e above will generate \"false\" for a normalized source\n */\n  @Test void testUseIncludeProfileSpecificSourcesSourcesOverridesDefault();\n  @Test void testWithPrefix();\n  @Test void testWithPrefixSortedName();\n  /** \n * \u003cpre\u003e - we have configmap-one with an application.yaml with two properties propA \u003d A, prop \u003d B - we have configmap-one-kubernetes with an application.yaml with two properties propA \u003d AA, probC \u003d C As a result we should get three properties as output. \u003c/pre\u003e\n */\n  @Test void testMerge();\n  @Test void testKeysWithPrefixNullMap();\n  @Test void testKeysWithPrefixEmptyMap();\n  @Test void testKeysWithPrefixEmptyPrefix();\n  @Test void testKeysWithPrefixNonEmptyPrefix();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-commons/src/test/java/org/springframework/cloud/kubernetes/commons/config/LabeledSecretNormalizedSourceTests.java",
        "name": "LabeledSecretNormalizedSourceTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.commons.config.LabeledSecretNormalizedSourceTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass LabeledSecretNormalizedSourceTests {\n  private final Map\u003cString,String\u003e labels\u003dCollections.singletonMap(\"a\",\"b\");\n  @Test void testEqualsAndHashCode(){\n    LabeledSecretNormalizedSource left\u003dnew LabeledSecretNormalizedSource(\"namespace\",labels,false,false);\n    LabeledSecretNormalizedSource right\u003dnew LabeledSecretNormalizedSource(\"namespace\",labels,true,false);\n    Assertions.assertEquals(left.hashCode(),right.hashCode());\n    Assertions.assertEquals(left,right);\n  }\n  @Test void testEqualsAndHashCodePrefixDoesNotMatter(){\n    ConfigUtils.Prefix knownLeft\u003dConfigUtils.findPrefix(\"left\",false,false,\"some\");\n    ConfigUtils.Prefix knownRight\u003dConfigUtils.findPrefix(\"right\",false,false,\"some\");\n    LabeledSecretNormalizedSource left\u003dnew LabeledSecretNormalizedSource(\"namespace\",labels,true,knownLeft,false);\n    LabeledSecretNormalizedSource right\u003dnew LabeledSecretNormalizedSource(\"namespace\",labels,true,knownRight,false);\n    Assertions.assertEquals(left.hashCode(),right.hashCode());\n    Assertions.assertEquals(left,right);\n  }\n  @Test void testType(){\n    LabeledSecretNormalizedSource source\u003dnew LabeledSecretNormalizedSource(\"namespace\",labels,false,false);\n    Assertions.assertSame(source.type(),NormalizedSourceType.LABELED_SECRET);\n  }\n  @Test void testImmutableGetLabels(){\n    LabeledSecretNormalizedSource source\u003dnew LabeledSecretNormalizedSource(\"namespace\",labels,false,false);\n    Assertions.assertThrows(RuntimeException.class,() -\u003e source.labels().put(\"c\",\"d\"));\n  }\n  @Test void testTarget(){\n    LabeledSecretNormalizedSource source\u003dnew LabeledSecretNormalizedSource(\"namespace\",labels,false,false);\n    Assertions.assertEquals(source.target(),\"secret\");\n  }\n  @Test void testConstructorFields(){\n    ConfigUtils.Prefix prefix\u003dConfigUtils.findPrefix(\"prefix\",false,false,\"some\");\n    LabeledSecretNormalizedSource source\u003dnew LabeledSecretNormalizedSource(\"namespace\",labels,false,prefix,true);\n    Assertions.assertTrue(source.name().isEmpty());\n    Assertions.assertEquals(source.namespace().get(),\"namespace\");\n    Assertions.assertFalse(source.failFast());\n    Assertions.assertTrue(source.profileSpecificSources());\n  }\n  @Test void testConstructorWithoutPrefixFields(){\n    LabeledSecretNormalizedSource source\u003dnew LabeledSecretNormalizedSource(\"namespace\",labels,true,true);\n    Assertions.assertEquals(source.namespace().get(),\"namespace\");\n    Assertions.assertTrue(source.failFast());\n    Assertions.assertSame(ConfigUtils.Prefix.DEFAULT,source.prefix());\n    Assertions.assertTrue(source.profileSpecificSources());\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass LabeledSecretNormalizedSourceTests {\n  private final Map\u003cString,String\u003e labels\u003dCollections.singletonMap(\"a\",\"b\");\n  @Test void testEqualsAndHashCode();\n  @Test void testEqualsAndHashCodePrefixDoesNotMatter();\n  @Test void testType();\n  @Test void testImmutableGetLabels();\n  @Test void testTarget();\n  @Test void testConstructorFields();\n  @Test void testConstructorWithoutPrefixFields();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-leader/src/main/java/org/springframework/cloud/kubernetes/fabric8/leader/Fabric8LeadershipController.java",
        "name": "Fabric8LeadershipController",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.leader.Fabric8LeadershipController",
        "extend": "LeadershipController",
        "implements": "",
        "raw": "/** \n * @author Gytis Trikleris\n */\npublic class Fabric8LeadershipController extends LeadershipController {\n  private static final Logger LOGGER\u003dLoggerFactory.getLogger(Fabric8LeadershipController.class);\n  private final KubernetesClient kubernetesClient;\n  public Fabric8LeadershipController(  Candidate candidate,  LeaderProperties leaderProperties,  LeaderEventPublisher leaderEventPublisher,  KubernetesClient kubernetesClient){\n    super(candidate,leaderProperties,leaderEventPublisher);\n    this.kubernetesClient\u003dkubernetesClient;\n  }\n  @Override public synchronized void update(){\n    LOGGER.debug(\"Checking leader state\");\n    ConfigMap configMap\u003dgetConfigMap();\n    if (configMap \u003d\u003d null \u0026\u0026 !leaderProperties.isCreateConfigMap()) {\n      LOGGER.warn(\"ConfigMap \u0027{}\u0027 does not exist and leaderProperties.isCreateConfigMap() \" + \"is false, cannot acquire leadership\",leaderProperties.getConfigMapName());\n      notifyOnFailedToAcquire();\n      return;\n    }\n    Leader leader\u003dextractLeader(configMap);\n    if (leader !\u003d null \u0026\u0026 isPodReady(leader.getId())) {\n      handleLeaderChange(leader);\n      return;\n    }\n    if (leader !\u003d null \u0026\u0026 leader.isCandidate(this.candidate)) {\n      revoke(configMap);\n    }\n else {\n      acquire(configMap);\n    }\n  }\n  public synchronized void revoke(){\n    ConfigMap configMap\u003dgetConfigMap();\n    Leader leader\u003dextractLeader(configMap);\n    if (leader !\u003d null \u0026\u0026 leader.isCandidate(this.candidate)) {\n      revoke(configMap);\n    }\n  }\n  private void revoke(  ConfigMap configMap){\n    LOGGER.debug(\"Trying to revoke leadership for \u0027{}\u0027\",this.candidate);\n    try {\n      String leaderKey\u003dgetLeaderKey();\n      removeConfigMapEntry(configMap,leaderKey);\n      handleLeaderChange(null);\n    }\n catch (    KubernetesClientException e) {\n      LOGGER.warn(\"Failure when revoking leadership for \u0027{}\u0027: {}\",this.candidate,e.getMessage());\n    }\n  }\n  private void acquire(  ConfigMap configMap){\n    LOGGER.debug(\"Trying to acquire leadership for \u0027{}\u0027\",this.candidate);\n    if (!isPodReady(this.candidate.getId())) {\n      LOGGER.debug(\"Pod of \u0027{}\u0027 is not ready at the moment, cannot acquire leadership\",this.candidate);\n      return;\n    }\n    try {\n      Map\u003cString,String\u003e data\u003dgetLeaderData(this.candidate);\n      if (configMap \u003d\u003d null) {\n        createConfigMap(data);\n      }\n else {\n        updateConfigMapEntry(configMap,data);\n      }\n      Leader newLeader\u003dnew Leader(this.candidate.getRole(),this.candidate.getId());\n      handleLeaderChange(newLeader);\n    }\n catch (    KubernetesClientException e) {\n      LOGGER.warn(\"Failure when acquiring leadership for \u0027{}\u0027: {}\",this.candidate,e.getMessage());\n      notifyOnFailedToAcquire();\n    }\n  }\n  @Override protected PodReadinessWatcher createPodReadinessWatcher(  String localLeaderId){\n    return new Fabric8PodReadinessWatcher(localLeaderId,this.kubernetesClient,this);\n  }\n  private Leader extractLeader(  ConfigMap configMap){\n    if (configMap \u003d\u003d null) {\n      return null;\n    }\n    return extractLeader(configMap.getData());\n  }\n  private boolean isPodReady(  String name){\n    return this.kubernetesClient.pods().withName(name).isReady();\n  }\n  private ConfigMap getConfigMap(){\n    return this.kubernetesClient.configMaps().inNamespace(this.leaderProperties.getNamespace(this.kubernetesClient.getNamespace())).withName(this.leaderProperties.getConfigMapName()).get();\n  }\n  private void createConfigMap(  Map\u003cString,String\u003e data){\n    LOGGER.debug(\"Creating new config map with data: {}\",data);\n    ConfigMap newConfigMap\u003dnew ConfigMapBuilder().withNewMetadata().withName(this.leaderProperties.getConfigMapName()).addToLabels(PROVIDER_KEY,PROVIDER).addToLabels(KIND_KEY,KIND).endMetadata().addToData(data).build();\n    this.kubernetesClient.configMaps().inNamespace(this.leaderProperties.getNamespace(this.kubernetesClient.getNamespace())).resource(newConfigMap).create();\n  }\n  private void updateConfigMapEntry(  ConfigMap configMap,  Map\u003cString,String\u003e newData){\n    LOGGER.debug(\"Adding new data to config map: {}\",newData);\n    ConfigMap newConfigMap\u003dnew ConfigMapBuilder(configMap).addToData(newData).build();\n    updateConfigMap(configMap,newConfigMap);\n  }\n  private void removeConfigMapEntry(  ConfigMap configMap,  String key){\n    LOGGER.debug(\"Removing config map entry \u0027{}\u0027\",key);\n    ConfigMap newConfigMap\u003dnew ConfigMapBuilder(configMap).removeFromData(key).build();\n    updateConfigMap(configMap,newConfigMap);\n  }\n  private void updateConfigMap(  ConfigMap oldConfigMap,  ConfigMap newConfigMap){\n    this.kubernetesClient.configMaps().inNamespace(this.leaderProperties.getNamespace(this.kubernetesClient.getNamespace())).resource(newConfigMap).lockResourceVersion(oldConfigMap.getMetadata().getResourceVersion()).replace();\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\npublic class Fabric8LeadershipController extends LeadershipController {\n  private static final Logger LOGGER\u003dLoggerFactory.getLogger(Fabric8LeadershipController.class);\n  private final KubernetesClient kubernetesClient;\n  public Fabric8LeadershipController(  Candidate candidate,  LeaderProperties leaderProperties,  LeaderEventPublisher leaderEventPublisher,  KubernetesClient kubernetesClient);\n  @Override public synchronized void update();\n  public synchronized void revoke();\n  private void revoke(  ConfigMap configMap);\n  private void acquire(  ConfigMap configMap);\n  @Override protected PodReadinessWatcher createPodReadinessWatcher(  String localLeaderId);\n  private Leader extractLeader(  ConfigMap configMap);\n  private boolean isPodReady(  String name);\n  private ConfigMap getConfigMap();\n  private void createConfigMap(  Map\u003cString,String\u003e data);\n  private void updateConfigMapEntry(  ConfigMap configMap,  Map\u003cString,String\u003e newData);\n  private void removeConfigMapEntry(  ConfigMap configMap,  String key);\n  private void updateConfigMap(  ConfigMap oldConfigMap,  ConfigMap newConfigMap);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-leader/src/main/java/org/springframework/cloud/kubernetes/fabric8/leader/Fabric8LeaderRecordWatcher.java",
        "name": "Fabric8LeaderRecordWatcher",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.leader.Fabric8LeaderRecordWatcher",
        "extend": "",
        "implements": "org.springframework.cloud.kubernetes.commons.leader.LeaderRecordWatcher Watcher\u003cConfigMap\u003e",
        "raw": "/** \n * @author Gytis Trikleris\n */\npublic class Fabric8LeaderRecordWatcher implements org.springframework.cloud.kubernetes.commons.leader.LeaderRecordWatcher, Watcher\u003cConfigMap\u003e {\n  private static final Logger LOGGER\u003dLoggerFactory.getLogger(Fabric8LeaderRecordWatcher.class);\n  private final Object lock\u003dnew Object();\n  private final Fabric8LeadershipController fabric8LeadershipController;\n  private final LeaderProperties leaderProperties;\n  private final KubernetesClient kubernetesClient;\n  private Watch watch;\n  public Fabric8LeaderRecordWatcher(  LeaderProperties leaderProperties,  Fabric8LeadershipController fabric8LeadershipController,  KubernetesClient kubernetesClient){\n    this.fabric8LeadershipController\u003dfabric8LeadershipController;\n    this.leaderProperties\u003dleaderProperties;\n    this.kubernetesClient\u003dkubernetesClient;\n  }\n  public void start(){\n    if (this.watch \u003d\u003d null) {\nsynchronized (this.lock) {\n        if (this.watch \u003d\u003d null) {\n          LOGGER.debug(\"Starting leader record watcher\");\n          this.watch\u003dthis.kubernetesClient.configMaps().inNamespace(this.leaderProperties.getNamespace(this.kubernetesClient.getNamespace())).withName(this.leaderProperties.getConfigMapName()).watch(this);\n        }\n      }\n    }\n  }\n  public void stop(){\n    if (this.watch !\u003d null) {\nsynchronized (this.lock) {\n        if (this.watch !\u003d null) {\n          LOGGER.debug(\"Stopping leader record watcher\");\n          this.watch.close();\n          this.watch\u003dnull;\n        }\n      }\n    }\n  }\n  @Override public void eventReceived(  Action action,  ConfigMap configMap){\n    LOGGER.debug(\"\u0027{}\u0027 event received, triggering leadership update\",action);\n    if (!Action.ERROR.equals(action)) {\n      this.fabric8LeadershipController.update();\n    }\n  }\n  @Override public void onClose(  WatcherException cause){\n    if (cause !\u003d null) {\nsynchronized (this.lock) {\n        LOGGER.warn(\"Watcher stopped unexpectedly, will restart\",cause);\n        this.watch\u003dnull;\n        start();\n      }\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\npublic class Fabric8LeaderRecordWatcher implements org.springframework.cloud.kubernetes.commons.leader.LeaderRecordWatcher, Watcher\u003cConfigMap\u003e {\n  private static final Logger LOGGER\u003dLoggerFactory.getLogger(Fabric8LeaderRecordWatcher.class);\n  private final Object lock\u003dnew Object();\n  private final Fabric8LeadershipController fabric8LeadershipController;\n  private final LeaderProperties leaderProperties;\n  private final KubernetesClient kubernetesClient;\n  private Watch watch;\n  public Fabric8LeaderRecordWatcher(  LeaderProperties leaderProperties,  Fabric8LeadershipController fabric8LeadershipController,  KubernetesClient kubernetesClient);\n  public void start();\n  public void stop();\n  @Override public void eventReceived(  Action action,  ConfigMap configMap);\n  @Override public void onClose(  WatcherException cause);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-leader/src/main/java/org/springframework/cloud/kubernetes/fabric8/leader/Fabric8LeaderAutoConfiguration.java",
        "name": "Fabric8LeaderAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @EnableConfigurationProperties(LeaderProperties.class) @ConditionalOnBean(KubernetesClient.class) @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.leader.enabled\",matchIfMissing\u003dtrue) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.leader.Fabric8LeaderAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Gytis Trikleris\n */\n@Configuration(proxyBeanMethods\u003dfalse) @EnableConfigurationProperties(LeaderProperties.class) @ConditionalOnBean(KubernetesClient.class) @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.leader.enabled\",matchIfMissing\u003dtrue) public class Fabric8LeaderAutoConfiguration {\n  @Bean @ConditionalOnMissingBean(LeaderEventPublisher.class) public LeaderEventPublisher defaultLeaderEventPublisher(  ApplicationEventPublisher applicationEventPublisher){\n    return new DefaultLeaderEventPublisher(applicationEventPublisher);\n  }\n  @Bean public Candidate candidate(  LeaderProperties leaderProperties) throws UnknownHostException {\n    String id\u003dLeaderUtils.hostName();\n    String role\u003dleaderProperties.getRole();\n    return new DefaultCandidate(id,role);\n  }\n  @Bean @ConditionalOnClass(InfoContributor.class) public LeaderInfoContributor leaderInfoContributor(  Fabric8LeadershipController fabric8LeadershipController,  Candidate candidate){\n    return new LeaderInfoContributor(fabric8LeadershipController,candidate);\n  }\n  @Bean public Fabric8LeadershipController leadershipController(  Candidate candidate,  LeaderProperties leaderProperties,  LeaderEventPublisher leaderEventPublisher,  KubernetesClient kubernetesClient){\n    return new Fabric8LeadershipController(candidate,leaderProperties,leaderEventPublisher,kubernetesClient);\n  }\n  @Bean public Fabric8LeaderRecordWatcher leaderRecordWatcher(  LeaderProperties leaderProperties,  Fabric8LeadershipController fabric8LeadershipController,  KubernetesClient kubernetesClient){\n    return new Fabric8LeaderRecordWatcher(leaderProperties,fabric8LeadershipController,kubernetesClient);\n  }\n  @Bean public Fabric8PodReadinessWatcher hostPodWatcher(  Candidate candidate,  KubernetesClient kubernetesClient,  Fabric8LeadershipController fabric8LeadershipController){\n    return new Fabric8PodReadinessWatcher(candidate.getId(),kubernetesClient,fabric8LeadershipController);\n  }\n  @Bean(destroyMethod\u003d\"stop\") public LeaderInitiator leaderInitiator(  LeaderProperties leaderProperties,  Fabric8LeadershipController fabric8LeadershipController,  Fabric8LeaderRecordWatcher fabric8LeaderRecordWatcher,  Fabric8PodReadinessWatcher hostPodWatcher){\n    return new LeaderInitiator(leaderProperties,fabric8LeadershipController,fabric8LeaderRecordWatcher,hostPodWatcher);\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\n@Configuration(proxyBeanMethods\u003dfalse) @EnableConfigurationProperties(LeaderProperties.class) @ConditionalOnBean(KubernetesClient.class) @ConditionalOnProperty(value\u003d\"spring.cloud.kubernetes.leader.enabled\",matchIfMissing\u003dtrue) public class Fabric8LeaderAutoConfiguration {\n  @Bean @ConditionalOnMissingBean(LeaderEventPublisher.class) public LeaderEventPublisher defaultLeaderEventPublisher(  ApplicationEventPublisher applicationEventPublisher);\n  @Bean public Candidate candidate(  LeaderProperties leaderProperties) throws UnknownHostException;\n  @Bean @ConditionalOnClass(InfoContributor.class) public LeaderInfoContributor leaderInfoContributor(  Fabric8LeadershipController fabric8LeadershipController,  Candidate candidate);\n  @Bean public Fabric8LeadershipController leadershipController(  Candidate candidate,  LeaderProperties leaderProperties,  LeaderEventPublisher leaderEventPublisher,  KubernetesClient kubernetesClient);\n  @Bean public Fabric8LeaderRecordWatcher leaderRecordWatcher(  LeaderProperties leaderProperties,  Fabric8LeadershipController fabric8LeadershipController,  KubernetesClient kubernetesClient);\n  @Bean public Fabric8PodReadinessWatcher hostPodWatcher(  Candidate candidate,  KubernetesClient kubernetesClient,  Fabric8LeadershipController fabric8LeadershipController);\n  @Bean(destroyMethod\u003d\"stop\") public LeaderInitiator leaderInitiator(  LeaderProperties leaderProperties,  Fabric8LeadershipController fabric8LeadershipController,  Fabric8LeaderRecordWatcher fabric8LeaderRecordWatcher,  Fabric8PodReadinessWatcher hostPodWatcher);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-leader/src/main/java/org/springframework/cloud/kubernetes/fabric8/leader/Fabric8PodReadinessWatcher.java",
        "name": "Fabric8PodReadinessWatcher",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.leader.Fabric8PodReadinessWatcher",
        "extend": "",
        "implements": "PodReadinessWatcher Watcher\u003cPod\u003e",
        "raw": "/** \n * @author Gytis Trikleris\n */\npublic class Fabric8PodReadinessWatcher implements PodReadinessWatcher, Watcher\u003cPod\u003e {\n  private static final Logger LOGGER\u003dLoggerFactory.getLogger(Fabric8PodReadinessWatcher.class);\n  private final Object lock\u003dnew Object();\n  private final String podName;\n  private final KubernetesClient kubernetesClient;\n  private final Fabric8LeadershipController fabric8LeadershipController;\n  private boolean previousState;\n  private Watch watch;\n  public Fabric8PodReadinessWatcher(  String podName,  KubernetesClient kubernetesClient,  Fabric8LeadershipController fabric8LeadershipController){\n    this.podName\u003dpodName;\n    this.kubernetesClient\u003dkubernetesClient;\n    this.fabric8LeadershipController\u003dfabric8LeadershipController;\n  }\n  @Override public void start(){\n    if (this.watch \u003d\u003d null) {\nsynchronized (this.lock) {\n        if (this.watch \u003d\u003d null) {\n          LOGGER.debug(\"Starting pod readiness watcher for \u0027{}\u0027\",this.podName);\n          PodResource podResource\u003dthis.kubernetesClient.pods().withName(this.podName);\n          this.previousState\u003dpodResource.isReady();\n          this.watch\u003dpodResource.watch(this);\n        }\n      }\n    }\n  }\n  @Override public void stop(){\n    if (this.watch !\u003d null) {\nsynchronized (this.lock) {\n        if (this.watch !\u003d null) {\n          LOGGER.debug(\"Stopping pod readiness watcher for \u0027{}\u0027\",this.podName);\n          this.watch.close();\n          this.watch\u003dnull;\n        }\n      }\n    }\n  }\n  @Override public void eventReceived(  Action action,  Pod pod){\n    boolean currentState\u003dReadiness.isPodReady(pod);\n    if (this.previousState !\u003d currentState) {\nsynchronized (this.lock) {\n        if (this.previousState !\u003d currentState) {\n          LOGGER.debug(\"\u0027{}\u0027 readiness status changed to \u0027{}\u0027, triggering leadership update\",this.podName,currentState);\n          this.previousState\u003dcurrentState;\n          this.fabric8LeadershipController.update();\n        }\n      }\n    }\n  }\n  @Override public void onClose(  WatcherException cause){\n    if (cause !\u003d null) {\nsynchronized (this.lock) {\n        LOGGER.warn(\"Watcher stopped unexpectedly, will restart\",cause);\n        this.watch\u003dnull;\n        start();\n      }\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\npublic class Fabric8PodReadinessWatcher implements PodReadinessWatcher, Watcher\u003cPod\u003e {\n  private static final Logger LOGGER\u003dLoggerFactory.getLogger(Fabric8PodReadinessWatcher.class);\n  private final Object lock\u003dnew Object();\n  private final String podName;\n  private final KubernetesClient kubernetesClient;\n  private final Fabric8LeadershipController fabric8LeadershipController;\n  private boolean previousState;\n  private Watch watch;\n  public Fabric8PodReadinessWatcher(  String podName,  KubernetesClient kubernetesClient,  Fabric8LeadershipController fabric8LeadershipController);\n  @Override public void start();\n  @Override public void stop();\n  @Override public void eventReceived(  Action action,  Pod pod);\n  @Override public void onClose(  WatcherException cause);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-leader/src/test/java/org/springframework/cloud/kubernetes/fabric8/leader/LeaderTest.java",
        "name": "LeaderTest",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.leader.LeaderTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Gytis Trikleris\n */\nclass LeaderTest {\n  private static final String ROLE\u003d\"test-role\";\n  private static final String ID\u003d\"test-id\";\n  private Leader leader;\n  @BeforeEach void before(){\n    leader\u003dnew Leader(ROLE,ID);\n  }\n  @Test void shouldGetRole(){\n    assertThat(leader.getRole()).isEqualTo(ROLE);\n  }\n  @Test void shouldGetId(){\n    assertThat(leader.getId()).isEqualTo(ID);\n  }\n  @Test void shouldCheckWithNullCandidate(){\n    assertThat(leader.isCandidate(null)).isEqualTo(false);\n  }\n  @Test void shouldCheckCandidate(){\n    Candidate candidate\u003dnew DefaultCandidate(ID,ROLE);\n    assertThat(leader.isCandidate(candidate)).isTrue();\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\nclass LeaderTest {\n  private static final String ROLE\u003d\"test-role\";\n  private static final String ID\u003d\"test-id\";\n  private Leader leader;\n  @BeforeEach void before();\n  @Test void shouldGetRole();\n  @Test void shouldGetId();\n  @Test void shouldCheckWithNullCandidate();\n  @Test void shouldCheckCandidate();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-leader/src/test/java/org/springframework/cloud/kubernetes/fabric8/leader/Fabric8LeaderRecordWatcherTest.java",
        "name": "Fabric8LeaderRecordWatcherTest",
        "modifiers": "@ExtendWith(MockitoExtension.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.leader.Fabric8LeaderRecordWatcherTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Gytis Trikleris\n */\n@ExtendWith(MockitoExtension.class) public class Fabric8LeaderRecordWatcherTest {\n  @Mock private LeaderProperties mockLeaderProperties;\n  @Mock private Fabric8LeadershipController mockFabric8LeadershipController;\n  @Mock private KubernetesClient mockKubernetesClient;\n  @Mock private MixedOperation\u003cConfigMap,ConfigMapList,Resource\u003cConfigMap\u003e\u003e mockConfigMapsOperation;\n  @Mock private NonNamespaceOperation\u003cConfigMap,ConfigMapList,Resource\u003cConfigMap\u003e\u003e mockInNamespaceOperation;\n  @Mock private Resource\u003cConfigMap\u003e mockWithNameResource;\n  @Mock private Watch mockWatch;\n  @Mock private ConfigMap mockConfigMap;\n  @Mock private WatcherException mockKubernetesClientException;\n  private Fabric8LeaderRecordWatcher watcher;\n  @BeforeEach public void before(){\n    this.watcher\u003dnew Fabric8LeaderRecordWatcher(this.mockLeaderProperties,this.mockFabric8LeadershipController,this.mockKubernetesClient);\n  }\n  @Test public void shouldStartOnce(){\n    initStubs();\n    this.watcher.start();\n    this.watcher.start();\n    verify(this.mockWithNameResource).watch(this.watcher);\n  }\n  @Test public void shouldStopOnce(){\n    initStubs();\n    this.watcher.start();\n    this.watcher.stop();\n    this.watcher.stop();\n    verify(this.mockWatch).close();\n  }\n  @Test public void shouldHandleEvent(){\n    this.watcher.eventReceived(Watcher.Action.ADDED,this.mockConfigMap);\n    this.watcher.eventReceived(Watcher.Action.DELETED,this.mockConfigMap);\n    this.watcher.eventReceived(Watcher.Action.MODIFIED,this.mockConfigMap);\n    verify(this.mockFabric8LeadershipController,times(3)).update();\n  }\n  @Test public void shouldIgnoreErrorEvent(){\n    this.watcher.eventReceived(Watcher.Action.ERROR,this.mockConfigMap);\n    verify(this.mockFabric8LeadershipController,times(0)).update();\n  }\n  @Test public void shouldHandleClose(){\n    initStubs();\n    this.watcher.onClose(this.mockKubernetesClientException);\n    verify(this.mockWithNameResource).watch(this.watcher);\n  }\n  @Test public void shouldIgnoreCloseWithoutCause(){\n    this.watcher.onClose(null);\n    verify(this.mockWithNameResource,times(0)).watch(this.watcher);\n  }\n  private void initStubs(){\n    given(this.mockKubernetesClient.configMaps()).willReturn(this.mockConfigMapsOperation);\n    given(this.mockConfigMapsOperation.inNamespace(null)).willReturn(this.mockInNamespaceOperation);\n    given(this.mockInNamespaceOperation.withName(null)).willReturn(this.mockWithNameResource);\n    given(this.mockWithNameResource.watch(this.watcher)).willReturn(this.mockWatch);\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\n@ExtendWith(MockitoExtension.class) public class Fabric8LeaderRecordWatcherTest {\n  @Mock private LeaderProperties mockLeaderProperties;\n  @Mock private Fabric8LeadershipController mockFabric8LeadershipController;\n  @Mock private KubernetesClient mockKubernetesClient;\n  @Mock private MixedOperation\u003cConfigMap,ConfigMapList,Resource\u003cConfigMap\u003e\u003e mockConfigMapsOperation;\n  @Mock private NonNamespaceOperation\u003cConfigMap,ConfigMapList,Resource\u003cConfigMap\u003e\u003e mockInNamespaceOperation;\n  @Mock private Resource\u003cConfigMap\u003e mockWithNameResource;\n  @Mock private Watch mockWatch;\n  @Mock private ConfigMap mockConfigMap;\n  @Mock private WatcherException mockKubernetesClientException;\n  private Fabric8LeaderRecordWatcher watcher;\n  @BeforeEach public void before();\n  @Test public void shouldStartOnce();\n  @Test public void shouldStopOnce();\n  @Test public void shouldHandleEvent();\n  @Test public void shouldIgnoreErrorEvent();\n  @Test public void shouldHandleClose();\n  @Test public void shouldIgnoreCloseWithoutCause();\n  private void initStubs();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-leader/src/test/java/org/springframework/cloud/kubernetes/fabric8/leader/LeaderContextTest.java",
        "name": "LeaderContextTest",
        "modifiers": "@ExtendWith(MockitoExtension.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.leader.LeaderContextTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Gytis Trikleris\n */\n@ExtendWith(MockitoExtension.class) public class LeaderContextTest {\n  @Mock private Candidate mockCandidate;\n  @Mock private Fabric8LeadershipController mockFabric8LeadershipController;\n  @Mock private Leader mockLeader;\n  private LeaderContext leaderContext;\n  @BeforeEach public void before(){\n    this.leaderContext\u003dnew LeaderContext(this.mockCandidate,this.mockFabric8LeadershipController);\n  }\n  @Test public void testIsLeaderWithoutLeader(){\n    given(this.mockFabric8LeadershipController.getLocalLeader()).willReturn(Optional.empty());\n    boolean result\u003dthis.leaderContext.isLeader();\n    assertThat(result).isFalse();\n  }\n  @Test public void testIsLeaderWithAnotherLeader(){\n    given(this.mockFabric8LeadershipController.getLocalLeader()).willReturn(Optional.of(this.mockLeader));\n    boolean result\u003dthis.leaderContext.isLeader();\n    assertThat(result).isFalse();\n  }\n  @Test public void testIsLeaderWhenLeader(){\n    given(this.mockFabric8LeadershipController.getLocalLeader()).willReturn(Optional.of(this.mockLeader));\n    given(this.mockLeader.isCandidate(this.mockCandidate)).willReturn(true);\n    boolean result\u003dthis.leaderContext.isLeader();\n    assertThat(result).isTrue();\n  }\n  @Test public void shouldYieldLeadership(){\n    this.leaderContext.yield();\n    verify(this.mockFabric8LeadershipController).revoke();\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\n@ExtendWith(MockitoExtension.class) public class LeaderContextTest {\n  @Mock private Candidate mockCandidate;\n  @Mock private Fabric8LeadershipController mockFabric8LeadershipController;\n  @Mock private Leader mockLeader;\n  private LeaderContext leaderContext;\n  @BeforeEach public void before();\n  @Test public void testIsLeaderWithoutLeader();\n  @Test public void testIsLeaderWithAnotherLeader();\n  @Test public void testIsLeaderWhenLeader();\n  @Test public void shouldYieldLeadership();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-leader/src/test/java/org/springframework/cloud/kubernetes/fabric8/leader/Fabric8LeadershipControllerTest.java",
        "name": "Fabric8LeadershipControllerTest",
        "modifiers": "@ExtendWith(MockitoExtension.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.leader.Fabric8LeadershipControllerTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Gytis Trikleris\n */\n@ExtendWith(MockitoExtension.class) public class Fabric8LeadershipControllerTest {\n  @Mock private Candidate mockCandidate;\n  @Mock private LeaderProperties mockLeaderProperties;\n  @Mock private LeaderEventPublisher mockLeaderEventPublisher;\n  @Mock(answer\u003dAnswers.RETURNS_DEEP_STUBS) private KubernetesClient mockKubernetesClient;\n  private Fabric8LeadershipController fabric8LeadershipController;\n  @BeforeEach public void before(){\n    this.fabric8LeadershipController\u003dnew Fabric8LeadershipController(this.mockCandidate,this.mockLeaderProperties,this.mockLeaderEventPublisher,this.mockKubernetesClient);\n  }\n  @Test public void shouldGetEmptyLocalLeader(){\n    assertThat(this.fabric8LeadershipController.getLocalLeader().isPresent()).isFalse();\n  }\n  @ExtendWith(OutputCaptureExtension.class) @Test void whenNonExistentConfigmapAndCreationNotAllowedStopLeadershipAcquire(  CapturedOutput output){\n    String testNamespace\u003d\"test-namespace\";\n    String testConfigmap\u003d\"test-configmap\";\n    Resource mockResource\u003dMockito.mock(Resource.class);\n    NonNamespaceOperation mockNonNamespaceOperation\u003dMockito.mock(NonNamespaceOperation.class);\n    Fabric8LeadershipController fabric8LeadershipController\u003dnew Fabric8LeadershipController(mockCandidate,mockLeaderProperties,mockLeaderEventPublisher,mockKubernetesClient);\n    when(mockLeaderProperties.isCreateConfigMap()).thenReturn(false);\n    when(mockLeaderProperties.isPublishFailedEvents()).thenReturn(true);\n    when(mockLeaderProperties.getConfigMapName()).thenReturn(testConfigmap);\n    when(mockKubernetesClient.getNamespace()).thenReturn(testNamespace);\n    when(mockLeaderProperties.getNamespace(anyString())).thenReturn(testNamespace);\n    when(mockKubernetesClient.configMaps().inNamespace(anyString())).thenReturn(mockNonNamespaceOperation);\n    when(mockNonNamespaceOperation.withName(any())).thenReturn(mockResource);\n    when(mockResource.get()).thenReturn(null);\n    fabric8LeadershipController.update();\n    assertThat(output).contains(\"ConfigMap \u0027\" + testConfigmap + \"\u0027 does not exist \"+ \"and leaderProperties.isCreateConfigMap() is false, cannot acquire leadership\");\n    verify(mockLeaderEventPublisher).publishOnFailedToAcquire(any(),any(),any());\n    verify(mockKubernetesClient,never()).pods();\n    verify(mockCandidate,never()).getId();\n    verify(mockLeaderProperties,never()).getLeaderIdPrefix();\n    verify(mockLeaderEventPublisher,never()).publishOnGranted(any(),any(),any());\n    verify(mockLeaderEventPublisher,never()).publishOnRevoked(any(),any(),any());\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\n@ExtendWith(MockitoExtension.class) public class Fabric8LeadershipControllerTest {\n  @Mock private Candidate mockCandidate;\n  @Mock private LeaderProperties mockLeaderProperties;\n  @Mock private LeaderEventPublisher mockLeaderEventPublisher;\n  @Mock(answer\u003dAnswers.RETURNS_DEEP_STUBS) private KubernetesClient mockKubernetesClient;\n  private Fabric8LeadershipController fabric8LeadershipController;\n  @BeforeEach public void before();\n  @Test public void shouldGetEmptyLocalLeader();\n  @ExtendWith(OutputCaptureExtension.class) @Test void whenNonExistentConfigmapAndCreationNotAllowedStopLeadershipAcquire(  CapturedOutput output);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-leader/src/test/java/org/springframework/cloud/kubernetes/fabric8/leader/Fabric8LeaderAutoConfigurationTests.java",
        "name": "Fabric8LeaderAutoConfigurationTests",
        "modifiers": "@ExtendWith(MockitoExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.leader.autoStartup\u003dfalse\",\"management.endpoints.web.exposure.include\u003dinfo\",\"management.endpoint.info.show-details\u003dalways\",\"management.info.kubernetes.enabled\u003dtrue\"}) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.leader.Fabric8LeaderAutoConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "@ExtendWith(MockitoExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.leader.autoStartup\u003dfalse\",\"management.endpoints.web.exposure.include\u003dinfo\",\"management.endpoint.info.show-details\u003dalways\",\"management.info.kubernetes.enabled\u003dtrue\"}) public class Fabric8LeaderAutoConfigurationTests {\n  @LocalManagementPort private int port;\n  @Autowired private WebTestClient webClient;\n  @Test public void contextLoads(){\n  }\n  @Test public void infoEndpointShouldContainLeaderElection(){\n    this.webClient.get().uri(\"http://localhost:{port}/actuator/info\",this.port).accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk().expectBody(String.class).value(containsString(\"kubernetes\"));\n  }\n@SpringBootConfiguration @EnableAutoConfiguration protected static class TestConfig {\n  }\n}\n",
        "abstract": "@ExtendWith(MockitoExtension.class) @SpringBootTest(webEnvironment\u003dSpringBootTest.WebEnvironment.RANDOM_PORT,properties\u003d{\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.leader.autoStartup\u003dfalse\",\"management.endpoints.web.exposure.include\u003dinfo\",\"management.endpoint.info.show-details\u003dalways\",\"management.info.kubernetes.enabled\u003dtrue\"}) public class Fabric8LeaderAutoConfigurationTests {\n  @LocalManagementPort private int port;\n  @Autowired private WebTestClient webClient;\n  @Test public void contextLoads();\n  @Test public void infoEndpointShouldContainLeaderElection();\n@SpringBootConfiguration @EnableAutoConfiguration protected static class TestConfig {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-leader/src/test/java/org/springframework/cloud/kubernetes/fabric8/leader/LeaderInitiatorTest.java",
        "name": "LeaderInitiatorTest",
        "modifiers": "@ExtendWith(MockitoExtension.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.leader.LeaderInitiatorTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Gytis Trikleris\n */\n@ExtendWith(MockitoExtension.class) public class LeaderInitiatorTest {\n  @Mock private LeaderProperties mockLeaderProperties;\n  @Mock private Fabric8LeadershipController mockFabric8LeadershipController;\n  @Mock private Fabric8LeaderRecordWatcher mockFabric8LeaderRecordWatcher;\n  @Mock private Fabric8PodReadinessWatcher mockFabric8PodReadinessWatcher;\n  @Mock private Runnable mockRunnable;\n  private LeaderInitiator leaderInitiator;\n  @BeforeEach public void before(){\n    this.leaderInitiator\u003dnew LeaderInitiator(this.mockLeaderProperties,this.mockFabric8LeadershipController,this.mockFabric8LeaderRecordWatcher,this.mockFabric8PodReadinessWatcher);\n  }\n  @AfterEach public void after(){\n    this.leaderInitiator.stop();\n  }\n  @Test public void testIsAutoStartup(){\n    given(this.mockLeaderProperties.isAutoStartup()).willReturn(true);\n    assertThat(this.leaderInitiator.isAutoStartup()).isTrue();\n  }\n  @Test public void shouldStart() throws InterruptedException {\n    given(this.mockLeaderProperties.getUpdatePeriod()).willReturn(Duration.ofMillis(1L));\n    this.leaderInitiator.start();\n    assertThat(this.leaderInitiator.isRunning()).isTrue();\n    verify(this.mockFabric8LeaderRecordWatcher).start();\n    verify(this.mockFabric8PodReadinessWatcher).start();\n    Thread.sleep(1000);\n    verify(this.mockFabric8LeadershipController,atLeastOnce()).update();\n  }\n  @Test public void shouldStartOnlyOnce(){\n    given(this.mockLeaderProperties.getUpdatePeriod()).willReturn(Duration.ofMillis(10000L));\n    this.leaderInitiator.start();\n    this.leaderInitiator.start();\n    verify(this.mockFabric8LeaderRecordWatcher).start();\n  }\n  @Test public void shouldStop(){\n    given(this.mockLeaderProperties.getUpdatePeriod()).willReturn(Duration.ofMillis(10000L));\n    this.leaderInitiator.start();\n    this.leaderInitiator.stop();\n    assertThat(this.leaderInitiator.isRunning()).isFalse();\n    verify(this.mockFabric8LeaderRecordWatcher).stop();\n    verify(this.mockFabric8PodReadinessWatcher).start();\n    verify(this.mockFabric8LeadershipController).revoke();\n  }\n  @Test public void shouldStopOnlyOnce(){\n    given(this.mockLeaderProperties.getUpdatePeriod()).willReturn(Duration.ofMillis(10000L));\n    this.leaderInitiator.start();\n    this.leaderInitiator.stop();\n    this.leaderInitiator.stop();\n    verify(this.mockFabric8LeaderRecordWatcher).stop();\n  }\n  @Test public void shouldStopAndExecuteCallback(){\n    given(this.mockLeaderProperties.getUpdatePeriod()).willReturn(Duration.ofMillis(10000L));\n    this.leaderInitiator.start();\n    this.leaderInitiator.stop(this.mockRunnable);\n    assertThat(this.leaderInitiator.isRunning()).isFalse();\n    verify(this.mockFabric8LeaderRecordWatcher).stop();\n    verify(this.mockFabric8PodReadinessWatcher).start();\n    verify(this.mockFabric8LeadershipController).revoke();\n    verify(this.mockRunnable).run();\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\n@ExtendWith(MockitoExtension.class) public class LeaderInitiatorTest {\n  @Mock private LeaderProperties mockLeaderProperties;\n  @Mock private Fabric8LeadershipController mockFabric8LeadershipController;\n  @Mock private Fabric8LeaderRecordWatcher mockFabric8LeaderRecordWatcher;\n  @Mock private Fabric8PodReadinessWatcher mockFabric8PodReadinessWatcher;\n  @Mock private Runnable mockRunnable;\n  private LeaderInitiator leaderInitiator;\n  @BeforeEach public void before();\n  @AfterEach public void after();\n  @Test public void testIsAutoStartup();\n  @Test public void shouldStart() throws InterruptedException;\n  @Test public void shouldStartOnlyOnce();\n  @Test public void shouldStop();\n  @Test public void shouldStopOnlyOnce();\n  @Test public void shouldStopAndExecuteCallback();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-fabric8-leader/src/test/java/org/springframework/cloud/kubernetes/fabric8/leader/Fabric8PodReadinessWatcherTest.java",
        "name": "Fabric8PodReadinessWatcherTest",
        "modifiers": "@ExtendWith(MockitoExtension.class) public",
        "qualified_name": "org.springframework.cloud.kubernetes.fabric8.leader.Fabric8PodReadinessWatcherTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Gytis Trikleris\n */\n@ExtendWith(MockitoExtension.class) public class Fabric8PodReadinessWatcherTest {\n  private static final String POD_NAME\u003d\"test-pod\";\n  @Mock private Fabric8LeadershipController mockFabric8LeadershipController;\n  @Mock private KubernetesClient mockKubernetesClient;\n  @Mock private MixedOperation\u003cPod,PodList,PodResource\u003e mockPodsOperation;\n  @Mock private PodResource mockPodResource;\n  @Mock private Pod mockPod;\n  @Mock private PodStatus mockPodStatus;\n  @Mock private Watch mockWatch;\n  @Mock private WatcherException mockKubernetesClientException;\n  private Fabric8PodReadinessWatcher watcher;\n  @BeforeEach public void before(){\n    this.watcher\u003dnew Fabric8PodReadinessWatcher(POD_NAME,this.mockKubernetesClient,this.mockFabric8LeadershipController);\n  }\n  @Test public void shouldStartOnce(){\n    initStubs();\n    this.watcher.start();\n    this.watcher.start();\n    verify(this.mockPodResource).watch(this.watcher);\n  }\n  @Test public void shouldStopOnce(){\n    initStubs();\n    this.watcher.start();\n    this.watcher.stop();\n    this.watcher.stop();\n    verify(this.mockWatch).close();\n  }\n  @Test public void shouldHandleEventWithStateChange(){\n    initStubs();\n    given(this.mockPodResource.isReady()).willReturn(true);\n    given(this.mockPod.getStatus()).willReturn(this.mockPodStatus);\n    this.watcher.start();\n    this.watcher.eventReceived(Watcher.Action.ADDED,this.mockPod);\n    verify(this.mockFabric8LeadershipController).update();\n  }\n  @Test public void shouldIgnoreEventIfStateDoesNotChange(){\n    initStubs();\n    given(this.mockPod.getStatus()).willReturn(this.mockPodStatus);\n    this.watcher.start();\n    this.watcher.eventReceived(Watcher.Action.ADDED,this.mockPod);\n    verify(this.mockFabric8LeadershipController,times(0)).update();\n  }\n  @Test public void shouldHandleClose(){\n    initStubs();\n    this.watcher.onClose(this.mockKubernetesClientException);\n    verify(this.mockPodResource).watch(this.watcher);\n  }\n  @Test public void shouldIgnoreCloseWithoutCause(){\n    this.watcher.onClose(null);\n    verify(this.mockPodResource,times(0)).watch(this.watcher);\n  }\n  private void initStubs(){\n    given(this.mockKubernetesClient.pods()).willReturn(this.mockPodsOperation);\n    given(this.mockPodsOperation.withName(POD_NAME)).willReturn(this.mockPodResource);\n    given(this.mockPodResource.watch(this.watcher)).willReturn(this.mockWatch);\n  }\n}\n",
        "abstract": "/** \n * @author Gytis Trikleris\n */\n@ExtendWith(MockitoExtension.class) public class Fabric8PodReadinessWatcherTest {\n  private static final String POD_NAME\u003d\"test-pod\";\n  @Mock private Fabric8LeadershipController mockFabric8LeadershipController;\n  @Mock private KubernetesClient mockKubernetesClient;\n  @Mock private MixedOperation\u003cPod,PodList,PodResource\u003e mockPodsOperation;\n  @Mock private PodResource mockPodResource;\n  @Mock private Pod mockPod;\n  @Mock private PodStatus mockPodStatus;\n  @Mock private Watch mockWatch;\n  @Mock private WatcherException mockKubernetesClientException;\n  private Fabric8PodReadinessWatcher watcher;\n  @BeforeEach public void before();\n  @Test public void shouldStartOnce();\n  @Test public void shouldStopOnce();\n  @Test public void shouldHandleEventWithStateChange();\n  @Test public void shouldIgnoreEventIfStateDoesNotChange();\n  @Test public void shouldHandleClose();\n  @Test public void shouldIgnoreCloseWithoutCause();\n  private void initStubs();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/main/java/org/springframework/cloud/kubernetes/discovery/KubernetesCatalogWatch.java",
        "name": "KubernetesCatalogWatch",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesCatalogWatch",
        "extend": "",
        "implements": "ApplicationEventPublisherAware",
        "raw": "/** \n * @author wind57\n */\nfinal class KubernetesCatalogWatch implements ApplicationEventPublisherAware {\n  private static final ParameterizedTypeReference\u003cList\u003cEndpointNameAndNamespace\u003e\u003e TYPE\u003dnew ParameterizedTypeReference\u003c\u003e(){\n  }\n;\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesCatalogWatch.class));\n  private final AtomicReference\u003cList\u003cEndpointNameAndNamespace\u003e\u003e catalogState\u003dnew AtomicReference\u003c\u003e(List.of());\n  private final RestTemplate restTemplate;\n  private ApplicationEventPublisher publisher;\n  KubernetesCatalogWatch(  RestTemplateBuilder builder,  KubernetesDiscoveryProperties properties){\n    this.restTemplate\u003dbuilder.rootUri(properties.discoveryServerUrl()).build();\n  }\n  @Override public void setApplicationEventPublisher(  ApplicationEventPublisher publisher){\n    this.publisher\u003dpublisher;\n  }\n  @Scheduled(fixedDelayString\u003d\"${\" + CATALOG_WATCH_PROPERTY_WITH_DEFAULT_VALUE + \"}\") public void catalogServicesWatch(){\n    try {\n      List\u003cEndpointNameAndNamespace\u003e currentState\u003drestTemplate.exchange(\"/state\",HttpMethod.GET,null,TYPE).getBody();\n      if (!catalogState.get().equals(currentState)) {\n        LOG.debug(() -\u003e \"Received update from kubernetes discovery http client: \" + currentState);\n        publisher.publishEvent(new HeartbeatEvent(this,currentState));\n      }\n      catalogState.set(currentState);\n    }\n catch (    Exception e) {\n      LOG.error(e,() -\u003e \"Error watching Kubernetes Services\");\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class KubernetesCatalogWatch implements ApplicationEventPublisherAware {\n  private static final ParameterizedTypeReference\u003cList\u003cEndpointNameAndNamespace\u003e\u003e TYPE\u003dnew ParameterizedTypeReference\u003c\u003e(){\n  }\n;\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesCatalogWatch.class));\n  private final AtomicReference\u003cList\u003cEndpointNameAndNamespace\u003e\u003e catalogState\u003dnew AtomicReference\u003c\u003e(List.of());\n  private final RestTemplate restTemplate;\n  private ApplicationEventPublisher publisher;\n  KubernetesCatalogWatch(  RestTemplateBuilder builder,  KubernetesDiscoveryProperties properties);\n  @Override public void setApplicationEventPublisher(  ApplicationEventPublisher publisher);\n  @Scheduled(fixedDelayString\u003d\"${\" + CATALOG_WATCH_PROPERTY_WITH_DEFAULT_VALUE + \"}\") public void catalogServicesWatch();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/main/java/org/springframework/cloud/kubernetes/discovery/KubernetesDiscoveryClientReactiveAutoConfiguration.java",
        "name": "KubernetesDiscoveryClientReactiveAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesReactiveDiscovery @EnableConfigurationProperties({DiscoveryClientHealthIndicatorProperties.class,KubernetesDiscoveryProperties.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesDiscoveryClientReactiveAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesReactiveDiscovery @EnableConfigurationProperties({DiscoveryClientHealthIndicatorProperties.class,KubernetesDiscoveryProperties.class}) class KubernetesDiscoveryClientReactiveAutoConfiguration {\n  @Bean @ConditionalOnMissingBean WebClient.Builder webClientBuilder(){\n    return WebClient.builder();\n  }\n  @Bean @ConditionalOnMissingBean KubernetesReactiveDiscoveryClient kubernetesReactiveDiscoveryClient(  WebClient.Builder webClientBuilder,  KubernetesDiscoveryProperties properties){\n    return new KubernetesReactiveDiscoveryClient(webClientBuilder,properties);\n  }\n  @Bean @ConditionalOnMissingBean PodUtils\u003c?\u003e kubernetesDiscoveryPodUtils(){\n    return new KubernetesDiscoveryPodUtils();\n  }\n  /** \n * Post an event so that health indicator is initialized.\n */\n  @Bean @ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer KubernetesDiscoveryClientHealthIndicatorInitializer reactiveIndicatorInitializer(  ApplicationEventPublisher applicationEventPublisher,  PodUtils\u003c?\u003e podUtils){\n    return new KubernetesDiscoveryClientHealthIndicatorInitializer(podUtils,applicationEventPublisher);\n  }\n  /** \n * unlike the blocking implementation, we need to register the health indicator.\n */\n  @Bean @ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer ReactiveDiscoveryClientHealthIndicator kubernetesReactiveDiscoveryClientHealthIndicator(  KubernetesReactiveDiscoveryClient client,  DiscoveryClientHealthIndicatorProperties properties){\n    return new ReactiveDiscoveryClientHealthIndicator(client,properties);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesReactiveDiscovery @EnableConfigurationProperties({DiscoveryClientHealthIndicatorProperties.class,KubernetesDiscoveryProperties.class}) class KubernetesDiscoveryClientReactiveAutoConfiguration {\n  @Bean @ConditionalOnMissingBean WebClient.Builder webClientBuilder();\n  @Bean @ConditionalOnMissingBean KubernetesReactiveDiscoveryClient kubernetesReactiveDiscoveryClient(  WebClient.Builder webClientBuilder,  KubernetesDiscoveryProperties properties);\n  @Bean @ConditionalOnMissingBean PodUtils\u003c?\u003e kubernetesDiscoveryPodUtils();\n  /** \n * Post an event so that health indicator is initialized.\n */\n  @Bean @ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer KubernetesDiscoveryClientHealthIndicatorInitializer reactiveIndicatorInitializer(  ApplicationEventPublisher applicationEventPublisher,  PodUtils\u003c?\u003e podUtils);\n  /** \n * unlike the blocking implementation, we need to register the health indicator.\n */\n  @Bean @ConditionalOnSpringCloudKubernetesReactiveDiscoveryHealthInitializer ReactiveDiscoveryClientHealthIndicator kubernetesReactiveDiscoveryClientHealthIndicator(  KubernetesReactiveDiscoveryClient client,  DiscoveryClientHealthIndicatorProperties properties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/main/java/org/springframework/cloud/kubernetes/discovery/KubernetesServiceInstance.java",
        "name": "KubernetesServiceInstance",
        "modifiers": "@Deprecated(forRemoval\u003dtrue) public",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesServiceInstance",
        "extend": "",
        "implements": "ServiceInstance",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Deprecated(forRemoval\u003dtrue) public class KubernetesServiceInstance implements ServiceInstance {\n  private String instanceId;\n  private String serviceId;\n  private String host;\n  private int port;\n  private boolean secure;\n  private URI uri;\n  private Map\u003cString,String\u003e metadata;\n  private String scheme;\n  private String namespace;\n  public KubernetesServiceInstance(){\n  }\n  public KubernetesServiceInstance(  String instanceId,  String serviceId,  String host,  int port,  boolean secure,  URI uri,  Map\u003cString,String\u003e metadata,  String scheme,  String namespace){\n    this.instanceId\u003dinstanceId;\n    this.serviceId\u003dserviceId;\n    this.host\u003dhost;\n    this.port\u003dport;\n    this.secure\u003dsecure;\n    this.uri\u003duri;\n    this.metadata\u003dmetadata;\n    this.scheme\u003dscheme;\n    this.namespace\u003dnamespace;\n  }\n  @Override public String getInstanceId(){\n    return instanceId;\n  }\n  @Override public String getServiceId(){\n    return serviceId;\n  }\n  @Override public String getHost(){\n    return host;\n  }\n  @Override public int getPort(){\n    return port;\n  }\n  @Override public boolean isSecure(){\n    return secure;\n  }\n  @Override public URI getUri(){\n    return uri;\n  }\n  @Override public Map\u003cString,String\u003e getMetadata(){\n    return metadata;\n  }\n  public void setInstanceId(  String instanceId){\n    this.instanceId\u003dinstanceId;\n  }\n  public void setServiceId(  String serviceId){\n    this.serviceId\u003dserviceId;\n  }\n  public void setHost(  String host){\n    this.host\u003dhost;\n  }\n  public void setPort(  int port){\n    this.port\u003dport;\n  }\n  public void setSecure(  boolean secure){\n    this.secure\u003dsecure;\n  }\n  public void setUri(  URI uri){\n    this.uri\u003duri;\n  }\n  public void setMetadata(  Map\u003cString,String\u003e metadata){\n    this.metadata\u003dmetadata;\n  }\n  public void setScheme(  String scheme){\n    this.scheme\u003dscheme;\n  }\n  public String getNamespace(){\n    return namespace;\n  }\n  public void setNamespace(  String namespace){\n    this.namespace\u003dnamespace;\n  }\n  @Override public String getScheme(){\n    return scheme;\n  }\n  @Override public boolean equals(  Object o){\n    if (this \u003d\u003d o) {\n      return true;\n    }\n    if (o \u003d\u003d null || getClass() !\u003d o.getClass()) {\n      return false;\n    }\n    KubernetesServiceInstance that\u003d(KubernetesServiceInstance)o;\n    return getPort() \u003d\u003d that.getPort() \u0026\u0026 isSecure() \u003d\u003d that.isSecure() \u0026\u0026 Objects.equals(getInstanceId(),that.getInstanceId()) \u0026\u0026 Objects.equals(getServiceId(),that.getServiceId()) \u0026\u0026 Objects.equals(getHost(),that.getHost()) \u0026\u0026 Objects.equals(getUri(),that.getUri()) \u0026\u0026 Objects.equals(getMetadata(),that.getMetadata()) \u0026\u0026 Objects.equals(getScheme(),that.getScheme()) \u0026\u0026 Objects.equals(getNamespace(),that.getNamespace());\n  }\n  @Override public int hashCode(){\n    return Objects.hash(getInstanceId(),getServiceId(),getHost(),getPort(),isSecure(),getUri(),getMetadata(),getScheme(),getNamespace());\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Deprecated(forRemoval\u003dtrue) public class KubernetesServiceInstance implements ServiceInstance {\n  private String instanceId;\n  private String serviceId;\n  private String host;\n  private int port;\n  private boolean secure;\n  private URI uri;\n  private Map\u003cString,String\u003e metadata;\n  private String scheme;\n  private String namespace;\n  public KubernetesServiceInstance();\n  public KubernetesServiceInstance(  String instanceId,  String serviceId,  String host,  int port,  boolean secure,  URI uri,  Map\u003cString,String\u003e metadata,  String scheme,  String namespace);\n  @Override public String getInstanceId();\n  @Override public String getServiceId();\n  @Override public String getHost();\n  @Override public int getPort();\n  @Override public boolean isSecure();\n  @Override public URI getUri();\n  @Override public Map\u003cString,String\u003e getMetadata();\n  public void setInstanceId(  String instanceId);\n  public void setServiceId(  String serviceId);\n  public void setHost(  String host);\n  public void setPort(  int port);\n  public void setSecure(  boolean secure);\n  public void setUri(  URI uri);\n  public void setMetadata(  Map\u003cString,String\u003e metadata);\n  public void setScheme(  String scheme);\n  public String getNamespace();\n  public void setNamespace(  String namespace);\n  @Override public String getScheme();\n  @Override public boolean equals(  Object o);\n  @Override public int hashCode();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/main/java/org/springframework/cloud/kubernetes/discovery/KubernetesDiscoveryClientProperties.java",
        "name": "KubernetesDiscoveryClientProperties",
        "modifiers": "@Deprecated(forRemoval\u003dtrue) @ConfigurationProperties(\"spring.cloud.kubernetes.discovery\") public",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesDiscoveryClientProperties",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @deprecated use{@link org.springframework.cloud.kubernetes.commons.discovery.KubernetesDiscoveryProperties}instead.\n */\n@Deprecated(forRemoval\u003dtrue) @ConfigurationProperties(\"spring.cloud.kubernetes.discovery\") public class KubernetesDiscoveryClientProperties {\n  private String discoveryServerUrl;\n  private boolean enabled\u003dtrue;\n  /** \n * If set then only the services and endpoints matching these namespaces will be fetched from the Kubernetes API server.\n */\n  private Set\u003cString\u003e namespaces\u003dSet.of();\n  public String getDiscoveryServerUrl(){\n    return discoveryServerUrl;\n  }\n  public void setDiscoveryServerUrl(  String discoveryServerUrl){\n    this.discoveryServerUrl\u003ddiscoveryServerUrl;\n  }\n  public boolean isEnabled(){\n    return enabled;\n  }\n  public void setEnabled(  boolean enabled){\n    this.enabled\u003denabled;\n  }\n  Set\u003cString\u003e getNamespaces(){\n    return namespaces;\n  }\n  void setNamespaces(  Set\u003cString\u003e namespaces){\n    this.namespaces\u003dnamespaces;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @deprecated use{@link org.springframework.cloud.kubernetes.commons.discovery.KubernetesDiscoveryProperties}instead.\n */\n@Deprecated(forRemoval\u003dtrue) @ConfigurationProperties(\"spring.cloud.kubernetes.discovery\") public class KubernetesDiscoveryClientProperties {\n  private String discoveryServerUrl;\n  private boolean enabled\u003dtrue;\n  /** \n * If set then only the services and endpoints matching these namespaces will be fetched from the Kubernetes API server.\n */\n  private Set\u003cString\u003e namespaces\u003dSet.of();\n  public String getDiscoveryServerUrl();\n  public void setDiscoveryServerUrl(  String discoveryServerUrl);\n  public boolean isEnabled();\n  public void setEnabled(  boolean enabled);\n  Set\u003cString\u003e getNamespaces();\n  void setNamespaces(  Set\u003cString\u003e namespaces);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/main/java/org/springframework/cloud/kubernetes/discovery/ConfigServerBootstrapper.java",
        "name": "ConfigServerBootstrapper",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.ConfigServerBootstrapper",
        "extend": "KubernetesConfigServerBootstrapper",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass ConfigServerBootstrapper extends KubernetesConfigServerBootstrapper {\n  @Override public void initialize(  BootstrapRegistry registry){\n    if (hasConfigServerInstanceProvider()) {\n      return;\n    }\n    registry.registerIfAbsent(ConfigServerInstanceProvider.Function.class,KubernetesFunction::create);\n  }\nfinal static class KubernetesFunction implements ConfigServerInstanceProvider.Function {\n    private KubernetesFunction(){\n    }\n    static KubernetesFunction create(    BootstrapContext context){\n      return new KubernetesFunction();\n    }\n    @Override public List\u003cServiceInstance\u003e apply(    String serviceId,    Binder binder,    BindHandler bindHandler,    Log log){\n      if (binder \u003d\u003d null || bindHandler \u003d\u003d null || !getDiscoveryEnabled(binder,bindHandler)) {\n        return Collections.emptyList();\n      }\n      return getInstanceProvider(binder,bindHandler).getInstances(serviceId);\n    }\n    private KubernetesConfigServerInstanceProvider getInstanceProvider(    Binder binder,    BindHandler bindHandler){\n      KubernetesDiscoveryProperties kubernetesDiscoveryProperties\u003dbinder.bind(KubernetesDiscoveryProperties.PREFIX,Bindable.of(KubernetesDiscoveryProperties.class),bindHandler).orElseGet(() -\u003e KubernetesDiscoveryProperties.DEFAULT);\n      KubernetesDiscoveryClientBlockingAutoConfiguration autoConfiguration\u003dnew KubernetesDiscoveryClientBlockingAutoConfiguration();\n      DiscoveryClient discoveryClient\u003dautoConfiguration.kubernetesDiscoveryClient(autoConfiguration.restTemplateBuilder(),kubernetesDiscoveryProperties);\n      return discoveryClient::getInstances;\n    }\n    @Override public List\u003cServiceInstance\u003e apply(    String serviceId){\n      return apply(serviceId,null,null,null);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass ConfigServerBootstrapper extends KubernetesConfigServerBootstrapper {\n  @Override public void initialize(  BootstrapRegistry registry);\nfinal static class KubernetesFunction implements ConfigServerInstanceProvider.Function {\n    private KubernetesFunction();\n    static KubernetesFunction create(    BootstrapContext context);\n    @Override public List\u003cServiceInstance\u003e apply(    String serviceId,    Binder binder,    BindHandler bindHandler,    Log log);\n    private KubernetesConfigServerInstanceProvider getInstanceProvider(    Binder binder,    BindHandler bindHandler);\n    @Override public List\u003cServiceInstance\u003e apply(    String serviceId);\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/main/java/org/springframework/cloud/kubernetes/discovery/KubernetesDiscoveryClient.java",
        "name": "KubernetesDiscoveryClient",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesDiscoveryClient",
        "extend": "",
        "implements": "DiscoveryClient",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesDiscoveryClient implements DiscoveryClient {\n  private final RestTemplate rest;\n  private final boolean emptyNamespaces;\n  private final Set\u003cString\u003e namespaces;\n  private final String discoveryServerUrl;\n  @Deprecated(forRemoval\u003dtrue) public KubernetesDiscoveryClient(  RestTemplate rest,  KubernetesDiscoveryClientProperties properties){\n    if (!StringUtils.hasText(properties.getDiscoveryServerUrl())) {\n      throw new DiscoveryServerUrlInvalidException();\n    }\n    this.rest\u003drest;\n    this.emptyNamespaces\u003dproperties.getNamespaces().isEmpty();\n    this.namespaces\u003dproperties.getNamespaces();\n    this.discoveryServerUrl\u003dproperties.getDiscoveryServerUrl();\n  }\n  KubernetesDiscoveryClient(  RestTemplate rest,  KubernetesDiscoveryProperties kubernetesDiscoveryProperties){\n    if (!StringUtils.hasText(kubernetesDiscoveryProperties.discoveryServerUrl())) {\n      throw new DiscoveryServerUrlInvalidException();\n    }\n    this.rest\u003drest;\n    this.emptyNamespaces\u003dkubernetesDiscoveryProperties.namespaces().isEmpty();\n    this.namespaces\u003dkubernetesDiscoveryProperties.namespaces();\n    this.discoveryServerUrl\u003dkubernetesDiscoveryProperties.discoveryServerUrl();\n  }\n  @Override public String description(){\n    return \"Kubernetes Discovery Client\";\n  }\n  @Override public List\u003cServiceInstance\u003e getInstances(  String serviceId){\n    DefaultKubernetesServiceInstance[] responseBody\u003drest.getForEntity(discoveryServerUrl + \"/apps/\" + serviceId,DefaultKubernetesServiceInstance[].class).getBody();\n    if (responseBody !\u003d null \u0026\u0026 responseBody.length \u003e 0) {\n      return Arrays.stream(responseBody).filter(this::matchNamespaces).collect(Collectors.toList());\n    }\n    return List.of();\n  }\n  @Override public List\u003cString\u003e getServices(){\n    Service[] services\u003drest.getForEntity(discoveryServerUrl + \"/apps\",Service[].class).getBody();\n    if (services !\u003d null \u0026\u0026 services.length \u003e 0) {\n      return Arrays.stream(services).filter(this::matchNamespaces).map(Service::name).toList();\n    }\n    return List.of();\n  }\n  private boolean matchNamespaces(  DefaultKubernetesServiceInstance kubernetesServiceInstance){\n    return emptyNamespaces || namespaces.contains(kubernetesServiceInstance.getNamespace());\n  }\n  private boolean matchNamespaces(  Service service){\n    return service.serviceInstances().isEmpty() || service.serviceInstances().stream().anyMatch(this::matchNamespaces);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesDiscoveryClient implements DiscoveryClient {\n  private final RestTemplate rest;\n  private final boolean emptyNamespaces;\n  private final Set\u003cString\u003e namespaces;\n  private final String discoveryServerUrl;\n  @Deprecated(forRemoval\u003dtrue) public KubernetesDiscoveryClient(  RestTemplate rest,  KubernetesDiscoveryClientProperties properties);\n  KubernetesDiscoveryClient(  RestTemplate rest,  KubernetesDiscoveryProperties kubernetesDiscoveryProperties);\n  @Override public String description();\n  @Override public List\u003cServiceInstance\u003e getInstances(  String serviceId);\n  @Override public List\u003cString\u003e getServices();\n  private boolean matchNamespaces(  DefaultKubernetesServiceInstance kubernetesServiceInstance);\n  private boolean matchNamespaces(  Service service);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/main/java/org/springframework/cloud/kubernetes/discovery/KubernetesCatalogWatchAutoConfiguration.java",
        "name": "KubernetesCatalogWatchAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesCatalogWatcherEnabled @ConditionalOnHttpDiscoveryCatalogWatcherEnabled @EnableConfigurationProperties(KubernetesDiscoveryProperties.class)",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesCatalogWatchAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesCatalogWatcherEnabled @ConditionalOnHttpDiscoveryCatalogWatcherEnabled @EnableConfigurationProperties(KubernetesDiscoveryProperties.class) class KubernetesCatalogWatchAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesCatalogWatchAutoConfiguration.class));\n  @Bean @ConditionalOnMissingBean RestTemplateBuilder restTemplateBuilder(){\n    return new RestTemplateBuilder();\n  }\n  @Bean @ConditionalOnMissingBean KubernetesCatalogWatch kubernetesCatalogWatch(  RestTemplateBuilder builder,  KubernetesDiscoveryProperties properties,  Environment environment){\n    String watchDelay\u003denvironment.getProperty(CATALOG_WATCH_PROPERTY_NAME);\n    if (watchDelay !\u003d null) {\n      LOG.debug(\"using delay : \" + watchDelay);\n    }\n else {\n      LOG.debug(\"using default watch delay : \" + CATALOG_WATCHER_DEFAULT_DELAY);\n    }\n    return new KubernetesCatalogWatch(builder,properties);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnKubernetesCatalogWatcherEnabled @ConditionalOnHttpDiscoveryCatalogWatcherEnabled @EnableConfigurationProperties(KubernetesDiscoveryProperties.class) class KubernetesCatalogWatchAutoConfiguration {\n  private static final LogAccessor LOG\u003dnew LogAccessor(LogFactory.getLog(KubernetesCatalogWatchAutoConfiguration.class));\n  @Bean @ConditionalOnMissingBean RestTemplateBuilder restTemplateBuilder();\n  @Bean @ConditionalOnMissingBean KubernetesCatalogWatch kubernetesCatalogWatch(  RestTemplateBuilder builder,  KubernetesDiscoveryProperties properties,  Environment environment);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/main/java/org/springframework/cloud/kubernetes/discovery/KubernetesDiscoveryPodUtils.java",
        "name": "KubernetesDiscoveryPodUtils",
        "modifiers": "final",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesDiscoveryPodUtils",
        "extend": "",
        "implements": "PodUtils\u003cObject\u003e",
        "raw": "/** \n * @author wind57\n */\nfinal class KubernetesDiscoveryPodUtils implements PodUtils\u003cObject\u003e {\n  @Override public Supplier\u003cObject\u003e currentPod(){\n    return () -\u003e null;\n  }\n  @Override public boolean isInsideKubernetes(){\n    return true;\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nfinal class KubernetesDiscoveryPodUtils implements PodUtils\u003cObject\u003e {\n  @Override public Supplier\u003cObject\u003e currentPod();\n  @Override public boolean isInsideKubernetes();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/main/java/org/springframework/cloud/kubernetes/discovery/DiscoveryServerUrlInvalidException.java",
        "name": "DiscoveryServerUrlInvalidException",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.DiscoveryServerUrlInvalidException",
        "extend": "RuntimeException",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class DiscoveryServerUrlInvalidException extends RuntimeException {\n  public DiscoveryServerUrlInvalidException(){\n    super(\"\u0027spring.cloud.kubernetes.discovery.discovery-server-url\u0027 must be specified and be a valid URL.\");\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class DiscoveryServerUrlInvalidException extends RuntimeException {\n  public DiscoveryServerUrlInvalidException();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/main/java/org/springframework/cloud/kubernetes/discovery/KubernetesDiscoveryClientBlockingAutoConfiguration.java",
        "name": "KubernetesDiscoveryClientBlockingAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesBlockingDiscovery @EnableConfigurationProperties({DiscoveryClientHealthIndicatorProperties.class,KubernetesDiscoveryProperties.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesDiscoveryClientBlockingAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesBlockingDiscovery @EnableConfigurationProperties({DiscoveryClientHealthIndicatorProperties.class,KubernetesDiscoveryProperties.class}) class KubernetesDiscoveryClientBlockingAutoConfiguration {\n  @Bean @ConditionalOnMissingBean RestTemplateBuilder restTemplateBuilder(){\n    return new RestTemplateBuilder();\n  }\n  @Bean @ConditionalOnMissingBean KubernetesDiscoveryClient kubernetesDiscoveryClient(  RestTemplateBuilder restTemplateBuilder,  KubernetesDiscoveryProperties properties){\n    return new KubernetesDiscoveryClient(restTemplateBuilder.build(),properties);\n  }\n  @Bean @ConditionalOnMissingBean PodUtils\u003c?\u003e kubernetesDiscoveryPodUtils(){\n    return new KubernetesDiscoveryPodUtils();\n  }\n  @Bean @ConditionalOnSpringCloudKubernetesBlockingDiscoveryHealthInitializer KubernetesDiscoveryClientHealthIndicatorInitializer indicatorInitializer(  PodUtils\u003c?\u003e podUtils,  ApplicationEventPublisher applicationEventPublisher){\n    return new KubernetesDiscoveryClientHealthIndicatorInitializer(podUtils,applicationEventPublisher);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnSpringCloudKubernetesBlockingDiscovery @EnableConfigurationProperties({DiscoveryClientHealthIndicatorProperties.class,KubernetesDiscoveryProperties.class}) class KubernetesDiscoveryClientBlockingAutoConfiguration {\n  @Bean @ConditionalOnMissingBean RestTemplateBuilder restTemplateBuilder();\n  @Bean @ConditionalOnMissingBean KubernetesDiscoveryClient kubernetesDiscoveryClient(  RestTemplateBuilder restTemplateBuilder,  KubernetesDiscoveryProperties properties);\n  @Bean @ConditionalOnMissingBean PodUtils\u003c?\u003e kubernetesDiscoveryPodUtils();\n  @Bean @ConditionalOnSpringCloudKubernetesBlockingDiscoveryHealthInitializer KubernetesDiscoveryClientHealthIndicatorInitializer indicatorInitializer(  PodUtils\u003c?\u003e podUtils,  ApplicationEventPublisher applicationEventPublisher);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/main/java/org/springframework/cloud/kubernetes/discovery/KubernetesDiscoveryClientAutoConfiguration.java",
        "name": "KubernetesDiscoveryClientAutoConfiguration",
        "modifiers": "@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesDiscoveryEnabled @EnableConfigurationProperties({DiscoveryClientHealthIndicatorProperties.class,KubernetesDiscoveryClientProperties.class}) @Deprecated(forRemoval\u003dtrue) public",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesDiscoveryClientAutoConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n * @deprecated in favor of {@link KubernetesDiscoveryClientBlockingAutoConfiguration} and{@link KubernetesDiscoveryClientReactiveAutoConfiguration}\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesDiscoveryEnabled @EnableConfigurationProperties({DiscoveryClientHealthIndicatorProperties.class,KubernetesDiscoveryClientProperties.class}) @Deprecated(forRemoval\u003dtrue) public class KubernetesDiscoveryClientAutoConfiguration {\n@Configuration(proxyBeanMethods\u003dfalse) public static class Servlet {\n    @Bean @ConditionalOnMissingClass(\"org.springframework.web.reactive.function.client.WebClient\") @ConditionalOnMissingBean(RestTemplate.class) public RestTemplate restTemplate(){\n      return new RestTemplateBuilder().build();\n    }\n    @Bean @ConditionalOnMissingClass(\"org.springframework.web.reactive.function.client.WebClient\") public DiscoveryClient kubernetesDiscoveryClient(    RestTemplate restTemplate,    KubernetesDiscoveryClientProperties properties){\n      return new KubernetesDiscoveryClient(restTemplate,properties);\n    }\n    @Bean @ConditionalOnClass({HealthIndicator.class}) @ConditionalOnDiscoveryHealthIndicatorEnabled public InitializingBean indicatorInitializer(    ApplicationEventPublisher applicationEventPublisher,    ApplicationContext applicationContext){\n      return () -\u003e applicationEventPublisher.publishEvent(new InstanceRegisteredEvent\u003c\u003e(applicationContext.getId(),null));\n    }\n  }\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnReactiveDiscoveryEnabled public static class Reactive {\n    @Bean @ConditionalOnClass(name\u003d{\"org.springframework.web.reactive.function.client.WebClient\"}) @ConditionalOnMissingBean(WebClient.Builder.class) public WebClient.Builder webClientBuilder(){\n      return WebClient.builder();\n    }\n    @Bean @ConditionalOnClass(name\u003d{\"org.springframework.web.reactive.function.client.WebClient\"}) public ReactiveDiscoveryClient kubernetesReactiveDiscoveryClient(    WebClient.Builder webClientBuilder,    KubernetesDiscoveryClientProperties properties){\n      return new KubernetesReactiveDiscoveryClient(webClientBuilder,properties);\n    }\n    @Bean @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.health.ReactiveHealthIndicator\") @ConditionalOnDiscoveryHealthIndicatorEnabled public ReactiveDiscoveryClientHealthIndicator kubernetesReactiveDiscoveryClientHealthIndicator(    KubernetesReactiveDiscoveryClient client,    DiscoveryClientHealthIndicatorProperties properties,    ApplicationContext applicationContext){\n      ReactiveDiscoveryClientHealthIndicator healthIndicator\u003dnew ReactiveDiscoveryClientHealthIndicator(client,properties);\n      InstanceRegisteredEvent event\u003dnew InstanceRegisteredEvent(applicationContext.getId(),null);\n      healthIndicator.onApplicationEvent(event);\n      return healthIndicator;\n    }\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n * @deprecated in favor of {@link KubernetesDiscoveryClientBlockingAutoConfiguration} and{@link KubernetesDiscoveryClientReactiveAutoConfiguration}\n */\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnDiscoveryEnabled @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES) @ConditionalOnKubernetesDiscoveryEnabled @EnableConfigurationProperties({DiscoveryClientHealthIndicatorProperties.class,KubernetesDiscoveryClientProperties.class}) @Deprecated(forRemoval\u003dtrue) public class KubernetesDiscoveryClientAutoConfiguration {\n@Configuration(proxyBeanMethods\u003dfalse) public static class Servlet {\n    @Bean @ConditionalOnMissingClass(\"org.springframework.web.reactive.function.client.WebClient\") @ConditionalOnMissingBean(RestTemplate.class) public RestTemplate restTemplate();\n    @Bean @ConditionalOnMissingClass(\"org.springframework.web.reactive.function.client.WebClient\") public DiscoveryClient kubernetesDiscoveryClient(    RestTemplate restTemplate,    KubernetesDiscoveryClientProperties properties);\n    @Bean @ConditionalOnClass({HealthIndicator.class}) @ConditionalOnDiscoveryHealthIndicatorEnabled public InitializingBean indicatorInitializer(    ApplicationEventPublisher applicationEventPublisher,    ApplicationContext applicationContext);\n  }\n@Configuration(proxyBeanMethods\u003dfalse) @ConditionalOnReactiveDiscoveryEnabled public static class Reactive {\n    @Bean @ConditionalOnClass(name\u003d{\"org.springframework.web.reactive.function.client.WebClient\"}) @ConditionalOnMissingBean(WebClient.Builder.class) public WebClient.Builder webClientBuilder();\n    @Bean @ConditionalOnClass(name\u003d{\"org.springframework.web.reactive.function.client.WebClient\"}) public ReactiveDiscoveryClient kubernetesReactiveDiscoveryClient(    WebClient.Builder webClientBuilder,    KubernetesDiscoveryClientProperties properties);\n    @Bean @ConditionalOnClass(name\u003d\"org.springframework.boot.actuate.health.ReactiveHealthIndicator\") @ConditionalOnDiscoveryHealthIndicatorEnabled public ReactiveDiscoveryClientHealthIndicator kubernetesReactiveDiscoveryClientHealthIndicator(    KubernetesReactiveDiscoveryClient client,    DiscoveryClientHealthIndicatorProperties properties,    ApplicationContext applicationContext);\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/main/java/org/springframework/cloud/kubernetes/discovery/Service.java",
        "name": "Service",
        "modifiers": "@Deprecated(forRemoval\u003dtrue) public",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.Service",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\n@Deprecated(forRemoval\u003dtrue) public class Service {\n  private String name;\n  private List\u003cKubernetesServiceInstance\u003e serviceInstances\u003dList.of();\n  public Service(){\n  }\n  public String getName(){\n    return name;\n  }\n  public void setName(  String name){\n    this.name\u003dname;\n  }\n  public List\u003cKubernetesServiceInstance\u003e getServiceInstances(){\n    return serviceInstances;\n  }\n  public void setServiceInstances(  List\u003cKubernetesServiceInstance\u003e serviceInstances){\n    this.serviceInstances\u003dserviceInstances;\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\n@Deprecated(forRemoval\u003dtrue) public class Service {\n  private String name;\n  private List\u003cKubernetesServiceInstance\u003e serviceInstances\u003dList.of();\n  public Service();\n  public String getName();\n  public void setName(  String name);\n  public List\u003cKubernetesServiceInstance\u003e getServiceInstances();\n  public void setServiceInstances(  List\u003cKubernetesServiceInstance\u003e serviceInstances);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/main/java/org/springframework/cloud/kubernetes/discovery/KubernetesReactiveDiscoveryClient.java",
        "name": "KubernetesReactiveDiscoveryClient",
        "modifiers": "public",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesReactiveDiscoveryClient",
        "extend": "",
        "implements": "ReactiveDiscoveryClient",
        "raw": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesReactiveDiscoveryClient implements ReactiveDiscoveryClient {\n  private final WebClient webClient;\n  @Deprecated(forRemoval\u003dtrue) public KubernetesReactiveDiscoveryClient(  WebClient.Builder webClientBuilder,  KubernetesDiscoveryClientProperties properties){\n    if (!StringUtils.hasText(properties.getDiscoveryServerUrl())) {\n      throw new DiscoveryServerUrlInvalidException();\n    }\n    webClient\u003dwebClientBuilder.baseUrl(properties.getDiscoveryServerUrl()).build();\n  }\n  KubernetesReactiveDiscoveryClient(  WebClient.Builder webClientBuilder,  KubernetesDiscoveryProperties properties){\n    if (!StringUtils.hasText(properties.discoveryServerUrl())) {\n      throw new DiscoveryServerUrlInvalidException();\n    }\n    webClient\u003dwebClientBuilder.baseUrl(properties.discoveryServerUrl()).build();\n  }\n  @Override public String description(){\n    return \"Reactive Kubernetes Discovery Client\";\n  }\n  @Override @Cacheable(\"serviceinstances\") public Flux\u003cServiceInstance\u003e getInstances(  String serviceId){\n    return webClient.get().uri(\"/apps/\" + serviceId).exchangeToFlux(clientResponse -\u003e clientResponse.bodyToFlux(DefaultKubernetesServiceInstance.class));\n  }\n  @Override @Cacheable(\"services\") public Flux\u003cString\u003e getServices(){\n    return webClient.get().uri(\"/apps\").exchangeToFlux(clientResponse -\u003e clientResponse.bodyToFlux(Service.class).map(Service::name));\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\npublic class KubernetesReactiveDiscoveryClient implements ReactiveDiscoveryClient {\n  private final WebClient webClient;\n  @Deprecated(forRemoval\u003dtrue) public KubernetesReactiveDiscoveryClient(  WebClient.Builder webClientBuilder,  KubernetesDiscoveryClientProperties properties);\n  KubernetesReactiveDiscoveryClient(  WebClient.Builder webClientBuilder,  KubernetesDiscoveryProperties properties);\n  @Override public String description();\n  @Override @Cacheable(\"serviceinstances\") public Flux\u003cServiceInstance\u003e getInstances(  String serviceId);\n  @Override @Cacheable(\"services\") public Flux\u003cString\u003e getServices();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/test/java/org/springframework/cloud/kubernetes/discovery/KubernetesCatalogWatchTests.java",
        "name": "KubernetesCatalogWatchTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesCatalogWatchTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesCatalogWatchTests {\n  private WireMockServer wireMockServer;\n  private static final ArgumentCaptor\u003cHeartbeatEvent\u003e HEARTBEAT_EVENT_ARGUMENT_CAPTOR\u003dArgumentCaptor.forClass(HeartbeatEvent.class);\n  private static final ApplicationEventPublisher APPLICATION_EVENT_PUBLISHER\u003dMockito.mock(ApplicationEventPublisher.class);\n  @AfterEach void afterEach(){\n    Mockito.reset(APPLICATION_EVENT_PUBLISHER);\n  }\n  @Test void testSingleCycleSameAsCurrentState(){\n    String body\u003d\"[]\";\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    stubFor(get(\"/state\").willReturn(aResponse().withStatus(200).withBody(body).withHeader(\"content-type\",\"application/json\")));\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false,wireMockServer.baseUrl());\n    KubernetesCatalogWatch catalogWatch\u003dnew KubernetesCatalogWatch(new RestTemplateBuilder(),properties);\n    catalogWatch.setApplicationEventPublisher(APPLICATION_EVENT_PUBLISHER);\n    catalogWatch.catalogServicesWatch();\n    Mockito.verifyNoInteractions(APPLICATION_EVENT_PUBLISHER);\n  }\n  @Test @SuppressWarnings(\"unchecked\") void testSingleCycleDifferentCurrentState(){\n    String body\u003dnull;\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    stubFor(get(\"/state\").willReturn(aResponse().withStatus(200).withBody(body).withHeader(\"content-type\",\"application/json\")));\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false,wireMockServer.baseUrl());\n    KubernetesCatalogWatch catalogWatch\u003dnew KubernetesCatalogWatch(new RestTemplateBuilder(),properties);\n    catalogWatch.setApplicationEventPublisher(APPLICATION_EVENT_PUBLISHER);\n    catalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(HEARTBEAT_EVENT_ARGUMENT_CAPTOR.capture());\n    HeartbeatEvent event\u003dHEARTBEAT_EVENT_ARGUMENT_CAPTOR.getValue();\n    Assertions.assertEquals(event.getSource().getClass(),KubernetesCatalogWatch.class);\n    List\u003cEndpointNameAndNamespace\u003e state\u003d(List\u003cEndpointNameAndNamespace\u003e)event.getValue();\n    Assertions.assertEquals(state.size(),1);\n    Assertions.assertEquals(state.get(0).namespace(),\"namespaceA\");\n  }\n  @Test @SuppressWarnings(\"unchecked\") void testTwoCyclesDifferentStates(){\n    String bodyOne\u003dnull;\n    String bodyTwo\u003dnull;\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    stubFor(get(\"/state\").willReturn(aResponse().withStatus(200).withBody(bodyOne).withHeader(\"content-type\",\"application/json\")));\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false,wireMockServer.baseUrl());\n    KubernetesCatalogWatch catalogWatch\u003dnew KubernetesCatalogWatch(new RestTemplateBuilder(),properties);\n    catalogWatch.setApplicationEventPublisher(APPLICATION_EVENT_PUBLISHER);\n    catalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER).publishEvent(HEARTBEAT_EVENT_ARGUMENT_CAPTOR.capture());\n    HeartbeatEvent eventOne\u003dHEARTBEAT_EVENT_ARGUMENT_CAPTOR.getValue();\n    Assertions.assertEquals(eventOne.getSource().getClass(),KubernetesCatalogWatch.class);\n    List\u003cEndpointNameAndNamespace\u003e stateOne\u003d(List\u003cEndpointNameAndNamespace\u003e)eventOne.getValue();\n    Assertions.assertEquals(stateOne.size(),1);\n    Assertions.assertEquals(stateOne.get(0).namespace(),\"namespaceA\");\n    stubFor(get(\"/state\").willReturn(aResponse().withStatus(200).withBody(bodyTwo).withHeader(\"content-type\",\"application/json\")));\n    catalogWatch.catalogServicesWatch();\n    verify(APPLICATION_EVENT_PUBLISHER,Mockito.times(2)).publishEvent(HEARTBEAT_EVENT_ARGUMENT_CAPTOR.capture());\n    HeartbeatEvent eventTwo\u003dHEARTBEAT_EVENT_ARGUMENT_CAPTOR.getValue();\n    Assertions.assertEquals(eventTwo.getSource().getClass(),KubernetesCatalogWatch.class);\n    List\u003cEndpointNameAndNamespace\u003e stateTwo\u003d(List\u003cEndpointNameAndNamespace\u003e)eventTwo.getValue();\n    Assertions.assertEquals(stateTwo.size(),1);\n    Assertions.assertEquals(stateTwo.get(0).namespace(),\"namespaceB\");\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesCatalogWatchTests {\n  private WireMockServer wireMockServer;\n  private static final ArgumentCaptor\u003cHeartbeatEvent\u003e HEARTBEAT_EVENT_ARGUMENT_CAPTOR\u003dArgumentCaptor.forClass(HeartbeatEvent.class);\n  private static final ApplicationEventPublisher APPLICATION_EVENT_PUBLISHER\u003dMockito.mock(ApplicationEventPublisher.class);\n  @AfterEach void afterEach();\n  @Test void testSingleCycleSameAsCurrentState();\n  @Test @SuppressWarnings(\"unchecked\") void testSingleCycleDifferentCurrentState();\n  @Test @SuppressWarnings(\"unchecked\") void testTwoCyclesDifferentStates();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/test/java/org/springframework/cloud/kubernetes/discovery/KubernetesReactiveDiscoveryClientTests.java",
        "name": "KubernetesReactiveDiscoveryClientTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesReactiveDiscoveryClientTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass KubernetesReactiveDiscoveryClientTests {\n  private static final String APPS\u003dnull;\n  private static final String APPS_NAME\u003dnull;\n  private static WireMockServer wireMockServer;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    stubFor(get(\"/apps\").willReturn(aResponse().withStatus(200).withBody(APPS).withHeader(\"content-type\",\"application/json\")));\n    stubFor(get(\"/apps/test-svc-3\").willReturn(aResponse().withStatus(200).withBody(APPS_NAME).withHeader(\"content-type\",\"application/json\")));\n    stubFor(get(\"/apps/does-not-exist\").willReturn(aResponse().withStatus(200).withBody(\"\").withHeader(\"content-type\",\"application/json\")));\n  }\n  @Test void getInstances(){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false,wireMockServer.baseUrl());\n    KubernetesReactiveDiscoveryClient discoveryClient\u003dnew KubernetesReactiveDiscoveryClient(WebClient.builder(),properties);\n    StepVerifier.create(discoveryClient.getServices()).expectNext(\"test-svc-1\",\"test-svc-3\").verifyComplete();\n  }\n  @Test void getServices(){\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false,wireMockServer.baseUrl());\n    KubernetesReactiveDiscoveryClient discoveryClient\u003dnew KubernetesReactiveDiscoveryClient(WebClient.builder(),properties);\n    Map\u003cString,String\u003e metadata\u003dnew HashMap\u003c\u003e();\n    metadata.put(\"spring\",\"true\");\n    metadata.put(\"http\",\"8080\");\n    metadata.put(\"k8s\",\"true\");\n    StepVerifier.create(discoveryClient.getInstances(\"test-svc-3\")).expectNext(new DefaultKubernetesServiceInstance(\"uid2\",\"test-svc-3\",\"2.2.2.2\",8080,metadata,false,\"namespace1\",null,null)).verifyComplete();\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass KubernetesReactiveDiscoveryClientTests {\n  private static final String APPS\u003dnull;\n  private static final String APPS_NAME\u003dnull;\n  private static WireMockServer wireMockServer;\n  @BeforeAll static void beforeAll();\n  @Test void getInstances();\n  @Test void getServices();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/test/java/org/springframework/cloud/kubernetes/discovery/KubernetesDiscoveryClientTests.java",
        "name": "KubernetesDiscoveryClientTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesDiscoveryClientTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass KubernetesDiscoveryClientTests {\n  private static final String APPS\u003dnull;\n  private static final String APPS_NAME\u003dnull;\n  private static WireMockServer wireMockServer;\n  @BeforeAll static void beforeAll(){\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    stubFor(get(\"/apps\").willReturn(aResponse().withStatus(200).withBody(APPS).withHeader(\"content-type\",\"application/json\")));\n    stubFor(get(\"/apps/test-svc-3\").willReturn(aResponse().withStatus(200).withBody(APPS_NAME).withHeader(\"content-type\",\"application/json\")));\n    stubFor(get(\"/apps/does-not-exist\").willReturn(aResponse().withStatus(200).withBody(\"\").withHeader(\"content-type\",\"application/json\")));\n  }\n  @Test void getInstances(){\n    RestTemplate rest\u003dnew RestTemplateBuilder().build();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false,wireMockServer.baseUrl());\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(rest,properties);\n    assertThat(discoveryClient.getServices()).contains(\"test-svc-1\",\"test-svc-3\");\n  }\n  @Test void getServices(){\n    RestTemplate rest\u003dnew RestTemplateBuilder().build();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,Set.of(),true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false,wireMockServer.baseUrl());\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(rest,properties);\n    Map\u003cString,String\u003e metadata\u003dnew HashMap\u003c\u003e();\n    metadata.put(\"spring\",\"true\");\n    metadata.put(\"http\",\"8080\");\n    metadata.put(\"k8s\",\"true\");\n    assertThat(discoveryClient.getInstances(\"test-svc-3\")).contains(new DefaultKubernetesServiceInstance(\"uid2\",\"test-svc-3\",\"2.2.2.2\",8080,metadata,false,\"namespace2\",null,null));\n    assertThat(discoveryClient.getInstances(\"does-not-exist\")).isEmpty();\n  }\n  @ParameterizedTest @MethodSource(\"servicesFilteredByNamespacesSource\") void getServicesFilteredByNamespaces(  Set\u003cString\u003e namespaces,  List\u003cString\u003e expectedServices){\n    RestTemplate rest\u003dnew RestTemplateBuilder().build();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,namespaces,true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false,wireMockServer.baseUrl());\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(rest,properties);\n    assertThat(discoveryClient.getServices()).containsExactlyInAnyOrderElementsOf(expectedServices);\n  }\n  @ParameterizedTest @MethodSource(\"instancesFilteredByNamespacesSource\") void getInstancesFilteredByNamespaces(  Set\u003cString\u003e namespaces,  String serviceId,  List\u003cString\u003e expectedInstances){\n    RestTemplate rest\u003dnew RestTemplateBuilder().build();\n    KubernetesDiscoveryProperties properties\u003dnew KubernetesDiscoveryProperties(true,true,namespaces,true,60,false,null,Set.of(),Map.of(),null,KubernetesDiscoveryProperties.Metadata.DEFAULT,0,false,false,wireMockServer.baseUrl());\n    KubernetesDiscoveryClient discoveryClient\u003dnew KubernetesDiscoveryClient(rest,properties);\n    assertThat(discoveryClient.getInstances(serviceId)).map(ServiceInstance::getInstanceId).containsExactlyInAnyOrderElementsOf(expectedInstances);\n  }\n  private static Stream\u003cArguments\u003e servicesFilteredByNamespacesSource(){\n    return Stream.of(Arguments.of(Set.of(),List.of(\"test-svc-1\",\"test-svc-3\")),Arguments.of(Set.of(\"namespace1\",\"namespace2\"),List.of(\"test-svc-1\",\"test-svc-3\")),Arguments.of(Set.of(\"namespace1\"),List.of(\"test-svc-1\")),Arguments.of(Set.of(\"namespace2\",\"does-not-exist\"),List.of(\"test-svc-3\")));\n  }\n  private static Stream\u003cArguments\u003e instancesFilteredByNamespacesSource(){\n    return Stream.of(Arguments.of(Set.of(),\"test-svc-3\",List.of(\"uid2\")),Arguments.of(Set.of(\"namespace1\"),\"test-svc-3\",List.of()),Arguments.of(Set.of(\"namespace2\"),\"test-svc-3\",List.of(\"uid2\")));\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass KubernetesDiscoveryClientTests {\n  private static final String APPS\u003dnull;\n  private static final String APPS_NAME\u003dnull;\n  private static WireMockServer wireMockServer;\n  @BeforeAll static void beforeAll();\n  @Test void getInstances();\n  @Test void getServices();\n  @ParameterizedTest @MethodSource(\"servicesFilteredByNamespacesSource\") void getServicesFilteredByNamespaces(  Set\u003cString\u003e namespaces,  List\u003cString\u003e expectedServices);\n  @ParameterizedTest @MethodSource(\"instancesFilteredByNamespacesSource\") void getInstancesFilteredByNamespaces(  Set\u003cString\u003e namespaces,  String serviceId,  List\u003cString\u003e expectedInstances);\n  private static Stream\u003cArguments\u003e servicesFilteredByNamespacesSource();\n  private static Stream\u003cArguments\u003e instancesFilteredByNamespacesSource();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/test/java/org/springframework/cloud/kubernetes/discovery/ConfigServerBootstrapperTests.java",
        "name": "ConfigServerBootstrapperTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.ConfigServerBootstrapperTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass ConfigServerBootstrapperTests {\n  private static WireMockServer wireMockServer;\n  protected ConfigurableApplicationContext context;\n  @AfterEach void close(){\n    wireMockServer.stop();\n    if (this.context !\u003d null) {\n      this.context.close();\n    }\n  }\n  @BeforeEach void beforeAll() throws JsonProcessingException {\n    wireMockServer\u003dnew WireMockServer(options().dynamicPort());\n    wireMockServer.start();\n    WireMock.configureFor(wireMockServer.port());\n    String appsName\u003dnull.formatted(wireMockServer.port(),wireMockServer.baseUrl());\n    stubFor(get(\"/apps/spring-cloud-kubernetes-configserver\").willReturn(aResponse().withStatus(200).withBody(appsName).withHeader(\"content-type\",\"application/json\")));\n    Environment environment\u003dnew Environment(\"test\",\"default\");\n    Map\u003cString,Object\u003e properties\u003dnew HashMap\u003c\u003e();\n    properties.put(\"hello\",\"world\");\n    PropertySource p\u003dnew PropertySource(\"p1\",properties);\n    environment.add(p);\n    ObjectMapper objectMapper\u003dnew ObjectMapper();\n    stubFor(get(\"/application/default\").willReturn(aResponse().withStatus(200).withBody(objectMapper.writeValueAsString(environment)).withHeader(\"content-type\",\"application/json\")));\n  }\n  @AfterEach void afterEach(){\n    context.close();\n  }\n  @Test void testBootstrapper(){\n    context\u003dsetup().run();\n    verify(1,getRequestedFor(urlEqualTo(\"/apps/spring-cloud-kubernetes-configserver\")));\n    assertThat(context.getEnvironment().getProperty(\"hello\")).isEqualTo(\"world\");\n  }\n  SpringApplicationBuilder setup(  String... env){\n    SpringApplicationBuilder builder\u003dnew SpringApplicationBuilder(TestConfig.class).properties(addDefaultEnv(env));\n    builder.addBootstrapRegistryInitializer(new ConfigServerBootstrapper());\n    return builder;\n  }\n  private String[] addDefaultEnv(  String[] env){\n    Set\u003cString\u003e set\u003dnew HashSet\u003c\u003e();\n    if (env !\u003d null) {\n      set.addAll(List.of(env));\n    }\n    set.add(\"server.port\u003d0\");\n    set.add(\"spring.cloud.config.discovery.enabled\u003dtrue\");\n    set.add(\"spring.config.import\u003doptional:configserver:\");\n    set.add(\"spring.cloud.config.discovery.service-id\u003dspring-cloud-kubernetes-configserver\");\n    set.add(\"spring.cloud.kubernetes.discovery.discoveryServerUrl\u003d\" + wireMockServer.baseUrl());\n    set.add(\"spring.main.web-application-type\u003dNONE\");\n    return set.toArray(new String[0]);\n  }\n@TestConfiguration static class TestConfig {\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass ConfigServerBootstrapperTests {\n  private static WireMockServer wireMockServer;\n  protected ConfigurableApplicationContext context;\n  @AfterEach void close();\n  @BeforeEach void beforeAll() throws JsonProcessingException;\n  @AfterEach void afterEach();\n  @Test void testBootstrapper();\n  SpringApplicationBuilder setup(  String... env);\n  private String[] addDefaultEnv(  String[] env);\n@TestConfiguration static class TestConfig {\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/test/java/org/springframework/cloud/kubernetes/discovery/HealthEventListenerConfiguration.java",
        "name": "HealthEventListenerConfiguration",
        "modifiers": "@TestConfiguration",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.HealthEventListenerConfiguration",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@TestConfiguration class HealthEventListenerConfiguration {\n  static boolean caught\u003dfalse;\n  @Bean HealthEventListener healthEventListener(){\n    return new HealthEventListener();\n  }\nprivate static class HealthEventListener implements ApplicationListener\u003cInstanceRegisteredEvent\u003c?\u003e\u003e {\n    @Override public void onApplicationEvent(    InstanceRegisteredEvent\u003c?\u003e event){\n      caught\u003dtrue;\n      Assertions.assertInstanceOf(RegisteredEventSource.class,event.getSource());\n      RegisteredEventSource registeredEventSource\u003d(RegisteredEventSource)event.getSource();\n      Assertions.assertTrue(registeredEventSource.inside());\n      Assertions.assertNull(registeredEventSource.pod());\n      Assertions.assertEquals(registeredEventSource.cloudPlatform(),\"kubernetes\");\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@TestConfiguration class HealthEventListenerConfiguration {\n  static boolean caught\u003dfalse;\n  @Bean HealthEventListener healthEventListener();\nprivate static class HealthEventListener implements ApplicationListener\u003cInstanceRegisteredEvent\u003c?\u003e\u003e {\n    @Override public void onApplicationEvent(    InstanceRegisteredEvent\u003c?\u003e event);\n  }\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/test/java/org/springframework/cloud/kubernetes/discovery/KubernetesDiscoveryAutoConfigurationTests.java",
        "name": "KubernetesDiscoveryAutoConfigurationTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesDiscoveryAutoConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryAutoConfigurationTests {\n  /** \n * \u003cpre\u003e \u0027@ConditionalOnDiscoveryEnabled\u0027 is not matched, thus no beans are created from either blocking or reactive configurations. \u003c/pre\u003e\n */\n  @Test void discoveryDisabled(){\n    setupWithFilteredClassLoader(null,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(RestTemplate.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(WebClient.Builder.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  /** \n * \u003cpre\u003e \u0027@ConditionalOnKubernetesDiscoveryEnabled\u0027 is not matched, thus no beans are created from either blocking or reactive configurations. \u003c/pre\u003e\n */\n  @Test void kubernetesDiscoveryDisabled(){\n    setupWithFilteredClassLoader(null,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(RestTemplate.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(WebClient.Builder.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  /** \n * \u003cpre\u003e \u0027@ConditionalOnCloudPlatform\u0027 does not match \u0027KUBERNETES\u0027, thus no beans are created from either blocking or reactive configurations. \u003c/pre\u003e\n */\n  @Test void cloudPlatformDisabled(){\n    setupWithFilteredClassLoader(null,\"spring.main.cloud-platform\u003dnone\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(RestTemplate.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(WebClient.Builder.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  /** \n * \u003cpre\u003e - reactive config is disabled, blocking is defaulted. - WebClient class is not present \u003c/pre\u003e\n */\n  @Test void reactiveDisabledBlockingEnabledWebClientPresent(){\n    setupWithFilteredClassLoader(WebClient.class,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://k8sdiscoveryserver\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(RestTemplateBuilder.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).getBean(\"indicatorInitializer\").isNotNull();\n      assertThat(context).doesNotHaveBean(WebClient.Builder.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  /** \n * \u003cpre\u003e - reactive config is disabled, blocking is defaulted. - WebClient class is present \u003c/pre\u003e\n */\n  @Test void reactiveDisabledBlockingEnabledWebClientMissing(){\n    setupWithFilteredClassLoader(null,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://k8sdiscoveryserver\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(RestTemplate.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).getBean(\"indicatorInitializer\").isNull();\n      assertThat(context).doesNotHaveBean(WebClient.Builder.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  /** \n * \u003cpre\u003e - reactive config is disabled, blocking is defaulted. - WebClient class is present \u003c/pre\u003e\n */\n  @Test void reactiveDisabledBlockingEnabledWebClientMissingHealthIndicatorMissing(){\n    setupWithFilteredClassLoader(HealthIndicator.class,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://k8sdiscoveryserver\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(RestTemplateBuilder.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(\"indicatorInitializer\");\n      assertThat(context).doesNotHaveBean(WebClient.Builder.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  /** \n * \u003cpre\u003e \u0027@ConditionalOnDiscoveryHealthIndicatorEnabled\u0027 not matched. \u003c/pre\u003e\n */\n  @Test void blockingHealthIndicatorDisabled(){\n    setupWithFilteredClassLoader(null,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.discovery.reactive.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://k8sdiscoveryserver\",\"spring.cloud.discovery.client.health-indicator.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(RestTemplateBuilder.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(\"indicatorInitializer\");\n      assertThat(context).hasSingleBean(WebClient.Builder.class);\n      assertThat(context).hasSingleBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  /** \n * \u003cpre\u003e - reactive config is enabled, blocking is defaulted. - WebClient class is present \u003c/pre\u003e\n */\n  @Test void reactiveEnabledBlockingEnabledWebClientPresent(){\n    setupWithFilteredClassLoader(null,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.discovery.reactive.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://k8sdiscoveryserver\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(RestTemplateBuilder.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).getBean(\"indicatorInitializer\").isNotNull();\n      assertThat(context).hasSingleBean(WebClient.Builder.class);\n      assertThat(context).hasSingleBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).getBean(\"kubernetesReactiveDiscoveryClientHealthIndicator\").isNotNull();\n    }\n);\n  }\n  /** \n * \u003cpre\u003e - reactive config is enabled, blocking is defaulted. - WebClient class is missing \u003c/pre\u003e\n */\n  @Test void reactiveEnabledBlockingEnabledWebClientMissing(){\n    setupWithFilteredClassLoader(WebClient.class,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.discovery.reactive.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://k8sdiscoveryserver\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(RestTemplateBuilder.class);\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).getBean(\"indicatorInitializer\").isNotNull();\n      assertThat(context).doesNotHaveBean(WebClient.Builder.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).getBean(\"kubernetesReactiveDiscoveryClientHealthIndicator\").isNull();\n    }\n);\n  }\n  /** \n * \u003cpre\u003e \u0027@ConditionalOnBlockingDiscoveryEnabled\u0027 is not matched. \u003c/pre\u003e\n */\n  @Test void testBlockingDisabled(){\n    setupWithFilteredClassLoader(WebClient.class,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.discovery.reactive.enabled\u003dtrue\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://k8sdiscoveryserver\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(RestTemplate.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).getBean(\"indicatorInitializer\").isNull();\n      assertThat(context).doesNotHaveBean(WebClient.Builder.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).getBean(\"kubernetesReactiveDiscoveryClientHealthIndicator\").isNull();\n    }\n);\n  }\n  /** \n * \u003cpre\u003e - WebClient is on the classpath (this is asserted via the presence of beans that come from the reactive auto-configuration) - This has no impact of the creation of the blocking discovery client \u003c/pre\u003e\n */\n  @Test void testFor1426Issue(){\n    setupWithFilteredClassLoader(null,\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.discovery.reactive.enabled\u003dtrue\",\"spring.cloud.discovery.blocking.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://k8sdiscoveryserver\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).hasSingleBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  private ApplicationContextRunner applicationContextRunner;\n  private void setupWithFilteredClassLoader(  Class\u003c?\u003e cls,  String... properties){\n    if (cls !\u003d null) {\n      applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesDiscoveryClientBlockingAutoConfiguration.class,KubernetesDiscoveryClientReactiveAutoConfiguration.class)).withClassLoader(new FilteredClassLoader(cls)).withPropertyValues(properties);\n    }\n else {\n      applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesDiscoveryClientBlockingAutoConfiguration.class,KubernetesDiscoveryClientReactiveAutoConfiguration.class)).withPropertyValues(properties);\n    }\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesDiscoveryAutoConfigurationTests {\n  /** \n * \u003cpre\u003e \u0027@ConditionalOnDiscoveryEnabled\u0027 is not matched, thus no beans are created from either blocking or reactive configurations. \u003c/pre\u003e\n */\n  @Test void discoveryDisabled();\n  /** \n * \u003cpre\u003e \u0027@ConditionalOnKubernetesDiscoveryEnabled\u0027 is not matched, thus no beans are created from either blocking or reactive configurations. \u003c/pre\u003e\n */\n  @Test void kubernetesDiscoveryDisabled();\n  /** \n * \u003cpre\u003e \u0027@ConditionalOnCloudPlatform\u0027 does not match \u0027KUBERNETES\u0027, thus no beans are created from either blocking or reactive configurations. \u003c/pre\u003e\n */\n  @Test void cloudPlatformDisabled();\n  /** \n * \u003cpre\u003e - reactive config is disabled, blocking is defaulted. - WebClient class is not present \u003c/pre\u003e\n */\n  @Test void reactiveDisabledBlockingEnabledWebClientPresent();\n  /** \n * \u003cpre\u003e - reactive config is disabled, blocking is defaulted. - WebClient class is present \u003c/pre\u003e\n */\n  @Test void reactiveDisabledBlockingEnabledWebClientMissing();\n  /** \n * \u003cpre\u003e - reactive config is disabled, blocking is defaulted. - WebClient class is present \u003c/pre\u003e\n */\n  @Test void reactiveDisabledBlockingEnabledWebClientMissingHealthIndicatorMissing();\n  /** \n * \u003cpre\u003e \u0027@ConditionalOnDiscoveryHealthIndicatorEnabled\u0027 not matched. \u003c/pre\u003e\n */\n  @Test void blockingHealthIndicatorDisabled();\n  /** \n * \u003cpre\u003e - reactive config is enabled, blocking is defaulted. - WebClient class is present \u003c/pre\u003e\n */\n  @Test void reactiveEnabledBlockingEnabledWebClientPresent();\n  /** \n * \u003cpre\u003e - reactive config is enabled, blocking is defaulted. - WebClient class is missing \u003c/pre\u003e\n */\n  @Test void reactiveEnabledBlockingEnabledWebClientMissing();\n  /** \n * \u003cpre\u003e \u0027@ConditionalOnBlockingDiscoveryEnabled\u0027 is not matched. \u003c/pre\u003e\n */\n  @Test void testBlockingDisabled();\n  /** \n * \u003cpre\u003e - WebClient is on the classpath (this is asserted via the presence of beans that come from the reactive auto-configuration) - This has no impact of the creation of the blocking discovery client \u003c/pre\u003e\n */\n  @Test void testFor1426Issue();\n  private ApplicationContextRunner applicationContextRunner;\n  private void setupWithFilteredClassLoader(  Class\u003c?\u003e cls,  String... properties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/test/java/org/springframework/cloud/kubernetes/discovery/App.java",
        "name": "App",
        "modifiers": "@SpringBootConfiguration @EnableAutoConfiguration",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.App",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\n@SpringBootConfiguration @EnableAutoConfiguration class App {\n}\n",
        "abstract": "/** \n * @author wind57\n */\n@SpringBootConfiguration @EnableAutoConfiguration class App {\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/test/java/org/springframework/cloud/kubernetes/discovery/KubernetesCatalogWatchAutoConfigurationTests.java",
        "name": "KubernetesCatalogWatchAutoConfigurationTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesCatalogWatchAutoConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author wind57\n */\nclass KubernetesCatalogWatchAutoConfigurationTests {\n  private ApplicationContextRunner applicationContextRunner;\n  @Test void discoveryEnabledDefault(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dexample.com\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(KubernetesCatalogWatch.class));\n  }\n  @Test void discoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dexample.com\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(KubernetesCatalogWatch.class));\n  }\n  @Test void discoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dexample.com\");\n    applicationContextRunner.run(context -\u003e assertThat(context).doesNotHaveBean(KubernetesCatalogWatch.class));\n  }\n  @Test void kubernetesDiscoveryEnabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dtrue\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dexample.com\");\n    applicationContextRunner.run(context -\u003e assertThat(context).hasSingleBean(KubernetesCatalogWatch.class));\n  }\n  @Test void kubernetesDiscoveryDisabled(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dexample.com\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dexample.com\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e assertThat(context).doesNotHaveBean(KubernetesCatalogWatch.class));\n  }\n  /** \n * both blocking and reactive configs are disabled, catalog watcher is disabled.\n */\n  @Test void disableBlockingAndReactive(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesCatalogWatch.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  /** \n * blocking is disabled, reactive is enabled, catalog watcher is enabled.\n */\n  @Test void disableBlockingEnableReactive(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\",\"spring.cloud.discovery.reactive.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dexample.com\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesCatalogWatch.class);\n    }\n);\n  }\n  /** \n * blocking is enabled, reactive is disabled, catalog watcher is enabled.\n */\n  @Test void enableBlockingDisableReactive(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.discovery.blocking.enabled\u003dtrue\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dexample.com\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesCatalogWatch.class);\n    }\n);\n  }\n  /** \n * spring.cloud.kubernetes.discovery.enabled is false, catalog watcher is disabled.\n */\n  @Test void disableKubernetesDiscovery(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dtrue\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesCatalogWatch.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  /** \n * spring.cloud.kubernetes.http.discovery.client.catalog.watcher.enabled is false, as such catalog watcher is not present.\n */\n  @Test void disableHttpDiscoveryClientCatalogWatcher(){\n    setup(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.config.enabled\u003dtrue\",\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\",\"spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled\u003dfalse\");\n    applicationContextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesCatalogWatch.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n    }\n);\n  }\n  private void setup(  String... properties){\n    applicationContextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(KubernetesCatalogWatchAutoConfiguration.class,KubernetesDiscoveryClientBlockingAutoConfiguration.class,KubernetesDiscoveryClientReactiveAutoConfiguration.class)).withPropertyValues(properties);\n  }\n}\n",
        "abstract": "/** \n * @author wind57\n */\nclass KubernetesCatalogWatchAutoConfigurationTests {\n  private ApplicationContextRunner applicationContextRunner;\n  @Test void discoveryEnabledDefault();\n  @Test void discoveryEnabled();\n  @Test void discoveryDisabled();\n  @Test void kubernetesDiscoveryEnabled();\n  @Test void kubernetesDiscoveryDisabled();\n  /** \n * both blocking and reactive configs are disabled, catalog watcher is disabled.\n */\n  @Test void disableBlockingAndReactive();\n  /** \n * blocking is disabled, reactive is enabled, catalog watcher is enabled.\n */\n  @Test void disableBlockingEnableReactive();\n  /** \n * blocking is enabled, reactive is disabled, catalog watcher is enabled.\n */\n  @Test void enableBlockingDisableReactive();\n  /** \n * spring.cloud.kubernetes.discovery.enabled is false, catalog watcher is disabled.\n */\n  @Test void disableKubernetesDiscovery();\n  /** \n * spring.cloud.kubernetes.http.discovery.client.catalog.watcher.enabled is false, as such catalog watcher is not present.\n */\n  @Test void disableHttpDiscoveryClientCatalogWatcher();\n  private void setup(  String... properties);\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/test/java/org/springframework/cloud/kubernetes/discovery/ReactiveDiscoveryHealthPublishedEventTest.java",
        "name": "ReactiveDiscoveryHealthPublishedEventTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.main.cloud-platform\u003dkubernetes\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://example\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\"},classes\u003d{HealthEventListenerConfiguration.class,App.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.ReactiveDiscoveryHealthPublishedEventTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * test that asserts the type of published event for reactive discovery.\n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.main.cloud-platform\u003dkubernetes\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://example\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\"},classes\u003d{HealthEventListenerConfiguration.class,App.class}) class ReactiveDiscoveryHealthPublishedEventTest {\n  @Autowired private ObjectProvider\u003cKubernetesDiscoveryClient\u003e discoveryClients;\n  @AfterEach void afterEach(){\n    HealthEventListenerConfiguration.caught\u003dfalse;\n  }\n  @Test void test(){\n    Assertions.assertTrue(HealthEventListenerConfiguration.caught);\n    Assertions.assertNull(discoveryClients.getIfAvailable());\n  }\n}\n",
        "abstract": "/** \n * test that asserts the type of published event for reactive discovery.\n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.main.cloud-platform\u003dkubernetes\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://example\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\"},classes\u003d{HealthEventListenerConfiguration.class,App.class}) class ReactiveDiscoveryHealthPublishedEventTest {\n  @Autowired private ObjectProvider\u003cKubernetesDiscoveryClient\u003e discoveryClients;\n  @AfterEach void afterEach();\n  @Test void test();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/test/java/org/springframework/cloud/kubernetes/discovery/KubernetesDiscoveryClientAutoConfigurationTests.java",
        "name": "KubernetesDiscoveryClientAutoConfigurationTests",
        "modifiers": "",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.KubernetesDiscoveryClientAutoConfigurationTests",
        "extend": "",
        "implements": "",
        "raw": "/** \n * @author Ryan Baxter\n */\nclass KubernetesDiscoveryClientAutoConfigurationTests {\n  private final ApplicationContextRunner contextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(UtilAutoConfiguration.class,ReactiveCommonsClientAutoConfiguration.class,KubernetesDiscoveryClientReactiveAutoConfiguration.class,KubernetesDiscoveryClientBlockingAutoConfiguration.class));\n  @Test void shouldWorkWithDefaults(){\n    contextRunner.withPropertyValues(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://k8sdiscoveryserver\").withClassLoader(new FilteredClassLoader(\"org.springframework.web.reactive\")).run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n  @Test void shouldNotHaveDiscoveryClientWhenDiscoveryDisabled(){\n    contextRunner.withPropertyValues(\"spring.cloud.discovery.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://k8sdiscoveryserver\").run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n  @Test void shouldNotHaveDiscoveryClientWhenKubernetesDiscoveryDisabled(){\n    contextRunner.withPropertyValues(\"spring.cloud.kubernetes.discovery.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://k8sdiscoveryserver\").run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n  @Test void shouldHaveReactiveDiscoveryClient(){\n    contextRunner.withPropertyValues(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.discovery.blocking.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://k8sdiscoveryserver\").run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(KubernetesDiscoveryClient.class);\n      assertThat(context).hasSingleBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n  @Test void shouldNotHaveDiscoveryClientWhenReactiveDiscoveryDisabled(){\n    contextRunner.withPropertyValues(\"spring.cloud.discovery.reactive.enabled\u003dfalse\").run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n  @Test void shouldNotHaveDiscoveryClientWhenKubernetesDisabled(){\n    contextRunner.run(context -\u003e {\n      assertThat(context).doesNotHaveBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n  @Test void worksWithoutActuator(){\n    contextRunner.withPropertyValues(\"spring.main.cloud-platform\u003dKUBERNETES\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://k8sdiscoveryserver\").withClassLoader(new FilteredClassLoader(\"org.springframework.boot.actuate\")).run(context -\u003e {\n      assertThat(context).hasSingleBean(KubernetesReactiveDiscoveryClient.class);\n      assertThat(context).doesNotHaveBean(ReactiveDiscoveryClientHealthIndicator.class);\n    }\n);\n  }\n}\n",
        "abstract": "/** \n * @author Ryan Baxter\n */\nclass KubernetesDiscoveryClientAutoConfigurationTests {\n  private final ApplicationContextRunner contextRunner\u003dnew ApplicationContextRunner().withConfiguration(AutoConfigurations.of(UtilAutoConfiguration.class,ReactiveCommonsClientAutoConfiguration.class,KubernetesDiscoveryClientReactiveAutoConfiguration.class,KubernetesDiscoveryClientBlockingAutoConfiguration.class));\n  @Test void shouldWorkWithDefaults();\n  @Test void shouldNotHaveDiscoveryClientWhenDiscoveryDisabled();\n  @Test void shouldNotHaveDiscoveryClientWhenKubernetesDiscoveryDisabled();\n  @Test void shouldHaveReactiveDiscoveryClient();\n  @Test void shouldNotHaveDiscoveryClientWhenReactiveDiscoveryDisabled();\n  @Test void shouldNotHaveDiscoveryClientWhenKubernetesDisabled();\n  @Test void worksWithoutActuator();\n}\n"
    },
    {
        "relative_path": "spring-cloud_spring-cloud-kubernetes/spring-cloud-kubernetes/spring-cloud-kubernetes-discovery/src/test/java/org/springframework/cloud/kubernetes/discovery/BlockingDiscoveryHealthPublishedEventTest.java",
        "name": "BlockingDiscoveryHealthPublishedEventTest",
        "modifiers": "@SpringBootTest(properties\u003d{\"spring.main.cloud-platform\u003dkubernetes\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://example\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\"},classes\u003d{HealthEventListenerConfiguration.class,App.class})",
        "qualified_name": "org.springframework.cloud.kubernetes.discovery.BlockingDiscoveryHealthPublishedEventTest",
        "extend": "",
        "implements": "",
        "raw": "/** \n * test that asserts the type of published event for blocking discovery.\n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.main.cloud-platform\u003dkubernetes\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://example\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\"},classes\u003d{HealthEventListenerConfiguration.class,App.class}) class BlockingDiscoveryHealthPublishedEventTest {\n  @AfterEach void afterEach(){\n    HealthEventListenerConfiguration.caught\u003dfalse;\n  }\n  @Test void test(){\n    Assertions.assertTrue(HealthEventListenerConfiguration.caught);\n  }\n}\n",
        "abstract": "/** \n * test that asserts the type of published event for blocking discovery.\n * @author wind57\n */\n@SpringBootTest(properties\u003d{\"spring.main.cloud-platform\u003dkubernetes\",\"spring.cloud.config.enabled\u003dfalse\",\"spring.cloud.kubernetes.discovery.discovery-server-url\u003dhttp://example\",\"spring.cloud.discovery.reactive.enabled\u003dfalse\"},classes\u003d{HealthEventListenerConfiguration.class,App.class}) class BlockingDiscoveryHealthPublishedEventTest {\n  @AfterEach void afterEach();\n  @Test void test();\n}\n"
    }
]